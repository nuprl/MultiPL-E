language: cpp
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    stack<char> st;\n    for (auto &it\
    \ : lst) {\n        if (it == \"(\") {\n            st.push('(');\n        } else\
    \ if (it == \")\") {\n            st.push(')');\n        } else {\n          \
    \  assert(false);\n        }\n    }\n    while (!st.empty()) {\n        char c\
    \ = st.top();\n        st.pop();\n        if (c == '(') {\n            ans = \"\
    Yes\";\n            break;\n        } else if (c == ')') {\n            ans =\
    \ \"No\";\n            break;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppp5j_8w1.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmppp5j_8w1.cpp:18:5: error: 'stack' was not declared in this scope\n\
    \     stack<char> st;\n     ^\n/tmp/tmppp5j_8w1.cpp:18:5: note: suggested alternative:\n\
    In file included from /usr/include/c++/4.8.2/stack:61:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:88,\n             \
    \    from /tmp/tmppp5j_8w1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_stack.h:96:11:\
    \ note:   'std::stack'\n     class stack\n           ^\n/tmp/tmppp5j_8w1.cpp:18:11:\
    \ error: expected primary-expression before 'char'\n     stack<char> st;\n   \
    \        ^\n/tmp/tmppp5j_8w1.cpp:18:11: error: expected ';' before 'char'\n/tmp/tmppp5j_8w1.cpp:19:16:\
    \ error: ISO C++ forbids declaration of 'it' with no type [-fpermissive]\n   \
    \  for (auto &it : lst) {\n                ^\n/tmp/tmppp5j_8w1.cpp:19:21: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &it :\
    \ lst) {\n                     ^\n/tmp/tmppp5j_8w1.cpp:20:19: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n         if (it == \"\
    (\") {\n                   ^\n/tmp/tmppp5j_8w1.cpp:21:13: error: 'st' was not\
    \ declared in this scope\n             st.push('(');\n             ^\n/tmp/tmppp5j_8w1.cpp:22:26:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         } else if (it == \")\") {\n                          ^\n/tmp/tmppp5j_8w1.cpp:23:13:\
    \ error: 'st' was not declared in this scope\n             st.push(')');\n   \
    \          ^\n/tmp/tmppp5j_8w1.cpp:28:13: error: 'st' was not declared in this\
    \ scope\n     while (!st.empty()) {\n             ^\n/tmp/tmppp5j_8w1.cpp: In\
    \ function 'int main()':\n/tmp/tmppp5j_8w1.cpp:42:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppp5j_8w1.cpp:2:\n/tmp/tmppp5j_8w1.cpp:43:47: warning:\
    \ ex"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.find(\"(\") != std::string::npos) {\n            if (s.find(\")\") != std::string::npos)\
    \ {\n                ans = \"Yes\";\n                break;\n            }\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqusfqj1r.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqusfqj1r.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpqusfqj1r.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpqusfqj1r.cpp:19:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") != std::string::npos) {\n               ^\n/tmp/tmpqusfqj1r.cpp:20:19:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \             if (s.find(\")\") != std::string::npos) {\n                   ^\n\
    /tmp/tmpqusfqj1r.cpp: In function 'int main()':\n/tmp/tmpqusfqj1r.cpp:29:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = match_parens;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqusfqj1r.cpp:2:\n/tmp/tmpqusfqj1r.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpqusfqj1r.cpp:30:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpqusfqj1r.cpp:30:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqusfqj1r.cpp:30:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s = \"No\";\n    bool flag = false;\n    for (auto i\
    \ : lst) {\n        if (i == \"(\") {\n            flag = true;\n        } else\
    \ if (i == \")\") {\n            flag = false;\n        } else if (flag) {\n \
    \           s += i;\n        }\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdx4gi_ha.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpdx4gi_ha.cpp:19:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpdx4gi_ha.cpp:28:5: error: expected\
    \ ';' before 'return'\n     return s;\n     ^\n/tmp/tmpdx4gi_ha.cpp:28:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmpdx4gi_ha.cpp:28:5: error:\
    \ expected ';' before 'return'\n/tmp/tmpdx4gi_ha.cpp:28:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpdx4gi_ha.cpp:28:5: error: expected ')' before 'return'\n\
    /tmp/tmpdx4gi_ha.cpp: In function 'int main()':\n/tmp/tmpdx4gi_ha.cpp:31:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = match_parens;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdx4gi_ha.cpp:2:\n/tmp/tmpdx4gi_ha.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpdx4gi_ha.cpp:32:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpdx4gi_ha.cpp:32:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdx4gi_ha.cpp:32:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpdx4gi_ha.cpp:33:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [ena"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // Your code here\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpms6h6yzm.cpp: In function 'int main()':\n/tmp/tmpms6h6yzm.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpms6h6yzm.cpp:2:\n/tmp/tmpms6h6yzm.cpp:21:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpms6h6yzm.cpp:21:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpms6h6yzm.cpp:21:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpms6h6yzm.cpp:21:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpms6h6yzm.cpp:22:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpms6h6yzm.cpp:22:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpms6h6yzm.cpp:22:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    bool flag = true;\n    for (auto\
    \ &x : lst) {\n        flag = flag && x.find(\"(\") != std::string::npos;\n  \
    \      flag = flag && x.find(\")\") != std::string::npos;\n    }\n    if (flag)\
    \ {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu8i03iul.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpu8i03iul.cpp:19:16: error: ISO C++ forbids declaration of 'x'\
    \ with no type [-fpermissive]\n     for (auto &x : lst) {\n                ^\n\
    /tmp/tmpu8i03iul.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &x : lst) {\n                    ^\n/tmp/tmpu8i03iul.cpp:20:26:\
    \ error: request for member 'find' in 'x', which is of non-class type 'int'\n\
    \         flag = flag && x.find(\"(\") != std::string::npos;\n               \
    \           ^\n/tmp/tmpu8i03iul.cpp:21:26: error: request for member 'find' in\
    \ 'x', which is of non-class type 'int'\n         flag = flag && x.find(\")\"\
    ) != std::string::npos;\n                          ^\n/tmp/tmpu8i03iul.cpp: In\
    \ function 'int main()':\n/tmp/tmpu8i03iul.cpp:29:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu8i03iul.cpp:2:\n/tmp/tmpu8i03iul.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpu8i03iul.cpp:30:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpu8i03iul.cpp:30:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpu8i03iul.cpp:30:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                  "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.find(\"(\") != std::string::npos) {\n            if (s.find(\")\") != std::string::npos)\
    \ {\n                ans = \"Yes\";\n                break;\n            }\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqusfqj1r.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqusfqj1r.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpqusfqj1r.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpqusfqj1r.cpp:19:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") != std::string::npos) {\n               ^\n/tmp/tmpqusfqj1r.cpp:20:19:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \             if (s.find(\")\") != std::string::npos) {\n                   ^\n\
    /tmp/tmpqusfqj1r.cpp: In function 'int main()':\n/tmp/tmpqusfqj1r.cpp:29:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = match_parens;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqusfqj1r.cpp:2:\n/tmp/tmpqusfqj1r.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpqusfqj1r.cpp:30:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpqusfqj1r.cpp:30:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqusfqj1r.cpp:30:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  std::string res;\n  for (int i = 0; i < lst.size(); i++) {\n    if\
    \ (lst[i][0] == '(' && lst[i][lst.size() - 1] == ')') {\n      res += lst[i] +\
    \ lst[i + 1];\n      i += 2;\n    } else if (lst[i][0] == '(' && lst[i][lst.size()\
    \ - 1] != ')') {\n      res += lst[i] + lst[i + 1];\n      i += 1;\n    } else\
    \ {\n      res += lst[i];\n    }\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdqgb8krc.cpp: In function 'int main()':\n/tmp/tmpdqgb8krc.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdqgb8krc.cpp:2:\n/tmp/tmpdqgb8krc.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpdqgb8krc.cpp:33:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpdqgb8krc.cpp:33:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdqgb8krc.cpp:33:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpdqgb8krc.cpp:34:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpdqgb8krc.cpp:34:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpdqgb8krc.cpp:34:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.size() == 1) {\n            if (s[0] == '(' || s[0] == ')') {\n         \
    \       ans = \"Yes\";\n                break;\n            }\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n  \
    \  assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpumqvpr8m.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpumqvpr8m.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpumqvpr8m.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpumqvpr8m.cpp:19:15:\
    \ error: request for member 'size' in 's', which is of non-class type 'int'\n\
    \         if (s.size() == 1) {\n               ^\n/tmp/tmpumqvpr8m.cpp:20:20:\
    \ error: invalid types 'int[int]' for array subscript\n             if (s[0] ==\
    \ '(' || s[0] == ')') {\n                    ^\n/tmp/tmpumqvpr8m.cpp:20:35: error:\
    \ invalid types 'int[int]' for array subscript\n             if (s[0] == '(' ||\
    \ s[0] == ')') {\n                                   ^\n/tmp/tmpumqvpr8m.cpp:\
    \ In function 'int main()':\n/tmp/tmpumqvpr8m.cpp:29:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpumqvpr8m.cpp:2:\n/tmp/tmpumqvpr8m.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpumqvpr8m.cpp:30:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpumqvpr8m.cpp:30:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpumqvpr8m.cpp:30:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    // Your code here\n    std::string ans = \"No\";\n    for (auto\
    \ &s : lst) {\n        if (s.find(\"(\") != std::string::npos) {\n           \
    \ ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjkmpsean.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpjkmpsean.cpp:19:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpjkmpsean.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpjkmpsean.cpp:20:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") != std::string::npos) {\n               ^\n/tmp/tmpjkmpsean.cpp:\
    \ In function 'int main()':\n/tmp/tmpjkmpsean.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjkmpsean.cpp:2:\n/tmp/tmpjkmpsean.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpjkmpsean.cpp:29:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpjkmpsean.cpp:29:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpjkmpsean.cpp:29:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpjkmpsean.cpp:30:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s = \"No\";\n    for (auto &i : lst) {\n        if (i.size()\
    \ == 1) {\n            s += i[0];\n        } else if (i.size() > 1) {\n      \
    \      s += \"(\";\n            for (auto &j : i) {\n                s += j;\n\
    \            }\n            s += \")\";\n        }\n    }\n    return s;\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoiwkhjtb.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpoiwkhjtb.cpp:18:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmpoiwkhjtb.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmpoiwkhjtb.cpp:19:15:\
    \ error: request for member 'size' in 'i', which is of non-class type 'int'\n\
    \         if (i.size() == 1) {\n               ^\n/tmp/tmpoiwkhjtb.cpp:20:21:\
    \ error: invalid types 'int[int]' for array subscript\n             s += i[0];\n\
    \                     ^\n/tmp/tmpoiwkhjtb.cpp:21:22: error: request for member\
    \ 'size' in 'i', which is of non-class type 'int'\n         } else if (i.size()\
    \ > 1) {\n                      ^\n/tmp/tmpoiwkhjtb.cpp:23:24: error: ISO C++\
    \ forbids declaration of 'j' with no type [-fpermissive]\n             for (auto\
    \ &j : i) {\n                        ^\n/tmp/tmpoiwkhjtb.cpp:23:28: error: range-based\
    \ 'for' loops are not allowed in C++98 mode\n             for (auto &j : i) {\n\
    \                            ^\n/tmp/tmpoiwkhjtb.cpp: In function 'int main()':\n\
    /tmp/tmpoiwkhjtb.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = match_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoiwkhjtb.cpp:2:\n/tmp/tmpoiwkhjtb.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpoiwkhjtb.cpp:33:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // Your code here\n  std::string ans = \"No\";\n  for (int i = 0;\
    \ i < lst.size(); i++) {\n    for (int j = i + 1; j < lst.size(); j++) {\n   \
    \   if (lst[i].size() > 0 && lst[j].size() > 0 && lst[i][j] == '(' && lst[j][i]\
    \ == '(') {\n        ans = \"Yes\";\n        break;\n      }\n    }\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqehg79rp.cpp: In function 'int main()':\n/tmp/tmpqehg79rp.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqehg79rp.cpp:2:\n/tmp/tmpqehg79rp.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpqehg79rp.cpp:31:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpqehg79rp.cpp:31:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqehg79rp.cpp:31:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpqehg79rp.cpp:32:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpqehg79rp.cpp:32:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpqehg79rp.cpp:32:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // Your code here\n  std::string ans = \"No\";\n  for (int i = 0;\
    \ i < lst.size(); i++) {\n    if (lst[i][0] == '(' && lst[i][1] == '(') {\n  \
    \    ans = \"Yes\";\n      break;\n    }\n    if (lst[i][0] == ')' && lst[i][1]\
    \ == ')') {\n      ans = \"Yes\";\n      break;\n    }\n  }\n  return ans;\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpalxd7cfq.cpp: In function 'int main()':\n/tmp/tmpalxd7cfq.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpalxd7cfq.cpp:2:\n/tmp/tmpalxd7cfq.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpalxd7cfq.cpp:33:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpalxd7cfq.cpp:33:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpalxd7cfq.cpp:33:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpalxd7cfq.cpp:34:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpalxd7cfq.cpp:34:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpalxd7cfq.cpp:34:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    // Your code here\n    std::string ans = \"No\";\n    for (auto\
    \ i : lst) {\n        if (i[0] == '(' && i[i - 1] == ')') {\n            ans =\
    \ \"Yes\";\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiqz3ey3w.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpiqz3ey3w.cpp:19:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpiqz3ey3w.cpp:24:5: error: expected\
    \ ';' before 'return'\n     return ans;\n     ^\n/tmp/tmpiqz3ey3w.cpp:24:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmpiqz3ey3w.cpp:24:5: error:\
    \ expected ';' before 'return'\n/tmp/tmpiqz3ey3w.cpp:24:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpiqz3ey3w.cpp:24:5: error: expected ')' before 'return'\n\
    /tmp/tmpiqz3ey3w.cpp: In function 'int main()':\n/tmp/tmpiqz3ey3w.cpp:27:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = match_parens;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiqz3ey3w.cpp:2:\n/tmp/tmpiqz3ey3w.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpiqz3ey3w.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpiqz3ey3w.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpiqz3ey3w.cpp:28:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpiqz3ey3w.cpp:29:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [e"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // Your code here\n  std::string ans = \"No\";\n  for (int i = 0;\
    \ i < lst.size(); i++) {\n    if (lst[i][0] == '(' && lst[i][1] == ')') {\n  \
    \    ans = \"Yes\";\n      break;\n    }\n  }\n  return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphaye3qw5.cpp: In function 'int main()':\n/tmp/tmphaye3qw5.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphaye3qw5.cpp:2:\n/tmp/tmphaye3qw5.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmphaye3qw5.cpp:29:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmphaye3qw5.cpp:29:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmphaye3qw5.cpp:29:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmphaye3qw5.cpp:30:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmphaye3qw5.cpp:30:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmphaye3qw5.cpp:30:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    bool flag = true;\n    for (auto\
    \ &s : lst) {\n        if (s.find(\"(\") == std::string::npos) {\n           \
    \ flag = false;\n            break;\n        }\n    }\n    if (flag) {\n     \
    \   ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd3ndfxm9.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpd3ndfxm9.cpp:19:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpd3ndfxm9.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpd3ndfxm9.cpp:20:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") == std::string::npos) {\n               ^\n/tmp/tmpd3ndfxm9.cpp:\
    \ In function 'int main()':\n/tmp/tmpd3ndfxm9.cpp:31:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd3ndfxm9.cpp:2:\n/tmp/tmpd3ndfxm9.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpd3ndfxm9.cpp:32:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpd3ndfxm9.cpp:32:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpd3ndfxm9.cpp:32:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpd3ndfxm9.cpp:33:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            ans = \"Yes\";\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7w9xb165.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp7w9xb165.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmp7w9xb165.cpp:23:5: error: expected\
    \ ';' before 'return'\n     return ans;\n     ^\n/tmp/tmp7w9xb165.cpp:23:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmp7w9xb165.cpp:23:5: error:\
    \ expected ';' before 'return'\n/tmp/tmp7w9xb165.cpp:23:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp7w9xb165.cpp:23:5: error: expected ')' before 'return'\n\
    /tmp/tmp7w9xb165.cpp: In function 'int main()':\n/tmp/tmp7w9xb165.cpp:26:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = match_parens;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7w9xb165.cpp:2:\n/tmp/tmp7w9xb165.cpp:27:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp7w9xb165.cpp:27:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp7w9xb165.cpp:27:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp7w9xb165.cpp:27:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp7w9xb165.cpp:28:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [e"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    stack<std::string> st;\n    for (auto\
    \ &s : lst) {\n        if (s == \"(\") {\n            st.push(s);\n        } else\
    \ if (s == \")\") {\n            if (st.empty()) {\n                ans = \"Yes\"\
    ;\n                break;\n            }\n            std::string top = st.top();\n\
    \            st.pop();\n            if (top == \"(\") {\n                st.push(s);\n\
    \            } else {\n                ans = \"No\";\n                break;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy9oo77no.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpy9oo77no.cpp:18:5: error: 'stack' was not declared in this scope\n\
    \     stack<std::string> st;\n     ^\n/tmp/tmpy9oo77no.cpp:18:5: note: suggested\
    \ alternative:\nIn file included from /usr/include/c++/4.8.2/stack:61:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:88,\n\
    \                 from /tmp/tmpy9oo77no.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_stack.h:96:11:\
    \ note:   'std::stack'\n     class stack\n           ^\n/tmp/tmpy9oo77no.cpp:18:22:\
    \ error: expected primary-expression before '>' token\n     stack<std::string>\
    \ st;\n                      ^\n/tmp/tmpy9oo77no.cpp:18:24: error: 'st' was not\
    \ declared in this scope\n     stack<std::string> st;\n                      \
    \  ^\n/tmp/tmpy9oo77no.cpp:19:16: error: ISO C++ forbids declaration of 's' with\
    \ no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n/tmp/tmpy9oo77no.cpp:19:20:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &s : lst) {\n                    ^\n/tmp/tmpy9oo77no.cpp:20:18: error: ISO C++\
    \ forbids comparison between pointer and integer [-fpermissive]\n         if (s\
    \ == \"(\") {\n                  ^\n/tmp/tmpy9oo77no.cpp:22:25: error: ISO C++\
    \ forbids comparison between pointer and integer [-fpermissive]\n         } else\
    \ if (s == \")\") {\n                         ^\n/tmp/tmpy9oo77no.cpp: In function\
    \ 'int main()':\n/tmp/tmpy9oo77no.cpp:40:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy9oo77no.cpp:2:\n/tmp/tmpy9oo77no.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpy9o"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    stack<std::string> st;\n    for (auto\
    \ &i : lst) {\n        if (i == \"(\") {\n            st.push(i);\n        } else\
    \ if (i == \")\") {\n            if (st.empty()) {\n                ans = \"Yes\"\
    ;\n                break;\n            }\n            while (!st.empty() && st.top()\
    \ == \"(\") {\n                st.pop();\n            }\n            if (st.empty())\
    \ {\n                ans = \"No\";\n                break;\n            }\n  \
    \          st.pop();\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp76pk5ov7.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp76pk5ov7.cpp:18:5: error: 'stack' was not declared in this scope\n\
    \     stack<std::string> st;\n     ^\n/tmp/tmp76pk5ov7.cpp:18:5: note: suggested\
    \ alternative:\nIn file included from /usr/include/c++/4.8.2/stack:61:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:88,\n\
    \                 from /tmp/tmp76pk5ov7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_stack.h:96:11:\
    \ note:   'std::stack'\n     class stack\n           ^\n/tmp/tmp76pk5ov7.cpp:18:22:\
    \ error: expected primary-expression before '>' token\n     stack<std::string>\
    \ st;\n                      ^\n/tmp/tmp76pk5ov7.cpp:18:24: error: 'st' was not\
    \ declared in this scope\n     stack<std::string> st;\n                      \
    \  ^\n/tmp/tmp76pk5ov7.cpp:19:16: error: ISO C++ forbids declaration of 'i' with\
    \ no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n/tmp/tmp76pk5ov7.cpp:19:20:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &i : lst) {\n                    ^\n/tmp/tmp76pk5ov7.cpp:20:18: error: ISO C++\
    \ forbids comparison between pointer and integer [-fpermissive]\n         if (i\
    \ == \"(\") {\n                  ^\n/tmp/tmp76pk5ov7.cpp:22:25: error: ISO C++\
    \ forbids comparison between pointer and integer [-fpermissive]\n         } else\
    \ if (i == \")\") {\n                         ^\n/tmp/tmp76pk5ov7.cpp: In function\
    \ 'int main()':\n/tmp/tmp76pk5ov7.cpp:40:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp76pk5ov7.cpp:2:\n/tmp/tmp76pk5ov7.cpp:41:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp76p"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // Your code here\n  std::string ans = \"No\";\n  for (int i = 0;\
    \ i < lst.size(); i++) {\n    if (lst[i][0] == '(' && lst[i][1] == ')') {\n  \
    \    ans = \"Yes\";\n      break;\n    }\n  }\n  return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphaye3qw5.cpp: In function 'int main()':\n/tmp/tmphaye3qw5.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphaye3qw5.cpp:2:\n/tmp/tmphaye3qw5.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmphaye3qw5.cpp:29:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmphaye3qw5.cpp:29:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmphaye3qw5.cpp:29:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmphaye3qw5.cpp:30:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmphaye3qw5.cpp:30:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmphaye3qw5.cpp:30:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector\
    \ of two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &x : lst) {\n        if\
    \ (x.size() == 1) {\n            ans = \"Yes\";\n            break;\n        }\n\
    \        ans = \"No\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt485e4oe.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpt485e4oe.cpp:18:16: error: ISO C++ forbids declaration of 'x'\
    \ with no type [-fpermissive]\n     for (auto &x : lst) {\n                ^\n\
    /tmp/tmpt485e4oe.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &x : lst) {\n                    ^\n/tmp/tmpt485e4oe.cpp:19:15:\
    \ error: request for member 'size' in 'x', which is of non-class type 'int'\n\
    \         if (x.size() == 1) {\n               ^\n/tmp/tmpt485e4oe.cpp: In function\
    \ 'int main()':\n/tmp/tmpt485e4oe.cpp:28:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt485e4oe.cpp:2:\n/tmp/tmpt485e4oe.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpt485e4oe.cpp:29:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpt485e4oe.cpp:29:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpt485e4oe.cpp:29:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpt485e4oe.cpp:30:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate(("
  stdout: ''
