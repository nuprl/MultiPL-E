language: cpp
name: HumanEval_141_file_name_check
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    \n    std::string\
    \ file_name_check;\n    \n    if (file_name.size() > 3 || file_name.find(\".\"\
    ) == 0 || file_name.substr(0, 1) < 'a' || file_name.substr(0, 1) > 'z' || file_name.substr(file_name.find_last_of(\"\
    .\") + 1) != \"txt\" || file_name.substr(file_name.find_last_of(\".\") + 1) !=\
    \ \"exe\" || file_name.substr(file_name.find_last_of(\".\") + 1) != \"dll\") {\n\
    \        file_name_check = \"No\";\n    } else {\n        file_name_check = \"\
    Yes\";\n    }\n    \n    return file_name_check;\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp18pfj7f5.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp18pfj7f5.cpp:22:84: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.size() > 3 || file_name.find(\"\
    .\") == 0 || file_name.substr(0, 1) < 'a' || file_name.substr(0, 1) > 'z' || file_name.substr(file_name.find_last_of(\"\
    .\") + 1) != \"txt\" || file_name.substr(file_name.find_last_of(\".\") + 1) !=\
    \ \"exe\" || file_name.substr(file_name.find_last_of(\".\") + 1) != \"dll\") {\n\
    \                                                                            \
    \        ^\n/tmp/tmp18pfj7f5.cpp:22:84: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmp18pfj7f5.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp18pfj7f5.cpp:22:86: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.size() > 3 ||\
    \ file_name.find(\".\") == 0 || file_name.substr(0, 1) < 'a' || file_name.substr(0,\
    \ 1) > 'z' || file_name.substr(file_name.find_last_of(\".\") + 1) != \"txt\" ||\
    \ file_name.substr(file_name.find_last_of(\".\") + 1) != \"exe\" || file_name.substr(file_name.find_last_of(\"\
    .\") + 1) != \"dll\") {\n                                                    \
    \                                  ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp18pfj7f5.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BIN"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    \n    //\
    \ Write your code here\n    \n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgfhyfa4i.cpp: In function 'int main()':\n/tmp/tmpgfhyfa4i.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgfhyfa4i.cpp:2:\n/tmp/tmpgfhyfa4i.cpp:26:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    std::string\
    \ file_extension = file_name.substr(file_name.find_last_of(\".\") + 1);\n    if\
    \ (file_name.find_last_of(\".\") > 0) {\n        if (file_name.find_last_of(\"\
    .\") > 3) {\n            return \"No\";\n        }\n    }\n    if (file_name.find_first_not_of(\"\
    0123456789\") == 0) {\n        return \"No\";\n    }\n    if (file_name.find_first_not_of(\"\
    abcdefghijklmnopqrstuvwxyz\") == 0) {\n        return \"No\";\n    }\n    if (file_name.find_first_not_of(\"\
    .txt\") == 0) {\n        return \"No\";\n    }\n    if (file_name.find_first_not_of(\"\
    .exe\") == 0) {\n        return \"No\";\n    }\n    if (file_name.find_first_not_of(\"\
    .dll\") == 0) {\n        return \"No\";\n    }\n    if (file_extension == \"txt\"\
    ) {\n        return \"Yes\";\n    }\n    if (file_extension == \"exe\") {\n  \
    \      return \"Yes\";\n    }\n    if (file_extension == \"dll\") {\n        return\
    \ \"Yes\";\n    }\n    return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuqjehw3r.cpp: In function 'int main()':\n/tmp/tmpuqjehw3r.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuqjehw3r.cpp:2:\n/tmp/tmpuqjehw3r.cpp:53:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code goes here\n    int\
    \ count = 0;\n    for(int i = 0; i < file_name.length(); i++) {\n        if(file_name[i]\
    \ >= '0' && file_name[i] <= '9') {\n            count++;\n        }\n    }\n \
    \   if(count > 3) {\n        return \"No\";\n    }\n    else if(file_name.find(\"\
    .\") == -1) {\n        return \"No\";\n    }\n    else if(file_name.substr(0,\
    \ 1) < 'a' || file_name.substr(0, 1) > 'z') {\n        return \"No\";\n    }\n\
    \    else if(file_name.substr(file_name.find(\".\") + 1) != \"txt\" && file_name.substr(file_name.find(\"\
    .\") + 1) != \"exe\" && file_name.substr(file_name.find(\".\") + 1) != \"dll\"\
    ) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nint main() {\n   \
    \ auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3b_9scmt.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp3b_9scmt.cpp:31:36: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     else if(file_name.substr(0, 1) <\
    \ 'a' || file_name.substr(0, 1) > 'z') {\n                                   \
    \ ^\n/tmp/tmp3b_9scmt.cpp:31:36: note: candidates are:\nIn file included from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n           \
    \      from /tmp/tmp3b_9scmt.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1: note:\
    \ template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant, std::_ValArray,\
    \ _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type> std::operator<(const\
    \ _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<, __less)\n ^\n\
    /usr/include/c++/4.8.2/valarray:1181:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp3b_9scmt.cpp:31:38: note:   mismatched types 'const std::valarray<_Tp>'\
    \ and 'char'\n     else if(file_name.substr(0, 1) < 'a' || file_name.substr(0,\
    \ 1) > 'z') {\n                                      ^\nIn file included from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n           \
    \      from /tmp/tmp3b_9scmt.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1: note:\
    \ template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray, std::_Constant,\
    \ _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type> std::operator<(const\
    \ std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<, __less)\n ^\n\
    /usr/include/c++/4.8.2/valarray:1181:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp3b_9scmt.cpp:31:38: note:   'std::basic_string<char>' is not\
    \ derived from 'const std::valarray<_Tp>'\n     else if(file_name.substr(0, 1)\
    \ < 'a' || file_name.substr(0, 1) > 'z') {\n                                 \
    \     ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp3b_9scmt.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code goes here\n    std::string\
    \ file_extension = file_name.substr(file_name.find_last_of('.') + 1); \n    std::string\
    \ file_content = file_name.substr(0, file_name.find_last_of('.'));\n    \n   \
    \ if(file_extension == \"txt\" || file_extension == \"exe\" || file_extension\
    \ == \"dll\"){\n        return \"Yes\";\n    }\n    else{\n        return \"No\"\
    ;\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmo_4d6w0.cpp: In function 'int main()':\n/tmp/tmpmo_4d6w0.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmo_4d6w0.cpp:2:\n/tmp/tmpmo_4d6w0.cpp:31:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    std::string file_name_check;\n\
    \    // Your code goes here\n    \n    return file_name_check;\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpooyw8rrf.cpp: In function 'int main()':\n/tmp/tmpooyw8rrf.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpooyw8rrf.cpp:2:\n/tmp/tmpooyw8rrf.cpp:25:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code goes here\n    \n\
    \    std::string file_extension = file_name.substr(file_name.find_last_of(\".\"\
    ) + 1);\n    \n    if (file_name.length() < 3 || file_name.find_last_of(\".\"\
    ) == std::string::npos) {\n        return \"No\";\n    }\n    \n    if (file_extension\
    \ != \"txt\" && file_extension != \"exe\" && file_extension != \"dll\") {\n  \
    \      return \"No\";\n    }\n    \n    if (file_name.substr(0, 1) < 'a' || file_name.substr(0,\
    \ 1) > 'z' || file_name.substr(0, 1) < 'A' || file_name.substr(0, 1) > 'Z') {\n\
    \        return \"No\";\n    }\n    \n    return \"Yes\";\n}\nint main() {\n \
    \   auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"))\
    \ == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n   \
    \ assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\"\
    )) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n\
    \    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyz1qvj66.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpyz1qvj66.cpp:30:32: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0, 1) < 'a'\
    \ || file_name.substr(0, 1) > 'z' || file_name.substr(0, 1) < 'A' || file_name.substr(0,\
    \ 1) > 'Z') {\n                                ^\n/tmp/tmpyz1qvj66.cpp:30:32:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpyz1qvj66.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpyz1qvj66.cpp:30:34: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0, 1)\
    \ < 'a' || file_name.substr(0, 1) > 'z' || file_name.substr(0, 1) < 'A' || file_name.substr(0,\
    \ 1) > 'Z') {\n                                  ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpyz1qvj66.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpyz1qvj66.cpp:30:34: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n     if (file_name.substr(0,\
    \ 1) < 'a' || file_name.substr(0, 1) > 'z' || file_name.substr(0, 1) < 'A' ||\
    \ file_name.substr(0, 1) > 'Z') {\n                                  ^\nIn file\
    \ included from /usr/include/c++/4.8.2/x"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code goes here\n    std::string\
    \ file_name = file_name;\n    std::string file_name = file_name.substr(0, file_name.find_first_of('.'));\n\
    \    std::string file_name = file_name.substr(0, file_name.find_first_not_of('.'));\n\
    \    std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.')));\n    std::string file_name = file_name.substr(0,\
    \ file_name.find_first_not_of('.', file_name.find_first_of('.', file_name.find_first_of('.'))));\n\
    \    std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.'))));\n\
    \    std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.')))));\n    std::string file_name = file_name.substr(0,\
    \ file_name.find_first_not_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.')))))));\n\
    \    std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.')))))));\n    std::string file_name = file_name.substr(0,\
    \ file_name.find_first_not_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.')))))));\n\
    \    std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.')))))))));\n    std::string file_name = file_name.substr(0,\
    \ file_name.find_first_not_of('.', file_name.find_first_of('.', file_name.find_first_of('.',\
    \ file_name.find_first_of('.\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0c01waj6.cpp:30:164: warning: missing terminating ' character [enabled\
    \ by default]\n     std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.\n\
    \                                                                            \
    \                                                                            \
    \            ^\n/tmp/tmp0c01waj6.cpp:30:5: error: missing terminating ' character\n\
    \     std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ file_name.find_first_of('.', file_name.find_first_of('.', file_name.find_first_of('.\n\
    \     ^\n/tmp/tmp0c01waj6.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp0c01waj6.cpp:19:17: error: declaration of 'std::string file_name' shadows\
    \ a parameter\n     std::string file_name = file_name;\n                 ^\n/tmp/tmp0c01waj6.cpp:20:17:\
    \ error: redeclaration of 'std::string file_name'\n     std::string file_name\
    \ = file_name.substr(0, file_name.find_first_of('.'));\n                 ^\n/tmp/tmp0c01waj6.cpp:19:17:\
    \ error: 'std::string file_name' previously declared here\n     std::string file_name\
    \ = file_name;\n                 ^\n/tmp/tmp0c01waj6.cpp:21:17: error: redeclaration\
    \ of 'std::string file_name'\n     std::string file_name = file_name.substr(0,\
    \ file_name.find_first_not_of('.'));\n                 ^\n/tmp/tmp0c01waj6.cpp:19:17:\
    \ error: 'std::string file_name' previously declared here\n     std::string file_name\
    \ = file_name;\n                 ^\n/tmp/tmp0c01waj6.cpp:22:17: error: redeclaration\
    \ of 'std::string file_name'\n     std::string file_name = file_name.substr(0,\
    \ file_name.find_first_not_of('.', file_name.find_first_of('.')));\n         \
    \        ^\n/tmp/tmp0c01waj6.cpp:19:17: error: 'std::string file_name' previously\
    \ declared here\n     std::string file_name = file_name;\n                 ^\n\
    /tmp/tmp0c01waj6.cpp:23:17: error: redeclaration of 'std::string file_name'\n\
    \     std::string file_name = file_name.substr(0, file_name.find_first_not_of('.',\
    \ fil"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Write your code here\n    \n\
    \    // return \"Yes\";\n    return \"No\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpve0tel_7.cpp: In function 'int main()':\n/tmp/tmpve0tel_7.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpve0tel_7.cpp:2:\n/tmp/tmpve0tel_7.cpp:25:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    std::string\
    \ file_extension = file_name.substr(file_name.find_last_of(\".\") + 1);\n    std::string\
    \ file_without_extension = file_name.substr(0, file_name.find_last_of(\".\"));\n\
    \    std::string file_without_extension_without_dots = file_without_extension.substr(0,\
    \ file_without_extension.find_last_of(\".\"));\n    std::string file_without_extension_without_dots_without_extension\
    \ = file_without_extension_without_dots.substr(0, file_without_extension_without_dots.find_last_of(\"\
    .\"));\n    std::string file_without_extension_without_dots_without_extension_without_dots\
    \ = file_without_extension_without_dots_without_extension.substr(0, file_without_extension_without_dots_without_extension.find_last_of(\"\
    .\"));\n    std::string file_without_extension_without_dots_without_extension_without_dots_without_extension\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension.substr(0,\
    \ file_without_extension_without_dots_without_extension_without_dots_without_extension.find_last_of(\"\
    .\"));\n    std::string file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots.substr(0,\
    \ file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots.find_last_of(\"\
    .\"));\n    std::string file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.substr(0,\
    \ file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.find_last_of(\"\
    .\"));\n    std::string file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.substr(0,\
    \ file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.find_last_of(\"\
    .\"));\n    std::string file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.substr(0,\
    \ file_without_extension\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2kdomie2.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp2kdomie2.cpp:27:148: error: 'file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension'\
    \ was not declared in this scope\n     std::string file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.substr(0,\
    \ file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.find_last_of(\"\
    .\"));\n                                                                     \
    \                                                                            \
    \   ^\n/tmp/tmp2kdomie2.cpp:28:166: error: 'file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension'\
    \ was not declared in this scope\n     std::string file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension\
    \ = file_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension_without_dots_without_extension.substr(0,\
    \ file_without_extension\n                                                   \
    \                                                                            \
    \                                       ^\n/tmp/tmp2kdomie2.cpp:29:1: error: expected\
    \ ')' before '}' token\n }\n ^\n/tmp/tmp2kdomie2.cpp: In function 'int main()':\n\
    /tmp/tmp2kdomie2.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    int num_digits = 0;\n    int dot_count\
    \ = 0;\n    for (int i = 0; i < file_name.length(); i++) {\n        if (file_name[i]\
    \ >= '0' && file_name[i] <= '9') {\n            num_digits++;\n        }\n   \
    \     else if (file_name[i] == '.') {\n            dot_count++;\n        }\n \
    \   }\n    if (dot_count > 1 || num_digits > 3) {\n        return \"No\";\n  \
    \  }\n    else if ((file_name[0] == 'a' || file_name[0] == 'A') && file_name[1]\
    \ >= 'a' && file_name[1] <= 'z') {\n        return \"Yes\";\n    }\n    else if\
    \ ((file_name[0] == 'b' || file_name[0] == 'B') && file_name[1] >= 'a' && file_name[1]\
    \ <= 'z') {\n        return \"Yes\";\n    }\n    else if ((file_name[0] == 'c'\
    \ || file_name[0] == 'C') && file_name[1] >= 'a' && file_name[1] <= 'z') {\n \
    \       return \"Yes\";\n    }\n    else if ((file_name[0] == 'd' || file_name[0]\
    \ == 'D') && file_name[1] >= 'a' && file_name[1] <= 'z') {\n        return \"\
    Yes\";\n    }\n    else if ((file_name[0] == 'e' || file_name[0] == 'E') && file_name[1]\
    \ >= 'a' && file_name[1] <= 'z') {\n        return \"Yes\";\n    }\n    else if\
    \ ((file_name[0] == 'f' || file_name[0] == 'F') && file_name[1] >= 'a' && file_name[1]\
    \ <= 'z') {\n        return \"Yes\";\n    }\n    else if ((file_name[0] == 'g'\
    \ || file_name[0] == 'G') && file_name[1] >= 'a' && file_name[1] <= 'z') {\n \
    \       return \"Yes\";\n    }\n    else if ((file_name[0] == 'h' || file_name[0]\
    \ == 'H') && file_name[1] >= 'a' && file_name[1] <= 'z') {\n        return \"\
    Yes\";\n    }\n    else if ((file_name[0] == 'i' || file_name[0] == 'I') && file_name[1]\
    \ >= 'a' && file_name[1] <= 'z') {\n        return \"Yes\";\n    }\n    else if\
    \ ((file_name[0] == 'j' || file_name[0] == 'J') && file_name[1] >= 'a' && file_name[1]\
    \ <= 'z') {\n        return \"Yes\";\n    }\n    else if ((file_name[0] == 'k'\
    \ || file_name[0] == 'K') && file_name[1] >= 'a' && file_name[1] <= 'z') {\n \
    \       return \"Yes\";\n    }\n    else if ((file_name[0] == 'l' || file_name[0]\
    \ == 'L') && file_name[1] >= 'a' && file_name[1] <= 'z') {\n        return \"\
    Yes\";\n    }\n    else if ((file_name[0] == 'm' || file_name[0] == 'M') && file_name[1]\
    \ >= 'a' && file_name[1] <= 'z') {\n        return \"Yes\";\n    }\n    else if\
    \ ((file_name[0] == 'n' || file_name[0] == 'N') && file_name[1] >= 'a' && file_name[1]\
    \ <= 'z') {\n        return \"Yes\";\n    }\n    else if ((file_name[0] == 'o'\
    \ || file_name[0] == '\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw8t2rq4r.cpp:73:54: warning: missing terminating ' character [enabled\
    \ by default]\n     else if ((file_name[0] == 'o' || file_name[0] == '\n     \
    \                                                 ^\n/tmp/tmpw8t2rq4r.cpp:73:5:\
    \ error: missing terminating ' character\n     else if ((file_name[0] == 'o' ||\
    \ file_name[0] == '\n     ^\n/tmp/tmpw8t2rq4r.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpw8t2rq4r.cpp:74:1: error: expected primary-expression before '}' token\n\
    \ }\n ^\n/tmp/tmpw8t2rq4r.cpp:74:1: error: expected ')' before '}' token\n/tmp/tmpw8t2rq4r.cpp:74:1:\
    \ error: expected ')' before '}' token\n/tmp/tmpw8t2rq4r.cpp:74:1: error: expected\
    \ primary-expression before '}' token\n/tmp/tmpw8t2rq4r.cpp:74:1: error: expected\
    \ ';' before '}' token\n/tmp/tmpw8t2rq4r.cpp: In function 'int main()':\n/tmp/tmpw8t2rq4r.cpp:76:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw8t2rq4r.cpp:2:\n/tmp/tmpw8t2rq4r.cpp:77:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code goes here\n    \n\
    \    std::string file_extension = file_name.substr(file_name.find_last_of(\".\"\
    ) + 1);\n    \n    if (file_name.length() > 3 && file_name.find_last_of(\".\"\
    ) > 0 && file_name[0] >= 'a' && file_name[0] <= 'z' && file_name[1] >= 'a' &&\
    \ file_name[1] <= 'z' && file_name[2] >= 'a' && file_name[2] <= 'z') {\n     \
    \   if (file_extension == \"txt\" || file_extension == \"exe\" || file_extension\
    \ == \"dll\") {\n            return \"Yes\";\n        }\n    }\n    return \"\
    No\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl7id6rx5.cpp: In function 'int main()':\n/tmp/tmpl7id6rx5.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl7id6rx5.cpp:2:\n/tmp/tmpl7id6rx5.cpp:31:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    std::string file_extension;\n\
    \    std::string file_extension_check;\n    std::string file_extension_check_2;\n\
    \    std::string file_extension_check_3;\n    std::string file_extension_check_4;\n\
    \    std::string file_extension_check_5;\n    std::string file_extension_check_6;\n\
    \    std::string file_extension_check_7;\n    std::string file_extension_check_8;\n\
    \    std::string file_extension_check_9;\n    std::string file_extension_check_10;\n\
    \    std::string file_extension_check_11;\n    std::string file_extension_check_12;\n\
    \    std::string file_extension_check_13;\n    std::string file_extension_check_14;\n\
    \    std::string file_extension_check_15;\n    std::string file_extension_check_16;\n\
    \    std::string file_extension_check_17;\n    std::string file_extension_check_18;\n\
    \    std::string file_extension_check_19;\n    std::string file_extension_check_20;\n\
    \    std::string file_extension_check_21;\n    std::string file_extension_check_22;\n\
    \    std::string file_extension_check_23;\n    std::string file_extension_check_24;\n\
    \    std::string file_extension_check_25;\n    std::string file_extension_check_26;\n\
    \    std::string file_extension_check_27;\n    std::string file_extension_check_28;\n\
    \    std::string file_extension_check_29;\n    std::string file_extension_check_30;\n\
    \    std::string file_extension_check_31;\n    std::string file_extension_check_32;\n\
    \    std::string file_extension_check_33;\n    std::string file_extension_check_34;\n\
    \    std::string file_extension_check_35;\n    std::string file_extension_check_36;\n\
    \    std::string file_extension_check_37;\n    std::string file_extension_check_38;\n\
    \    std::string file_extension_check_39;\n    std::string file_extension_check_40;\n\
    \    std::string file_extension_check_41;\n    std::string file_extension_check_42;\n\
    \    std::string file_extension_check_43;\n    std::string file_extension_check_44;\n\
    \    std::string file_extension_check_45;\n    std::string file_extension_check_46;\n\
    \    std::string file_extension_check_47;\n    std::string file_extension_check_48;\n\
    \    std::string file_extension_check_49;\n    std::string file_extension_check_50;\n\
    \    std::string file_extension_check_51;\n    std::string file_extension_check_52;\n\
    \    std::string file_extension_check_53;\n    std::string file_extension_check_54;\n\
    \    std::string file_extension_check_55;\n    std::string file_extension_check_56;\n\
    \    std::string file_extension_check_57;\n    std::string file_extension_check_58;\n\
    \    std::string file_\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpns7bodro.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpns7bodro.cpp:78:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpns7bodro.cpp: In function 'int main()':\n/tmp/tmpns7bodro.cpp:80:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpns7bodro.cpp:2:\n/tmp/tmpns7bodro.cpp:81:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    \n    //\
    \ Write your code here\n    \n    return file_name;\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_t8hc74c.cpp: In function 'int main()':\n/tmp/tmp_t8hc74c.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_t8hc74c.cpp:2:\n/tmp/tmp_t8hc74c.cpp:26:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Write your code here\n    \n\
    \    // return \"Yes\";\n    return \"No\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpve0tel_7.cpp: In function 'int main()':\n/tmp/tmpve0tel_7.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpve0tel_7.cpp:2:\n/tmp/tmpve0tel_7.cpp:25:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    int count\
    \ = 0;\n    for (int i = 0; i < file_name.length(); i++) {\n        if (file_name[i]\
    \ >= 'a' && file_name[i] <= 'z') {\n            count++;\n        }\n        if\
    \ (file_name[i] >= 'A' && file_name[i] <= 'Z') {\n            count++;\n     \
    \   }\n        if (file_name[i] == '.') {\n            count++;\n        }\n \
    \       if (count > 3) {\n            return \"No\";\n        }\n    }\n    if\
    \ (file_name.find(\".\") == std::string::npos) {\n        return \"No\";\n   \
    \ }\n    if (file_name.substr(0, 1) != 'a' && file_name.substr(0, 1) != 'A') {\n\
    \        return \"No\";\n    }\n    if (file_name.substr(file_name.find(\".\"\
    ) + 1) != \"txt\" && file_name.substr(file_name.find(\".\") + 1) != \"exe\" &&\
    \ file_name.substr(file_name.find(\".\") + 1) != \"dll\") {\n        return \"\
    No\";\n    }\n    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnu2kbh3m.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpnu2kbh3m.cpp:37:32: error: no match for 'operator!=' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0, 1) != 'a'\
    \ && file_name.substr(0, 1) != 'A') {\n                                ^\n/tmp/tmpnu2kbh3m.cpp:37:32:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpnu2kbh3m.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnu2kbh3m.cpp:37:35: note: \
    \  mismatched types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0,\
    \ 1) != 'a' && file_name.substr(0, 1) != 'A') {\n                            \
    \       ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpnu2kbh3m.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnu2kbh3m.cpp:37:35: note: \
    \  'std::basic_string<char>' is not derived from 'const std::valarray<_Tp>'\n\
    \     if (file_name.substr(0, 1) != 'a' && file_name.substr(0, 1) != 'A') {\n\
    \                                   ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpnu2kbh3m.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ \n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphvr86179.cpp: In function 'int main()':\n/tmp/tmphvr86179.cpp:167:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphvr86179.cpp:2:\n/tmp/tmphvr86179.cpp:168:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    int n = file_name.size();\n  \
    \  if (n < 3 || file_name.at(0) == '0' || file_name.at(0) == '9') {\n        return\
    \ \"No\";\n    }\n    if (file_name.at(-1) != '.') {\n        return \"No\";\n\
    \    }\n    if (file_name.at(0) != 'a' || file_name.at(0) != 'z' || file_name.at(0)\
    \ != 'A' || file_name.at(0) != 'Z') {\n        return \"No\";\n    }\n    if (file_name.at(1)\
    \ == '0' || file_name.at(1) == '9') {\n        return \"No\";\n    }\n    if (file_name.at(file_name.size()\
    \ - 1) != 'txt' || file_name.at(file_name.size() - 1) != 'exe' || file_name.at(file_name.size()\
    \ - 1) != 'dll') {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nint\
    \ main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpokqiczpy.cpp:31:47: warning: multi-character character constant\
    \ [-Wmultichar]\n     if (file_name.at(file_name.size() - 1) != 'txt' || file_name.at(file_name.size()\
    \ - 1) != 'exe' || file_name.at(file_name.size() - 1) != 'dll') {\n          \
    \                                     ^\n/tmp/tmpokqiczpy.cpp:31:94: warning:\
    \ multi-character character constant [-Wmultichar]\n     if (file_name.at(file_name.size()\
    \ - 1) != 'txt' || file_name.at(file_name.size() - 1) != 'exe' || file_name.at(file_name.size()\
    \ - 1) != 'dll') {\n                                                         \
    \                                     ^\n/tmp/tmpokqiczpy.cpp:31:141: warning:\
    \ multi-character character constant [-Wmultichar]\n     if (file_name.at(file_name.size()\
    \ - 1) != 'txt' || file_name.at(file_name.size() - 1) != 'exe' || file_name.at(file_name.size()\
    \ - 1) != 'dll') {\n                                                         \
    \                                                                            \
    \        ^\n/tmp/tmpokqiczpy.cpp: In function 'int main()':\n/tmp/tmpokqiczpy.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpokqiczpy.cpp:2:\n/tmp/tmpokqiczpy.cpp:38:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code here\n    \n    return\
    \ file_name;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp31mxw7uu.cpp: In function 'int main()':\n/tmp/tmp31mxw7uu.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp31mxw7uu.cpp:2:\n/tmp/tmp31mxw7uu.cpp:24:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"\
    ))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string\
    \ file_name_check(std::string file_name) {\n    // Your code goes here\n    int\
    \ count = 0;\n    for (int i = 0; i < file_name.length(); i++) {\n        if (file_name[i]\
    \ < '0' || file_name[i] > '9') {\n            count++;\n        }\n    }\n   \
    \ if (count > 3) {\n        return \"No\";\n    }\n    if (file_name.find(\".\"\
    ) == std::string::npos) {\n        return \"No\";\n    }\n    if (file_name.substr(0,\
    \ 1) < 'a' || file_name.substr(0, 1) > 'z') {\n        return \"No\";\n    }\n\
    \    if (file_name.substr(file_name.find(\".\") + 1) != \"txt\" && file_name.substr(file_name.find(\"\
    .\") + 1) != \"exe\" && file_name.substr(file_name.find(\".\") + 1) != \"dll\"\
    ) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nint main() {\n   \
    \ auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp88beayew.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp88beayew.cpp:31:32: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0, 1) < 'a'\
    \ || file_name.substr(0, 1) > 'z') {\n                                ^\n/tmp/tmp88beayew.cpp:31:32:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp88beayew.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp88beayew.cpp:31:34: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0, 1)\
    \ < 'a' || file_name.substr(0, 1) > 'z') {\n                                 \
    \ ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp88beayew.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp88beayew.cpp:31:34: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n     if (file_name.substr(0,\
    \ 1) < 'a' || file_name.substr(0, 1) > 'z') {\n                              \
    \    ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp88beayew.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std"
  stdout: ''
