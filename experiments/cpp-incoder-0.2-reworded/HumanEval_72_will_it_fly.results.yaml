language: cpp
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp62plb4qq.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp62plb4qq.cpp:20:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp62plb4qq.cpp:23:5: error: expected\
    \ ';' before 'if'\n     if (sum < w) return false;\n     ^\n/tmp/tmp62plb4qq.cpp:23:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmp62plb4qq.cpp:23:5: error:\
    \ expected ';' before 'if'\n/tmp/tmp62plb4qq.cpp:23:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp62plb4qq.cpp:23:5: error: expected ')' before 'if'\n/tmp/tmp62plb4qq.cpp:25:15:\
    \ error: 'i' does not name a type\n     for (auto i : q) {\n               ^\n\
    /tmp/tmp62plb4qq.cpp:28:5: error: expected ';' before 'return'\n     return max_sum\
    \ == w;\n     ^\n/tmp/tmp62plb4qq.cpp:28:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp62plb4qq.cpp:28:5: error: expected ';' before 'return'\n\
    /tmp/tmp62plb4qq.cpp:28:5: error: expected primary-expression before 'return'\n\
    /tmp/tmp62plb4qq.cpp:28:5: error: expected ')' before 'return'\n/tmp/tmp62plb4qq.cpp:\
    \ In function 'int main()':\n/tmp/tmp62plb4qq.cpp:31:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp62plb4qq.cpp:2:\n/tmp/tmp62plb4qq.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp62plb4qq.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp62plb4qq.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 ["
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_balanced(q);\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj2pbwz6v.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpj2pbwz6v.cpp:20:40: error: 'is_balanced' was not declared\
    \ in this scope\n     return max_sum < w && is_balanced(q);\n                \
    \                        ^\n/tmp/tmpj2pbwz6v.cpp: In function 'int main()':\n\
    /tmp/tmpj2pbwz6v.cpp:23:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj2pbwz6v.cpp:2:\n/tmp/tmpj2pbwz6v.cpp:24:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpj2pbwz6v.cpp:24:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpj2pbwz6v.cpp:24:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpj2pbwz6v.cpp:24:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpj2pbwz6v.cpp:24:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpj2pbwz6v.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpog26snql.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpog26snql.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmpog26snql.cpp:27:5: error: expected\
    \ ';' before 'if'\n     if (max_weight == w) {\n     ^\n/tmp/tmpog26snql.cpp:27:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpog26snql.cpp:27:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpog26snql.cpp:27:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpog26snql.cpp:27:5: error: expected ')' before 'if'\n/tmp/tmpog26snql.cpp:\
    \ In function 'int main()':\n/tmp/tmpog26snql.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpog26snql.cpp:2:\n/tmp/tmpog26snql.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpog26snql.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpog26snql.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpog26snql.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpog26snql.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpog26snql.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vect"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    if (max_sum == w) {\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9yhhc_gb.cpp: In function 'int main()':\n/tmp/tmp9yhhc_gb.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9yhhc_gb.cpp:2:\n/tmp/tmp9yhhc_gb.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp9yhhc_gb.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp9yhhc_gb.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp9yhhc_gb.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp9yhhc_gb.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp9yhhc_gb.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9yhhc_gb.cpp:2:\n/tmp/tmp9yhhc_gb.cpp:34:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (sum == max_sum) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yrq588b.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp7yrq588b.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp7yrq588b.cpp:27:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmp7yrq588b.cpp: In function 'int main()':\n\
    /tmp/tmp7yrq588b.cpp:36:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yrq588b.cpp:2:\n/tmp/tmp7yrq588b.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp7yrq588b.cpp:37:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp7yrq588b.cpp:37:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp7yrq588b.cpp:37:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp7yrq588b.cpp:37:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp7yrq588b.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum\
    \ += q[i];\n    }\n    if (max_sum < w) return false;\n    long sum = 0;\n   \
    \ for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n        if (sum\
    \ > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpswh_jok5.cpp: In function 'int main()':\n/tmp/tmpswh_jok5.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpswh_jok5.cpp:2:\n/tmp/tmpswh_jok5.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpswh_jok5.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpswh_jok5.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpswh_jok5.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpswh_jok5.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpswh_jok5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpswh_jok5.cpp:2:\n/tmp/tmpswh_jok5.cpp:34:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if(sum > max_weight) {\n            max_weight = sum;\n        }\n  \
    \  }\n    return max_weight <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppp0354b3.cpp: In function 'int main()':\n/tmp/tmppp0354b3.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppp0354b3.cpp:2:\n/tmp/tmppp0354b3.cpp:31:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmppp0354b3.cpp:31:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmppp0354b3.cpp:31:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmppp0354b3.cpp:31:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmppp0354b3.cpp:31:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmppp0354b3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppp0354b3.cpp:2:\n/tmp/tmppp0354b3.cpp:31:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum += q[i];\n \
    \   }\n    if(sum < w) {\n        return false;\n    }\n    long max_weight =\
    \ w;\n    for(long i = 0; i < q.size(); i++) {\n        if(q[i] > max_weight)\
    \ {\n            max_weight = q[i];\n        }\n    }\n    for(long i = 0; i <\
    \ q.size(); i++) {\n        q[i] /= max_weight;\n    }\n    for(long i = 0; i\
    \ < q.size(); i++) {\n        if(q[i] != 0) {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0mloxq2d.cpp: In function 'int main()':\n/tmp/tmp0mloxq2d.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0mloxq2d.cpp:2:\n/tmp/tmp0mloxq2d.cpp:45:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp0mloxq2d.cpp:45:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp0mloxq2d.cpp:45:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp0mloxq2d.cpp:45:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp0mloxq2d.cpp:45:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp0mloxq2d.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0mloxq2d.cpp:2:\n/tmp/tmp0mloxq2d.cpp:45:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n        if (max_sum\
    \ > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7nqkj118.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp7nqkj118.cpp:20:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp7nqkj118.cpp:23:5: error: expected\
    \ ';' before 'if'\n     if (sum < w) return false;\n     ^\n/tmp/tmp7nqkj118.cpp:23:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmp7nqkj118.cpp:23:5: error:\
    \ expected ';' before 'if'\n/tmp/tmp7nqkj118.cpp:23:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp7nqkj118.cpp:23:5: error: expected ')' before 'if'\n/tmp/tmp7nqkj118.cpp:25:15:\
    \ error: 'i' does not name a type\n     for (auto i : q) {\n               ^\n\
    /tmp/tmp7nqkj118.cpp:29:5: error: expected ';' before 'return'\n     return true;\n\
    \     ^\n/tmp/tmp7nqkj118.cpp:29:5: error: expected primary-expression before\
    \ 'return'\n/tmp/tmp7nqkj118.cpp:29:5: error: expected ';' before 'return'\n/tmp/tmp7nqkj118.cpp:29:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp7nqkj118.cpp:29:5:\
    \ error: expected ')' before 'return'\n/tmp/tmp7nqkj118.cpp: In function 'int\
    \ main()':\n/tmp/tmp7nqkj118.cpp:32:10: error: 'candidate' does not name a type\n\
    \     auto candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7nqkj118.cpp:2:\n/tmp/tmp7nqkj118.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp7nqkj118.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp7nqkj118.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum < w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp21crw4zl.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp21crw4zl.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp21crw4zl.cpp:27:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmp21crw4zl.cpp: In function 'int main()':\n\
    /tmp/tmp21crw4zl.cpp:36:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp21crw4zl.cpp:2:\n/tmp/tmp21crw4zl.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp21crw4zl.cpp:37:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp21crw4zl.cpp:37:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp21crw4zl.cpp:37:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp21crw4zl.cpp:37:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp21crw4zl.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (auto i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    long sum\
    \ = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    return max_sum ==\
    \ sum && max_sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ztqpgs3.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp8ztqpgs3.cpp:20:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp8ztqpgs3.cpp:23:5: error: expected\
    \ ';' before 'long'\n     long sum = 0;\n     ^\n/tmp/tmp8ztqpgs3.cpp:24:5: error:\
    \ expected primary-expression before 'for'\n     for (auto i : q) {\n     ^\n\
    /tmp/tmp8ztqpgs3.cpp:24:5: error: expected ')' before 'for'\n/tmp/tmp8ztqpgs3.cpp:24:15:\
    \ error: 'i' does not name a type\n     for (auto i : q) {\n               ^\n\
    /tmp/tmp8ztqpgs3.cpp:27:5: error: expected ';' before 'return'\n     return max_sum\
    \ == sum && max_sum < w;\n     ^\n/tmp/tmp8ztqpgs3.cpp:27:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp8ztqpgs3.cpp:27:5: error: expected ';' before 'return'\n\
    /tmp/tmp8ztqpgs3.cpp:27:5: error: expected primary-expression before 'return'\n\
    /tmp/tmp8ztqpgs3.cpp:27:5: error: expected ')' before 'return'\n/tmp/tmp8ztqpgs3.cpp:\
    \ In function 'int main()':\n/tmp/tmp8ztqpgs3.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ztqpgs3.cpp:2:\n/tmp/tmp8ztqpgs3.cpp:31:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp8ztqpgs3.cpp:31:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp8ztqpgs3.cpp:31:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8ztqpgs3.cpp:31:68: error: no matching function for call to 'std::"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long max_sum = 0;\n    for (long i\
    \ : q) {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuswiipux.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpuswiipux.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpuswiipux.cpp:28:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpuswiipux.cpp: In function 'int main()':\n\
    /tmp/tmpuswiipux.cpp:37:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuswiipux.cpp:2:\n/tmp/tmpuswiipux.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpuswiipux.cpp:38:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpuswiipux.cpp:38:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpuswiipux.cpp:38:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpuswiipux.cpp:38:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpuswiipux.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && q == q;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7xv9i4m4.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp7xv9i4m4.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp7xv9i4m4.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return max_weight == w && q == q;\n     ^\n/tmp/tmp7xv9i4m4.cpp:27:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp7xv9i4m4.cpp:27:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp7xv9i4m4.cpp:27:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp7xv9i4m4.cpp:27:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp7xv9i4m4.cpp: In function 'int main()':\n/tmp/tmp7xv9i4m4.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7xv9i4m4.cpp:2:\n/tmp/tmp7xv9i4m4.cpp:31:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp7xv9i4m4.cpp:31:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp7xv9i4m4.cpp:31:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp7xv9i4m4.cpp:31:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp7xv9i4m4.cpp:31:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp7xv9i4m4.cpp:2:\n/usr/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprqh3mh25.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmprqh3mh25.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmprqh3mh25.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return true;\n     ^\n/tmp/tmprqh3mh25.cpp:27:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmprqh3mh25.cpp:27:5: error:\
    \ expected ';' before 'return'\n/tmp/tmprqh3mh25.cpp:27:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmprqh3mh25.cpp:27:5: error: expected ')' before 'return'\n\
    /tmp/tmprqh3mh25.cpp: In function 'int main()':\n/tmp/tmprqh3mh25.cpp:30:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = will_it_fly;\n     \
    \     ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n        \
    \         from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprqh3mh25.cpp:2:\n/tmp/tmprqh3mh25.cpp:31:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmprqh3mh25.cpp:31:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmprqh3mh25.cpp:31:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmprqh3mh25.cpp:31:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmprqh3mh25.cpp:31:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmprqh3mh25.cpp:2:\n/usr/include/c++/4.8.2/bit"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > maxWeight) {\n            maxWeight = sum;\n        }\n   \
    \ }\n    if (maxWeight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fe4tc9w.cpp: In function 'int main()':\n/tmp/tmp7fe4tc9w.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7fe4tc9w.cpp:2:\n/tmp/tmp7fe4tc9w.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp7fe4tc9w.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp7fe4tc9w.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp7fe4tc9w.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp7fe4tc9w.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp7fe4tc9w.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7fe4tc9w.cpp:2:\n/tmp/tmp7fe4tc9w.cpp:34:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return q[0] == w;\n\
    \    if (w == 0)\n        return false;\n    if (w == 1)\n        return q[0]\
    \ == w && will_it_fly(q.subvector(1, n), 0);\n    if (w % 2 == 0)\n        return\
    \ will_it_fly(q.subvector(0, n / 2), w) && will_it_fly(q.subvector(n / 2, n),\
    \ w);\n    return will_it_fly(q.subvector(0, n / 2), w) || will_it_fly(q.subvector(n\
    \ / 2, n), w);\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpopp2r1wd.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpopp2r1wd.cpp:27:43: error: 'class std::vector<long int>'\
    \ has no member named 'subvector'\n         return q[0] == w && will_it_fly(q.subvector(1,\
    \ n), 0);\n                                           ^\n/tmp/tmpopp2r1wd.cpp:29:30:\
    \ error: 'class std::vector<long int>' has no member named 'subvector'\n     \
    \    return will_it_fly(q.subvector(0, n / 2), w) && will_it_fly(q.subvector(n\
    \ / 2, n), w);\n                              ^\n/tmp/tmpopp2r1wd.cpp:29:71: error:\
    \ 'class std::vector<long int>' has no member named 'subvector'\n         return\
    \ will_it_fly(q.subvector(0, n / 2), w) && will_it_fly(q.subvector(n / 2, n),\
    \ w);\n                                                                      \
    \ ^\n/tmp/tmpopp2r1wd.cpp:30:26: error: 'class std::vector<long int>' has no member\
    \ named 'subvector'\n     return will_it_fly(q.subvector(0, n / 2), w) || will_it_fly(q.subvector(n\
    \ / 2, n), w);\n                          ^\n/tmp/tmpopp2r1wd.cpp:30:67: error:\
    \ 'class std::vector<long int>' has no member named 'subvector'\n     return will_it_fly(q.subvector(0,\
    \ n / 2), w) || will_it_fly(q.subvector(n / 2, n), w);\n                     \
    \                                              ^\n/tmp/tmpopp2r1wd.cpp: In function\
    \ 'int main()':\n/tmp/tmpopp2r1wd.cpp:33:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = will_it_fly;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpopp2r1wd.cpp:2:\n/tmp/tmpopp2r1wd.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpopp2r1wd.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({("
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_e2z0qy5.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp_e2z0qy5.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp_e2z0qy5.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return max_sum == w && std::equal(q.begin(), q.end(),\
    \ q.rbegin());\n     ^\n/tmp/tmp_e2z0qy5.cpp:27:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp_e2z0qy5.cpp:27:5: error: expected ';' before 'return'\n\
    /tmp/tmp_e2z0qy5.cpp:27:5: error: expected primary-expression before 'return'\n\
    /tmp/tmp_e2z0qy5.cpp:27:5: error: expected ')' before 'return'\n/tmp/tmp_e2z0qy5.cpp:\
    \ In function 'int main()':\n/tmp/tmp_e2z0qy5.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_e2z0qy5.cpp:2:\n/tmp/tmp_e2z0qy5.cpp:31:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp_e2z0qy5.cpp:31:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp_e2z0qy5.cpp:31:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp_e2z0qy5.cpp:31:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_e2z0qy5.cpp:31:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    f"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(auto i : q) {\n        sum += i;\n        if(sum > max_weight)\
    \ {\n            max_weight = sum;\n        }\n    }\n    return max_weight ==\
    \ w && q == std::reverse(q.begin(), q.end());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7xyj6oqv.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp7xyj6oqv.cpp:21:14: error: 'i' does not name a type\n \
    \    for(auto i : q) {\n              ^\n/tmp/tmp7xyj6oqv.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return max_weight == w && q == std::reverse(q.begin(),\
    \ q.end());\n     ^\n/tmp/tmp7xyj6oqv.cpp:27:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp7xyj6oqv.cpp:27:5: error: expected ';' before 'return'\n\
    /tmp/tmp7xyj6oqv.cpp:27:5: error: expected primary-expression before 'return'\n\
    /tmp/tmp7xyj6oqv.cpp:27:5: error: expected ')' before 'return'\n/tmp/tmp7xyj6oqv.cpp:27:33:\
    \ error: no match for 'operator==' (operand types are 'std::vector<long int>'\
    \ and 'void')\n     return max_weight == w && q == std::reverse(q.begin(), q.end());\n\
    \                                 ^\n/tmp/tmp7xyj6oqv.cpp:27:33: note: candidates\
    \ are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp7xyj6oqv.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp7xyj6oqv.cpp:27:67: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'void'\n     return max_weight == w &&\
    \ q == std::reverse(q.begin(), q.end());\n                                   \
    \                                ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp7xyj6oqv.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BIN"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q, w);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqx35y5ab.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpqx35y5ab.cpp:20:46: error: 'is_palindromic' was not declared\
    \ in this scope\n     return max_sum < w && is_palindromic(q, w);\n          \
    \                                    ^\n/tmp/tmpqx35y5ab.cpp: In function 'int\
    \ main()':\n/tmp/tmpqx35y5ab.cpp:23:10: error: 'candidate' does not name a type\n\
    \     auto candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqx35y5ab.cpp:2:\n/tmp/tmpqx35y5ab.cpp:24:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpqx35y5ab.cpp:24:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpqx35y5ab.cpp:24:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqx35y5ab.cpp:24:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpqx35y5ab.cpp:24:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpqx35y5ab.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argum"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ >= w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpve_ibwxk.cpp: In function 'int main()':\n/tmp/tmpve_ibwxk.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpve_ibwxk.cpp:2:\n/tmp/tmpve_ibwxk.cpp:30:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpve_ibwxk.cpp:30:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpve_ibwxk.cpp:30:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpve_ibwxk.cpp:30:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpve_ibwxk.cpp:30:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpve_ibwxk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpve_ibwxk.cpp:2:\n/tmp/tmpve_ibwxk.cpp:30:68: note:\
    \   candidat"
  stdout: ''
