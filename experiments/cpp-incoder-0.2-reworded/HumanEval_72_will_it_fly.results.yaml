language: cpp
name: HumanEval_72_will_it_fly
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpl47sabpu: /tmp/tmpl47sabpu.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_balanced(q);\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd2b7xygl.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpd2b7xygl.cpp:20:27: error: \u2018is_balanced\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_balanced(q);\n\
    \      |                           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqk1mo3wp: /tmp/tmpqk1mo3wp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    if (max_sum == w) {\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpjo74uoda: /tmp/tmpjo74uoda.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (sum == max_sum) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpq1x65wxm: /tmp/tmpq1x65wxm.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum\
    \ += q[i];\n    }\n    if (max_sum < w) return false;\n    long sum = 0;\n   \
    \ for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n        if (sum\
    \ > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp0nt1imyc: /tmp/tmp0nt1imyc.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if(sum > max_weight) {\n            max_weight = sum;\n        }\n  \
    \  }\n    return max_weight <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfjq2kx1g: /tmp/tmpfjq2kx1g.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum += q[i];\n \
    \   }\n    if(sum < w) {\n        return false;\n    }\n    long max_weight =\
    \ w;\n    for(long i = 0; i < q.size(); i++) {\n        if(q[i] > max_weight)\
    \ {\n            max_weight = q[i];\n        }\n    }\n    for(long i = 0; i <\
    \ q.size(); i++) {\n        q[i] /= max_weight;\n    }\n    for(long i = 0; i\
    \ < q.size(); i++) {\n        if(q[i] != 0) {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5nvgfr6z: /tmp/tmp5nvgfr6z.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n        if (max_sum\
    \ > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpja9qmfii: /tmp/tmpja9qmfii.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum < w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2twxj3te: /tmp/tmp2twxj3te.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (auto i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    long sum\
    \ = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    return max_sum ==\
    \ sum && max_sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpx6w81t93: /tmp/tmpx6w81t93.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long max_sum = 0;\n    for (long i\
    \ : q) {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbc73kshu: /tmp/tmpbc73kshu.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && q == q;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnv9qa0va: /tmp/tmpnv9qa0va.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpabe699rq: /tmp/tmpabe699rq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > maxWeight) {\n            maxWeight = sum;\n        }\n   \
    \ }\n    if (maxWeight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqvbmp0w4: /tmp/tmpqvbmp0w4.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return q[0] == w;\n\
    \    if (w == 0)\n        return false;\n    if (w == 1)\n        return q[0]\
    \ == w && will_it_fly(q.subvector(1, n), 0);\n    if (w % 2 == 0)\n        return\
    \ will_it_fly(q.subvector(0, n / 2), w) && will_it_fly(q.subvector(n / 2, n),\
    \ w);\n    return will_it_fly(q.subvector(0, n / 2), w) || will_it_fly(q.subvector(n\
    \ / 2, n), w);\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv_cz8v5c.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpv_cz8v5c.cpp:27:43: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018subvector\u2019; did you mean \u2018vector\u2019\
    ?\n   27 |         return q[0] == w && will_it_fly(q.subvector(1, n), 0);\n  \
    \    |                                           ^~~~~~~~~\n      |          \
    \                                 vector\n/tmp/tmpv_cz8v5c.cpp:29:30: error: \u2018\
    class std::vector<long int>\u2019 has no member named \u2018subvector\u2019; did\
    \ you mean \u2018vector\u2019?\n   29 |         return will_it_fly(q.subvector(0,\
    \ n / 2), w) && will_it_fly(q.subvector(n / 2, n), w);\n      |              \
    \                ^~~~~~~~~\n      |                              vector\n/tmp/tmpv_cz8v5c.cpp:29:71:\
    \ error: \u2018class std::vector<long int>\u2019 has no member named \u2018subvector\u2019\
    ; did you mean \u2018vector\u2019?\n   29 |         return will_it_fly(q.subvector(0,\
    \ n / 2), w) && will_it_fly(q.subvector(n / 2, n), w);\n      |              \
    \                                                         ^~~~~~~~~\n      | \
    \                                                                      vector\n\
    /tmp/tmpv_cz8v5c.cpp:30:26: error: \u2018class std::vector<long int>\u2019 has\
    \ no member named \u2018subvector\u2019; did you mean \u2018vector\u2019?\n  \
    \ 30 |     return will_it_fly(q.subvector(0, n / 2), w) || will_it_fly(q.subvector(n\
    \ / 2, n), w);\n      |                          ^~~~~~~~~\n      |          \
    \                vector\n/tmp/tmpv_cz8v5c.cpp:30:67: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018subvector\u2019; did you mean \u2018vector\u2019\
    ?\n   30 |     return will_it_fly(q.subvector(0, n / 2), w) || will_it_fly(q.subvector(n\
    \ / 2, n), w);\n      |                                                      \
    \             ^~~~~~~~~\n      |                                             \
    \                      vector\n"
  stdout: ''
  timestamp: 1660126903
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(auto i : q) {\n        sum += i;\n        if(sum > max_weight)\
    \ {\n            max_weight = sum;\n        }\n    }\n    return max_weight ==\
    \ w && q == std::reverse(q.begin(), q.end());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmxzk2q5y.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpmxzk2q5y.cpp:27:33: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    void\u2019)\n   27 |     return max_weight == w && q == std::reverse(q.begin(),\
    \ q.end());\n      |                               ~ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |                |\n      |           \
    \                    |                void\n      |                          \
    \     std::vector<long int>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmxzk2q5y.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpmxzk2q5y.cpp:27:67:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   27 |     return max_weight == w && q == std::reverse(q.begin(), q.end());\n\
    \      |                                                                   ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmxzk2q5y.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ fa"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q, w);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5i3j4701.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp5i3j4701.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q,\
    \ w);\n      |                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ >= w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphmy67aop: /tmp/tmphmy67aop.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > maxWeight) {\n            maxWeight = sum;\n        }\n   \
    \ }\n    if (maxWeight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqvbmp0w4: /tmp/tmpqvbmp0w4.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum < w) return\
    \ false;\n    for(long i : q) {\n        if(sum > w) return false;\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpyh5vu793: /tmp/tmpyh5vu793.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max_sum = sum\
    \ - w;\n    long min_sum = sum + w;\n    if (max_sum < min_sum) {\n        return\
    \ false;\n    }\n    long mid = max_sum / 2;\n    long mid2 = min_sum / 2;\n \
    \   long mid3 = max_sum / 3;\n    long mid4 = min_sum / 3;\n    long mid5 = max_sum\
    \ / 4;\n    long mid6 = min_sum / 4;\n    long mid7 = max_sum / 5;\n    long mid8\
    \ = min_sum / 5;\n    long mid9 = max_sum / 6;\n    long mid10 = min_sum / 6;\n\
    \    long mid11 = max_sum / 7;\n    long mid12 = min_sum / 7;\n    long mid13\
    \ = max_sum / 8;\n    long mid14 = min_sum / 8;\n    long mid15 = max_sum / 9;\n\
    \    long mid16 = min_sum / 9;\n    long mid17 = max_sum / 10;\n    long mid18\
    \ = min_sum / 10;\n    long mid19 = max_sum / 11;\n    long mid20 = min_sum /\
    \ 11;\n    long mid21 = max_sum / 12;\n    long mid22 = min_sum / 12;\n    long\
    \ mid23 = max_sum / 13;\n    long mid24 = min_sum / 13;\n    long mid25 = max_sum\
    \ / 14;\n    long mid26 = min_sum / 14;\n    long mid27 = max_sum / 15;\n    long\
    \ mid28 = min_sum / 15;\n    long mid29 = max_sum / 16;\n    long mid30 = min_sum\
    \ / 16;\n    long mid31 = max_sum / 17;\n    long mid32 = min_sum / 17;\n    long\
    \ mid33 = max_sum / 18;\n    long mid34 = min_sum / 18;\n    long mid35 = max_sum\
    \ / 19;\n    long mid36 = min_sum / 19;\n    long mid37 = max_sum / 20;\n    long\
    \ mid38 = min_sum / 20;\n    long mid39 = max_sum / 21;\n    long mid40 = min_sum\
    \ / 21;\n    long mid41 = max_sum / 22;\n    long mid42 = min_sum / 22;\n    long\
    \ mid43 = max_sum / 23;\n    long mid44 = min_sum / 23;\n    long mid45 = max_sum\
    \ / \n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx3omzcmj.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpx3omzcmj.cpp:77:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   77 | }\n      | ^\n/tmp/tmpx3omzcmj.cpp:77:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   77 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum +=\
    \ q[i];\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp58zipq_m: /tmp/tmp58zipq_m.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum +=\
    \ q[i];\n    }\n    if (sum == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcz9solz5: /tmp/tmpcz9solz5.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && sum_of_elements(q)\
    \ <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsp5v7q8v.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpsp5v7q8v.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && sum_of_elements(q) <= w;\n      |                           ^~~~~~~~~~~~~~\n\
    /tmp/tmpsp5v7q8v.cpp:20:48: error: \u2018sum_of_elements\u2019 was not declared\
    \ in this scope\n   20 |     return max_sum < w && is_palindromic(q) && sum_of_elements(q)\
    \ <= w;\n      |                                                ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \    }\n    if (max_sum > w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4at_6jof: /tmp/tmp4at_6jof.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpabe699rq: /tmp/tmpabe699rq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmps059658w: /tmp/tmps059658w.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q, w);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa0j23uh2.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpa0j23uh2.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q,\
    \ w);\n      |                            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    return max_weight <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps1b_3v9v: /tmp/tmps1b_3v9v.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Write your code\
    \ here\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n       \
    \ sum += q[i];\n    }\n    if (sum < w) {\n        return false;\n    }\n    long\
    \ max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum +=\
    \ q[i];\n    }\n    if (max_sum > w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcm32k8ws: /tmp/tmpcm32k8ws.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return q[0] == w;\n\
    \    if (q[n/2] + q[n/2-1] <= w)\n        return will_it_fly(q, w);\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm2xh7_hq: /tmp/tmpm2xh7_hq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgxa_qvg1: /tmp/tmpgxa_qvg1.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = std::accumulate(q.begin(), q.end(), 0);\n    return max_sum\
    \ <= w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum < w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2twxj3te: /tmp/tmp2twxj3te.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    if (max_sum == w) return\
    \ true;\n    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n      \
    \  if (sum > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpt0act6gc: /tmp/tmpt0act6gc.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max_sum = sum\
    \ - w;\n    if (max_sum < 0) {\n        return false;\n    }\n    long min_sum\
    \ = sum + w;\n    if (min_sum > max_sum) {\n        return false;\n    }\n   \
    \ long mid = max_sum / 2;\n    long mid2 = min_sum / 2;\n    long mid3 = max_sum\
    \ / 3;\n    long mid4 = min_sum / 3;\n    long mid5 = max_sum / 5;\n    long mid6\
    \ = min_sum / 5;\n    long mid7 = max_sum / 7;\n    long mid8 = min_sum / 7;\n\
    \    long mid9 = max_sum / 9;\n    long mid10 = min_sum / 9;\n    long mid11 =\
    \ max_sum / 10;\n    long mid12 = min_sum / 10;\n    long mid13 = max_sum / 11;\n\
    \    long mid14 = min_sum / 11;\n    long mid15 = max_sum / 12;\n    long mid16\
    \ = min_sum / 12;\n    long mid17 = max_sum / 13;\n    long mid18 = min_sum /\
    \ 13;\n    long mid19 = max_sum / 14;\n    long mid20 = min_sum / 14;\n    long\
    \ mid21 = max_sum / 15;\n    long mid22 = min_sum / 15;\n    long mid23 = max_sum\
    \ / 16;\n    long mid24 = min_sum / 16;\n    long mid25 = max_sum / 17;\n    long\
    \ mid26 = min_sum / 17;\n    long mid27 = max_sum / 18;\n    long mid28 = min_sum\
    \ / 18;\n    long mid29 = max_sum / 19;\n    long mid30 = min_sum / 19;\n    long\
    \ mid31 = max_sum / 20;\n    long mid32 = min_sum / 20;\n    long mid33 = max_sum\
    \ / 21;\n    long mid34 = min_sum / 21;\n    long mid35 = max_sum / 22;\n    long\
    \ mid36 = min_sum / 22;\n    long mid37 = max_sum / 23;\n    long mid38 = min_sum\
    \ / 23;\n    long mid39 = max_sum / 24;\n    long mid40 = min_sum / 24;\n    long\
    \ mid41 = max_sum / 25;\n    long mid42 = min_sum / 25;\n    long mid43 = max_sum\
    \ / 26;\n    long mid44\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpycnik7y0.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpycnik7y0.cpp:79:1: error: expected initializer\
    \ before \u2018}\u2019 token\n   79 | }\n      | ^\n/tmp/tmpycnik7y0.cpp:79:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   79 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpama815ck: /tmp/tmpama815ck.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max_sum\
    \ = 0;\n    for (auto i : q) {\n        sum += i;\n        max_sum = std::max(max_sum,\
    \ sum);\n    }\n    return max_sum <= w;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6i0m3l5h: /tmp/tmp6i0m3l5h.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    return sum\
    \ == maxWeight;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpfrmyw5tz: /tmp/tmpfrmyw5tz.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134499
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q, max_sum);\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0wdkt8oo.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp0wdkt8oo.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q,\
    \ max_sum);\n      |                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    long maxWeight = w;\n    for(long i = 0; i < q.size(); i++) {\n\
    \        sum += q[i];\n        if(sum > maxWeight) {\n            maxWeight =\
    \ sum;\n        }\n    }\n    if(sum == maxWeight) {\n        return true;\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqts23bjv: /tmp/tmpqts23bjv.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(auto i : q) {\n        sum += i;\n        if(sum > max_weight)\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp65y2v7_j: /tmp/tmp65y2v7_j.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0_5p1nnh: /tmp/tmp0_5p1nnh.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    if (sum > w) {\n\
    \        return true;\n    }\n    long max_sum = 0;\n    for (long i = 0; i <\
    \ q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum < w) {\n\
    \        return false;\n    }\n    if (max_sum > w) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2dm2x1fz: /tmp/tmp2dm2x1fz.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpkbiepmnz: /tmp/tmpkbiepmnz.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > maxWeight) {\n            maxWeight = sum;\n        }\n   \
    \ }\n    if (maxWeight <= 0) {\n        return false;\n    }\n    long reverseSum\
    \ = 0;\n    for (long i = 0; i < q.size(); i++) {\n        reverseSum += q[q.size()\
    \ - i - 1];\n        if (reverseSum > maxWeight) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwzny6vjb: /tmp/tmpwzny6vjb.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > maxWeight) {\n            maxWeight = sum;\n        }\n   \
    \ }\n    if (maxWeight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqvbmp0w4: /tmp/tmpqvbmp0w4.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) return false;\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > w) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpubhlo7vs: /tmp/tmpubhlo7vs.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max_sum = 0;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n\
    \    if (max_sum > w) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6am9pyik: /tmp/tmp6am9pyik.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ >= w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphmy67aop: /tmp/tmphmy67aop.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum < w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpolxb0pgu: /tmp/tmpolxb0pgu.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) return false;\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > w) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpubhlo7vs: /tmp/tmpubhlo7vs.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6brka_6e: /tmp/tmp6brka_6e.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpvrx919vp: /tmp/tmpvrx919vp.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqk1mo3wp: /tmp/tmpqk1mo3wp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return q[0] == w;\n\
    \    if (w == 0)\n        return false;\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w)\n        return false;\n    long sum = 0;\n\
    \    for (long i = 0; i < n; i++) {\n        sum += q[i];\n        if (sum > w)\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1im3fbat: /tmp/tmp1im3fbat.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum <= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgg0lg4ne.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpgg0lg4ne.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum <= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmpgg0lg4ne.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum <= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    long sum = 0;\n    for\
    \ (auto i : q) {\n        sum += i;\n    }\n    return sum <= w;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdz3psxvj: /tmp/tmpdz3psxvj.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \        if (max_sum > w) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgij9qifl: /tmp/tmpgij9qifl.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (long i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    long sum\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    return max_sum ==\
    \ sum && max_sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1shb4bi7: /tmp/tmp1shb4bi7.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpama815ck: /tmp/tmpama815ck.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = 0;\n    long sum = 0;\n    for (auto i : q) {\n        sum\
    \ += i;\n        max_sum = std::max(max_sum, sum);\n    }\n    return max_sum\
    \ <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpyv4lcl4z: /tmp/tmpyv4lcl4z.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = sum - w;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        if (q[i] > max_sum) return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpiopwh1xr: /tmp/tmpiopwh1xr.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i + w);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpf7s0_noq: /tmp/tmpf7s0_noq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum <= w && is_palindromic(q) && max_sum < w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjl8x92b1.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpjl8x92b1.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum <= w && is_palindromic(q)\
    \ && max_sum < w;\n      |                            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (sum > max_sum) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp3aat6knj: /tmp/tmp3aat6knj.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm2xh7_hq: /tmp/tmpm2xh7_hq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long max_sum = sum;\n    for (long\
    \ i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    return max_sum\
    \ == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp0113wxq7: /tmp/tmp0113wxq7.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    return max_sum == w && sum == max_sum;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpd4f4415f: /tmp/tmpd4f4415f.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ max_sum = w;\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n\
    \        sum += q[i];\n        if (sum > max_sum) {\n            max_sum = sum;\n\
    \        }\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpt42uny0q: /tmp/tmpt42uny0q.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    long max_element = q.back();\n    for\
    \ (long i : q) {\n        if (i > max_element) {\n            return false;\n\
    \        }\n        max_element = i;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpsgakla4z: /tmp/tmpsgakla4z.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqk1mo3wp: /tmp/tmpqk1mo3wp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum < w) {\n\
    \        return false;\n    }\n    for(long i : q) {\n        if(sum - i < w)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp_337pq6_: /tmp/tmp_337pq6_.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum >= w)\
    \ {\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwuwq4_xe: /tmp/tmpwuwq4_xe.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134500
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ <= 0) {\n        return false;\n    }\n    long reverseSum = 0;\n    for (auto\
    \ i : q) {\n        reverseSum += i;\n    }\n    if (reverseSum != sum) {\n  \
    \      return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpsqa31d52: /tmp/tmpsqa31d52.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptg8sa2hs: /tmp/tmptg8sa2hs.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprubeae9o: /tmp/tmprubeae9o.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqk1mo3wp: /tmp/tmpqk1mo3wp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    long max_weight = 0;\n    for (auto i : q) {\n       \
    \ sum += i;\n        max_weight = max(max_weight, i);\n    }\n    if (sum < max_weight)\
    \ {\n        return false;\n    }\n    long mid = max_weight / 2;\n    long left\
    \ = 0;\n    long right = 0;\n    for (auto i : q) {\n        if (i < mid) {\n\
    \            left += i;\n        } else {\n            right += i;\n        }\n\
    \    }\n    if (left == right) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9rm3nf6e.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp9rm3nf6e.cpp:24:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   24 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9rm3nf6e.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134500
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmps059658w: /tmp/tmps059658w.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    if (max_sum == w) {\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpjo74uoda: /tmp/tmpjo74uoda.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \    }\n    if (max_sum > w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4at_6jof: /tmp/tmp4at_6jof.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum = std::max(max_sum, q[i]);\n\
    \    }\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n       \
    \ sum += q[i];\n        if (sum > max_sum) {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcqi_afyy: /tmp/tmpcqi_afyy.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long maxSum = w;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        maxSum -= q[i];\n    }\n \
    \   if (maxSum < 0) {\n        return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpy38n38mu: /tmp/tmpy38n38mu.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && is_palindromic(q) && sum <= max_weight;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbh0d_x4x.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpbh0d_x4x.cpp:27:31: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return max_weight == w && is_palindromic(q)\
    \ && sum <= max_weight;\n      |                               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134500
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppehbbdjd: /tmp/tmppehbbdjd.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum >= w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpn5w6ppea: /tmp/tmpn5w6ppea.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmps059658w: /tmp/tmps059658w.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (auto i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    long sum\
    \ = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    return max_sum ==\
    \ sum && max_sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpx6w81t93: /tmp/tmpx6w81t93.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum > w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpd4mn8spj: /tmp/tmpd4mn8spj.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max = (long) sqrt(w);\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        if (q[i] > max) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpf4783hcy: /tmp/tmpf4783hcy.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqk1mo3wp: /tmp/tmpqk1mo3wp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w)\n        return false;\n    long sum = 0;\n\
    \    for (auto i : q)\n        sum += i;\n    if (sum < w)\n        return false;\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpmx7d6bfv: /tmp/tmpmx7d6bfv.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum\
    \ < w) return false;\n    long max_sum = w;\n    for(long i : q) {\n        max_sum\
    \ = std::max(max_sum, i);\n    }\n    return max_sum == sum;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphepa46iq: /tmp/tmphepa46iq.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max_sum = w\
    \ - sum;\n    long max_weight = 0;\n    for (long i = 0; i < q.size(); i++) {\n\
    \        max_weight = max(max_weight, q[i]);\n    }\n    if (max_sum == max_weight)\
    \ {\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp5ncf5l4.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpp5ncf5l4.cpp:30:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   30 |    \
    \     max_weight = max(max_weight, q[i]);\n      |                      ^~~\n\
    \      |                      std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp5ncf5l4.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if(sum >= w) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpkwsp8v6w: /tmp/tmpkwsp8v6w.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6brka_6e: /tmp/tmp6brka_6e.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmps059658w: /tmp/tmps059658w.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    if (max_sum\
    \ > w) return true;\n    return false;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppmzhe8bt: /tmp/tmppmzhe8bt.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (auto i : q) {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n     \
    \   return false;\n    }\n    long sum = 0;\n    for (auto i : q) {\n        sum\
    \ += i;\n    }\n    if (sum == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpd2qatny3: /tmp/tmpd2qatny3.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long maxSum = w;\n    for (auto i : q)\
    \ {\n        maxSum = std::max(maxSum, i);\n    }\n    if (maxSum < w) {\n   \
    \     return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4shg4rtz: /tmp/tmp4shg4rtz.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum < w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2twxj3te: /tmp/tmp2twxj3te.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnpb08_iu: /tmp/tmpnpb08_iu.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwj5l5npg: /tmp/tmpwj5l5npg.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == 0) {\n        return true;\n    }\n    long max_sum = 0;\n    for (auto i\
    \ : q) {\n        max_sum += i;\n        if (max_sum > max_weight) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp43xa1z97: /tmp/tmp43xa1z97.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    if (sum > w) {\n\
    \        return true;\n    }\n    long max = 0;\n    for (long i = 0; i < q.size();\
    \ i++) {\n        if (q[i] > max) {\n            max = q[i];\n        }\n    }\n\
    \    if (sum == max) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmplpe7fvsv: /tmp/tmplpe7fvsv.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    if (max_sum == w) {\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpjo74uoda: /tmp/tmpjo74uoda.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (long i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    bool is_balanced\
    \ = max_sum == w;\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n\
    \    }\n    return is_balanced && sum < max_sum;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnc21l6sd: /tmp/tmpnc21l6sd.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long maxSum = sum;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        maxSum -= q[i];\n        if\
    \ (maxSum < 0) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpd4pc6dcu: /tmp/tmpd4pc6dcu.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_balanced(q);\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd2b7xygl.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpd2b7xygl.cpp:20:27: error: \u2018is_balanced\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_balanced(q);\n\
    \      |                           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum > w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpd4mn8spj: /tmp/tmpd4mn8spj.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    if (max_sum == w) {\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpjo74uoda: /tmp/tmpjo74uoda.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppehbbdjd: /tmp/tmppehbbdjd.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (auto i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    long sum\
    \ = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    return max_sum ==\
    \ sum && max_sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpx6w81t93: /tmp/tmpx6w81t93.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return q[0] == w;\n\
    \    if (q[0] == w && q[1] == w - q[0])\n        return will_it_fly(q.substr(2),\
    \ w);\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6a56v7ym.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp6a56v7ym.cpp:25:30: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018substr\u2019\n   25 |         return will_it_fly(q.substr(2),\
    \ w);\n      |                              ^~~~~~\n"
  stdout: ''
  timestamp: 1660134501
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpabe699rq: /tmp/tmpabe699rq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm2xh7_hq: /tmp/tmpm2xh7_hq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum\
    \ += q[i];\n    }\n    if (max_sum < w) {\n        return false;\n    }\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > w) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpmynd69xq: /tmp/tmpmynd69xq.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Write your code\
    \ here\n    long sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum\
    \ += q[i];\n    }\n    if(sum < w) return false;\n    for(long i = 0; i < q.size();\
    \ i++) {\n        if(q[i] != (sum - q[i])) return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp40229cpk: /tmp/tmp40229cpk.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm2xh7_hq: /tmp/tmpm2xh7_hq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprebj6_0n: /tmp/tmprebj6_0n.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    long min_sum = sum + w;\n    long mid = max_sum / 2;\n\
    \    if (max_sum % 2 == 0) return (min_sum == mid);\n    return (min_sum == mid\
    \ || min_sum == mid + 1);\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmph316uzlu: /tmp/tmph316uzlu.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    if (max_weight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprf9yjwkz: /tmp/tmprf9yjwkz.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppsu4vncb: /tmp/tmppsu4vncb.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > maxWeight) {\n            maxWeight = sum;\n        }\n   \
    \ }\n    if (maxWeight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqvbmp0w4: /tmp/tmpqvbmp0w4.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmps059658w: /tmp/tmps059658w.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum <= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgg0lg4ne.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpgg0lg4ne.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum <= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmpgg0lg4ne.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum <= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = w;\n    for (long i = 0; i < q.size(); i++) {\n \
    \       max_sum = std::max(max_sum, q[i] + w);\n    }\n    return max_sum == w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqarlm1gi: /tmp/tmpqarlm1gi.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_balanced(q);\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd2b7xygl.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpd2b7xygl.cpp:20:27: error: \u2018is_balanced\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_balanced(q);\n\
    \      |                           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    if (max_sum == w) return\
    \ true;\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n      \
    \  if (sum > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptuzk_7u0: /tmp/tmptuzk_7u0.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = 0;\n    long sum = 0;\n    for (long i = 0; i < q.size();\
    \ i++) {\n        sum += q[i];\n        max_sum = std::max(max_sum, sum);\n  \
    \  }\n    if (max_sum == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6hmbklkk: /tmp/tmp6hmbklkk.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = w;\n    for (long i : q)\
    \ {\n        max_sum = std::max(max_sum, i);\n    }\n    if (max_sum == w) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp_d41u2kz: /tmp/tmp_d41u2kz.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm2xh7_hq: /tmp/tmpm2xh7_hq.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_weight = w;\n    for (auto i : q) {\n        max_weight =\
    \ std::max(max_weight, i);\n    }\n    long min_weight = w;\n    for (auto i :\
    \ q) {\n        min_weight = std::min(min_weight, i);\n    }\n    if (max_weight\
    \ == min_weight) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp8hrrhd5q: /tmp/tmp8hrrhd5q.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptg8sa2hs: /tmp/tmptg8sa2hs.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum\
    \ += q[i];\n    }\n    if (max_sum < w) {\n        return false;\n    }\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > w) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpc2sbmpdr: /tmp/tmpc2sbmpdr.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgxa_qvg1: /tmp/tmpgxa_qvg1.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long max_sum = 0;\n    for (auto i\
    \ : q) {\n        max_sum += i;\n    }\n    if (max_sum == w) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9u4gp63a: /tmp/tmp9u4gp63a.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    return max_weight <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps1b_3v9v: /tmp/tmps1b_3v9v.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    if (sum > w) {\n\
    \        return true;\n    }\n    long max = 0;\n    for (long i = 0; i < q.size();\
    \ i++) {\n        if (q[i] > max) {\n            max = q[i];\n        }\n    }\n\
    \    if (sum == max) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmplpe7fvsv: /tmp/tmplpe7fvsv.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134501
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = sum - w;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        if (q[i] > max_sum) return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpiopwh1xr: /tmp/tmpiopwh1xr.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    long sum = 0;\n    for\
    \ (long i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n \
    \   return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprb_r4e9z: /tmp/tmprb_r4e9z.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max = 0;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        if (q[i] > max) {\n      \
    \      max = q[i];\n        }\n    }\n    if (sum == max) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkk3on8pp: /tmp/tmpkk3on8pp.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134502
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && q == q.pop_back();\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp23gq0rl5.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp23gq0rl5.cpp:27:33: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    void\u2019)\n   27 |     return max_weight == w && q == q.pop_back();\n      |\
    \                               ~ ^~ ~~~~~~~~~~~~\n      |                   \
    \            |              |\n      |                               |       \
    \       void\n      |                               std::vector<long int>\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23gq0rl5.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23gq0rl5.cpp:27:47:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   27 |     return max_weight == w && q == q.pop_back();\n      |          \
    \                                     ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23gq0rl5.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23gq0rl5.cpp:27:47: note:   \u2018std::vector<long int>\u2019\
    \ is not derived"
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    long sum = 0;\n    for\
    \ (auto i : q) {\n        sum += i;\n        if (sum > w) return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpq61_oxgg: /tmp/tmpq61_oxgg.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    return maxWeight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \    }\n    if (max_sum > w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4at_6jof: /tmp/tmp4at_6jof.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpe_9nm5ir: /tmp/tmpe_9nm5ir.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpvrx919vp: /tmp/tmpvrx919vp.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134498
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpl47sabpu: /tmp/tmpl47sabpu.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpz4pnkgv6: /tmp/tmpz4pnkgv6.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum, i);\n\
    \    }\n    return max_sum == sum;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfxdsibbq: /tmp/tmpfxdsibbq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpabe699rq: /tmp/tmpabe699rq.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660126903
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) {\n\
    \        return false;\n    }\n    long max_sum = sum - w;\n    for (long i =\
    \ 0; i < q.size(); i++) {\n        if (q[i] > max_sum) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpx6s5hjti: /tmp/tmpx6s5hjti.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    if (sum > w) {\n\
    \        return true;\n    }\n    long maxSum = w;\n    for (long i = 0; i < q.size();\
    \ i++) {\n        maxSum = std::max(maxSum, q[i]);\n    }\n    return maxSum ==\
    \ w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7gq6lnpg: /tmp/tmp7gq6lnpg.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum <= w && is_palindromic(q) && max_sum < w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjl8x92b1.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpjl8x92b1.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum <= w && is_palindromic(q)\
    \ && max_sum < w;\n      |                            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    return max_weight == w && is_palindromic(q) && sum <= w;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsua49hkp.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpsua49hkp.cpp:27:31: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return max_weight == w && is_palindromic(q)\
    \ && sum <= w;\n      |                               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134502
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == sum;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp0brge1i2: /tmp/tmp0brge1i2.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Write your code\
    \ here\n    long sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum\
    \ += q[i];\n    }\n    if(sum < w) return false;\n    long max_sum = sum - w;\n\
    \    for(long i = 0; i < q.size(); i++) {\n        if(q[i] > max_sum) return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnznas5gu: /tmp/tmpnznas5gu.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(auto i : q) {\n        sum += i;\n    }\n    if(sum < w) {\n\
    \        return false;\n    }\n    for(auto i : q) {\n        sum += i;\n    }\n\
    \    if(sum >= w) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpersoyn4t: /tmp/tmpersoyn4t.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max = 0;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        max = std::max(max, q[i]);\n\
    \    }\n    if (sum == max) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdrhw5mep: /tmp/tmpdrhw5mep.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) {\n\
    \        return false;\n    }\n    long max_sum = w;\n    for (long i = 0; i <\
    \ q.size(); i++) {\n        max_sum = std::max(max_sum, q[i]);\n    }\n    if\
    \ (max_sum == w) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppjl6upxu: /tmp/tmppjl6upxu.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxSum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (maxSum < w) return false;\n    long sum = 0;\n    for\
    \ (auto i : q) {\n        sum += i;\n        if (sum > w) return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp0m0_by28: /tmp/tmp0m0_by28.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptfbe4m13.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptfbe4m13.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmptfbe4m13.cpp:20:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum < w && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum +=\
    \ q[i];\n    }\n    if (max_sum >= w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqtuy8abm: /tmp/tmpqtuy8abm.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    int\
    \ max_sum = w;\n    int max_sum_index = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        max_sum += q[i];\n        if (max_sum > w) {\n            return false;\n\
    \        }\n        if (max_sum == w) {\n            max_sum_index = i;\n    \
    \    }\n    }\n    if (max_sum_index == n) {\n        return true;\n    }\n  \
    \  return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1g72uipb: /tmp/tmp1g72uipb.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q) && is_balanced(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphn6p3xv8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphn6p3xv8.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q)\
    \ && is_balanced(q);\n      |                            ^~~~~~~~~~~~~~\n/tmp/tmphn6p3xv8.cpp:20:49:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   20 |     return\
    \ max_sum >= w && is_palindromic(q) && is_balanced(q);\n      |              \
    \                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134497
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long maxSum = sum;\n    for (long i : q)\
    \ {\n        maxSum -= i;\n        if (maxSum < 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpm6losq3q: /tmp/tmpm6losq3q.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    long sum = 0;\n    for\
    \ (auto i : q) {\n        sum += i;\n        if (sum > w) return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpq61_oxgg: /tmp/tmpq61_oxgg.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ maxWeight = w;\n    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n\
    \    }\n    if (sum < maxWeight) {\n        return false;\n    }\n    long maxSum\
    \ = 0;\n    for (auto i : q) {\n        maxSum += i;\n    }\n    if (maxSum <\
    \ maxWeight) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpniguf_su: /tmp/tmpniguf_su.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134504
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long maxWeight = std::max(q.front(), q.back());\n    long sum = 0;\n    for\
    \ (long i : q) {\n        sum += i;\n    }\n    return sum <= maxWeight && sum\
    \ == std::reverse(q.begin(), q.end());\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplkeuawxw.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmplkeuawxw.cpp:25:36: error: invalid operands\
    \ of types \u2018long int\u2019 and \u2018void\u2019 to binary \u2018operator==\u2019\
    \n   25 |     return sum <= maxWeight && sum == std::reverse(q.begin(), q.end());\n\
    \      |                                ~~~ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                |                  |\n      |        \
    \                        long int           void\n"
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = sum - w;\n    for (long\
    \ i : q) {\n        if (i > max_sum) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpdarxxdxm: /tmp/tmpdarxxdxm.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) {\n\
    \        return false;\n    }\n    long max_sum = w;\n    for (long i = 0; i <\
    \ q.size(); i++) {\n        max_sum = std::max(max_sum, q[i]);\n    }\n    if\
    \ (max_sum == w) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppjl6upxu: /tmp/tmppjl6upxu.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (auto i : q) {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n     \
    \   return false;\n    }\n    long sum = 0;\n    for (auto i : q) {\n        sum\
    \ += i;\n        if (sum > w) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmph9eipg36: /tmp/tmph9eipg36.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134504
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum, i);\n\
    \    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2phs1btt: /tmp/tmp2phs1btt.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134503
