language: cpp
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // code here\n    long smalest_value = 0;\n    int smalest_index = 0;\n\
    \    int size = arr.size();\n    for (int i = 0; i < size; i++) {\n        if\
    \ (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n           \
    \     smalest_value = arr[i];\n                smalest_index = i;\n          \
    \  }\n        }\n    }\n    if (smalest_value == 0) {\n        return {};\n  \
    \  }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n  \
    \  result.push_back(smalest_index);\n    return result;\n}\nint main() {\n   \
    \ auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeargsg4n.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmpeargsg4n.cpp:42:9: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n         return\
    \ {};\n         ^\n/tmp/tmpeargsg4n.cpp: In function 'int main()':\n/tmp/tmpeargsg4n.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeargsg4n.cpp:2:\n/tmp/tmpeargsg4n.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpeargsg4n.cpp:51:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpeargsg4n.cpp:51:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpeargsg4n.cpp:51:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpeargsg4n.cpp:51:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpeargsg4n.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vecto"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (long i\
    \ = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == 0) {\n                smalest_value = arr[i];\n          \
    \      smalest_index = i;\n            } else if (smalest_value < arr[i]) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp70y4dsc7.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmp70y4dsc7.cpp:43:9: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n         return\
    \ {};\n         ^\n/tmp/tmp70y4dsc7.cpp: In function 'int main()':\n/tmp/tmp70y4dsc7.cpp:51:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp70y4dsc7.cpp:2:\n/tmp/tmp70y4dsc7.cpp:52:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmp70y4dsc7.cpp:52:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmp70y4dsc7.cpp:52:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp70y4dsc7.cpp:52:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp70y4dsc7.cpp:52:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp70y4dsc7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vecto"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // Your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoagitqg3.cpp: In function 'int main()':\n/tmp/tmpoagitqg3.cpp:48:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoagitqg3.cpp:2:\n/tmp/tmpoagitqg3.cpp:49:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpoagitqg3.cpp:49:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpoagitqg3.cpp:49:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpoagitqg3.cpp:49:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpoagitqg3.cpp:49:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpoagitqg3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoagitqg3.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // Your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxpj3gqtb.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmpxpj3gqtb.cpp:82:1: error: expected initializer before '}' token\n\
    \ }\n ^\n/tmp/tmpxpj3gqtb.cpp: In function 'int main()':\n/tmp/tmpxpj3gqtb.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxpj3gqtb.cpp:2:\n/tmp/tmpxpj3gqtb.cpp:85:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpxpj3gqtb.cpp:85:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpxpj3gqtb.cpp:85:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpxpj3gqtb.cpp:85:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpxpj3gqtb.cpp:85:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpxpj3gqtb.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    if (arr.size()\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n\
    \    res.push_back(smalest_index);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv6qbv5i_.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmpv6qbv5i_.cpp:40:9: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n         return\
    \ {};\n         ^\n/tmp/tmpv6qbv5i_.cpp: In function 'int main()':\n/tmp/tmpv6qbv5i_.cpp:48:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv6qbv5i_.cpp:2:\n/tmp/tmpv6qbv5i_.cpp:49:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpv6qbv5i_.cpp:49:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpv6qbv5i_.cpp:49:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpv6qbv5i_.cpp:49:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpv6qbv5i_.cpp:49:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpv6qbv5i_.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vecto"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsp014xtk.cpp: In function 'int main()':\n/tmp/tmpsp014xtk.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsp014xtk.cpp:2:\n/tmp/tmpsp014xtk.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpsp014xtk.cpp:48:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpsp014xtk.cpp:48:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpsp014xtk.cpp:48:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpsp014xtk.cpp:48:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsp014xtk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsp014xtk.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    if (smalest_index\
    \ == arr.size() - 1) {\n        return std::vector<long>();\n    }\n    return\
    \ std::vector<long>({smalest_value, smalest_index});\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpackjltbm.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmpackjltbm.cpp:42:29: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n     return\
    \ std::vector<long>({smalest_value, smalest_index});\n                       \
    \      ^\n/tmp/tmpackjltbm.cpp:42:60: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n     return\
    \ std::vector<long>({smalest_value, smalest_index});\n                       \
    \                                     ^\n/tmp/tmpackjltbm.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n/tmp/tmpackjltbm.cpp: In function 'int main()':\n/tmp/tmpackjltbm.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpackjltbm.cpp:2:\n/tmp/tmpackjltbm.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpackjltbm.cpp:46:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpackjltbm.cpp:46:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpackjltbm.cpp:46:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpackjltbm.cpp:46:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \               "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // code here\n    long smalest_value = 0;\n    int smalest_index = 0;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smalest_value == 0) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            } else if (smalest_value < arr[i])\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n            }\n        }\n    }\n    if (smalest_value == 0) {\n       \
    \ return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfylhzkg8.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmpfylhzkg8.cpp:44:9: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n         return\
    \ {};\n         ^\n/tmp/tmpfylhzkg8.cpp: In function 'int main()':\n/tmp/tmpfylhzkg8.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfylhzkg8.cpp:2:\n/tmp/tmpfylhzkg8.cpp:53:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpfylhzkg8.cpp:53:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpfylhzkg8.cpp:53:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpfylhzkg8.cpp:53:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpfylhzkg8.cpp:53:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpfylhzkg8.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vecto"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value == 0) {\n                smalest_value =\
    \ arr[i];\n                smalest_index = i;\n            } else if (smalest_value\
    \ < arr[i]) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            }\n        }\n    }\n    if (smalest_value == 0) {\n     \
    \   return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu18qug91.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmpu18qug91.cpp:44:9: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n         return\
    \ {};\n         ^\n/tmp/tmpu18qug91.cpp: In function 'int main()':\n/tmp/tmpu18qug91.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu18qug91.cpp:2:\n/tmp/tmpu18qug91.cpp:53:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpu18qug91.cpp:53:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpu18qug91.cpp:53:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu18qug91.cpp:53:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu18qug91.cpp:53:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpu18qug91.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vecto"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    int smalest_index = 0;\n    for (int\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    if (smalest_index\
    \ == arr.size() - 1) {\n        return std::vector<long>();\n    }\n    return\
    \ std::vector<long>{smalest_value, smalest_index};\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps2_ncqzj.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmps2_ncqzj.cpp:42:17: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n     return\
    \ std::vector<long>{smalest_value, smalest_index};\n                 ^\n/tmp/tmps2_ncqzj.cpp:\
    \ In function 'int main()':\n/tmp/tmps2_ncqzj.cpp:45:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = pluck;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps2_ncqzj.cpp:2:\n/tmp/tmps2_ncqzj.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmps2_ncqzj.cpp:46:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmps2_ncqzj.cpp:46:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmps2_ncqzj.cpp:46:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmps2_ncqzj.cpp:46:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmps2_ncqzj.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa_rjvmfe.cpp: In function 'int main()':\n/tmp/tmpa_rjvmfe.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa_rjvmfe.cpp:2:\n/tmp/tmpa_rjvmfe.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpa_rjvmfe.cpp:48:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpa_rjvmfe.cpp:48:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpa_rjvmfe.cpp:48:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpa_rjvmfe.cpp:48:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpa_rjvmfe.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa_rjvmfe.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsp014xtk.cpp: In function 'int main()':\n/tmp/tmpsp014xtk.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsp014xtk.cpp:2:\n/tmp/tmpsp014xtk.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpsp014xtk.cpp:48:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpsp014xtk.cpp:48:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpsp014xtk.cpp:48:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpsp014xtk.cpp:48:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsp014xtk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsp014xtk.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // code here\n    long smalest_value = 0;\n    long smalest_index = 0;\n\
    \    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_even_value == 0) {\n                smalest_even_value = arr[i];\n\
    \                smalest_even_index = i;\n            } else if (smalest_even_value\
    \ < arr[i]) {\n                smalest_even_value = arr[i];\n                smalest_even_index\
    \ = i;\n            }\n        } else {\n            if (smalest_value == 0) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    if (smalest_even_value == 0) {\n        return std::vector<long>();\n\
    \    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5qmlvqni.cpp: In function 'int main()':\n/tmp/tmp5qmlvqni.cpp:62:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5qmlvqni.cpp:2:\n/tmp/tmp5qmlvqni.cpp:63:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmp5qmlvqni.cpp:63:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmp5qmlvqni.cpp:63:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5qmlvqni.cpp:63:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5qmlvqni.cpp:63:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5qmlvqni.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5qmlvqni.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    return std::vector<long>({smalest_value,\
    \ smalest_index});\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppm5f388f.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmppm5f388f.cpp:39:29: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n     return\
    \ std::vector<long>({smalest_value, smalest_index});\n                       \
    \      ^\n/tmp/tmppm5f388f.cpp:39:60: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n     return\
    \ std::vector<long>({smalest_value, smalest_index});\n                       \
    \                                     ^\n/tmp/tmppm5f388f.cpp:39:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n/tmp/tmppm5f388f.cpp: In function 'int main()':\n/tmp/tmppm5f388f.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppm5f388f.cpp:2:\n/tmp/tmppm5f388f.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmppm5f388f.cpp:43:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmppm5f388f.cpp:43:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmppm5f388f.cpp:43:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmppm5f388f.cpp:43:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \               "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // Your code here\n    std::vector<long> res;\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long index = 0;\n    for(long i = 0;\
    \ i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n            if(smallest_value\
    \ == 0) {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n                index = i;\n            } else {\n                if(arr[i]\
    \ < smallest_value) {\n                    smallest_value = arr[i];\n        \
    \            smallest_index = i;\n                    index = i;\n           \
    \     }\n            }\n        }\n    }\n    res.push_back(smallest_value);\n\
    \    res.push_back(smallest_index);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplwjugvk4.cpp: In function 'int main()':\n/tmp/tmplwjugvk4.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplwjugvk4.cpp:2:\n/tmp/tmplwjugvk4.cpp:55:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmplwjugvk4.cpp:55:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmplwjugvk4.cpp:55:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmplwjugvk4.cpp:55:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmplwjugvk4.cpp:55:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmplwjugvk4.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplwjugvk4.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] <\
    \ smalest_value) {\n            smalest_value = arr[i];\n            smalest_index\
    \ = i;\n            smalest_index_value = arr[i];\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt7b25r40.cpp: In function 'int main()':\n/tmp/tmpt7b25r40.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt7b25r40.cpp:2:\n/tmp/tmpt7b25r40.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpt7b25r40.cpp:51:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpt7b25r40.cpp:51:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpt7b25r40.cpp:51:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpt7b25r40.cpp:51:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpt7b25r40.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt7b25r40.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // code here\n    std::vector<long> result;\n    long smalest_value;\n\
    \    long smalest_index;\n    long smallest_value;\n    long smallest_index;\n\
    \    long smallest_even_value;\n    long smallest_even_count;\n    long index;\n\
    \    for (auto it = arr.begin(); it != arr.end(); it++) {\n        if (*it % 2\
    \ == 0) {\n            smallest_even_value = *it;\n            smallest_even_count\
    \ = 1;\n        }\n        else {\n            if (smallest_even_count > 1) {\n\
    \                smallest_value = smallest_even_value;\n                smallest_index\
    \ = smallest_even_count;\n            }\n            else {\n                smallest_value\
    \ = *it;\n                smallest_index = *it / 2;\n            }\n         \
    \   smallest_even_count++;\n        }\n    }\n    if (smallest_even_count == 0)\
    \ {\n        return result;\n    }\n    for (auto it = arr.begin(); it != arr.end();\
    \ it++) {\n        if (*it % 2 == 0) {\n            if (smallest_even_count ==\
    \ 1) {\n                result.push_back(smallest_value);\n                result.push_back(smallest_index);\n\
    \            }\n            else {\n                if (smallest_value == smallest_even_value)\
    \ {\n                    result.push_back(smallest_value);\n                 \
    \   result.push_back(smallest_index);\n                }\n                else\
    \ {\n                    result.push_back(smallest_value);\n                 \
    \   result.push_back(smallest_index);\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp62ou17vr.cpp: In function 'std::vector<long int> pluck(std::vector<long\
    \ int>)':\n/tmp/tmp62ou17vr.cpp:38:15: error: 'it' does not name a type\n    \
    \ for (auto it = arr.begin(); it != arr.end(); it++) {\n               ^\n/tmp/tmp62ou17vr.cpp:38:33:\
    \ error: expected ';' before 'it'\n     for (auto it = arr.begin(); it != arr.end();\
    \ it++) {\n                                 ^\n/tmp/tmp62ou17vr.cpp:38:33: error:\
    \ 'it' was not declared in this scope\n/tmp/tmp62ou17vr.cpp:58:15: error: 'it'\
    \ does not name a type\n     for (auto it = arr.begin(); it != arr.end(); it++)\
    \ {\n               ^\n/tmp/tmp62ou17vr.cpp:58:33: error: expected ';' before\
    \ 'it'\n     for (auto it = arr.begin(); it != arr.end(); it++) {\n          \
    \                       ^\n/tmp/tmp62ou17vr.cpp:58:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmp62ou17vr.cpp: In function 'int main()':\n/tmp/tmp62ou17vr.cpp:79:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp62ou17vr.cpp:2:\n/tmp/tmp62ou17vr.cpp:80:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmp62ou17vr.cpp:80:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmp62ou17vr.cpp:80:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp62ou17vr.cpp:80:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp62ou17vr.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // Your code here\n    std::vector<long> result;\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smallest_value == 0) {\n\
    \                smallest_value = arr[i];\n                smallest_index = i;\n\
    \            } else if (arr[i] < smallest_value) {\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdwku1kq7.cpp: In function 'int main()':\n/tmp/tmpdwku1kq7.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdwku1kq7.cpp:2:\n/tmp/tmpdwku1kq7.cpp:50:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpdwku1kq7.cpp:50:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpdwku1kq7.cpp:50:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpdwku1kq7.cpp:50:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpdwku1kq7.cpp:50:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpdwku1kq7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdwku1kq7.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsp014xtk.cpp: In function 'int main()':\n/tmp/tmpsp014xtk.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsp014xtk.cpp:2:\n/tmp/tmpsp014xtk.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpsp014xtk.cpp:48:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpsp014xtk.cpp:48:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpsp014xtk.cpp:48:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpsp014xtk.cpp:48:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsp014xtk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsp014xtk.c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a vector, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4,\
    \ (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2,\
    \ (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n\
    // Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0,\
    \ (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr)\
    \ {\n    // Your code here\n    std::vector<long> result;\n    long smallest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value)\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi9wx_ewp.cpp: In function 'int main()':\n/tmp/tmpi9wx_ewp.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = pluck;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi9wx_ewp.cpp:2:\n/tmp/tmpi9wx_ewp.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n                             \
    \           ^\n/tmp/tmpi9wx_ewp.cpp:47:68: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n        \
    \                                                            ^\n/tmp/tmpi9wx_ewp.cpp:47:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpi9wx_ewp.cpp:47:68: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpi9wx_ewp.cpp:47:68: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpi9wx_ewp.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi9wx_ewp.c"
  stdout: ''
