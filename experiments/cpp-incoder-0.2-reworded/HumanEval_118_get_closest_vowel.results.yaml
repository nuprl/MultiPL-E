language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_upper = vowels_reversed.toupper();\n    std::string\
    \ vowels_reversed_lower = vowels_reversed.tolower();\n    std::string vowels_reversed_upper_lower\
    \ = vowels_reversed_upper.tolower() + vowels_reversed_lower.tolower();\n    std::string\
    \ vowels_reversed_upper_lower_upper = vowels_reversed_upper_lower.toupper() +\
    \ vowels_reversed_upper.toupper();\n    std::string vowels_reversed_upper_lower_upper_reversed\
    \ = vowels_reversed_upper_lower_upper.substr(0, vowels_reversed_upper_lower_upper.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed =\
    \ vowels_reversed_upper_lower_upper_reversed.substr(0, vowels_reversed_upper_lower_upper_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed.substr(0, vowels_reversed_upper_lower_upper_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed.substr(0, vowels_reversed_upper_lower_upper_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqbhfrvj4.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpqbhfrvj4.cpp:20:57: error: 'std::string' has no member named 'toupper'\n\
    \     std::string vowels_reversed_upper = vowels_reversed.toupper();\n       \
    \                                                  ^\n/tmp/tmpqbhfrvj4.cpp:21:57:\
    \ error: 'std::string' has no member named 'tolower'\n     std::string vowels_reversed_lower\
    \ = vowels_reversed.tolower();\n                                             \
    \            ^\n/tmp/tmpqbhfrvj4.cpp:22:69: error: 'std::string' has no member\
    \ named 'tolower'\n     std::string vowels_reversed_upper_lower = vowels_reversed_upper.tolower()\
    \ + vowels_reversed_lower.tolower();\n                                       \
    \                              ^\n/tmp/tmpqbhfrvj4.cpp:22:103: error: 'std::string'\
    \ has no member named 'tolower'\n     std::string vowels_reversed_upper_lower\
    \ = vowels_reversed_upper.tolower() + vowels_reversed_lower.tolower();\n     \
    \                                                                            \
    \                      ^\n/tmp/tmpqbhfrvj4.cpp:23:81: error: 'std::string' has\
    \ no member named 'toupper'\n     std::string vowels_reversed_upper_lower_upper\
    \ = vowels_reversed_upper_lower.toupper() + vowels_reversed_upper.toupper();\n\
    \                                                                            \
    \     ^\n/tmp/tmpqbhfrvj4.cpp:23:115: error: 'std::string' has no member named\
    \ 'toupper'\n     std::string vowels_reversed_upper_lower_upper = vowels_reversed_upper_lower.toupper()\
    \ + vowels_reversed_upper.toupper();\n                                       \
    \                                                                            ^\n\
    /tmp/tmpqbhfrvj4.cpp:30:17: error: redeclaration of 'std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed'\n\
    \     std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_l"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_back\
    \ = \"\";\n    std::string vowels_back_back = \"\";\n    std::string vowels_back_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back = \"\";\n    std::string\
    \ vowels_back_back_reverse_back_reverse = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsx85awwa.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpsx85awwa.cpp:40:17: error: redeclaration of 'std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:39:17: error: 'std::string\
    \ vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:41:17: error: redeclaration\
    \ of 'std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:39:17: error: 'std::string\
    \ vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:42:17: error: redeclaration\
    \ of 'std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:39:17: error: 'std::string\
    \ vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_lower = \"AEIOUaeiou\";\n    std::string vowels_upper\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower = \"AEIOUAEIOU\";\n  \
    \  std::string vowels_upper_lower_lower = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string \n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkbcmg6nr.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpkbcmg6nr.cpp:30:17: error: redeclaration of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:29:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower' previously\
    \ declared here\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:31:17: error: redeclaration\
    \ of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:29:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower' previously\
    \ declared here\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:32:17: error: redeclaration\
    \ of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:29:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower' previously\
    \ declared here\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:35:17: error: redeclaration\
    \ of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:34:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower'\
    \ previously declared here\n   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    int n = word.size();\n    int vowel_count = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_count++;\n        }\n    }\n    if (vowel_count <= 1) {\n\
    \        return \"\";\n    }\n    int vowel_pos = n - vowel_count + 1;\n    for\
    \ (int i = vowel_pos; i < n; i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word[i];\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn5_udcex.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpn5_udcex.cpp:33:26: error: invalid conversion from 'char' to 'const char*'\
    \ [-fpermissive]\n             return word[i];\n                          ^\n\
    In file included from /usr/include/c++/4.8.2/string:53:0,\n                 from\
    \ /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn5_udcex.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpn5_udcex.cpp: In function 'int main()':\n/tmp/tmpn5_udcex.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn5_udcex.cpp:2:\n/tmp/tmpn5_udcex.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiricm2tv.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmpiricm2tv.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmpiricm2tv.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmpiricm2tv.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmpiricm2tv.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmpiricm2tv.cpp: In function\
    \ 'int main()':\n/tmp/tmpiricm2tv.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiricm2tv.cpp:2:\n/tmp/tmpiricm2tv.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_middle_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_start_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_start_end_end_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end = \"AEIOUaeiou\";\n\
    \    std::string vowels_start_end_middle_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46z22nzl.cpp:45:79: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n                                                              \
    \                 ^\n/tmp/tmp46z22nzl.cpp:45:5: error: missing terminating \"\
    \ character\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n     ^\n/tmp/tmp46z22nzl.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp46z22nzl.cpp:42:17: error: redeclaration of 'std::string vowels_start_end_middle_end_end_end_end_end_end_end_end'\n\
    \     std::string vowels_start_end_middle_end_end_end_end_end_end_end_end = \"\
    AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:40:17: error: 'std::string\
    \ vowels_start_end_middle_end_end_end_end_end_end_end_end' previously declared\
    \ here\n     std::string vowels_start_end_middle_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:45:17: error: redeclaration\
    \ of 'std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end'\n\
    \     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n                 ^\n/tmp/tmp46z22nzl.cpp:43:17: error: 'std::string\
    \ vowels_middle_start_end_end_end_end_end_end_end_end_end_end' previously declared\
    \ here\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:46:1: error: expected\
    \ primary-expression before '}' token\n }\n ^\n/tmp/tmp46z22nzl.cpp: In function\
    \ 'int main()':\n/tmp/tmp46z22nzl.cpp:48:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46z22nzl.cpp:2:\n/tmp/tmp46z22nzl.cpp:49:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowel_pos = 0;\n    int vowel_len = vowels.size();\n    int consonant_pos\
    \ = word.size()-1;\n    int consonant_len = word.length()-1;\n    int consonant_count\
    \ = 0;\n    while(consonant_pos >= 0 && consonant_len >= 0) {\n        if(word[consonant_pos]\
    \ == vowels[vowel_pos]) {\n            consonant_count++;\n            consonant_pos--;\n\
    \            vowel_pos++;\n            consonant_len--;\n            vowel_len--;\n\
    \        } else {\n            consonant_pos--;\n            consonant_len--;\n\
    \        }\n    }\n    if(consonant_count == 0) {\n        return \"\";\n    }\n\
    \    while(vowel_pos < vowel_len && consonant_pos >= 0) {\n        if(word[consonant_pos]\
    \ == vowels[vowel_pos]) {\n            consonant_pos--;\n            vowel_pos++;\n\
    \        } else {\n            vowel_pos++;\n        }\n    }\n    return word;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3fc8hpr3.cpp: In function 'int main()':\n/tmp/tmp3fc8hpr3.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3fc8hpr3.cpp:2:\n/tmp/tmp3fc8hpr3.cpp:51:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    int vowel_count\
    \ = 0;\n    for(int i = n - 1; i >= 0; i--) {\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A'\
    \ || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n\
    \            vowel_count++;\n        }\n    }\n    if(vowel_count == 0) {\n  \
    \      return \"\";\n    }\n    int vowel_start = n - vowel_count;\n    int vowel_end\
    \ = n - 1;\n    for(int i = vowel_start; i >= 0; i--) {\n        if(word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U') {\n            vowel_end = i;\n            break;\n        }\n    }\n\
    \    std::string vowel = word.substr(vowel_start, vowel_end + 1);\n    return\
    \ vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmporof_2k8.cpp: In function 'int main()':\n/tmp/tmporof_2k8.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmporof_2k8.cpp:2:\n/tmp/tmporof_2k8.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowel_count = 0;\n    int consonant_count = 0;\n    int consonant_index\
    \ = 0;\n    int vowel_index = 0;\n    int consonant_len = word.size();\n    int\
    \ vowel_len = vowels.size();\n    \n    for (int i = 0; i < consonant_len; i++)\
    \ {\n        if (word[i] == word[consonant_index]) {\n            consonant_count++;\n\
    \        }\n    }\n    for (int i = consonant_len - 1; i >= 0; i--) {\n      \
    \  if (word[i] == word[consonant_index]) {\n            consonant_count++;\n \
    \       }\n    }\n    for (int i = 0; i < vowel_len; i++) {\n        if (vowels[i]\
    \ == word[vowel_index]) {\n            vowel_count++;\n        }\n    }\n    for\
    \ (int i = vowel_len - 1; i >= 0; i--) {\n        if (vowels[i] == word[vowel_index])\
    \ {\n            vowel_count++;\n        }\n    }\n    if (consonant_count > vowel_count)\
    \ {\n        consonant_index = consonant_len - 1;\n        vowel_index = vowel_len\
    \ - 1;\n    } else if (vowel_count > consonant_count) {\n        consonant_index\
    \ = 0;\n        vowel_index = vowel_len - 1;\n    } else {\n        consonant_index\
    \ = consonant_len - 1;\n        vowel_index = vowel_len - 1;\n    }\n    return\
    \ word[consonant_index];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiyxf8rpm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpiyxf8rpm.cpp:56:32: error: invalid conversion from 'char' to 'const char*'\
    \ [-fpermissive]\n     return word[consonant_index];\n                       \
    \         ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n     \
    \            from /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiyxf8rpm.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpiyxf8rpm.cpp: In function 'int main()':\n/tmp/tmpiyxf8rpm.cpp:59:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiyxf8rpm.cpp:2:\n/tmp/tmpiyxf8rpm.cpp:60:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_2 = \"AEIOUaeiou\";\n    std::string vowels_start_end_3 = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_5 = \"AEIOUaeiou\";\n    std::string vowels_start_end_6 = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_8 = \"AEIOUaeiou\";\n    std::string vowels_start_end_9 = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_10 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_11 = \"AEIOUaeiou\";\n    std::string vowels_start_end_12 =\
    \ \"AEIOUaeiou\";\n    std::string vowels_start_end_13 = \"AEIOUaeiou\";\n   \
    \ std::string vowels_start_end_14 = \"AEIOUaeiou\";\n    std::string vowels_start_end_15\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_16 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_17 = \"AEIOUaeiou\";\n    std::string vowels_start_end_18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_19 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_20 = \"AEIOUaeiou\";\n    std::string vowels_start_end_21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_22 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_23 = \"AEIOUaeiou\";\n    std::string vowels_start_end_24\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_25 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_26 = \"AEIOUaeiou\";\n    std::string vowels_start_end_27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_28 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_29 = \"AEIOUaeiou\";\n    std::string vowels_start_end_30\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_31 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_32 = \"AE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyyfd0g8o.cpp:52:39: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_32 = \"AE\n                 \
    \                      ^\n/tmp/tmpyyfd0g8o.cpp:52:5: error: missing terminating\
    \ \" character\n     std::string vowels_start_end_32 = \"AE\n     ^\n/tmp/tmpyyfd0g8o.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmpyyfd0g8o.cpp:53:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmpyyfd0g8o.cpp:53:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmpyyfd0g8o.cpp: In function\
    \ 'int main()':\n/tmp/tmpyyfd0g8o.cpp:55:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyyfd0g8o.cpp:2:\n/tmp/tmpyyfd0g8o.cpp:56:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp69v8gsl7.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp69v8gsl7.cpp:56:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmp69v8gsl7.cpp: In function 'int main()':\n/tmp/tmp69v8gsl7.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp69v8gsl7.cpp:2:\n/tmp/tmp69v8gsl7.cpp:59:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
