language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_upper = vowels_reversed.toupper();\n    std::string\
    \ vowels_reversed_lower = vowels_reversed.tolower();\n    std::string vowels_reversed_upper_lower\
    \ = vowels_reversed_upper.tolower() + vowels_reversed_lower.tolower();\n    std::string\
    \ vowels_reversed_upper_lower_upper = vowels_reversed_upper_lower.toupper() +\
    \ vowels_reversed_upper.toupper();\n    std::string vowels_reversed_upper_lower_upper_reversed\
    \ = vowels_reversed_upper_lower_upper.substr(0, vowels_reversed_upper_lower_upper.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed =\
    \ vowels_reversed_upper_lower_upper_reversed.substr(0, vowels_reversed_upper_lower_upper_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed.substr(0, vowels_reversed_upper_lower_upper_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed.substr(0, vowels_reversed_upper_lower_upper_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqbhfrvj4.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpqbhfrvj4.cpp:20:57: error: 'std::string' has no member named 'toupper'\n\
    \     std::string vowels_reversed_upper = vowels_reversed.toupper();\n       \
    \                                                  ^\n/tmp/tmpqbhfrvj4.cpp:21:57:\
    \ error: 'std::string' has no member named 'tolower'\n     std::string vowels_reversed_lower\
    \ = vowels_reversed.tolower();\n                                             \
    \            ^\n/tmp/tmpqbhfrvj4.cpp:22:69: error: 'std::string' has no member\
    \ named 'tolower'\n     std::string vowels_reversed_upper_lower = vowels_reversed_upper.tolower()\
    \ + vowels_reversed_lower.tolower();\n                                       \
    \                              ^\n/tmp/tmpqbhfrvj4.cpp:22:103: error: 'std::string'\
    \ has no member named 'tolower'\n     std::string vowels_reversed_upper_lower\
    \ = vowels_reversed_upper.tolower() + vowels_reversed_lower.tolower();\n     \
    \                                                                            \
    \                      ^\n/tmp/tmpqbhfrvj4.cpp:23:81: error: 'std::string' has\
    \ no member named 'toupper'\n     std::string vowels_reversed_upper_lower_upper\
    \ = vowels_reversed_upper_lower.toupper() + vowels_reversed_upper.toupper();\n\
    \                                                                            \
    \     ^\n/tmp/tmpqbhfrvj4.cpp:23:115: error: 'std::string' has no member named\
    \ 'toupper'\n     std::string vowels_reversed_upper_lower_upper = vowels_reversed_upper_lower.toupper()\
    \ + vowels_reversed_upper.toupper();\n                                       \
    \                                                                            ^\n\
    /tmp/tmpqbhfrvj4.cpp:30:17: error: redeclaration of 'std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed'\n\
    \     std::string vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_lower_upper_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_l"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_back\
    \ = \"\";\n    std::string vowels_back_back = \"\";\n    std::string vowels_back_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back = \"\";\n    std::string\
    \ vowels_back_back_reverse_back_reverse = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsx85awwa.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpsx85awwa.cpp:40:17: error: redeclaration of 'std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:39:17: error: 'std::string\
    \ vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:41:17: error: redeclaration\
    \ of 'std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:39:17: error: 'std::string\
    \ vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:42:17: error: redeclaration\
    \ of 'std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmpsx85awwa.cpp:39:17: error: 'std::string\
    \ vowels_back_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_lower = \"AEIOUaeiou\";\n    std::string vowels_upper\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower = \"AEIOUAEIOU\";\n  \
    \  std::string vowels_upper_lower_lower = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string \n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkbcmg6nr.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpkbcmg6nr.cpp:30:17: error: redeclaration of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:29:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower' previously\
    \ declared here\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:31:17: error: redeclaration\
    \ of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:29:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower' previously\
    \ declared here\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:32:17: error: redeclaration\
    \ of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:29:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower' previously\
    \ declared here\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:35:17: error: redeclaration\
    \ of 'std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower'\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n                 ^\n/tmp/tmpkbcmg6nr.cpp:34:17: error: 'std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower'\
    \ previously declared here\n   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    int n = word.size();\n    int vowel_count = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowel_count++;\n        }\n    }\n    if (vowel_count <= 1) {\n\
    \        return \"\";\n    }\n    int vowel_pos = n - vowel_count + 1;\n    for\
    \ (int i = vowel_pos; i < n; i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word[i];\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn5_udcex.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpn5_udcex.cpp:33:26: error: invalid conversion from 'char' to 'const char*'\
    \ [-fpermissive]\n             return word[i];\n                          ^\n\
    In file included from /usr/include/c++/4.8.2/string:53:0,\n                 from\
    \ /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn5_udcex.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpn5_udcex.cpp: In function 'int main()':\n/tmp/tmpn5_udcex.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn5_udcex.cpp:2:\n/tmp/tmpn5_udcex.cpp:40:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiricm2tv.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmpiricm2tv.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmpiricm2tv.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmpiricm2tv.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmpiricm2tv.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmpiricm2tv.cpp: In function\
    \ 'int main()':\n/tmp/tmpiricm2tv.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiricm2tv.cpp:2:\n/tmp/tmpiricm2tv.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_middle_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_start_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_start_end_end_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end = \"AEIOUaeiou\";\n\
    \    std::string vowels_start_end_middle_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46z22nzl.cpp:45:79: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n                                                              \
    \                 ^\n/tmp/tmp46z22nzl.cpp:45:5: error: missing terminating \"\
    \ character\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n     ^\n/tmp/tmp46z22nzl.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp46z22nzl.cpp:42:17: error: redeclaration of 'std::string vowels_start_end_middle_end_end_end_end_end_end_end_end'\n\
    \     std::string vowels_start_end_middle_end_end_end_end_end_end_end_end = \"\
    AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:40:17: error: 'std::string\
    \ vowels_start_end_middle_end_end_end_end_end_end_end_end' previously declared\
    \ here\n     std::string vowels_start_end_middle_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:45:17: error: redeclaration\
    \ of 'std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end'\n\
    \     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n                 ^\n/tmp/tmp46z22nzl.cpp:43:17: error: 'std::string\
    \ vowels_middle_start_end_end_end_end_end_end_end_end_end_end' previously declared\
    \ here\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:46:1: error: expected\
    \ primary-expression before '}' token\n }\n ^\n/tmp/tmp46z22nzl.cpp: In function\
    \ 'int main()':\n/tmp/tmp46z22nzl.cpp:48:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46z22nzl.cpp:2:\n/tmp/tmp46z22nzl.cpp:49:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowel_pos = 0;\n    int vowel_len = vowels.size();\n    int consonant_pos\
    \ = word.size()-1;\n    int consonant_len = word.length()-1;\n    int consonant_count\
    \ = 0;\n    while(consonant_pos >= 0 && consonant_len >= 0) {\n        if(word[consonant_pos]\
    \ == vowels[vowel_pos]) {\n            consonant_count++;\n            consonant_pos--;\n\
    \            vowel_pos++;\n            consonant_len--;\n            vowel_len--;\n\
    \        } else {\n            consonant_pos--;\n            consonant_len--;\n\
    \        }\n    }\n    if(consonant_count == 0) {\n        return \"\";\n    }\n\
    \    while(vowel_pos < vowel_len && consonant_pos >= 0) {\n        if(word[consonant_pos]\
    \ == vowels[vowel_pos]) {\n            consonant_pos--;\n            vowel_pos++;\n\
    \        } else {\n            vowel_pos++;\n        }\n    }\n    return word;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3fc8hpr3.cpp: In function 'int main()':\n/tmp/tmp3fc8hpr3.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3fc8hpr3.cpp:2:\n/tmp/tmp3fc8hpr3.cpp:51:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    int vowel_count\
    \ = 0;\n    for(int i = n - 1; i >= 0; i--) {\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A'\
    \ || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n\
    \            vowel_count++;\n        }\n    }\n    if(vowel_count == 0) {\n  \
    \      return \"\";\n    }\n    int vowel_start = n - vowel_count;\n    int vowel_end\
    \ = n - 1;\n    for(int i = vowel_start; i >= 0; i--) {\n        if(word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U') {\n            vowel_end = i;\n            break;\n        }\n    }\n\
    \    std::string vowel = word.substr(vowel_start, vowel_end + 1);\n    return\
    \ vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmporof_2k8.cpp: In function 'int main()':\n/tmp/tmporof_2k8.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmporof_2k8.cpp:2:\n/tmp/tmporof_2k8.cpp:41:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowel_count = 0;\n    int consonant_count = 0;\n    int consonant_index\
    \ = 0;\n    int vowel_index = 0;\n    int consonant_len = word.size();\n    int\
    \ vowel_len = vowels.size();\n    \n    for (int i = 0; i < consonant_len; i++)\
    \ {\n        if (word[i] == word[consonant_index]) {\n            consonant_count++;\n\
    \        }\n    }\n    for (int i = consonant_len - 1; i >= 0; i--) {\n      \
    \  if (word[i] == word[consonant_index]) {\n            consonant_count++;\n \
    \       }\n    }\n    for (int i = 0; i < vowel_len; i++) {\n        if (vowels[i]\
    \ == word[vowel_index]) {\n            vowel_count++;\n        }\n    }\n    for\
    \ (int i = vowel_len - 1; i >= 0; i--) {\n        if (vowels[i] == word[vowel_index])\
    \ {\n            vowel_count++;\n        }\n    }\n    if (consonant_count > vowel_count)\
    \ {\n        consonant_index = consonant_len - 1;\n        vowel_index = vowel_len\
    \ - 1;\n    } else if (vowel_count > consonant_count) {\n        consonant_index\
    \ = 0;\n        vowel_index = vowel_len - 1;\n    } else {\n        consonant_index\
    \ = consonant_len - 1;\n        vowel_index = vowel_len - 1;\n    }\n    return\
    \ word[consonant_index];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiyxf8rpm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpiyxf8rpm.cpp:56:32: error: invalid conversion from 'char' to 'const char*'\
    \ [-fpermissive]\n     return word[consonant_index];\n                       \
    \         ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n     \
    \            from /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiyxf8rpm.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpiyxf8rpm.cpp: In function 'int main()':\n/tmp/tmpiyxf8rpm.cpp:59:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiyxf8rpm.cpp:2:\n/tmp/tmpiyxf8rpm.cpp:60:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_2 = \"AEIOUaeiou\";\n    std::string vowels_start_end_3 = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_5 = \"AEIOUaeiou\";\n    std::string vowels_start_end_6 = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_8 = \"AEIOUaeiou\";\n    std::string vowels_start_end_9 = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_10 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_11 = \"AEIOUaeiou\";\n    std::string vowels_start_end_12 =\
    \ \"AEIOUaeiou\";\n    std::string vowels_start_end_13 = \"AEIOUaeiou\";\n   \
    \ std::string vowels_start_end_14 = \"AEIOUaeiou\";\n    std::string vowels_start_end_15\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_16 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_17 = \"AEIOUaeiou\";\n    std::string vowels_start_end_18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_19 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_20 = \"AEIOUaeiou\";\n    std::string vowels_start_end_21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_22 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_23 = \"AEIOUaeiou\";\n    std::string vowels_start_end_24\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_25 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_26 = \"AEIOUaeiou\";\n    std::string vowels_start_end_27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_28 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_29 = \"AEIOUaeiou\";\n    std::string vowels_start_end_30\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_31 = \"AEIOUaeiou\";\n \
    \   std::string vowels_start_end_32 = \"AE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyyfd0g8o.cpp:52:39: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_32 = \"AE\n                 \
    \                      ^\n/tmp/tmpyyfd0g8o.cpp:52:5: error: missing terminating\
    \ \" character\n     std::string vowels_start_end_32 = \"AE\n     ^\n/tmp/tmpyyfd0g8o.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmpyyfd0g8o.cpp:53:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmpyyfd0g8o.cpp:53:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmpyyfd0g8o.cpp: In function\
    \ 'int main()':\n/tmp/tmpyyfd0g8o.cpp:55:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyyfd0g8o.cpp:2:\n/tmp/tmpyyfd0g8o.cpp:56:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp69v8gsl7.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp69v8gsl7.cpp:56:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmp69v8gsl7.cpp: In function 'int main()':\n/tmp/tmp69v8gsl7.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp69v8gsl7.cpp:2:\n/tmp/tmp69v8gsl7.cpp:59:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reversed = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reversed_upper = vowels_reversed.toUpper();\n\
    \    std::string vowels_reversed_lower = vowels_reversed.toLower();\n    std::string\
    \ vowels_reversed_upper_reversed = vowels_reversed_upper.substr(0, vowels_reversed_upper.size()\
    \ - 1);\n    std::string vowels_reversed_lower_reversed = vowels_reversed_lower.substr(0,\
    \ vowels_reversed_lower.size() - 1);\n    std::string vowels_reversed_upper_reversed_reversed\
    \ = vowels_reversed_upper_reversed.substr(0, vowels_reversed_upper_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_lower_reversed_reversed = vowels_reversed_lower_reversed.substr(0,\
    \ vowels_reversed_lower_reversed.size() - 1);\n    std::string vowels_reversed_upper_reversed_reversed_reversed\
    \ = vowels_reversed_upper_reversed_reversed.substr(0, vowels_reversed_upper_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_lower_reversed_reversed_reversed = vowels_reversed_lower_reversed_reversed.substr(0,\
    \ vowels_reversed_lower_reversed_reversed.size() - 1);\n    std::string vowels_reversed_upper_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_reversed_reversed_reversed.substr(0, vowels_reversed_upper_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_lower_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_lower_reversed_reversed_reversed.substr(0, vowels_reversed_lower_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_upper_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_lower_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_lower_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_lower_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_reversed_reversed_reversed_reversed_reversed.size() -\
    \ 1);\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_lh60pi2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_lower = \"aeiou\";\n    std::string\
    \ vowels_upper = \"AEIOUAEIOU\";\n    std::string vowels_upper2 = \"AEIOU\";\n\
    \    std::string vowels_upper3 = \"AEIOUAEIOUAEIOU\";\n    std::string vowels_upper4\
    \ = \"AEIOUAEIOUAEIOUAEIOU\";\n    std::string vowels_upper5 = \"AEIOUAEIOUAEIOUAEIOUAEIOU\"\
    ;\n    std::string vowels_upper6 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\";\n    std::string\
    \ vowels_upper7 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\";\n    std::string vowels_upper8\
    \ = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\";\n    std::string vowels_upper9\
    \ = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\";\n    std::string vowels_upper10\
    \ = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpojrjenvj.cpp:30:34: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_upper10 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\n\
    \                                  ^\n/tmp/tmpojrjenvj.cpp:30:5: error: missing\
    \ terminating \" character\n     std::string vowels_upper10 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\n\
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpojrjenvj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/s"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels + vowels.substr(1, vowels.size() -\
    \ 1);\n    std::string vowels_reverse2 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse3 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse4 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse5 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse6 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse7 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse8 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse9 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse11 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse12 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse13 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse14 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse15 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse16 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse17 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse18 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse19 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse20 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse21 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse22 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse23 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse24 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse25 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse26 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse27 = vowels + vowels.substr(1, vowels.size()\
    \ - 1);\n    std::string vowels_reverse28 = vowels + vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse29 = vowels + \n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyoaz2v7l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_upper = \"AEIOUAEIOU\";\n    std::string vowels_lower\
    \ = \"\";\n    std::string vowels_upper2 = \"\";\n    std::string vowels_lower2\
    \ = \"\";\n    std::string vowels_upper3 = \"\";\n    std::string vowels_lower3\
    \ = \"\";\n    std::string vowels_upper4 = \"\";\n    std::string vowels_lower4\
    \ = \"\";\n    std::string vowels_upper5 = \"\";\n    std::string vowels_lower5\
    \ = \"\";\n    std::string vowels_upper6 = \"\";\n    std::string vowels_lower6\
    \ = \"\";\n    std::string vowels_upper7 = \"\";\n    std::string vowels_lower7\
    \ = \"\";\n    std::string vowels_upper8 = \"\";\n    std::string vowels_lower8\
    \ = \"\";\n    std::string vowels_upper9 = \"\";\n    std::string vowels_lower9\
    \ = \"\";\n    std::string vowels_upper10 = \"\";\n    std::string vowels_lower10\
    \ = \"\";\n    std::string vowels_upper11 = \"\";\n    std::string vowels_lower11\
    \ = \"\";\n    std::string vowels_upper12 = \"\";\n    std::string vowels_lower12\
    \ = \"\";\n    std::string vowels_upper13 = \"\";\n    std::string vowels_lower13\
    \ = \"\";\n    std::string vowels_upper14 = \"\";\n    std::string vowels_lower14\
    \ = \"\";\n    std::string vowels_upper15 = \"\";\n    std::string vowels_lower15\
    \ = \"\";\n    std::string vowels_upper16 = \"\";\n    std::string vowels_lower16\
    \ = \"\";\n    std::string vowels_upper17 = \"\";\n    std::string vowels_lower17\
    \ = \"\";\n    std::string vowels_upper18 = \"\";\n    std::string vowels_lower18\
    \ = \"\";\n    std::string vowels_upper19 = \"\";\n    std::string vowels_lower19\
    \ = \"\";\n    std::string vowels_upper20 = \"\";\n    std::string vowels_lower20\
    \ = \"\";\n    std::string vowels_upper21 = \"\";\n    std::string vowels_lower21\
    \ = \"\";\n    std::string vowels_upper22 = \"\";\n    std::string vowels_lower22\
    \ = \"\";\n    std::string vowels_upper23 = \"\";\n    std::string vowels_lower23\
    \ = \"\";\n    std::string vowels_upper24 = \"\";\n    std::string vowels_lower24\
    \ = \"\";\n    std::string vowels_upper25 = \"\";\n    std::string vowels_lower25\
    \ = \"\";\n    std::string vowels_upper26 = \"\";\n    std::string vowels_lower26\
    \ = \"\";\n    std::string vowels_upper27 = \"\";\n    std::string vowels_lower27\
    \ = \"\";\n    std::string vowels_upper28 = \"\";\n    std::string vowels_lower28\
    \ = \"\";\n    std::string vowels_upper29 = \"\";\n    std::string vowels_lower29\
    \ = \"\";\n    std::string vowels_upper30 = \"\";\n    std::string vowels_lower30\
    \ = \"\";\n    std::string vowels_upper31 = \"\";\n    std::string vowels_\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuk7islgv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_upper = \"AEIOUAEIOU\";\n    std::string vowels_lower\
    \ = \"aeiouaeiou\";\n    std::string vowels_upper_lower = \"AEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_upper_lower_lower = \"aeiouaeiouaeiou\";\n    std::string\
    \ vowels_upper_lower_lower_lower = \"AEIOUaeiouAEIOUaeiou\";\n    std::string\
    \ vowels_upper_lower_lower_lower_lower = \"aeiouaeiouaeiouaeiou\";\n    std::string\
    \ vowels_upper_lower_lower_lower_lower_lower = \"AEIOUaeiouAEIOUaeiouaeiouaeiou\"\
    ;\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower = \"aeiouaeiouaeiouaeiouaeiouaeiou\"\
    ;\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower = \"\
    AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiou\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower = \"\
    aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"aeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiouaeiou\";\n    std::string\
    \ vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiouaeiouae\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk24asqom.cpp:35:104: warning: missing terminating \" character\
    \ [enabled by default]\n     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiouaeiouae\n                      \
    \                                                                            \
    \      ^\n/tmp/tmpk24asqom.cpp:35:5: error: missing terminating \" character\n\
    \     std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUaeiouAEIOUaeiouaeiouaeiouaeiouaeiouaeiouae\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk24asqom.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m("
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"aeiouAE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqrreg7.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp7fqrreg7.cpp:54:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqrreg7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_start_middle = \"\
    AEIOUaeiou\";\n    std::string vowels_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_middle = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_end_middle_end = \"AEIOUaeiou\";\n\
    \    std::string vowels_start_middle_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_middle_end_middle_end = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp32hu4vg8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_start_middle = \"\
    AEIOUaeiou\";\n    std::string vowels_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_middle = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_end_middle_end = \"AEIOUaeiou\";\n\
    \    std::string vowels_start_middle_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_middle_end_middle_end = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_middle_end_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp32hu4vg8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowel_count = 0;\n    for (int i = 0; i < word.length(); i++) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            vowel_count++;\n\
    \        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n\
    \    int vowel_pos = word.length() - vowel_count;\n    int vowel_left = word.length()\
    \ - vowel_pos;\n    int vowel_right = word.length() - vowel_pos - 1;\n    int\
    \ vowel_mid = word.length() - vowel_pos - 2;\n    int vowel_mid2 = word.length()\
    \ - vowel_pos - 3;\n    int vowel_mid3 = word.length() - vowel_pos - 4;\n    int\
    \ vowel_mid4 = word.length() - vowel_pos - 5;\n    int vowel_mid5 = word.length()\
    \ - vowel_pos - 6;\n    int vowel_mid6 = word.length() - vowel_pos - 7;\n    int\
    \ vowel_mid7 = word.length() - vowel_pos - 8;\n    int vowel_mid8 = word.length()\
    \ - vowel_pos - 9;\n    int vowel_mid9 = word.length() - vowel_pos - 10;\n   \
    \ int vowel_mid10 = word.length() - vowel_pos - 11;\n    int vowel_mid11 = word.length()\
    \ - vowel_pos - 12;\n    int vowel_mid12 = word.length() - vowel_pos - 13;\n \
    \   int vowel_mid13 = word.length() - vowel_pos - 14;\n    int vowel_mid14 = word.length()\
    \ - vowel_pos - 15;\n    int vowel_mid15 = word.length() - vowel_pos - 16;\n \
    \   int vowel_mid16 = word.length() - vowel_pos - 17;\n    int vowel_mid17 = word.length()\
    \ - vowel_pos - 18;\n    int vowel_mid18 = word.length() - vowel_pos - 19;\n \
    \   int vowel_mid19 = word.length() - vowel_pos - 20;\n    int vowel_mid20 = word.length()\
    \ - vowel_pos - 21;\n    int vowel_mid21 = word.length() - vowel_pos - 22;\n \
    \   int vowel_mid22 = word.length() - vowel_pos - 23;\n    int vowel_mid23 = word.length()\
    \ - vowel_pos - 24;\n    int vowel_mid24 = word.length() - vowel_pos - 25;\n \
    \   int vowel_mid25 = word.length() - vowel_pos - 26;\n    int vowel_mid26 = word.length()\
    \ - vowel_pos - 27;\n    int vowel_mid27 = word.length() - vowel_pos - 28;\n \
    \   int vowel_mid28 = word.length() - vowel_pos - 29;\n\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcglwk3dt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle2 = \"AEIOUaeiou\";\n    std::string vowels_start3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle3 = \"AEIOUaeiou\";\n    std::string vowels_start4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end4 = \"AEIOUaeiou\";\n    std::string vowels_middle4\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start5 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end5 = \"AEIOUaeiou\";\n    std::string vowels_middle5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start6 = \"AEIOUaeiou\";\n    std::string vowels_end6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle6 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start7 = \"AEIOUaeiou\";\n    std::string vowels_end7 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle7 = \"AEIOUaeiou\";\n    std::string vowels_start8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_end8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle8 = \"AEIOUaeiou\";\n    std::string vowels_start9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end9 = \"AEIOUaeiou\";\n    std::string vowels_middle9\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start10 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end10 = \"AEIOUaeiou\";\n    std::string vowels_middle10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start11 = \"AEIOUaeiou\";\n    std::string vowels_end11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle11 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start12 = \"AEIOUaeiou\";\n    std::string vowels_end12 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle12 = \"AEIOUaeiou\";\n\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_g067rse.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_lower = \"AEIOUaeiou\";\n    std::string vowels_upper\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower = \"AEIOUAEIOU\";\n  \
    \  std::string vowels_upper_lower_lower = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx7zrxq87.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"aeiouAE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqrreg7.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp7fqrreg7.cpp:54:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqrreg7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    int vowel_count\
    \ = 0;\n    int consonant_count = 0;\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    for (int i = 0; i < n; i++) {\n        if (word[i] == vowels[vowel_count])\
    \ {\n            vowel_count++;\n        }\n        else if (word[i] == consonants[consonant_count])\
    \ {\n            consonant_count++;\n        }\n        else if (word[i] == consonants[consonant_count]\
    \ && word[i + 1] == vowels[vowel_count]) {\n            vowel_count++;\n     \
    \   }\n        else if (word[i] == consonants[consonant_count] && word[i + 1]\
    \ == consonants[consonant_count - 1]) {\n            consonant_count++;\n    \
    \    }\n        else if (word[i] == consonants[consonant_count] && word[i + 1]\
    \ == consonants[consonant_count - 1] && word[i + 2] == vowels[vowel_count]) {\n\
    \            vowel_count++;\n        }\n        else if (word[i] == consonants[consonant_count]\
    \ && word[i + 1] == consonants[consonant_count - 1] && word[i + 2] == consonants[consonant_count\
    \ - 2] && word[i + 3] == vowels[vowel_count]) {\n            vowel_count++;\n\
    \        }\n        else if (word[i] == consonants[consonant_count] && word[i\
    \ + 1] == consonants[consonant_count - 1] && word[i + 2] == consonants[consonant_count\
    \ - 2] && word[i + 3] == consonants[consonant_count - 3] && word[i + 4] == vowels[vowel_count])\
    \ {\n            vowel_count++;\n        }\n        else if (word[i] == consonants[consonant_count]\
    \ && word[i + 1] == consonants[consonant_count - 1] && word[i + 2] == consonants[consonant_count\
    \ - 2] && word[i + 3] == consonants[consonant_count - 3] && word[i + 4] == consonants[consonant_count\
    \ - 4] && word[i + 5] == vowels[vowel_count]) {\n            vowel_count++;\n\
    \        }\n        else if (word[i] == consonants[consonant_count] && word[i\
    \ + 1] == consonants[consonant_count - 1] && word[i + 2] == consonants[consonant_count\
    \ - 2] && word[i + 3] == consonants[consonant_count - 3] && word[i + 4] == consonants[consonant_count\
    \ - 4] && word[i + 5] == consonants[consonant_count - 5] && \n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4e9dcch2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_middle_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_start_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_start_end_end_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end = \"AEIOUaeiou\";\n\
    \    std::string vowels_start_end_middle_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp46z22nzl.cpp:45:79: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n                                                              \
    \                 ^\n/tmp/tmp46z22nzl.cpp:45:5: error: missing terminating \"\
    \ character\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n     ^\n/tmp/tmp46z22nzl.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp46z22nzl.cpp:42:17: error: redeclaration of 'std::string vowels_start_end_middle_end_end_end_end_end_end_end_end'\n\
    \     std::string vowels_start_end_middle_end_end_end_end_end_end_end_end = \"\
    AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:40:17: error: 'std::string\
    \ vowels_start_end_middle_end_end_end_end_end_end_end_end' previously declared\
    \ here\n     std::string vowels_start_end_middle_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:45:17: error: redeclaration\
    \ of 'std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end'\n\
    \     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUae\n                 ^\n/tmp/tmp46z22nzl.cpp:43:17: error: 'std::string\
    \ vowels_middle_start_end_end_end_end_end_end_end_end_end_end' previously declared\
    \ here\n     std::string vowels_middle_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmp46z22nzl.cpp:46:1: error: expected\
    \ primary-expression before '}' token\n }\n ^\n/tmp/tmp46z22nzl.cpp: In function\
    \ 'int main()':\n/tmp/tmp46z22nzl.cpp:48:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46z22nzl.cpp:2:\n/tmp/tmp46z22nzl.cpp:49:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_middle_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle_end_start = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle_end_start_end_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start_end_middle_start_end = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_end = \"\
    AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end =\
    \ \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end_middle_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end_middle_start_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start_end_middle_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end_middle_start_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start_end_middle_start_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end_middle_start_end_middle_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start_end_middle_start_end_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle_end_start_end_middle_start_end_middle_start_end_middle_start_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_middle_start_end_middle_start_end_middle_start_end_middle_start\
    \ = \"AE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoke0hbp6.cpp:45:100: warning: missing terminating \" character\
    \ [enabled by default]\n     std::string vowels_start_end_middle_start_end_middle_start_end_middle_start_end_middle_start\
    \ = \"AE\n                                                                   \
    \                                 ^\n/tmp/tmpoke0hbp6.cpp:45:5: error: missing\
    \ terminating \" character\n     std::string vowels_start_end_middle_start_end_middle_start_end_middle_start_end_middle_start\
    \ = \"AE\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoke0hbp6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/b"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    int vowel_count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y')\
    \ {\n            vowel_count++;\n        }\n    }\n    if (vowel_count == 0) {\n\
    \        return \"\";\n    }\n    int vowel_pos = n - 1;\n    for (int i = n -\
    \ 1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y') {\n            vowel_pos\
    \ = i;\n            break;\n        }\n    }\n    if (vowel_pos == 0) {\n    \
    \    return \"\";\n    }\n    int consonant_count = 0;\n    for (int i = vowel_pos\
    \ + 1; i < n; i++) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y') {\n          \
    \  consonant_count++;\n        }\n    }\n    if (consonant_count == 0) {\n   \
    \     return \"\";\n    }\n    int consonant_pos = n - 1;\n    for (int i = n\
    \ - 1; i >= vowel_pos; i--) {\n        if (word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y') {\n  \
    \          consonant_pos = i;\n            break;\n        }\n    }\n    if (consonant_pos\
    \ == 0) {\n        return \"\";\n    }\n    int vowel_dist = abs(vowel_pos - consonant_pos);\n\
    \    int consonant_dist = abs(consonant_pos - vowel_pos);\n    if (vowel_dist\
    \ < consonant_dist) {\n        return word[vowel_pos];\n    }\n    return word[consonant_pos];\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7hdnw3t0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    int m =\
    \ word.size();\n    int vowel_count = 0;\n    int consonant_count = 0;\n    int\
    \ vowel_start = 0;\n    int vowel_end = 0;\n    int consonant_start = 0;\n   \
    \ int consonant_end = 0;\n    for (int i = 0; i < n; i++) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'y') {\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'b' || word[i] == 'c' || word[i] == 'd' || word[i] == 'f' || word[i] == 'g'\
    \ || word[i] == 'h' || word[i] == 'j' || word[i] == 'k' || word[i] == 'l' || word[i]\
    \ == 'm' || word[i] == 'n' || word[i] == 'p' || word[i] == 'q' || word[i] == 'r'\
    \ || word[i] == 's' || word[i] == 't' || word[i] == 'v' || word[i] == 'w' || word[i]\
    \ == 'x' || word[i] == 'y') {\n            vowel_count++;\n        }\n       \
    \ if (word[i] == 'z') {\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'\
    \ || word[i] == 'Y') {\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'B' || word[i] == 'C' || word[i] == 'D' || word[i] == 'F' || word[i] == 'G'\
    \ || word[i] == 'H' || word[i] == 'J' || word[i] == 'K' || word[i] == 'L' || word[i]\
    \ == 'M' || word[i] == 'N' || word[i] == 'P' || word[i] == 'Q' || word[i] == 'R'\
    \ || word[i] == 'S' || word[i] == 'T' || word[i] == 'V' || word[i] == 'W' || word[i]\
    \ == 'X' || word[i] == 'Y') {\n            vowel_count++;\n        }\n       \
    \ if (word[i] == 'Z') {\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'y') {\n            consonant_count++;\n        }\n        if\
    \ (word[i] == 'b' || word[i] == 'c' || word[i] == 'd' || word[i] == 'f' || word[i]\
    \ == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k' || word[i] == 'l'\
    \ || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i] == 'q' || word[i]\
    \ == 'r' || word[i] == 's' || word[i] == 't' || word[i] == 'v' || word[i] == 'w'\
    \ || word[i]\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdjie2ofp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_re\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz0emciql.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int len = word.length();\n    int\
    \ vowel_pos = 0;\n    int consonant_pos = 0;\n    int vowel_len = 0, consonant_len\
    \ = 0;\n    std::string vowel = \"aeiouAEIOU\";\n    std::string consonant = \"\
    bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    for (int i = 0; i < len; i++)\
    \ {\n        if (word[i] == vowel[vowel_pos]) {\n            vowel_pos++;\n  \
    \          vowel_len++;\n        }\n        if (word[i] == consonant[consonant_pos])\
    \ {\n            consonant_pos++;\n            consonant_len++;\n        }\n \
    \       if (vowel_len == consonant_len) {\n            vowel_pos = 0;\n      \
    \      consonant_pos = 0;\n            vowel_len = 0;\n            consonant_len\
    \ = 0;\n        }\n    }\n    if (vowel_len == consonant_len) {\n        return\
    \ \"\";\n    }\n    int vowel_start = vowel_pos - consonant_pos + 1;\n    int\
    \ vowel_end = vowel_pos + 1;\n    int consonant_start = consonant_pos - vowel_len\
    \ + 1;\n    int consonant_end = consonant_pos + 1;\n    if (vowel_start < 0 ||\
    \ consonant_start < 0) {\n        return \"\";\n    }\n    if (vowel_end > len\
    \ || consonant_end > len) {\n        return \"\";\n    }\n    return word[vowel_start];\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf5nl_mz1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxs8g5e8t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_end = \"AEIOUaeiou\";\n   \
    \ std::string vowels_begin = \"AEIOUaeiou\";\n    std::string vowels_begin2 =\
    \ \"aeiouAEIOU\";\n    std::string vowels_end2 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin3 = \"aeiouAEIOU\";\n    std::string vowels_end3 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string vowels_end4\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin5 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end5 = \"AEIOUaeiou\";\n    std::string vowels_begin6 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end6 = \"AEIOUaeiou\";\n    std::string vowels_begin7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string vowels_end9\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin10 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end10 = \"AEIOUaeiou\";\n    std::string vowels_begin11 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end11 = \"AEIOUaeiou\";\n    std::string vowels_begin12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string vowels_end14\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin15 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end15 = \"AEIOUaeiou\";\n    std::string vowels_begin16 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end16 = \"AEIOUaeiou\";\n    std::string vowels_begin17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18 = \"AE\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp20ivenhd.cpp:55:32: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_end18 = \"AE\n                        \
    \        ^\n/tmp/tmp20ivenhd.cpp:55:5: error: missing terminating \" character\n\
    \     std::string vowels_end18 = \"AE\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp20ivenhd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression befo"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle2 = \"AEIOUaeiou\";\n    std::string vowels_start3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle3 = \"AEIOUaeiou\";\n    std::string vowels_start4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end4 = \"AEIOUaeiou\";\n    std::string vowels_middle4\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start5 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end5 = \"AEIOUaeiou\";\n    std::string vowels_middle5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start6 = \"AEIOUaeiou\";\n    std::string vowels_end6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle6 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start7 = \"AEIOUaeiou\";\n    std::string vowels_end7 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle7 = \"AEIOUaeiou\";\n    std::string vowels_start8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_end8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle8 = \"AEIOUaeiou\";\n    std::string vowels_start9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end9 = \"AEIOUaeiou\";\n    std::string vowels_middle9\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start10 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end10 = \"AEIOUaeiou\";\n    std::string vowels_middle10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start11 = \"AEIOUaeiou\";\n    std::string vowels_end11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle11 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_start12 = \"AEIOUaeiou\";\n    std::string vowels_end12 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle12 = \"AEIOUaeiou\";\n\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_g067rse.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_end = \"AEIOUaeiou\";\n   \
    \ std::string vowels_start = \"AEIOUaeiou\";\n    std::string vowels_start_end\
    \ = \"aeiouAEIOU\";\n    std::string vowels_start_end_end = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_end_end = \"aeiouAEIOUaeiouAEIOU\";\n    std::string\
    \ vowels_start_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    std::string\
    \ vowels_start_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n   \
    \ std::string vowels_start_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end = \"aeiouAEIOUaeiouAEIOU\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9buzei03.cpp:35:72: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiouAEIOU\n                                                 \
    \                       ^\n/tmp/tmp9buzei03.cpp:35:5: error: missing terminating\
    \ \" character\n     std::string vowels_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiouAEIOU\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9buzei03.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_rev = \"AEIOUaeiou\";\n   \
    \ for (int i = 0; i < n; i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowels_rev = vowels_rev.replace(word[i], \"\");\n        }\n\
    \    }\n    int vowels_rev_len = vowels_rev.length();\n    int vowels_len = vowels.length();\n\
    \    int vowels_rev_pos = 0;\n    int vowels_pos = 0;\n    int vowels_rev_pos_count\
    \ = 0;\n    int vowels_pos_count = 0;\n    int vowels_rev_pos_count_max = 0;\n\
    \    int vowels_pos_count_max = 0;\n    for (int i = 0; i < n; i++) {\n      \
    \  if (vowels.find(word[i]) != std::string::npos) {\n            vowels_rev_pos\
    \ = i;\n            vowels_pos = i;\n            vowels_rev_pos_count = 0;\n \
    \           vowels_pos_count = 0;\n            vowels_rev_pos_count_max = 0;\n\
    \            vowels_pos_count_max = 0;\n        }\n        if (vowels_rev.find(word[i])\
    \ != std::string::npos) {\n            vowels_rev_pos = i;\n            vowels_pos\
    \ = i;\n            vowels_rev_pos_count++;\n            vowels_pos_count++;\n\
    \            vowels_rev_pos_count_max = std::max(vowels_rev_pos_count_max, vowels_rev_pos);\n\
    \            vowels_pos_count_max = std::max(vowels_pos_count_max, vowels_pos);\n\
    \        }\n    }\n    if (vowels_rev_pos_count > vowels_pos_count) {\n      \
    \  return \"\";\n    }\n    int vowels_rev_pos_count_min = std::min(vowels_rev_pos_count_max,\
    \ vowels_rev_pos);\n    int vowels_pos_count_min = std::min(vowels_pos_count_max,\
    \ vowels_pos);\n    int vowels_rev_pos_count_min_diff = vowels_rev_pos_count_min\
    \ - vowels_pos;\n    int vowels_pos_count_min_diff = vowels_pos_count_min - vowels_rev_pos;\n\
    \    int vowels_rev_pos_count_min_diff_max = vowels_rev_pos_count_min - vowels_pos_count_min;\n\
    \    int vowels_pos_count_min_diff_max = vowels_pos_count_min - vowels_rev_pos_count_min;\n\
    \    int vowels_rev_pos_count_min_diff_max_2 = vowels_rev_pos_count_min - vowels_pos_count_min\
    \ - 1;\n    int vowels_pos_count_min_diff_max_2 = vowels_pos_count_min - vowels_rev_pos_count_min\
    \ - 1;\n    int vowels_rev_pos_count_min_diff_max_3 = vowels_rev_pos_count_min\
    \ - vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpch5dlx3v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_bvdsi76.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp_bvdsi76.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_bvdsi76.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_reversed = vowels_reversed.substr(0, vowels_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed = vowels_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed =\
    \ vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5rl__ruo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels_reverse.substr(0, vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0, vowels_reverse2.size()\
    \ - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0, vowels_reverse3.size()\
    \ - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0, vowels_reverse4.size()\
    \ - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0, vowels_reverse5.size()\
    \ - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0, vowels_reverse6.size()\
    \ - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0, vowels_reverse7.size()\
    \ - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0, vowels_reverse8.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0, vowels_reverse9.size()\
    \ - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0, vowels_reverse10.size()\
    \ - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0, vowels_reverse11.size()\
    \ - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0, vowels_reverse12.size()\
    \ - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0, vowels_reverse13.size()\
    \ - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0, vowels_reverse14.size()\
    \ - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0, vowels_reverse15.size()\
    \ - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0, vowels_reverse16.size()\
    \ - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0, vowels_reverse17.size()\
    \ - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0, vowels_reverse18.size()\
    \ - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0, vowels_reverse19.size()\
    \ - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0, vowels_reverse20.size()\
    \ - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0, vowels_reverse21.size()\
    \ - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0, vowels_reverse22.size()\
    \ - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0, vowels_reverse23.size()\
    \ - 1);\n    std::string vowels_reverse25 = vowels_reverse24.substr(0, vowels_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz9qi9q4s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowels_size = vowels.size();\n    std::string vowels_str = \"\";\n\
    \    int vowels_index = 0;\n    int vowels_index_start = 0;\n    int vowels_index_end\
    \ = 0;\n    int vowels_index_mid = 0;\n    int vowels_index_mid_start = 0;\n \
    \   int vowels_index_mid_end = 0;\n    int vowels_index_mid_mid = 0;\n    int\
    \ vowels_index_mid_mid_start = 0;\n    int vowels_index_mid_mid_end = 0;\n   \
    \ int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n \
    \   int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_index_mid_mid_mid = 0;\n    int vowels_index_mid_mid_mid = 0;\n\
    \    int vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpivuxurw8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_re\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz0emciql.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1) + vowels.substr(1,\
    \ vowels.size() - 1);\n    std::string vowels_reversed_upper = vowels_reversed.toUpper();\n\
    \    std::string vowels_reversed_lower = vowels_reversed.toLower();\n    std::string\
    \ vowels_reversed_upper_reversed = vowels_reversed_upper.substr(0, vowels_reversed_upper.size()\
    \ - 1) + vowels_reversed_upper.substr(1, vowels_reversed_upper.size() - 1);\n\
    \    std::string vowels_reversed_lower_reversed = vowels_reversed_lower.substr(0,\
    \ vowels_reversed_lower.size() - 1) + vowels_reversed_lower.substr(1, vowels_reversed_lower.size()\
    \ - 1);\n    std::string vowels_reversed_upper_reversed_reversed = vowels_reversed_upper_reversed.substr(0,\
    \ vowels_reversed_upper_reversed.size() - 1) + vowels_reversed_upper_reversed.substr(1,\
    \ vowels_reversed_upper_reversed.size() - 1);\n    std::string vowels_reversed_lower_reversed_reversed\
    \ = vowels_reversed_lower_reversed.substr(0, vowels_reversed_lower_reversed.size()\
    \ - 1) + vowels_reversed_lower_reversed.substr(1, vowels_reversed_lower_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_reversed_reversed_reversed = vowels_reversed_upper_reversed_reversed.substr(0,\
    \ vowels_reversed_upper_reversed_reversed.size() - 1) + vowels_reversed_upper_reversed_reversed.substr(1,\
    \ vowels_reversed_upper_reversed_reversed.size() - 1);\n    std::string vowels_reversed_lower_reversed_reversed_reversed\
    \ = vowels_reversed_lower_reversed_reversed.substr(0, vowels_reversed_lower_reversed_reversed.size()\
    \ - 1) + vowels_reversed_lower_reversed_reversed.substr(1, vowels_reversed_lower_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_upper_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_upper_reversed_reversed_reversed.substr(0, vowels_reversed_upper_reversed_reversed_reversed.size()\
    \ - 1) + vowels_reversed_upper_reversed_reversed_reversed.substr(1, vowels_reversed_upper_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_lower_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_lower_reversed_reversed_reversed.substr(0, vowels_reversed_lower_reversed_reversed_reversed.size()\
    \ - 1) + vowels_reversed_lower_reversed_reversed_reversed.substr(\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpukayoo97.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int n = word.size();\n    int vowel_count = 0;\n    int consonant_count\
    \ = 0;\n    int vowel_pos = 0;\n    int consonant_pos = 0;\n    std::string vowel_found\
    \ = \"\";\n    std::string consonant_found = \"\";\n    std::string vowel_before\
    \ = \"\";\n    std::string consonant_before = \"\";\n    std::string vowel_after\
    \ = \"\";\n    std::string consonant_after = \"\";\n    for (int i = 0; i < n;\
    \ i++) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            vowel_found = \"a\";\n            vowel_pos\
    \ = i;\n            vowel_count++;\n        }\n        if (word[i] == 'b' || word[i]\
    \ == 'c' || word[i] == 'd' || word[i] == 'f' || word[i] == 'g' || word[i] == 'h'\
    \ || word[i] == 'j' || word[i] == 'k' || word[i] == 'l' || word[i] == 'm' || word[i]\
    \ == 'n' || word[i] == 'p' || word[i] == 'q' || word[i] == 'r' || word[i] == 's'\
    \ || word[i] == 't' || word[i] == 'v' || word[i] == 'w' || word[i] == 'x' || word[i]\
    \ == 'y' || word[i] == 'z') {\n            vowel_found = \"b\";\n            vowel_pos\
    \ = i;\n            vowel_count++;\n        }\n        if (word[i] == 'c' || word[i]\
    \ == 'd' || word[i] == 'f' || word[i] == 'g' || word[i] == 'h' || word[i] == 'j'\
    \ || word[i] == 'k' || word[i] == 'l' || word[i] == 'm' || word[i] == 'n' || word[i]\
    \ == 'p' || word[i] == 'q' || word[i] == 'r' || word[i] == 's' || word[i] == 't'\
    \ || word[i] == 'v' || word[i] == 'w' || word[i] == 'x' || word[i] == 'y' || word[i]\
    \ == 'z') {\n            vowel_found = \"c\";\n            vowel_pos = i;\n  \
    \          vowel_count++;\n        }\n        if (word[i] == 'd' || word[i] ==\
    \ 'f' || word[i] == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k'\
    \ || word[i] == 'l' || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i]\
    \ == 'q' || word[i] == 'r' || word[i] == 's' || word[i] == 't' || word[i] == 'v'\
    \ || word[i] == 'w' || word[i] == 'x' || word[i] == 'y' || word[i] == 'z') {\n\
    \            vowel_found = \"d\";\n            vowel_pos = i;\n            vowel_count++;\n\
    \        }\n        if (word[i] == '\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa9x0q9sh.cpp:51:24: warning: missing terminating ' character [enabled\
    \ by default]\n         if (word[i] == '\n                        ^\n/tmp/tmpa9x0q9sh.cpp:51:9:\
    \ error: missing terminating ' character\n         if (word[i] == '\n        \
    \ ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa9x0q9sh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       cons"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"aeiouAE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqrreg7.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp7fqrreg7.cpp:54:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqrreg7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_reversed = vowels_reversed.substr(0, vowels_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed = vowels_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed =\
    \ vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5rl__ruo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = vowels.rbegin();\n\
    \    std::string vowels_reverse2 = vowels.rend();\n    std::string vowels_reverse3\
    \ = vowels_reverse2.rbegin();\n    std::string vowels_reverse4 = vowels_reverse3.rend();\n\
    \    std::string vowels_reverse5 = vowels_reverse4.rbegin();\n    std::string\
    \ vowels_reverse6 = vowels_reverse5.rend();\n    std::string vowels_reverse7 =\
    \ vowels_reverse6.rbegin();\n    std::string vowels_reverse8 = vowels_reverse7.rend();\n\
    \    std::string vowels_reverse9 = vowels_reverse8.rbegin();\n    std::string\
    \ vowels_reverse10 = vowels_reverse9.rend();\n    std::string vowels_reverse11\
    \ = vowels_reverse10.rbegin();\n    std::string vowels_reverse12 = vowels_reverse11.rend();\n\
    \    std::string vowels_reverse13 = vowels_reverse12.rbegin();\n    std::string\
    \ vowels_reverse14 = vowels_reverse13.rend();\n    std::string vowels_reverse15\
    \ = vowels_reverse14.rbegin();\n    std::string vowels_reverse16 = vowels_reverse15.rend();\n\
    \    std::string vowels_reverse17 = vowels_reverse16.rbegin();\n    std::string\
    \ vowels_reverse18 = vowels_reverse17.rend();\n    std::string vowels_reverse19\
    \ = vowels_reverse18.rbegin();\n    std::string vowels_reverse20 = vowels_reverse19.rend();\n\
    \    std::string vowels_reverse21 = vowels_reverse20.rbegin();\n    std::string\
    \ vowels_reverse22 = vowels_reverse21.rend();\n    std::string vowels_reverse23\
    \ = vowels_reverse22.rbegin();\n    std::string vowels_reverse24 = vowels_reverse23.rend();\n\
    \    std::string vowels_reverse25 = vowels_reverse24.rbegin();\n    std::string\
    \ vowels_reverse26 = vowels_reverse25.rend();\n    std::string vowels_reverse27\
    \ = vowels_reverse26.rbegin();\n    std::string vowels_reverse28 = vowels_reverse27.rend();\n\
    \    std::string vowels_reverse29 = vowels_reverse28.rbegin();\n    std::string\
    \ vowels_reverse30 = vowels_reverse29.rend();\n    std::string vowels_reverse31\
    \ = vowels_reverse30.rbegin();\n    std::string vowels_reverse32 = vowels_reverse31.rend();\n\
    \    std::string vowels_reverse33 = vowels_reverse32.rbegin();\n    std::string\
    \ vowels_reverse34 = vowels_reverse33.rend();\n    std::string vowels_reverse35\
    \ = vowels_reverse34.rbegin();\n    std::string vowel\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9f7n1a8w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpm4ji_upa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1) + vowels.substr(1,\
    \ vowels.size() - 1);\n    std::string vowels_reversed_reversed = vowels_reversed.substr(0,\
    \ vowels_reversed.size() - 1) + vowels_reversed.substr(1, vowels_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed = vowels_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed.size() - 1) + vowels_reversed_reversed.substr(1, vowels_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed.size() - 1) + vowels_reversed_reversed_reversed.substr(1,\
    \ vowels_reversed_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1) + vowels_reversed_reversed_reversed_reversed.substr(1, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1) + vowels_reversed_reversed_reversed_reversed_reversed.substr(1, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed.size() - 1) + vowels_reversed_reversed_reversed_reversed_reversed.substr(1,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1) + vowels_reversed_reversed_reversed_reversed_reversed_reversed.substr(1,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp87ccfd5v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiricm2tv.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmpiricm2tv.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmpiricm2tv.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmpiricm2tv.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmpiricm2tv.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmpiricm2tv.cpp: In function\
    \ 'int main()':\n/tmp/tmpiricm2tv.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiricm2tv.cpp:2:\n/tmp/tmpiricm2tv.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_rev = \"AEIOUaeiou\";\n   \
    \ std::string vowels_rev1 = \"AEIOUaeiou\";\n    std::string vowels_rev2 = \"\"\
    ;\n    std::string vowels_rev3 = \"\";\n    std::string vowels_rev4 = \"\";\n\
    \    std::string vowels_rev5 = \"\";\n    std::string vowels_rev6 = \"\";\n  \
    \  std::string vowels_rev7 = \"\";\n    std::string vowels_rev8 = \"\";\n    std::string\
    \ vowels_rev9 = \"\";\n    std::string vowels_rev10 = \"\";\n    std::string vowels_rev11\
    \ = \"\";\n    std::string vowels_rev12 = \"\";\n    std::string vowels_rev13\
    \ = \"\";\n    std::string vowels_rev14 = \"\";\n    std::string vowels_rev15\
    \ = \"\";\n    std::string vowels_rev16 = \"\";\n    std::string vowels_rev17\
    \ = \"\";\n    std::string vowels_rev18 = \"\";\n    std::string vowels_rev19\
    \ = \"\";\n    std::string vowels_rev20 = \"\";\n    std::string vowels_rev21\
    \ = \"\";\n    std::string vowels_rev22 = \"\";\n    std::string vowels_rev23\
    \ = \"\";\n    std::string vowels_rev24 = \"\";\n    std::string vowels_rev25\
    \ = \"\";\n    std::string vowels_rev26 = \"\";\n    std::string vowels_rev27\
    \ = \"\";\n    std::string vowels_rev28 = \"\";\n    std::string vowels_rev29\
    \ = \"\";\n    std::string vowels_rev30 = \"\";\n    std::string vowels_rev31\
    \ = \"\";\n    std::string vowels_rev32 = \"\";\n    std::string vowels_rev33\
    \ = \"\";\n    std::string vowels_rev34 = \"\";\n    std::string vowels_rev35\
    \ = \"\";\n    std::string vowels_rev36 = \"\";\n    std::string vowels_rev37\
    \ = \"\";\n    std::string vowels_rev38 = \"\";\n    std::string vowels_rev39\
    \ = \"\";\n    std::string vowels_rev40 = \"\";\n    std::string vowels_rev41\
    \ = \"\";\n    std::string vowels_rev42 = \"\";\n    std::string vowels_rev43\
    \ = \"\";\n    std::string vowels_rev44 = \"\";\n    std::string vowels_rev45\
    \ = \"\";\n    std::string vowels_rev46 = \"\";\n    std::string vowels_rev47\
    \ = \"\";\n    std::string vowels_rev48 = \"\";\n    std::string vowels_rev49\
    \ = \"\";\n    std::string vowels_rev50 = \"\";\n    std::string vowels_rev51\
    \ = \"\";\n    std::string vowels_rev52 = \"\";\n    std::string vowels_rev53\
    \ = \"\";\n    std::string vowels_rev54 = \"\";\n    std::string vowels_rev55\
    \ = \"\";\n    std::string vowels_rev56 = \"\";\n    std::string vowels_rev57\
    \ = \"\";\n    std::string vowels_rev58 = \"\";\n    std::string \n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa2x32b3s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_back\
    \ = \"\";\n    std::string vowels_back_reverse = \"\";\n    std::string vowels_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse = \"\";\n    std::string\
    \ vowels_back_reverse_back_reverse_back = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph9hffbfa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_upper = \"AEIOUAEIOU\";\n    std::string vowels_lower\
    \ = \"\";\n    std::string vowels_upper_reverse = \"\";\n    std::string vowels_lower_reverse\
    \ = \"\";\n    std::string vowels_reverse = \"\";\n    std::string vowels_upper_reverse_2\
    \ = \"\";\n    std::string vowels_lower_reverse_2 = \"\";\n    std::string vowels_reverse_2\
    \ = \"\";\n    std::string vowels_upper_reverse_3 = \"\";\n    std::string vowels_lower_reverse_3\
    \ = \"\";\n    std::string vowels_reverse_3 = \"\";\n    std::string vowels_upper_reverse_4\
    \ = \"\";\n    std::string vowels_lower_reverse_4 = \"\";\n    std::string vowels_reverse_4\
    \ = \"\";\n    std::string vowels_upper_reverse_5 = \"\";\n    std::string vowels_lower_reverse_5\
    \ = \"\";\n    std::string vowels_reverse_5 = \"\";\n    std::string vowels_upper_reverse_6\
    \ = \"\";\n    std::string vowels_lower_reverse_6 = \"\";\n    std::string vowels_reverse_6\
    \ = \"\";\n    std::string vowels_upper_reverse_7 = \"\";\n    std::string vowels_lower_reverse_7\
    \ = \"\";\n    std::string vowels_reverse_7 = \"\";\n    std::string vowels_upper_reverse_8\
    \ = \"\";\n    std::string vowels_lower_reverse_8 = \"\";\n    std::string vowels_reverse_8\
    \ = \"\";\n    std::string vowels_upper_reverse_9 = \"\";\n    std::string vowels_lower_reverse_9\
    \ = \"\";\n    std::string vowels_reverse_9 = \"\";\n    std::string vowels_upper_reverse_10\
    \ = \"\";\n    std::string vowels_lower_reverse_10 = \"\";\n    std::string vowels_reverse_10\
    \ = \"\";\n    std::string vowels_upper_reverse_11 = \"\";\n    std::string vowels_lower_reverse_11\
    \ = \"\";\n    std::string vowels_reverse_11 = \"\";\n    std::string vowels_upper_reverse_12\
    \ = \"\";\n    std::string vowels_lower_reverse_12 = \"\";\n    std::string vowels_reverse_12\
    \ = \"\";\n    std::string vowels_upper_reverse_13 = \"\";\n    std::string vowels_lower_reverse_13\
    \ = \"\";\n    std::string vowels_reverse_13 = \"\";\n    std::string vowels_upper_reverse_14\
    \ = \"\";\n    std::string vowels_lower_reverse_14 = \"\";\n    std::string vowels_reverse_14\
    \ = \"\";\n    std::string vowels_upper_reverse_15 = \"\";\n    std::string vowels_lower_reverse_15\
    \ = \"\";\n    std::string vowels_reverse_15 = \"\";\n    std::string vowels_upper_reverse_16\
    \ = \"\";\n    std::string vowels_lower_reverse_16 = \"\";\n    std::string vowels_reverse_16\
    \ = \"\";\n    std::string vowels_upper_reverse_17 = \"\";\n    std::string vowels_lower_reverse_17\
    \ = \"\";\n    std::string vowels_reverse_17 = \"\";\n    std::string vowels_upper_reverse_18\
    \ = \"\";\n    std::string vowels_lower_reverse_18 = \"\";\n    std::string vowels_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppc89zq18.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqydjzu1u.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmpqydjzu1u.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqydjzu1u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse_reverse = vowels_reverse.substr(0, vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse = vowels_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_re\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplw3gfedm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp69v8gsl7.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp69v8gsl7.cpp:56:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmp69v8gsl7.cpp: In function 'int main()':\n/tmp/tmp69v8gsl7.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp69v8gsl7.cpp:2:\n/tmp/tmp69v8gsl7.cpp:59:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int len = word.length();\n    int\
    \ vowel_count = 0;\n    int consonant_count = 0;\n    int consonant_index = 0;\n\
    \    int vowel_index = 0;\n    std::string vowel = \"\";\n    std::string consonant\
    \ = \"\";\n    std::string vowel_found = \"\";\n    std::string consonant_found\
    \ = \"\";\n    std::string vowel_found2 = \"\";\n    std::string consonant_found2\
    \ = \"\";\n    for (int i = 0; i < len; i++) {\n        if (word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i]\
    \ == 'y') {\n            vowel_found2 = vowel_found;\n            vowel_found\
    \ = \"\";\n            vowel_count++;\n        }\n        if (word[i] == 'b' ||\
    \ word[i] == 'c' || word[i] == 'd' || word[i] == 'f' || word[i] == 'g' || word[i]\
    \ == 'h' || word[i] == 'j' || word[i] == 'k' || word[i] == 'l' || word[i] == 'm'\
    \ || word[i] == 'n' || word[i] == 'p' || word[i] == 'q' || word[i] == 'r' || word[i]\
    \ == 's' || word[i] == 't' || word[i] == 'v' || word[i] == 'w' || word[i] == 'x'\
    \ || word[i] == 'y') {\n            vowel_found2 = vowel_found;\n            vowel_found\
    \ = \"\";\n            vowel_count++;\n        }\n        if (word[i] == 'A' ||\
    \ word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' || word[i]\
    \ == 'Y') {\n            vowel_found2 = vowel_found;\n            vowel_found\
    \ = \"\";\n            vowel_count++;\n        }\n        if (word[i] == 'B' ||\
    \ word[i] == 'C' || word[i] == 'D' || word[i] == 'F' || word[i] == 'G' || word[i]\
    \ == 'H' || word[i] == 'J' || word[i] == 'K' || word[i] == 'L' || word[i] == 'M'\
    \ || word[i] == 'N' || word[i] == 'P' || word[i] == 'Q' || word[i] == 'R' || word[i]\
    \ == 'S' || word[i] == 'T' || word[i] == 'V' || word[i] == 'W' || word[i] == 'X'\
    \ || word[i] == 'Y') {\n            vowel_found2 = vowel_found;\n            vowel_found\
    \ = \"\";\n            vowel_count++;\n        }\n        if (word[i] == 'd' ||\
    \ word[i] == 'e' || word[i] == 'f' || word[i] == 'g' || word[i] == 'h' || word[i]\
    \ == 'j' || word[i] == 'k' || word[i] == 'l' || word[i] == 'm' || word[i] == 'n'\
    \ || word[i] == 'p' || word[i] == 'q' || word[i] == 'r' || word[i] == 's' || word[i]\
    \ == '\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6blksdai.cpp:50:276: warning: missing terminating ' character [enabled\
    \ by default]\n         if (word[i] == 'd' || word[i] == 'e' || word[i] == 'f'\
    \ || word[i] == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k' || word[i]\
    \ == 'l' || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i] == 'q'\
    \ || word[i] == 'r' || word[i] == 's' || word[i] == '\n                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                          ^\n/tmp/tmp6blksdai.cpp:50:9: error: missing terminating\
    \ ' character\n         if (word[i] == 'd' || word[i] == 'e' || word[i] == 'f'\
    \ || word[i] == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k' || word[i]\
    \ == 'l' || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i] == 'q'\
    \ || word[i] == 'r' || word[i] == 's' || word[i] == '\n         ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6blksdai.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowi"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_lower = \"AEIOUaeiou\";\n    std::string vowels_upper\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper2 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper3 = \"AEIOUAEIOU\";\n    std::string vowels_upper4 = \"AEIOUAEIOU\"\
    ;\n    std::string vowels_upper5 = \"AEIOUAEIOU\";\n    std::string vowels_upper6\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper7 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper8 = \"AEIOUAEIOU\";\n    std::string vowels_upper9 = \"AEIOUAEIOU\"\
    ;\n    std::string vowels_upper10 = \"AEIOUAEIOU\";\n    std::string vowels_upper11\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper12 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper13 = \"AEIOUAEIOU\";\n    std::string vowels_upper14 = \"AEIOUAEIOU\"\
    ;\n    std::string vowels_upper15 = \"AEIOUAEIOU\";\n    std::string vowels_upper16\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper17 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper18 = \"AEIOUAEIOU\";\n    std::string vowels_upper19 = \"AEIOUAEIOU\"\
    ;\n    std::string vowels_upper20 = \"AEIOUAEIOU\";\n    std::string vowels_upper21\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper22 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper23 = \"AEIOUAEIOU\";\n    std::string vowels_upper24 = \"AEIOUAEIOU\"\
    ;\n    std::string vowels_upper25 = \"AEIOUAEIOU\";\n    std::string vowels_upper26\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper27 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper28 = \"AEIOUAEIOU\";\n    std::string vowels_upper29 = \"AEIOUAEIOU\"\
    ;\n    std::string vowels_upper30 = \"AEIOUAEIOU\";\n    std::string vowels_upper31\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper32 = \"AEIOUAEIOU\";\n    std::string\
    \ vowels_upper33 = \"\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyzbxg8lj.cpp:52:34: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_upper33 = \"\n                        \
    \          ^\n/tmp/tmpyzbxg8lj.cpp:52:5: error: missing terminating \" character\n\
    \     std::string vowels_upper33 = \"\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyzbxg8lj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression be"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse_reverse = vowels_reverse.substr(0, vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse = vowels_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_re\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplw3gfedm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxs8g5e8t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse3 = vowels.substr(0, vowels.size() - 1);\n    std::string\
    \ vowels_reverse4 = vowels.substr(vowels.size() - 1, vowels.size());\n    std::string\
    \ vowels_reverse5 = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse6\
    \ = vowels.substr(vowels.size() - 1, vowels.size());\n    std::string vowels_reverse7\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse8 = vowels.substr(vowels.size()\
    \ - 1, vowels.size());\n    std::string vowels_reverse9 = vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse11 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse12 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse13 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse14 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse15 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse16 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse17 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse18 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse19 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse20 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse21 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse22 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse23 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse24 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse25 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse26 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse27 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse28 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse29 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse30 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowel\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpt98ipuwe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6rcy9qr_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjhk9s252.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reverse2 = vowels.substr(0, vowels.size()\
    \ - 2);\n    std::string vowels_reverse3 = vowels.substr(0, vowels.size() - 3);\n\
    \    std::string vowels_reverse4 = vowels.substr(0, vowels.size() - 4);\n    std::string\
    \ vowels_reverse5 = vowels.substr(0, vowels.size() - 5);\n    std::string vowels_reverse6\
    \ = vowels.substr(0, vowels.size() - 6);\n    std::string vowels_reverse7 = vowels.substr(0,\
    \ vowels.size() - 7);\n    std::string vowels_reverse8 = vowels.substr(0, vowels.size()\
    \ - 8);\n    std::string vowels_reverse9 = vowels.substr(0, vowels.size() - 9);\n\
    \    std::string vowels_reverse10 = vowels.substr(0, vowels.size() - 10);\n  \
    \  std::string vowels_reverse11 = vowels.substr(0, vowels.size() - 11);\n    std::string\
    \ vowels_reverse12 = vowels.substr(0, vowels.size() - 12);\n    std::string vowels_reverse13\
    \ = vowels.substr(0, vowels.size() - 13);\n    std::string vowels_reverse14 =\
    \ vowels.substr(0, vowels.size() - 14);\n    std::string vowels_reverse15 = vowels.substr(0,\
    \ vowels.size() - 15);\n    std::string vowels_reverse16 = vowels.substr(0, vowels.size()\
    \ - 16);\n    std::string vowels_reverse17 = vowels.substr(0, vowels.size() -\
    \ 17);\n    std::string vowels_reverse18 = vowels.substr(0, vowels.size() - 18);\n\
    \    std::string vowels_reverse19 = vowels.substr(0, vowels.size() - 19);\n  \
    \  std::string vowels_reverse20 = vowels.substr(0, vowels.size() - 20);\n    std::string\
    \ vowels_reverse21 = vowels.substr(0, vowels.size() - 21);\n    std::string vowels_reverse22\
    \ = vowels.substr(0, vowels.size() - 22);\n    std::string vowels_reverse23 =\
    \ vowels.substr(0, vowels.size() - 23);\n    std::string vowels_reverse24 = vowels.substr(0,\
    \ vowels.size() - 24);\n    std::string vowels_reverse25 = vowels.substr(0, vowels.size()\
    \ - 25);\n    std::string vowels_reverse26 = vowels.substr(0, vowels.size() -\
    \ 26);\n    std::string vowels_reverse27 = vowels.substr(0, vowels.size() - 27);\n\
    \    std::string vowels_reverse28 = vowels.substr(0, vowels.size() - 28);\n  \
    \  std::string vowels_reverse29 = vowels.substr(0, vowels.size() - 29);\n    std::string\
    \ vowels_reverse30 = vowels.substr(0, vowels.size() - 30);\n    std::string vowels_reverse31\
    \ = vowels.substr(0, vowels.size() - 31);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpm4gm755i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int len = word.length();\n    int start = 0;\n    int end = 0;\n    int\
    \ mid = 0;\n    int vowel_pos = 0;\n    int vowel_pos_count = 0;\n    std::string\
    \ vowel_found = \"\";\n    std::string vowel_found_temp = \"\";\n    std::string\
    \ vowel_found_temp_2 = \"\";\n    std::string vowel_found_temp_3 = \"\";\n   \
    \ std::string vowel_found_temp_4 = \"\";\n    std::string vowel_found_temp_5 =\
    \ \"\";\n    std::string vowel_found_temp_6 = \"\";\n    std::string vowel_found_temp_7\
    \ = \"\";\n    std::string vowel_found_temp_8 = \"\";\n    std::string vowel_found_temp_9\
    \ = \"\";\n    std::string vowel_found_temp_10 = \"\";\n    std::string vowel_found_temp_11\
    \ = \"\";\n    std::string vowel_found_temp_12 = \"\";\n    std::string vowel_found_temp_13\
    \ = \"\";\n    std::string vowel_found_temp_14 = \"\";\n    std::string vowel_found_temp_15\
    \ = \"\";\n    std::string vowel_found_temp_16 = \"\";\n    std::string vowel_found_temp_17\
    \ = \"\";\n    std::string vowel_found_temp_18 = \"\";\n    std::string vowel_found_temp_19\
    \ = \"\";\n    std::string vowel_found_temp_20 = \"\";\n    std::string vowel_found_temp_21\
    \ = \"\";\n    std::string vowel_found_temp_22 = \"\";\n    std::string vowel_found_temp_23\
    \ = \"\";\n    std::string vowel_found_temp_24 = \"\";\n    std::string vowel_found_temp_25\
    \ = \"\";\n    std::string vowel_found_temp_26 = \"\";\n    std::string vowel_found_temp_27\
    \ = \"\";\n    std::string vowel_found_temp_28 = \"\";\n    std::string vowel_found_temp_29\
    \ = \"\";\n    std::string vowel_found_temp_30 = \"\";\n    std::string vowel_found_temp_31\
    \ = \"\";\n    std::string vowel_found_temp_32 = \"\";\n    std::string vowel_found_temp_33\
    \ = \"\";\n    std::string vowel_found_temp_34 = \"\";\n    std::string vowel_found_temp_35\
    \ = \"\";\n    std::string vowel_found_temp_36 = \"\";\n    std::string vowel_found_temp_37\
    \ = \"\";\n    std::string vowel_found_temp_38 = \"\";\n    std::string vowel_found_temp_39\
    \ = \"\";\n    std::string vowel_found_temp_40 = \"\";\n    std::string vowel_found_temp_41\
    \ = \"\";\n    std::string vowel_found_temp_42 = \"\";\n    std::string vowel_found_temp_43\
    \ = \"\";\n    std::string vowel_found_temp_44 = \"\";\n    std::string vowel_found_temp_45\
    \ = \"\";\n    std::string vowel_found_temp_46 = \"\";\n    std::string vowel_found_temp_47\
    \ = \"\";\n    std::string vowel_found_temp_48 = \"\";\n    std::string vowel_found_temp_49\
    \ = \"\";\n    std::string vowel_found_temp_50 = \"\";\n    std::string vowel_found_temp_51\
    \ = \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp43edpacc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5wlygb9.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpa5wlygb9.cpp:26:17: error: redeclaration of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:25:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously declared\
    \ here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:28:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:29:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:30:17: error: redeclaration\
    \ of 'std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse'\n\
    \     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n                 ^\n/tmp/tmpa5wlygb9.cpp:27:17: error: 'std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse' previously\
    \ declared here\n     std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_lower = \"AEIOUaeiou\";\n    std::string vowels_upper\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower = \"AEIOUAEIOU\";\n  \
    \  std::string vowels_upper_lower_lower = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower = \"\
    AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = \"AEIOUAEIOU\";\n    std::string vowels_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx7zrxq87.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int n = word.size();\n    int vowel_count = 0;\n    int consonant_count\
    \ = 0;\n    int consonant_index = -1;\n    int vowel_index = -1;\n    int vowel_start_index\
    \ = -1;\n    int vowel_end_index = -1;\n    for (int i = 0; i < n; i++) {\n  \
    \      if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u') {\n            vowel_count++;\n            if (vowel_count\
    \ == 1) {\n                vowel_index = i;\n                vowel_start_index\
    \ = i;\n                vowel_end_index = i;\n            }\n        }\n     \
    \   if (word[i] == word[i + 1]) {\n            consonant_count++;\n          \
    \  if (consonant_count == 1) {\n                consonant_index = i;\n       \
    \     }\n        }\n    }\n    if (vowel_count > 1) {\n        for (int i = vowel_index\
    \ + 1; i < n; i++) {\n            if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n                vowel_count--;\n\
    \                if (vowel_count == 0) {\n                    vowel_index = i;\n\
    \                    vowel_start_index = i;\n                    vowel_end_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (consonant_count\
    \ > 1) {\n        for (int i = consonant_index + 1; i < n; i++) {\n          \
    \  if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u') {\n                consonant_count--;\n                if (consonant_count\
    \ == 0) {\n                    consonant_index = i;\n                }\n     \
    \       }\n        }\n    }\n    if (vowel_count > 0 && consonant_count == 0)\
    \ {\n        return \"\";\n    }\n    if (vowel_count == 0 && consonant_count\
    \ == 0) {\n        return word;\n    }\n    if (vowel_count == 0 && consonant_count\
    \ > 0) {\n        return word;\n    }\n    if (vowel_count == 0 && consonant_count\
    \ == 1) {\n        return word.substr(vowel_start_index, vowel_end_index - vowel_start_index);\n\
    \    }\n    if (vowel_count > 0 && consonant_count == 1) {\n        return word.substr(vowel_start_index,\
    \ vowel_end_index - vowel_start_index);\n    }\n    if (vowel_count > 0 && consonant_count\
    \ > 1) {\n        return word.substr(vowel_start_index, vowel_end_index - vowel_start_index);\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprqp2ucuu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"aeiouAE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqrreg7.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp7fqrreg7.cpp:54:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqrreg7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_begin\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin2 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end2 = \"aeiouAEIOU\";\n    std::string vowels_begin3 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string vowels_begin4\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin5 = \"aeiouAEIOU\";\n    std::string vowels_end5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin6 = \"aeiouAEIOU\";\n    std::string vowels_end6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end7 = \"aeiouAEIOU\";\n    std::string vowels_begin8 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end8 = \"aeiouAEIOU\";\n    std::string vowels_begin9\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin10 = \"aeiouAEIOU\";\n    std::string vowels_end10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin11 = \"aeiouAEIOU\";\n    std::string vowels_end11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end12 = \"aeiouAEIOU\";\n    std::string vowels_begin13 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end13 = \"aeiouAEIOU\";\n    std::string vowels_begin14\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin15 = \"aeiouAEIOU\";\n    std::string vowels_end15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin16 = \"aeiouAEIOU\";\n    std::string vowels_end16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end17 = \"aeiouAEIOU\";\n    std::string vowels_begin18 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end18 = \"aeiouAEIOU\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf5qkp6_o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_rev = \"AEIOUaeiou\";\n   \
    \ for (int i = 0; i < n; i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            vowels_rev = vowels_rev.replace(word[i], \"\");\n        }\n\
    \    }\n    if (vowels_rev.length() == 0) {\n        return \"\";\n    }\n   \
    \ int vowel_pos = 0;\n    int vowel_pos_rev = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_pos\
    \ = i;\n            break;\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        if (vowels_rev.find(word[i]) != std::string::npos) {\n          \
    \  vowel_pos_rev = i;\n            break;\n        }\n    }\n    if (vowel_pos\
    \ == 0) {\n        return \"\";\n    }\n    if (vowel_pos_rev == n - 1) {\n  \
    \      return \"\";\n    }\n    int vowel_pos_diff = abs(vowel_pos - vowel_pos_rev);\n\
    \    if (vowel_pos_diff == 1) {\n        return word[vowel_pos];\n    }\n    if\
    \ (vowel_pos_diff == 2) {\n        return word[vowel_pos] + word[vowel_pos + 1];\n\
    \    }\n    if (vowel_pos_diff == 3) {\n        return word[vowel_pos] + word[vowel_pos\
    \ + 1] + word[vowel_pos + 2];\n    }\n    if (vowel_pos_diff == 4) {\n       \
    \ return word[vowel_pos] + word[vowel_pos + 1] + word[vowel_pos + 2] + word[vowel_pos\
    \ + 3];\n    }\n    if (vowel_pos_diff == 5) {\n        return word[vowel_pos]\
    \ + word[vowel_pos + 1] + word[vowel_pos + 2] + word[vowel_pos + 3] + word[vowel_pos\
    \ + 4];\n    }\n    if (vowel_pos_diff == 6) {\n        return word[vowel_pos]\
    \ + word[vowel_pos + 1] + word[vowel_pos + 2] + word[vowel_pos + 3] + word[vowel_pos\
    \ + 4] + word[vowel_pos + 5];\n    }\n    if (vowel_pos_diff == 7) {\n       \
    \ return word[vowel_pos] + word[vowel_pos + 1] + word[vowel_pos + 2] + word[vowel_pos\
    \ + 3] + word[vowel_pos + 4] + word[vowel_pos + 5] + word[vowel_pos + 6];\n  \
    \  }\n    if (vowel_pos_diff == 8) {\n        return word[vowel_pos] + word[vowel_pos\
    \ + 1] + word[vowel_pos + 2] + word[vowel_pos + 3] + word[vowel\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy_sshu2e.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    int vowel_counter\
    \ = 0;\n    int consonant_counter = 0;\n    int vowel_start = 0;\n    int vowel_end\
    \ = 0;\n    int consonant_start = 0;\n    int consonant_end = 0;\n    int vowel_found\
    \ = 0;\n    int consonant_found = 0;\n    for (int i = 0; i < n; i++) {\n    \
    \    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u') {\n            vowel_counter++;\n        }\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            vowel_start = i;\n        }\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n          \
    \  vowel_end = i;\n        }\n        if (word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            vowel_found\
    \ = 1;\n        }\n        if (word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u') {\n            vowel_found = 1;\n \
    \       }\n    }\n    for (int i = n-1; i >= 0; i--) {\n        if (word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            consonant_counter++;\n        }\n        if (word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n  \
    \          consonant_start = i;\n        }\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n          \
    \  consonant_end = i;\n        }\n        if (word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            consonant_found\
    \ = 1;\n        }\n        if (word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u') {\n            consonant_found = 1;\n\
    \        }\n    }\n    if (vowel_counter == 0 && consonant_counter == 0) {\n \
    \       return \"\";\n    }\n    if (vowel_counter == 0 && consonant_counter ==\
    \ 1) {\n        return word;\n    }\n    if (vowel_counter == 1 && consonant_counter\
    \ == 0) {\n        return word;\n    }\n    if (vowel_counter == 1 && consonant_counter\
    \ == 1) {\n        if (vowel_start < consonant_start && vowel_end \n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw6hmc6sl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_begin\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin2 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end2 = \"AEIOUaeiou\";\n    std::string vowels_begin3 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string vowels_begin4\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin5 = \"aeiouAEIOU\";\n    std::string vowels_end5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin6 = \"aeiouAEIOU\";\n    std::string vowels_end6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end7 = \"AEIOUaeiou\";\n    std::string vowels_begin8 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end8 = \"AEIOUaeiou\";\n    std::string vowels_begin9\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin10 = \"aeiouAEIOU\";\n    std::string vowels_end10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin11 = \"aeiouAEIOU\";\n    std::string vowels_end11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end12 = \"AEIOUaeiou\";\n    std::string vowels_begin13 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end13 = \"AEIOUaeiou\";\n    std::string vowels_begin14\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin15 = \"aeiouAEIOU\";\n    std::string vowels_end15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin16 = \"aeiouAEIOU\";\n    std::string vowels_end16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end17 = \"AEIOUaeiou\";\n    std::string vowels_begin18 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end18 = \"AEIOUaeiou\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprufeqsv2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_back = \"AEIOUaeiou\";\n    std::string vowels_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back = \"AEIOUaeiou\";\n    std::string\
    \ vowels_back_back_reverse = \"AEIOUaeiou\";\n    std::string vowels_back_back_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_back_back_back_back = \"AEIOUaeiou\";\n    std::string\
    \ vowels_back_back_back_back_reverse = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_reverse =\
    \ \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back = \"AEIOUaeiou\"\
    ;\n    std::string vowels_back_back_back_back_back_back_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_back_back_back_back_back_back_back = \"AEIOUaeiou\"\
    ;\n    std::string vowels_back_back_back_back_back_back_back_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_back_back_back_back_back_back_back_back = \"AEIOUaeiou\"\
    ;\n    std::string vowels_back_back_back_back_back_back_back_back_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back_back_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back_back_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_back_back_back_back_back_back_back_back_back_back_reverse\
    \ = \"AEIOUaeiou\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc6up08nq.cpp:45:84: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_back_back_back_back_back_back_back_back_back_back_reverse\
    \ = \"AEIOUaeiou\n                                                           \
    \                         ^\n/tmp/tmpc6up08nq.cpp:45:5: error: missing terminating\
    \ \" character\n     std::string vowels_back_back_back_back_back_back_back_back_back_back_reverse\
    \ = \"AEIOUaeiou\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc6up08nq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_upper = vowels_reversed.toupper();\n    std::string\
    \ vowels_reversed_lower = vowels_reversed.tolower();\n    std::string vowels_reversed_upper_lower\
    \ = vowels_reversed_upper.tolower() + vowels_reversed_lower.tolower();\n    std::string\
    \ vowels_reversed_upper_lower_lower = vowels_reversed_upper_lower + vowels_reversed_lower.toupper();\n\
    \    std::string vowels_reversed_upper_lower_lower_lower = vowels_reversed_upper_lower_lower\
    \ + vowels_reversed_lower.toupper() + vowels_reversed_upper.tolower();\n    std::string\
    \ vowels_reversed_upper_lower_lower_lower_lower = vowels_reversed_upper_lower_lower_lower\
    \ + vowels_reversed_lower.toupper() + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper();\n\
    \    std::string vowels_reversed_upper_lower_lower_lower_lower_lower = vowels_reversed_upper_lower_lower_lower_lower\
    \ + vowels_reversed_lower.toupper() + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper()\
    \ + vowels_reversed_lower.tolower();\n    std::string vowels_reversed_upper_lower_lower_lower_lower_lower_lower\
    \ = vowels_reversed_upper_lower_lower_lower_lower_lower_lower + vowels_reversed_lower.toupper()\
    \ + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper() + vowels_reversed_lower.tolower()\
    \ + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper();\n    std::string\
    \ vowels_reversed_upper_lower_lower_lower_lower_lower_lower_lower_lower = vowels_reversed_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ + vowels_reversed_lower.toupper() + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper()\
    \ + vowels_reversed_lower.tolower() + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper()\
    \ + vowels_reversed_lower.tolower() + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper();\n\
    \    std::string vowels_reversed_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ = vowels_reversed_upper_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower_lower\
    \ + vowels_reversed_lower.toupper() + vowels_reversed_upper.tolower() + vowels_reversed_lower.toupper()\
    \ + vowels_reversed_lower.tolower(\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpt93t3qtx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int len = word.length();\n    int vowel_pos = 0;\n    int consonant_pos\
    \ = word.length() - 1;\n    int vowel_len = vowels.length();\n    int consonant_len\
    \ = consonants.length();\n    while (vowel_pos < vowel_len && consonant_pos >=\
    \ 0) {\n        if (vowels[vowel_pos] == word[vowel_pos]) {\n            vowel_pos++;\n\
    \        } else if (consonants[consonant_pos] == word[consonant_pos]) {\n    \
    \        consonant_pos--;\n        } else {\n            vowel_pos = 0;\n    \
    \        consonant_pos = word.length() - 1;\n        }\n    }\n    if (vowel_pos\
    \ == vowel_len) {\n        return \"\";\n    } else if (consonant_pos == 0) {\n\
    \        return vowels[vowel_pos];\n    } else {\n        return word[vowel_pos];\n\
    \    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjgyhky_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_begin\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin2 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end2 = \"AEIOUaeiou\";\n    std::string vowels_begin3 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string vowels_begin4\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin5 = \"aeiouAEIOU\";\n    std::string vowels_end5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin6 = \"aeiouAEIOU\";\n    std::string vowels_end6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end7 = \"AEIOUaeiou\";\n    std::string vowels_begin8 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end8 = \"AEIOUaeiou\";\n    std::string vowels_begin9\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin10 = \"aeiouAEIOU\";\n    std::string vowels_end10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin11 = \"aeiouAEIOU\";\n    std::string vowels_end11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end12 = \"AEIOUaeiou\";\n    std::string vowels_begin13 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end13 = \"AEIOUaeiou\";\n    std::string vowels_begin14\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin15 = \"aeiouAEIOU\";\n    std::string vowels_end15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin16 = \"aeiouAEIOU\";\n    std::string vowels_end16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end17 = \"AEIOUaeiou\";\n    std::string vowels_begin18 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end18 = \"AEIOUaeiou\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprufeqsv2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels_reverse.substr(0, vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0, vowels_reverse2.size()\
    \ - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0, vowels_reverse3.size()\
    \ - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0, vowels_reverse4.size()\
    \ - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0, vowels_reverse5.size()\
    \ - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0, vowels_reverse6.size()\
    \ - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0, vowels_reverse7.size()\
    \ - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0, vowels_reverse8.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0, vowels_reverse9.size()\
    \ - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0, vowels_reverse10.size()\
    \ - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0, vowels_reverse11.size()\
    \ - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0, vowels_reverse12.size()\
    \ - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0, vowels_reverse13.size()\
    \ - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0, vowels_reverse14.size()\
    \ - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0, vowels_reverse15.size()\
    \ - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0, vowels_reverse16.size()\
    \ - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0, vowels_reverse17.size()\
    \ - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0, vowels_reverse18.size()\
    \ - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0, vowels_reverse19.size()\
    \ - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0, vowels_reverse20.size()\
    \ - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0, vowels_reverse21.size()\
    \ - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0, vowels_reverse22.size()\
    \ - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0, vowels_reverse23.size()\
    \ - 1);\n    std::string vowels_reverse25 = vowels_reverse24.substr(0, vowels_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz9qi9q4s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.rbegin();\n    std::string vowels_reverse2\
    \ = vowels.rend();\n    std::string vowels_reverse3 = vowels.rbegin();\n    std::string\
    \ vowels_reverse4 = vowels.rend();\n    std::string vowels_reverse5 = vowels.rbegin();\n\
    \    std::string vowels_reverse6 = vowels.rend();\n    std::string vowels_reverse7\
    \ = vowels.rbegin();\n    std::string vowels_reverse8 = vowels.rend();\n    std::string\
    \ vowels_reverse9 = vowels.rbegin();\n    std::string vowels_reverse10 = vowels.rend();\n\
    \    std::string vowels_reverse11 = vowels.rbegin();\n    std::string vowels_reverse12\
    \ = vowels.rend();\n    std::string vowels_reverse13 = vowels.rbegin();\n    std::string\
    \ vowels_reverse14 = vowels.rend();\n    std::string vowels_reverse15 = vowels.rbegin();\n\
    \    std::string vowels_reverse16 = vowels.rend();\n    std::string vowels_reverse17\
    \ = vowels.rbegin();\n    std::string vowels_reverse18 = vowels.rend();\n    std::string\
    \ vowels_reverse19 = vowels.rbegin();\n    std::string vowels_reverse20 = vowels.rend();\n\
    \    std::string vowels_reverse21 = vowels.rbegin();\n    std::string vowels_reverse22\
    \ = vowels.rend();\n    std::string vowels_reverse23 = vowels.rbegin();\n    std::string\
    \ vowels_reverse24 = vowels.rend();\n    std::string vowels_reverse25 = vowels.rbegin();\n\
    \    std::string vowels_reverse26 = vowels.rend();\n    std::string vowels_reverse27\
    \ = vowels.rbegin();\n    std::string vowels_reverse28 = vowels.rend();\n    std::string\
    \ vowels_reverse29 = vowels.rbegin();\n    std::string vowels_reverse30 = vowels.rend();\n\
    \    std::string vowels_reverse31 = vowels.rbegin();\n    std::string vowels_reverse32\
    \ = vowels.rend();\n    std::string vowels_reverse33 = vowels.rbegin();\n    std::string\
    \ vowels_reverse34 = vowels.rend();\n    std::string vowels_reverse35 = vowels.rbegin();\n\
    \    std::string vowels_reverse36 = vowels.rend();\n    std::string vowels_reverse37\
    \ = vowels.rbegin();\n    std::string vowels_reverse38 = vowels.rend();\n    std::string\
    \ vowels_reverse39 = vowels.rbegin();\n    std::string vowels_reverse40 = vowels.rend();\n\
    \    std::string vowels_reverse41 = vowels.rbegin();\n\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8bk4h3tj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx_gl404_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.size();\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxpuvi_3z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string vowels_reverse3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string vowels_reverse8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string vowels_reverse13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string vowels_reverse18\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string vowels_reverse23\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string vowels_reverse28\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string vowels_reverse33\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2uswi1da.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_end = \"AEIOUaeiouy\";\n    std::string vowels_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end = \"AEIOUaeiouy\";\n   \
    \ std::string vowels_start_end_start = \"AEIOUaeiou\";\n    std::string vowels_start_end_start_end\
    \ = \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_start_end_start_end = \"AEIOUaeiouy\";\n \
    \   std::string vowels_start_end_start_end_start_end_start = \"AEIOUaeiou\";\n\
    \    std::string vowels_start_end_start_end_start_end_start_end = \"AEIOUaeiouy\"\
    ;\n    std::string vowels_start_end_start_end_start_end_start_end_start = \"AEIOUaeiou\"\
    ;\n    std::string vowels_start_end_start_end_start_end_start_end_start_end =\
    \ \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end\
    \ = \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end\
    \ = \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end\
    \ = \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end\
    \ = \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiouy\";\n    std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplwlcqtmp.cpp:40:122: warning: missing terminating \" character\
    \ [enabled by default]\n     std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\n                                                           \
    \                                                               ^\n/tmp/tmplwlcqtmp.cpp:40:5:\
    \ error: missing terminating \" character\n     std::string vowels_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = \"AEIOUaeiou\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplwlcqtmp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __r"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels.substr(0, vowels.size() - 2);\n    std::string\
    \ vowels_reverse3 = vowels.substr(0, vowels.size() - 3);\n    std::string vowels_reverse4\
    \ = vowels.substr(0, vowels.size() - 4);\n    std::string vowels_reverse5 = vowels.substr(0,\
    \ vowels.size() - 5);\n    std::string vowels_reverse6 = vowels.substr(0, vowels.size()\
    \ - 6);\n    std::string vowels_reverse7 = vowels.substr(0, vowels.size() - 7);\n\
    \    std::string vowels_reverse8 = vowels.substr(0, vowels.size() - 8);\n    std::string\
    \ vowels_reverse9 = vowels.substr(0, vowels.size() - 9);\n    std::string vowels_reverse10\
    \ = vowels.substr(0, vowels.size() - 10);\n    std::string vowels_reverse11 =\
    \ vowels.substr(0, vowels.size() - 11);\n    std::string vowels_reverse12 = vowels.substr(0,\
    \ vowels.size() - 12);\n    std::string vowels_reverse13 = vowels.substr(0, vowels.size()\
    \ - 13);\n    std::string vowels_reverse14 = vowels.substr(0, vowels.size() -\
    \ 14);\n    std::string vowels_reverse15 = vowels.substr(0, vowels.size() - 15);\n\
    \    std::string vowels_reverse16 = vowels.substr(0, vowels.size() - 16);\n  \
    \  std::string vowels_reverse17 = vowels.substr(0, vowels.size() - 17);\n    std::string\
    \ vowels_reverse18 = vowels.substr(0, vowels.size() - 18);\n    std::string vowels_reverse19\
    \ = vowels.substr(0, vowels.size() - 19);\n    std::string vowels_reverse20 =\
    \ vowels.substr(0, vowels.size() - 20);\n    std::string vowels_reverse21 = vowels.substr(0,\
    \ vowels.size() - 21);\n    std::string vowels_reverse22 = vowels.substr(0, vowels.size()\
    \ - 22);\n    std::string vowels_reverse23 = vowels.substr(0, vowels.size() -\
    \ 23);\n    std::string vowels_reverse24 = vowels.substr(0, vowels.size() - 24);\n\
    \    std::string vowels_reverse25 = vowels.substr(0, vowels.size() - 25);\n  \
    \  std::string vowels_reverse26 = vowels.substr(0, vowels.size() - 26);\n    std::string\
    \ vowels_reverse27 = vowels.substr(0, vowels.size() - 27);\n    std::string vowels_reverse28\
    \ = vowels.substr(0, vowels.size() - 28);\n    std::string vowels_reverse29 =\
    \ vowels.substr(0, vowels.size() - 29);\n    std::string vowels_reverse30 = vowels.substr(0,\
    \ vowels.size() - 30);\n    std::string vowels_reverse31 = vowels.substr(0, vowels.size()\
    \ - 31);\n    std::string vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg5k4u_n2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse_reverse = vowels_reverse.substr(0, vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse = vowels_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_re\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoff9wzzt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpydan6ruv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string vowels_reverse3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string vowels_reverse8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string vowels_reverse13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string vowels_reverse18\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string vowels_reverse23\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string vowels_reverse28\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string vowels_reverse33\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2uswi1da.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_re\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz0emciql.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_re\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz0emciql.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt2c3jn2i.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmpt2c3jn2i.cpp:39:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpt2c3jn2i.cpp: In function 'int main()':\n/tmp/tmpt2c3jn2i.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2c3jn2i.cpp:2:\n/tmp/tmpt2c3jn2i.cpp:42:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"aeiouAE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqrreg7.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp7fqrreg7.cpp:54:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqrreg7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse =\
    \ \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppsye8x0.cpp:39:98: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\n                                                           \
    \                                       ^\n/tmp/tmpppsye8x0.cpp:39:5: error: missing\
    \ terminating \" character\n     std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppsye8x0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c+"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_reversed = vowels_reversed.substr(0, vowels_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed = vowels_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed =\
    \ vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5rl__ruo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjd382z3f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int vowels_size = vowels.size();\n    int vowels_index = word.size() -\
    \ vowels_size;\n    int vowels_index_2 = word.size() - vowels_size - 1;\n    int\
    \ vowels_index_3 = word.size() - vowels_size - 2;\n    int vowels_index_4 = word.size()\
    \ - vowels_size - 3;\n    int vowels_index_5 = word.size() - vowels_size - 4;\n\
    \    int vowels_index_6 = word.size() - vowels_size - 5;\n    int vowels_index_7\
    \ = word.size() - vowels_size - 6;\n    int vowels_index_8 = word.size() - vowels_size\
    \ - 7;\n    int vowels_index_9 = word.size() - vowels_size - 8;\n    int vowels_index_10\
    \ = word.size() - vowels_size - 9;\n    int vowels_index_11 = word.size() - vowels_size\
    \ - 10;\n    int vowels_index_12 = word.size() - vowels_size - 11;\n    int vowels_index_13\
    \ = word.size() - vowels_size - 12;\n    int vowels_index_14 = word.size() - vowels_size\
    \ - 13;\n    int vowels_index_15 = word.size() - vowels_size - 14;\n    int vowels_index_16\
    \ = word.size() - vowels_size - 15;\n    int vowels_index_17 = word.size() - vowels_size\
    \ - 16;\n    int vowels_index_18 = word.size() - vowels_size - 17;\n    int vowels_index_19\
    \ = word.size() - vowels_size - 18;\n    int vowels_index_20 = word.size() - vowels_size\
    \ - 19;\n    int vowels_index_21 = word.size() - vowels_size - 20;\n    int vowels_index_22\
    \ = word.size() - vowels_size - 21;\n    int vowels_index_23 = word.size() - vowels_size\
    \ - 22;\n    int vowels_index_24 = word.size() - vowels_size - 23;\n    int vowels_index_25\
    \ = word.size() - vowels_size - 24;\n    int vowels_index_26 = word.size() - vowels_size\
    \ - 25;\n    int vowels_index_27 = word.size() - vowels_size - 26;\n    int vowels_index_28\
    \ = word.size() - vowels_size - 27;\n    int vowels_index_29 = word.size() - vowels_size\
    \ - 28;\n    int vowels_index_30 = word.size() - vowels_size - 29;\n    int vowels_index_31\
    \ = word.size() - vowels_size - 30;\n    int vowels_index_32 = word.size() - vowels_size\
    \ - 31;\n    int vowels_index_33 = word.size() - vowels_size - 32;\n    int vowels_index_34\
    \ = word.size() - vowels_size - 33;\n    int vowels_index_35 = word.size() - vowels_size\
    \ - 34;\n    int \n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpha62ln97.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_begin\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end2 = \"AEIOUaeiou\";\n    std::string vowels_begin3 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string vowels_begin4\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin5 = \"aeiouAEIOU\";\n    std::string vowels_end5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin6 = \"aeiouAEIOU\";\n    std::string vowels_end6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end7 = \"AEIOUaeiou\";\n    std::string vowels_begin8 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end8 = \"AEIOUaeiou\";\n    std::string vowels_begin9\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin10 = \"aeiouAEIOU\";\n    std::string vowels_end10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin11 = \"aeiouAEIOU\";\n    std::string vowels_end11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end12 = \"AEIOUaeiou\";\n    std::string vowels_begin13 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end13 = \"AEIOUaeiou\";\n    std::string vowels_begin14\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin15 = \"aeiouAEIOU\";\n    std::string vowels_end15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin16 = \"aeiouAEIOU\";\n    std::string vowels_end16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end17 = \"AEIOUaeiou\";\n    std::string vowels_begin18 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end18 = \"AEIOUaeiou\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpav1nnslw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    int m\
    \ = n;\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp22quhmrq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reversed = vowels.substr(0,\
    \ vowels.size() - 1);\n    std::string vowels_reversed_reversed = vowels_reversed.substr(0,\
    \ vowels_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed\
    \ = vowels_reversed_reversed.substr(0, vowels_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk7w3xpt1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dsodmzm.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp7dsodmzm.cpp:34:17: error: redeclaration of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:33:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:37:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:38:17: error: redeclaration\
    \ of 'std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\n\
    \     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm.cpp:36:17: error: 'std::string\
    \ vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back'\
    \ previously declared here\n     std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n                 ^\n/tmp/tmp7dsodmzm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = \"\
    AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string \n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl5cbstjg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    int vowel_counter\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n            vowel_counter++;\n\
    \    }\n    if (vowel_counter == 0)\n        return \"\";\n    int vowel_counter2\
    \ = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n    \
    \        vowel_counter2++;\n    }\n    if (vowel_counter2 == 0)\n        return\
    \ \"\";\n    int vowel_counter3 = 0;\n    for (int i = n - 1; i >= 0; i--) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u')\n            vowel_counter3++;\n    }\n    if (vowel_counter3\
    \ == 0)\n        return \"\";\n    int vowel_counter4 = 0;\n    for (int i = n\
    \ - 1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n            vowel_counter4++;\n\
    \    }\n    if (vowel_counter4 == 0)\n        return \"\";\n    int vowel_counter5\
    \ = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n    \
    \        vowel_counter5++;\n    }\n    if (vowel_counter5 == 0)\n        return\
    \ \"\";\n    int vowel_counter6 = 0;\n    for (int i = n - 1; i >= 0; i--) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u')\n            vowel_counter6++;\n    }\n    if (vowel_counter6\
    \ == 0)\n        return \"\";\n    int vowel_counter7 = 0;\n    for (int i = n\
    \ - 1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n            vowel_counter7++;\n\
    \    }\n    if (vowel_counter7 == 0)\n        return \"\";\n    int vowel_counter8\
    \ = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n    \
    \        vowel_counter8++;\n    }\n    if (vowel_counter8 == 0)\n        return\
    \ \"\";\n    int vowel_counter9 = 0;\n    for (int \n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9q2oiqhz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code goes here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxcgs9gjq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels.substr(0, vowels.size() - 2);\n    std::string\
    \ vowels_reverse3 = vowels.substr(0, vowels.size() - 3);\n    std::string vowels_reverse4\
    \ = vowels.substr(0, vowels.size() - 4);\n    std::string vowels_reverse5 = vowels.substr(0,\
    \ vowels.size() - 5);\n    std::string vowels_reverse6 = vowels.substr(0, vowels.size()\
    \ - 6);\n    std::string vowels_reverse7 = vowels.substr(0, vowels.size() - 7);\n\
    \    std::string vowels_reverse8 = vowels.substr(0, vowels.size() - 8);\n    std::string\
    \ vowels_reverse9 = vowels.substr(0, vowels.size() - 9);\n    std::string vowels_reverse10\
    \ = vowels.substr(0, vowels.size() - 10);\n    std::string vowels_reverse11 =\
    \ vowels.substr(0, vowels.size() - 11);\n    std::string vowels_reverse12 = vowels.substr(0,\
    \ vowels.size() - 12);\n    std::string vowels_reverse13 = vowels.substr(0, vowels.size()\
    \ - 13);\n    std::string vowels_reverse14 = vowels.substr(0, vowels.size() -\
    \ 14);\n    std::string vowels_reverse15 = vowels.substr(0, vowels.size() - 15);\n\
    \    std::string vowels_reverse16 = vowels.substr(0, vowels.size() - 16);\n  \
    \  std::string vowels_reverse17 = vowels.substr(0, vowels.size() - 17);\n    std::string\
    \ vowels_reverse18 = vowels.substr(0, vowels.size() - 18);\n    std::string vowels_reverse19\
    \ = vowels.substr(0, vowels.size() - 19);\n    std::string vowels_reverse20 =\
    \ vowels.substr(0, vowels.size() - 20);\n    std::string vowels_reverse21 = vowels.substr(0,\
    \ vowels.size() - 21);\n    std::string vowels_reverse22 = vowels.substr(0, vowels.size()\
    \ - 22);\n    std::string vowels_reverse23 = vowels.substr(0, vowels.size() -\
    \ 23);\n    std::string vowels_reverse24 = vowels.substr(0, vowels.size() - 24);\n\
    \    std::string vowels_reverse25 = vowels.substr(0, vowels.size() - 25);\n  \
    \  std::string vowels_reverse26 = vowels.substr(0, vowels.size() - 26);\n    std::string\
    \ vowels_reverse27 = vowels.substr(0, vowels.size() - 27);\n    std::string vowels_reverse28\
    \ = vowels.substr(0, vowels.size() - 28);\n    std::string vowels_reverse29 =\
    \ vowels.substr(0, vowels.size() - 29);\n    std::string vowels_reverse30 = vowels.substr(0,\
    \ vowels.size() - 30);\n    std::string vowels_reverse31 = vowels.substr(0, vowels.size()\
    \ - 31);\n    std::string vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg5k4u_n2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels.substr(0, vowels.size() - 1);\n  \
    \  std::string vowels_reversed_reversed = vowels_reversed.substr(0, vowels_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed = vowels_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed =\
    \ vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzqq7nn7k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_reverse = \"AEIOUaeiou\";\n\
    \    std::string vowels_reverse2 = \"AEIOUaeiou\";\n    std::string vowels_reverse3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string vowels_reverse13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string vowels_reverse18\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string vowels_reverse28\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string vowels_reverse33\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp69v8gsl7.cpp: In function 'std::string get_closest_vowel(std::string)':\n\
    /tmp/tmp69v8gsl7.cpp:56:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmp69v8gsl7.cpp: In function 'int main()':\n/tmp/tmp69v8gsl7.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = get_closest_vowel;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp69v8gsl7.cpp:2:\n/tmp/tmp69v8gsl7.cpp:59:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_rev = \"AEIOUaeiou\";\n   \
    \ std::string vowels_rev2 = \"\";\n    std::string vowels_rev3 = \"\";\n    std::string\
    \ vowels_rev4 = \"\";\n    std::string vowels_rev5 = \"\";\n    std::string vowels_rev6\
    \ = \"\";\n    std::string vowels_rev7 = \"\";\n    std::string vowels_rev8 =\
    \ \"\";\n    std::string vowels_rev9 = \"\";\n    std::string vowels_rev10 = \"\
    \";\n    std::string vowels_rev11 = \"\";\n    std::string vowels_rev12 = \"\"\
    ;\n    std::string vowels_rev13 = \"\";\n    std::string vowels_rev14 = \"\";\n\
    \    std::string vowels_rev15 = \"\";\n    std::string vowels_rev16 = \"\";\n\
    \    std::string vowels_rev17 = \"\";\n    std::string vowels_rev18 = \"\";\n\
    \    std::string vowels_rev19 = \"\";\n    std::string vowels_rev20 = \"\";\n\
    \    std::string vowels_rev21 = \"\";\n    std::string vowels_rev22 = \"\";\n\
    \    std::string vowels_rev23 = \"\";\n    std::string vowels_rev24 = \"\";\n\
    \    std::string vowels_rev25 = \"\";\n    std::string vowels_rev26 = \"\";\n\
    \    std::string vowels_rev27 = \"\";\n    std::string vowels_rev28 = \"\";\n\
    \    std::string vowels_rev29 = \"\";\n    std::string vowels_rev30 = \"\";\n\
    \    std::string vowels_rev31 = \"\";\n    std::string vowels_rev32 = \"\";\n\
    \    std::string vowels_rev33 = \"\";\n    std::string vowels_rev34 = \"\";\n\
    \    std::string vowels_rev35 = \"\";\n    std::string vowels_rev36 = \"\";\n\
    \    std::string vowels_rev37 = \"\";\n    std::string vowels_rev38 = \"\";\n\
    \    std::string vowels_rev39 = \"\";\n    std::string vowels_rev40 = \"\";\n\
    \    std::string vowels_rev41 = \"\";\n    std::string vowels_rev42 = \"\";\n\
    \    std::string vowels_rev43 = \"\";\n    std::string vowels_rev44 = \"\";\n\
    \    std::string vowels_rev45 = \"\";\n    std::string vowels_rev46 = \"\";\n\
    \    std::string vowels_rev47 = \"\";\n    std::string vowels_rev48 = \"\";\n\
    \    std::string vowels_rev49 = \"\";\n    std::string vowels_rev50 = \"\";\n\
    \    std::string vowels_rev51 = \"\";\n    std::string vowels_rev52 = \"\";\n\
    \    std::string vowels_rev53 = \"\";\n    std::string vowels_rev54 = \"\";\n\
    \    std::string vowels_rev55 = \"\";\n    std::string vowels_rev56 = \"\";\n\
    \    std::string vowels_rev57 = \"\";\n    std::string vowels_rev58 = \"\";\n\
    \    std::string vowels_rev59 = \"\";\n    std::string vowels_rev60 = \"\";\n\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpspotxkny.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Write your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_rev = \"AEIOUaeiou\";\n   \
    \ std::string vowels_rev2 = \"\";\n    std::string vowels_rev3 = \"\";\n    std::string\
    \ vowels_rev4 = \"\";\n    std::string vowels_rev5 = \"\";\n    std::string vowels_rev6\
    \ = \"\";\n    std::string vowels_rev7 = \"\";\n    std::string vowels_rev8 =\
    \ \"\";\n    std::string vowels_rev9 = \"\";\n    std::string vowels_rev10 = \"\
    \";\n    std::string vowels_rev11 = \"\";\n    std::string vowels_rev12 = \"\"\
    ;\n    std::string vowels_rev13 = \"\";\n    std::string vowels_rev14 = \"\";\n\
    \    std::string vowels_rev15 = \"\";\n    std::string vowels_rev16 = \"\";\n\
    \    std::string vowels_rev17 = \"\";\n    std::string vowels_rev18 = \"\";\n\
    \    std::string vowels_rev19 = \"\";\n    std::string vowels_rev20 = \"\";\n\
    \    std::string vowels_rev21 = \"\";\n    std::string vowels_rev22 = \"\";\n\
    \    std::string vowels_rev23 = \"\";\n    std::string vowels_rev24 = \"\";\n\
    \    std::string vowels_rev25 = \"\";\n    std::string vowels_rev26 = \"\";\n\
    \    std::string vowels_rev27 = \"\";\n    std::string vowels_rev28 = \"\";\n\
    \    std::string vowels_rev29 = \"\";\n    std::string vowels_rev30 = \"\";\n\
    \    std::string vowels_rev31 = \"\";\n    std::string vowels_rev32 = \"\";\n\
    \    std::string vowels_rev33 = \"\";\n    std::string vowels_rev34 = \"\";\n\
    \    std::string vowels_rev35 = \"\";\n    std::string vowels_rev36 = \"\";\n\
    \    std::string vowels_rev37 = \"\";\n    std::string vowels_rev38 = \"\";\n\
    \    std::string vowels_rev39 = \"\";\n    std::string vowels_rev40 = \"\";\n\
    \    std::string vowels_rev41 = \"\";\n    std::string vowels_rev42 = \"\";\n\
    \    std::string vowels_rev43 = \"\";\n    std::string vowels_rev44 = \"\";\n\
    \    std::string vowels_rev45 = \"\";\n    std::string vowels_rev46 = \"\";\n\
    \    std::string vowels_rev47 = \"\";\n    std::string vowels_rev48 = \"\";\n\
    \    std::string vowels_rev49 = \"\";\n    std::string vowels_rev50 = \"\";\n\
    \    std::string vowels_rev51 = \"\";\n    std::string vowels_rev52 = \"\";\n\
    \    std::string vowels_rev53 = \"\";\n    std::string vowels_rev54 = \"\";\n\
    \    std::string vowels_rev55 = \"\";\n    std::string vowels_rev56 = \"\";\n\
    \    std::string vowels_rev57 = \"\";\n    std::string vowels_rev58 = \"\";\n\
    \    std::string vowels_rev59 = \"\";\n    std::string vowels_rev60 = \"\";\n\
    \    \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6j6pz9sg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    std::string vowels_rev = \"AEIOUaeiou\";\n   \
    \ std::string vowels_rev1 = \"aeiouAEIOU\";\n    std::string vowels_rev2 = \"\"\
    ;\n    std::string vowels_rev3 = \"\";\n    std::string vowels_rev4 = \"\";\n\
    \    std::string vowels_rev5 = \"\";\n    std::string vowels_rev6 = \"\";\n  \
    \  std::string vowels_rev7 = \"\";\n    std::string vowels_rev8 = \"\";\n    std::string\
    \ vowels_rev9 = \"\";\n    std::string vowels_rev10 = \"\";\n    std::string vowels_rev11\
    \ = \"\";\n    std::string vowels_rev12 = \"\";\n    std::string vowels_rev13\
    \ = \"\";\n    std::string vowels_rev14 = \"\";\n    std::string vowels_rev15\
    \ = \"\";\n    std::string vowels_rev16 = \"\";\n    std::string vowels_rev17\
    \ = \"\";\n    std::string vowels_rev18 = \"\";\n    std::string vowels_rev19\
    \ = \"\";\n    std::string vowels_rev20 = \"\";\n    std::string vowels_rev21\
    \ = \"\";\n    std::string vowels_rev22 = \"\";\n    std::string vowels_rev23\
    \ = \"\";\n    std::string vowels_rev24 = \"\";\n    std::string vowels_rev25\
    \ = \"\";\n    std::string vowels_rev26 = \"\";\n    std::string vowels_rev27\
    \ = \"\";\n    std::string vowels_rev28 = \"\";\n    std::string vowels_rev29\
    \ = \"\";\n    std::string vowels_rev30 = \"\";\n    std::string vowels_rev31\
    \ = \"\";\n    std::string vowels_rev32 = \"\";\n    std::string vowels_rev33\
    \ = \"\";\n    std::string vowels_rev34 = \"\";\n    std::string vowels_rev35\
    \ = \"\";\n    std::string vowels_rev36 = \"\";\n    std::string vowels_rev37\
    \ = \"\";\n    std::string vowels_rev38 = \"\";\n    std::string vowels_rev39\
    \ = \"\";\n    std::string vowels_rev40 = \"\";\n    std::string vowels_rev41\
    \ = \"\";\n    std::string vowels_rev42 = \"\";\n    std::string vowels_rev43\
    \ = \"\";\n    std::string vowels_rev44 = \"\";\n    std::string vowels_rev45\
    \ = \"\";\n    std::string vowels_rev46 = \"\";\n    std::string vowels_rev47\
    \ = \"\";\n    std::string vowels_rev48 = \"\";\n    std::string vowels_rev49\
    \ = \"\";\n    std::string vowels_rev50 = \"\";\n    std::string vowels_rev51\
    \ = \"\";\n    std::string vowels_rev52 = \"\";\n    std::string vowels_rev53\
    \ = \"\";\n    std::string vowels_rev54 = \"\";\n    std::string vowels_rev55\
    \ = \"\";\n    std::string vowels_rev56 = \"\";\n    std::string vowels_rev57\
    \ = \"\";\n    std::string vowels_rev58 = \"\";\n    std::string vowel\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph__9ihln.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int n = word.size();\n    int vowel_count = 0;\n    int consonant_count\
    \ = 0;\n    int consonant_index = 0;\n    int vowel_index = 0;\n    int vowel_start\
    \ = 0;\n    int vowel_end = 0;\n    std::string vowel_found = \"\";\n    std::string\
    \ consonant_found = \"\";\n    for (int i = 0; i < n; i++) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\
    \ {\n            vowel_found = \"\";\n            vowel_start = i;\n         \
    \   vowel_end = i;\n            vowel_count++;\n        }\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == '\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuynv9jwo.cpp:77:96: warning: missing terminating ' character [enabled\
    \ by default]\n         if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == '\n                                        \
    \                                                        ^\n/tmp/tmpuynv9jwo.cpp:77:9:\
    \ error: missing terminating ' character\n         if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == '\n         ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuynv9jwo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algob"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reversed = vowels + vowels.substr(1, vowels.size());\n\
    \    std::string vowels_reversed_reversed = vowels_reversed + vowels_reversed.substr(1,\
    \ vowels_reversed.size());\n    std::string vowels_reversed_reversed_reversed\
    \ = vowels_reversed_reversed + vowels_reversed_reversed.substr(1, vowels_reversed_reversed.size());\n\
    \    std::string vowels_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed.substr(1, vowels_reversed_reversed_reversed.size());\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed.substr(1, vowels_reversed_reversed_reversed_reversed.size());\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed.substr(1,\
    \ vowels_reversed_reversed_reversed_reversed_reversed.size());\n    std::string\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed.substr(1, vowels_reversed_reversed_reversed_reversed_reversed_reversed.size());\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(1,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size());\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(1,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size());\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj10m1jyu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"\";\n    std::string vowels_reverse_back = \"\";\n    std::string vowels_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back = \"\";\n    std::string\
    \ vowels_reverse_back_reverse_back_reverse = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiknw_3o1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back = \"AEIOUaeiou\";\n \
    \   std::string vowels_reverse_back_reverse = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse_back_reverse_back = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back_reverse_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpydan6ruv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748787
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    int len = word.length();\n    int vowel_pos = -1;\n    int consonant_pos\
    \ = -1;\n    int consonant_len = word.length() - 1;\n    std::string vowel_str\
    \ = word;\n    for (int i = 0; i < len - 1; i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            vowel_pos = i;\n            break;\n  \
    \      }\n    }\n    for (int i = len - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            vowel_pos = i;\n            break;\n  \
    \      }\n    }\n    for (int i = 0; i < len; i++) {\n        if (word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n\
    \            consonant_pos = i;\n            break;\n        }\n    }\n    for\
    \ (int i = len - 1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            consonant_pos\
    \ = i;\n            break;\n        }\n    }\n    if (vowel_pos == -1 || consonant_pos\
    \ == -1) {\n        return \"\";\n    }\n    int vowel_len = vowel_pos - vowel_pos\
    \ + 1;\n    int consonant_len = consonant_pos - consonant_pos + 1;\n    if (vowel_len\
    \ > consonant_len) {\n        vowel_pos = consonant_pos + 1;\n    }\n    if (vowel_len\
    \ < consonant_len) {\n        vowel_pos = vowel_pos + 1;\n    }\n    std::string\
    \ vowel_str = word.substr(vowel_pos, vowel_len);\n    std::string consonant_str\
    \ = word.substr(consonant_pos, consonant_len);\n    if (vowel_str == consonant_str)\
    \ {\n        return vowel_str;\n    }\n    return \"\";\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx2_zxawe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    // Your code here\n    std::string\
    \ vowels = \"AEIOUaeiou\";\n    std::string vowels_end = \"AEIOUaeiou\";\n   \
    \ std::string vowels_start = \"AEIOUaeiou\";\n    std::string vowels_middle =\
    \ \"AEIOUaeiou\";\n    std::string vowels_middle2 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle3 = \"AEIOUaeiou\";\n    std::string vowels_middle4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle5 = \"AEIOUaeiou\";\n    std::string vowels_middle6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle8 = \"AEIOUaeiou\";\n    std::string vowels_middle9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle10 = \"AEIOUaeiou\";\n    std::string vowels_middle11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle12 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle13 = \"AEIOUaeiou\";\n    std::string vowels_middle14 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle15 = \"AEIOUaeiou\";\n    std::string vowels_middle16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle18 = \"AEIOUaeiou\";\n    std::string vowels_middle19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle20 = \"AEIOUaeiou\";\n    std::string vowels_middle21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle22 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle23 = \"AEIOUaeiou\";\n    std::string vowels_middle24 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle25 = \"AEIOUaeiou\";\n    std::string vowels_middle26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle28 = \"AEIOUaeiou\";\n    std::string vowels_middle29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_middle30 = \"AEIOUaeiou\";\n    std::string vowels_middle31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_middle32 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_middle33 = \"AEIOUaeiou\";\n    std::string vowels_middle34 = \"\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6c294k9u.cpp:55:35: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_middle34 = \"\n                       \
    \            ^\n/tmp/tmp6c294k9u.cpp:55:5: error: missing terminating \" character\n\
    \     std::string vowels_middle34 = \"\n     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6c294k9u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    int n = word.length();\n    int vowel_count\
    \ = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i]\
    \ == 'y') {\n            vowel_count++;\n        }\n    }\n    if (vowel_count\
    \ == 0) {\n        return \"\";\n    }\n    int vowel_count_right = word[n - 1]\
    \ - 'a';\n    int vowel_count_left = word[0] - 'a';\n    int min_distance = std::min(std::abs(vowel_count_right\
    \ - vowel_count_left), std::abs(vowel_count_left - vowel_count_right));\n    int\
    \ min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_left - vowel_count_right));\n\
    \    int min_distance = std::min(min_distance, std::abs(vowel_count_right - vowel_count_left));\n\
    \    int min_distance = std::\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmhwd2aqw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_begin\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin2 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_end2 = \"aeiouAEIOU\";\n    std::string vowels_begin3 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end3 = \"AEIOUaeiou\";\n    std::string vowels_begin4\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end4 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin5 = \"aeiouAEIOU\";\n    std::string vowels_end5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin6 = \"aeiouAEIOU\";\n    std::string vowels_end6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end7 = \"AEIOUaeiou\";\n    std::string vowels_begin8 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end8 = \"AEIOUaeiou\";\n    std::string vowels_begin9\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end9 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin10 = \"aeiouAEIOU\";\n    std::string vowels_end10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin11 = \"aeiouAEIOU\";\n    std::string vowels_end11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end12 = \"AEIOUaeiou\";\n    std::string vowels_begin13 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end13 = \"AEIOUaeiou\";\n    std::string vowels_begin14\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end14 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin15 = \"aeiouAEIOU\";\n    std::string vowels_end15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin16 = \"aeiouAEIOU\";\n    std::string vowels_end16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end17 = \"AEIOUaeiou\";\n    std::string vowels_begin18 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end18 = \"AEIOUaeiou\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpva2xhp16.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748788
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"AEIOUaeiou\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"AEIOUaeiou\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"AEIOUaeiou\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"AEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"AEIOUaeiou\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"AEIOUaeiou\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"AEIOUaeiou\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse36 = \"AEIOU\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp96bqudcg.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp96bqudcg.cpp:54:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\n/tmp/tmp96bqudcg.cpp:\
    \ In function 'std::string get_closest_vowel(std::string)':\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp96bqudcg.cpp:55:1:\
    \ error: expected ',' or ';' before '}' token\n/tmp/tmp96bqudcg.cpp: In function\
    \ 'int main()':\n/tmp/tmp96bqudcg.cpp:57:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = get_closest_vowel;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp96bqudcg.cpp:2:\n/tmp/tmp96bqudcg.cpp:58:32: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n                                ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse36 = \"aeiouAE\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqrreg7.cpp:54:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp7fqrreg7.cpp:54:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqrreg7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748786
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n\
    // (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"\
    quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string\
    \ get_closest_vowel(std::string word) {\n    std::string vowels = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels_reverse.substr(0, vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0, vowels_reverse2.size()\
    \ - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0, vowels_reverse3.size()\
    \ - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0, vowels_reverse4.size()\
    \ - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0, vowels_reverse5.size()\
    \ - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0, vowels_reverse6.size()\
    \ - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0, vowels_reverse7.size()\
    \ - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0, vowels_reverse8.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0, vowels_reverse9.size()\
    \ - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0, vowels_reverse10.size()\
    \ - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0, vowels_reverse11.size()\
    \ - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0, vowels_reverse12.size()\
    \ - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0, vowels_reverse13.size()\
    \ - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0, vowels_reverse14.size()\
    \ - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0, vowels_reverse15.size()\
    \ - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0, vowels_reverse16.size()\
    \ - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0, vowels_reverse17.size()\
    \ - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0, vowels_reverse18.size()\
    \ - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0, vowels_reverse19.size()\
    \ - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0, vowels_reverse20.size()\
    \ - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0, vowels_reverse21.size()\
    \ - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0, vowels_reverse22.size()\
    \ - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0, vowels_reverse23.size()\
    \ - 1);\n    std::string vowels_reverse25 = vowels_reverse24.substr(0, vowels_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz9qi9q4s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748786
