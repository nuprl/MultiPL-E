{
  "name": "HumanEval_93_encode",
  "language": "swift",
  "prompt": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else if c in consonants {\n            result += consonants2[consonants.Index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpb_srovvs.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:19:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n/tmp/tmpb_srovvs.swift:21:21: error: expected '{' after 'if' condition\n        } else if c in consonants {\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40 = \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp60kqc70b.swift:52:20: error: unterminated string literal\n    var vowels40 = \"\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40 = \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp60kqc70b.swift:52:20: error: unterminated string literal\n    var vowels40 = \"\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels_index = 0\n    var message_index = 0\n    var encoded_message = \"\"\n    for message_index < len(message) {\n        if message[message_index] in vowels {\n            encoded_message += message[message_index]\n            message_index += 2\n        } else {\n            encoded_message += message[message_index]\n            message_index += 1\n        }\n    }\n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmppsi4_jdm.swift:17:23: error: expected 'in' after for-each pattern\n    for message_index < len(message) {\n                      ^\n/tmp/tmppsi4_jdm.swift:17:23: error: unary operator cannot be separated from its operand\n    for message_index < len(message) {\n                      ^~\n                       \n/tmp/tmppsi4_jdm.swift:18:35: error: expected '{' after 'if' condition\n        if message[message_index] in vowels {\n                                  ^\n/tmp/tmppsi4_jdm.swift:17:23: error: '<' is not a prefix unary operator\n    for message_index < len(message) {\n                      ^\n/tmp/tmppsi4_jdm.swift:17:25: error: cannot find 'len' in scope\n    for message_index < len(message) {\n                        ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, c := range message {\n        if c == ' ' {\n            result += \" \"\n        } else if c == '.' {\n            result += \".\"\n        } else if c == ',' {\n            result += \",\"\n        } else if c == '!' {\n            result += \"!\"\n        } else if c == '?' {\n            result += \"?\"\n        } else if c == '\\'' {\n            result += \"'\"\n        } else if c == '\\\"' {\n            result += \"\\\"\"\n        } else if c == '\\n' {\n            result += \" \"\n        } else if c == '\\t' {\n            result += \" \"\n        } else if c == '\\r' {\n            result += \" \"\n        } else if c == '\\b' {\n            result += \" \"\n        } else if c == '\\f' {\n            result += \" \"\n        } else if c == '\\v' {\n            result += \" \"\n        } else if c == '\\a' {\n            result += \" \"\n        } else if c == '\\0' {\n            result += \" \"\n        } else if c == '\\x00' {\n            result += \" \"\n        } else if c == '\\x01' {\n            result += \" \"\n        } else if c == '\\x02' {\n            result += \" \"\n        } else if c == '\\x03' {\n            result += \" \"\n        } else if c == '\\x04' {\n            result += \" \"\n        } else if c == '\\x05' {\n            result += \" \"\n        } else if c == '\\x06' {\n            result += \" \"\n        } else if c == '\\x07' {\n            result += \" \"\n        } else if c == '\\x08' {\n            result += \" \"\n        } else if c == '\\x09' {\n            result += \" \"\n        } else if c == '\\x0a' {\n            result += \" \"\n        } else if c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpj8thms9u.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpj8thms9u.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpj8thms9u.swift:17:17: error: single-quoted string literal found, use '\"'\n        if c == ' ' {\n                ^~~\n                \" \"\n/tmp/tmpj8thms9u.swift:19:24: error: single-quoted string literal found, use '\"'\n        } else if c == '.' {\n                       ^~~\n                       \".\"\n/tmp/tmpj8thms9u.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ',' {\n                       ^~~\n                       \",\"\n/tmp/tmpj8thms9u.swift:23:24: error: single-quoted string literal found, use '\"'\n        } else if c == '!' {\n                       ^~~\n                       \"!\"\n/tmp/tmpj8thms9u.swift:25:24: error: single-quoted string literal found, use '\"'\n        } else if c == '?' {\n                       ^~~\n                       \"?\"\n/tmp/tmpj8thms9u.swift:27:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\'' {\n                       ^~~~\n                       \"'\"\n/tmp/tmpj8thms9u.swift:29:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\\"' {\n                       ^~~~\n                       \"\\\"\"\n/tmp/tmpj8thms9u.swift:31:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\n' {\n                       ^~~~\n                       \"\\n\"\n/tmp/tmpj8thms9u.swift:33:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\t' {\n                       ^~~~\n                       \"\\t\"\n/tmp/tmpj8thms9u.swift:35:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\r' {\n                       ^~~~\n                       \"\\r\"\n/tmp/tmpj8thms9u.swift:37:26: error: invalid escape sequence in literal\n        } else if c == '\\b' {\n                         ^\n/tmp/tmpj8thms9u.swift:37:24: error: singl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, c := range message {\n        if c >= 'A' && c <= 'Z' {\n            result += c\n        } else if c >= 'a' && c <= 'z' {\n            result += c.toUpperCase()\n        } else if c == ' ' {\n            result += c\n        } else if c == '.' {\n            result += c\n        } else if c == ',' {\n            result += c\n        } else if c == '!' {\n            result += c\n        } else if c == '?' {\n            result += c\n        } else if c == '\\'' {\n            result += c\n        } else if c == '\\n' {\n            result += c\n        } else if c == '\\t' {\n            result += c\n        } else if c == '\\r' {\n            result += c\n        } else if c == '\\v' {\n            result += c\n        } else if c == '\\f' {\n            result += c\n        } else if c == '\\b' {\n            result += c\n        } else if c == '\\a' {\n            result += c\n        } else if c == '\\0' {\n            result += c\n        } else if c == '\\x00' {\n            result += c\n        } else if c == '\\x01' {\n            result += c\n        } else if c == '\\x02' {\n            result += c\n        } else if c == '\\x03' {\n            result += c\n        } else if c == '\\x04' {\n            result += c\n        } else if c == '\\x05' {\n            result += c\n        } else if c == '\\x06' {\n            result += c\n        } else if c == '\\x07' {\n            result += c\n        } else if c == '\\x08' {\n            result += c\n        } else if c == '\\x09' {\n            result += c\n        } else if c == '\\x0a' {\n            result += c\n        } else if c == '\\x0b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp_m7h23vl.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmp_m7h23vl.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmp_m7h23vl.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c >= 'A' && c <= 'Z' {\n                ^~~\n                \"A\"\n/tmp/tmp_m7h23vl.swift:16:29: error: single-quoted string literal found, use '\"'\n        if c >= 'A' && c <= 'Z' {\n                            ^~~\n                            \"Z\"\n/tmp/tmp_m7h23vl.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c >= 'a' && c <= 'z' {\n                       ^~~\n                       \"a\"\n/tmp/tmp_m7h23vl.swift:18:36: error: single-quoted string literal found, use '\"'\n        } else if c >= 'a' && c <= 'z' {\n                                   ^~~\n                                   \"z\"\n/tmp/tmp_m7h23vl.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ' ' {\n                       ^~~\n                       \" \"\n/tmp/tmp_m7h23vl.swift:22:24: error: single-quoted string literal found, use '\"'\n        } else if c == '.' {\n                       ^~~\n                       \".\"\n/tmp/tmp_m7h23vl.swift:24:24: error: single-quoted string literal found, use '\"'\n        } else if c == ',' {\n                       ^~~\n                       \",\"\n/tmp/tmp_m7h23vl.swift:26:24: error: single-quoted string literal found, use '\"'\n        } else if c == '!' {\n                       ^~~\n                       \"!\"\n/tmp/tmp_m7h23vl.swift:28:24: error: single-quoted string literal found, use '\"'\n        } else if c == '?' {\n                       ^~~\n                       \"?\"\n/tmp/tmp_m7h23vl.swift:30:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\'' {\n                       ^~~~\n                       \"'\"\n/tmp/tmp_m7h23vl.swift:32:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\n'",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char == ' ' {\n            encoded += \" \"\n        } else if char == '.' {\n            encoded += \".\"\n        } else if char == ',' {\n            encoded += \",\"\n        } else if char == '!' {\n            encoded += \"!\"\n        } else if char == '?' {\n            encoded += \"?\"\n        } else if char == '\\'' {\n            encoded += \"'\"\n        } else if char == '\\\"' {\n            encoded += \"\\\"\"\n        } else if char == '\\n' {\n            encoded += \"\\n\"\n        } else if char == '\\t' {\n            encoded += \"\\t\"\n        } else if char == '\\r' {\n            encoded += \"\\r\"\n        } else if char == '\\b' {\n            encoded += \"\\b\"\n        } else if char == '\\f' {\n            encoded += \"\\f\"\n        } else if char == '\\v' {\n            encoded += \"\\v\"\n        } else if char == '\\a' {\n            encoded += \"\\a\"\n        } else if char == '\\0' {\n            encoded += \"\\0\"\n        } else if char == '\\x00' {\n            encoded += \"\\x00\"\n        } else if char == '\\x01' {\n            encoded += \"\\x01\"\n        } else if char == '\\x02' {\n            encoded += \"\\x02\"\n        } else if char == '\\x03' {\n            encoded += \"\\x03\"\n        } else if char == '\\x04' {\n            encoded += \"\\x04\"\n        } else if char == '\\x05' {\n            encoded += \"\\x05\"\n        } else if char == '\\x06' {\n            encoded += \"\\x06\"\n        } else if char == '\\x07' {\n            encoded += \"\\x07\"\n        } else if char == '\\\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp4p05s8nm.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmp4p05s8nm.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmp4p05s8nm.swift:17:20: error: single-quoted string literal found, use '\"'\n        if char == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmp4p05s8nm.swift:19:27: error: single-quoted string literal found, use '\"'\n        } else if char == '.' {\n                          ^~~\n                          \".\"\n/tmp/tmp4p05s8nm.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ',' {\n                          ^~~\n                          \",\"\n/tmp/tmp4p05s8nm.swift:23:27: error: single-quoted string literal found, use '\"'\n        } else if char == '!' {\n                          ^~~\n                          \"!\"\n/tmp/tmp4p05s8nm.swift:25:27: error: single-quoted string literal found, use '\"'\n        } else if char == '?' {\n                          ^~~\n                          \"?\"\n/tmp/tmp4p05s8nm.swift:27:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\'' {\n                          ^~~~\n                          \"'\"\n/tmp/tmp4p05s8nm.swift:29:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\\"' {\n                          ^~~~\n                          \"\\\"\"\n/tmp/tmp4p05s8nm.swift:31:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\n' {\n                          ^~~~\n                          \"\\n\"\n/tmp/tmp4p05s8nm.swift:33:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\t' {\n                          ^~~~\n                          \"\\t\"\n/tmp/tmp4p05s8nm.swift:35:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\r' {\n                          ^~~~\n                          \"\\r\"\n/tmp/tmp4p05s8nm.swift:37:29: error: invalid escape sequence in literal\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpilav42e3.swift:53:9: error: type annotation missing in pattern\n    var vowels40\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.Contains(string(letter)) {\n            result += consonants[vowels.Index(string(letter))] + consonants[vowels.Index(string(letter))]\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpnex1_4an.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpnex1_4an.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, c := range message {\n        if c >= 'a' && c <= 'z' {\n            result += string(c + (26 - c) % 26)\n        } else if c >= 'A' && c <= 'Z' {\n            result += string(c + (26 - c) % 26)\n        } else if c == ' ' {\n            result += string(c)\n        } else if c == '\\'' {\n            result += string(c)\n        } else if c == '-' {\n            result += string(c)\n        } else if c == '.' {\n            result += string(c)\n        } else if c == ',' {\n            result += string(c)\n        } else if c == '!' {\n            result += string(c)\n        } else if c == '?' {\n            result += string(c)\n        } else if c == ';' {\n            result += string(c)\n        } else if c == ':' {\n            result += string(c)\n        } else if c == '\\n' {\n            result += string(c)\n        } else if c == '\\r' {\n            result += string(c)\n        } else if c == '\\t' {\n            result += string(c)\n        } else if c == '\\v' {\n            result += string(c)\n        } else if c == '\\f' {\n            result += string(c)\n        } else if c == '\\b' {\n            result += string(c)\n        } else if c == '\\a' {\n            result += string(c)\n        } else if c == '\\0' {\n            result += string(c)\n        } else if c == '\\u00A0' {\n            result += string(c)\n        } else if c == '\\u00A1' {\n            result += string(c)\n        } else if c == '\\u00A2' {\n            result += string(c)\n        } else if c == '\\u00A3' {\n            result += string(c)\n        } else if c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpkej0cfbx.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpkej0cfbx.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpkej0cfbx.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c >= 'a' && c <= 'z' {\n                ^~~\n                \"a\"\n/tmp/tmpkej0cfbx.swift:16:29: error: single-quoted string literal found, use '\"'\n        if c >= 'a' && c <= 'z' {\n                            ^~~\n                            \"z\"\n/tmp/tmpkej0cfbx.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c >= 'A' && c <= 'Z' {\n                       ^~~\n                       \"A\"\n/tmp/tmpkej0cfbx.swift:18:36: error: single-quoted string literal found, use '\"'\n        } else if c >= 'A' && c <= 'Z' {\n                                   ^~~\n                                   \"Z\"\n/tmp/tmpkej0cfbx.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ' ' {\n                       ^~~\n                       \" \"\n/tmp/tmpkej0cfbx.swift:22:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\'' {\n                       ^~~~\n                       \"'\"\n/tmp/tmpkej0cfbx.swift:24:24: error: single-quoted string literal found, use '\"'\n        } else if c == '-' {\n                       ^~~\n                       \"-\"\n/tmp/tmpkej0cfbx.swift:26:24: error: single-quoted string literal found, use '\"'\n        } else if c == '.' {\n                       ^~~\n                       \".\"\n/tmp/tmpkej0cfbx.swift:28:24: error: single-quoted string literal found, use '\"'\n        } else if c == ',' {\n                       ^~~\n                       \",\"\n/tmp/tmpkej0cfbx.swift:30:24: error: single-quoted string literal found, use '\"'\n        } else if c == '!' {\n                       ^~~\n                       \"!\"\n/tmp/tmpkej0cfbx.swift:32:24: error: single-quoted string literal found, use '\"'\n        } else if c == '?' ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYX\"\n    \n    var vowels_count = 0\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n        }\n    }\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            if vowels_count == 1 {\n                result += message[i] + message[i]\n            } else if vowels_count == 2 {\n                result += message[i] + message[i+2]\n            } else if vowels_count == 3 {\n                result += message[i] + message[i+2] + message[i+3]\n            }\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5s4curyk.swift:20:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp5s4curyk.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp5s4curyk.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp5s4curyk.swift:21:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmp5s4curyk.swift:28:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp5s4curyk.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp5s4curyk.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp5s4curyk.swift:29:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += consonants[(vowels.index(c) + 2) % len(vowels)] + c\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpclshm3gz.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpclshm3gz.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpclshm3gz.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    \n    var encoded = \"\"\n    \n    for _, letter := range message {\n        if letter == \" \" {\n            encoded += \" \"\n            continue\n        }\n        \n        if letter == \".\" {\n            encoded += \".\"\n            continue\n        }\n        \n        if letter == \",\" {\n            encoded += \",\"\n            continue\n        }\n        \n        if letter == \"!\" {\n            encoded += \"!\"\n            continue\n        }\n        \n        if letter == \"?\" {\n            encoded += \"?\"\n            continue\n        }\n        \n        if letter == \"\\\"\" {\n            encoded += \"\\\"\"\n            continue\n        }\n        \n        if letter == \":\" {\n            encoded += \":\"\n            continue\n        }\n        \n        if letter == \";\" {\n            encoded += \";\"\n            continue\n        }\n        \n        if letter == \"-\" {\n            encoded += \"-\"\n            continue\n        }\n        \n        if letter == \"*\" {\n            encoded += \"*\"\n            continue\n        }\n        \n        if letter == \"(\" {\n            encoded += \"(\"\n            continue\n        }\n        \n        if letter == \")\" {\n            encoded += \")\"\n            continue\n        }\n        \n        if letter == \"{\" {\n            encoded += \"{\"\n            continue\n        }\n        \n        if letter == \"}\" {\n            encoded += \"}\"\n            continue\n        }\n        \n        if letter == \"=\" {\n            encoded += \"=\"\n            continue\n        }\n        \n        if letter == \"&\" {\n            encoded += \"&\"\n            continue\n        }\n        \n        if letter == \"|\" {\n            encoded += \"|\"\n            continue\n        }\n        \n        if letter == \"\\\\\" {\n            encoded += \"\\\\\"\n            continue\n        }\n        \n        if letter == \"/\" {\n            encoded += \"/\"\n            continue\n        }\n        \n        if letter == \";\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpu6v40cxv.swift:20:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpu6v40cxv.swift:20:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmpu6v40cxv.swift:116:25: error: expected '{' after 'if' condition\n        if letter == \";\"\n                        ^\n/tmp/tmpu6v40cxv.swift:136:84: error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                                                                   ^\n/tmp/tmpu6v40cxv.swift:12:40: note: to match this opening '{'\nfunc encode(message: String) -> String {\n                                       ^\n/tmp/tmpu6v40cxv.swift:120:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.indexOf(letter) != -1 {\n            result += vowels2[vowels.indexOf(letter) + 2]\n        } else if consonants.indexOf(letter) != -1 {\n            result += consonants2[consonants.indexOf(letter) + 2]\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpa58aj8ku.swift:18:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpa58aj8ku.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if vowels.Contains(message[i]) {\n            encoded += consonants[(vowels.Index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpmb1m_dq1.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpmb1m_dq1.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpmb1m_dq1.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(string(letter)) {\n            encoded += consonants[(vowels.Index(string(letter)) + 2) % 6] + string(letter)\n        } else {\n            encoded += string(letter)\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpp7p02w3m.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpp7p02w3m.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels2 = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if strings.Contains(vowels, string(letter)) {\n            result += string(vowels2[vowels.Index(string(letter))])\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpew1q5__a.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpew1q5__a.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40 = \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp60kqc70b.swift:52:20: error: unterminated string literal\n    var vowels40 = \"\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpg1ht0o0r.swift:15:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpg1ht0o0r.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpg1ht0o0r.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpg1ht0o0r.swift:16:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpn03nt268.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpn03nt268.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n        return String.fromCharCode(match.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpk0uia32t.swift:15:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n                                                       ^~~~~~~~\n/tmp/tmpk0uia32t.swift:15:65: error: cannot find 'match' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n                                                                ^~~~~\n/tmp/tmpk0uia32t.swift:16:36: error: cannot find 'match' in scope\n        return String.fromCharCode(match.charCodeAt(0) + 2)\n                                   ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels2 = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.Contains(string(letter)) {\n            result += string(vowels2[vowels.Index(string(letter)) + 2])\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpg2nfnptz.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpg2nfnptz.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels2 = \"AEIOU\"\n    var vowels3 = \"AEIOUAEIOU\"\n    var vowels4 = \"AEIOUAEIOUAEIOU\"\n    var vowels5 = \"AEIOUAEIOUAEIOUAEIOU\"\n    var vowels6 = \"AEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels7 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels8 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels9 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels10 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels11 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels12 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels13 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels14 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels15 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels16 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vow\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpiefnw_pl.swift:29:9: error: type annotation missing in pattern\n    var vow\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpia08uci7.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpia08uci7.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpia08uci7.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpia08uci7.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if vowels.Contains(message[i]) {\n            encoded += consonants[(vowels.Index(message[i]) + 2) % 6]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpl607bjy6.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpl607bjy6.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpl607bjy6.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels_index = 0\n    var vowels_count = 0\n    var message_count = 0\n    var encoded_message = \"\"\n    for message_count < len(message) {\n        if message[message_count] in vowels {\n            vowels_index = vowels.index(message[message_count])\n            vowels_count = vowels_count + 2\n            encoded_message = encoded_message + vowels[vowels_index + vowels_count]\n        } else {\n            encoded_message = encoded_message + message[message_count]\n        }\n        message_count = message_count + 1\n    }\n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5a3yoj6f.swift:18:23: error: expected 'in' after for-each pattern\n    for message_count < len(message) {\n                      ^\n/tmp/tmp5a3yoj6f.swift:18:23: error: unary operator cannot be separated from its operand\n    for message_count < len(message) {\n                      ^~\n                       \n/tmp/tmp5a3yoj6f.swift:19:35: error: expected '{' after 'if' condition\n        if message[message_count] in vowels {\n                                  ^\n/tmp/tmp5a3yoj6f.swift:18:23: error: '<' is not a prefix unary operator\n    for message_count < len(message) {\n                      ^\n/tmp/tmp5a3yoj6f.swift:18:25: error: cannot find 'len' in scope\n    for message_count < len(message) {\n                        ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if c in vowels {\n            encoded += consonants[(vowels.index(c) + 2) % len(vowels)]\n        } else {\n            encoded += c\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp4r92b39e.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmp4r92b39e.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmp4r92b39e.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpz51dimqt.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                       ^~~~~~~~\n/tmp/tmpz51dimqt.swift:14:65: error: cannot find 'c' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                                ^\n/tmp/tmpz51dimqt.swift:15:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpn03nt268.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpn03nt268.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.Index(letter) + 2]\n        } else {\n            encoded += vowels[vowels.Index(letter) + 2]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpsh45ngol.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpsh45ngol.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i + 2]\n        } else if message[i] in vowels2 {\n            result += message[i] + message[i + 1]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdu8nmj_k.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdu8nmj_k.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdu8nmj_k.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdu8nmj_k.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpdu8nmj_k.swift:19:30: error: expected '{' after 'if' condition\n        } else if message[i] in vowels2 {\n                             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40 = \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp60kqc70b.swift:52:20: error: unterminated string literal\n    var vowels40 = \"\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUYAEIOU\"\n    var vowels4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpy2bu1k7z.swift:28:20: error: unterminated string literal\n    var vowels16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYAEIOU\"\n    var vowels_4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels_5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels_6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5px_r3il.swift:28:21: error: unterminated string literal\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for _, c := range message {\n        if c in vowels {\n            encoded += consonants[(vowels.index(c) + 2) % len(vowels)] + c\n        } else {\n            encoded += c\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprwhy58kh.swift:19:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmprwhy58kh.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmprwhy58kh.swift:20:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpz51dimqt.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                       ^~~~~~~~\n/tmp/tmpz51dimqt.swift:14:65: error: cannot find 'c' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                                ^\n/tmp/tmpz51dimqt.swift:15:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels3 = \"AEIOU\"\n    var consonants3 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels4 = \"AEIOU\"\n    var consonants4 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels5 = \"AEIOU\"\n    var consonants5 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels6 = \"AEIOU\"\n    var consonants6 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels7 = \"AEIOU\"\n    var consonants7 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels8 = \"AEIOU\"\n    var consonants8 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels9 = \"AEIOU\"\n    var consonants9 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels10 = \"AEIOU\"\n    var consonants10 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels11 = \"AEIOU\"\n    var consonants11 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels12 = \"AEIOU\"\n    var consonants12 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels13 = \"AEIOU\"\n    var consonants13 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels14 = \"AEIOU\"\n    var consonants14 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels15 = \"AEIOU\"\n    var consonants15 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprmsz288b.swift:43:9: error: type annotation missing in pattern\n    var vowels\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmphn723rqu/tmphn723rqu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f76c03c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f768fab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f768fa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f768f97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphn723rqu                        0x0000560bb1802307 <unavailable> + 4871\n5    libc.so.6                          0x00002b3f76def460 __libc_start_main + 245\n6    tmphn723rqu                        0x0000560bb1801f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.indexOf(letter) != -1 {\n            result += message[vowels.indexOf(letter) + 2]\n        } else {\n            result += message[vowels.indexOf(letter) + 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp6wqqb823.swift:15:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp6wqqb823.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"aeiouAEIOU\"\n    var vowels_count = 0\n    var vowels_index = 0\n    var vowels_index_2 = 0\n    var encoded_message = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n            vowels_index = i\n            vowels_index_2 = vowels_index + 2\n        }\n    }\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded_message += message[vowels_index_2]\n        } else {\n            encoded_message += message[i]\n        }\n    }\n    \n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp14_w4ncq.swift:20:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp14_w4ncq.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp14_w4ncq.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp14_w4ncq.swift:21:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmp14_w4ncq.swift:28:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp14_w4ncq.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp14_w4ncq.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp14_w4ncq.swift:29:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40 = \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp60kqc70b.swift:52:20: error: unterminated string literal\n    var vowels40 = \"\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else if c in consonants {\n            result += consonants2[consonants.Index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp3ps2hsih.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmp3ps2hsih.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmp3ps2hsih.swift:19:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n/tmp/tmp3ps2hsih.swift:21:21: error: expected '{' after 'if' condition\n        } else if c in consonants {\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, c := range message {\n        if c == ' ' {\n            result += \" \"\n        } else if c == '.' {\n            result += \".\"\n        } else if c == ',' {\n            result += \",\"\n        } else if c == '!' {\n            result += \"!\"\n        } else if c == '?' {\n            result += \"?\"\n        } else if c == '\\'' {\n            result += \"\\\"\"\n        } else if c == '\\\"' {\n            result += \"\\\"\"\n        } else if c == '\\n' {\n            result += \" \"\n        } else if c == '\\t' {\n            result += \" \"\n        } else if c == '\\r' {\n            result += \" \"\n        } else if c == '\\b' {\n            result += \" \"\n        } else if c == '\\f' {\n            result += \" \"\n        } else if c == '\\v' {\n            result += \" \"\n        } else if c == '\\a' {\n            result += \" \"\n        } else if c == '\\e' {\n            result += \" \"\n        } else if c == '\\0' {\n            result += \" \"\n        } else if c == '\\x00' {\n            result += \" \"\n        } else if c == '\\x01' {\n            result += \" \"\n        } else if c == '\\x02' {\n            result += \" \"\n        } else if c == '\\x03' {\n            result += \" \"\n        } else if c == '\\x04' {\n            result += \" \"\n        } else if c == '\\x05' {\n            result += \" \"\n        } else if c == '\\x06' {\n            result += \" \"\n        } else if c == '\\x07' {\n            result += \" \"\n        } else if c == '\\x08' {\n            result += \" \"\n        } else if c == '\\x09' {\n            result += \" \"\n        } else if c ==\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpad3xb36g.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpad3xb36g.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpad3xb36g.swift:17:17: error: single-quoted string literal found, use '\"'\n        if c == ' ' {\n                ^~~\n                \" \"\n/tmp/tmpad3xb36g.swift:19:24: error: single-quoted string literal found, use '\"'\n        } else if c == '.' {\n                       ^~~\n                       \".\"\n/tmp/tmpad3xb36g.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ',' {\n                       ^~~\n                       \",\"\n/tmp/tmpad3xb36g.swift:23:24: error: single-quoted string literal found, use '\"'\n        } else if c == '!' {\n                       ^~~\n                       \"!\"\n/tmp/tmpad3xb36g.swift:25:24: error: single-quoted string literal found, use '\"'\n        } else if c == '?' {\n                       ^~~\n                       \"?\"\n/tmp/tmpad3xb36g.swift:27:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\'' {\n                       ^~~~\n                       \"'\"\n/tmp/tmpad3xb36g.swift:29:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\\"' {\n                       ^~~~\n                       \"\\\"\"\n/tmp/tmpad3xb36g.swift:31:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\n' {\n                       ^~~~\n                       \"\\n\"\n/tmp/tmpad3xb36g.swift:33:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\t' {\n                       ^~~~\n                       \"\\t\"\n/tmp/tmpad3xb36g.swift:35:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\r' {\n                       ^~~~\n                       \"\\r\"\n/tmp/tmpad3xb36g.swift:37:26: error: invalid escape sequence in literal\n        } else if c == '\\b' {\n                         ^\n/tmp/tmpad3xb36g.swift:37:24: error: singl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.Index(letter) + 2]\n        } else {\n            encoded += letter\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpt78_96vp.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpt78_96vp.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += vowels2[vowels.Index(message[i]) + 2]\n        } else if message[i] in consonants {\n            result += consonants2[consonants.Index(message[i]) + 2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpzv4ea84w.swift:18:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpzv4ea84w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpzv4ea84w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpzv4ea84w.swift:19:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpzv4ea84w.swift:21:30: error: expected '{' after 'if' condition\n        } else if message[i] in consonants {\n                             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if c in vowels {\n            encoded += consonants[(vowels.index(c) + 2) % len(vowels)] + c\n        } else {\n            encoded += c\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpvkeh_ryt.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpvkeh_ryt.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpvkeh_ryt.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += consonants[vowels.index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpycomjueh.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpycomjueh.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpycomjueh.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(string(letter)) {\n            encoded += consonants[vowels.Index(string(letter)) + 2]\n        } else {\n            encoded += consonants[vowels.Index(string(letter))]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp9sqe7_u6.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp9sqe7_u6.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13}\n    \n    var encoded_message = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded_message += message[i] + message[vowels_index[message[i] - 'A']]\n        } else {\n            encoded_message += message[i]\n        }\n    }\n    \n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmphiz6ct3v.swift:15:26: error: consecutive statements on a line must be separated by ';'\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13}\n                         ^\n                         ;\n/tmp/tmphiz6ct3v.swift:15:31: error: consecutive statements on a line must be separated by ';'\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13}\n                              ^\n                              ;\n/tmp/tmphiz6ct3v.swift:15:31: error: expected expression\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13}\n                              ^\n/tmp/tmphiz6ct3v.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmphiz6ct3v.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmphiz6ct3v.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmphiz6ct3v.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmphiz6ct3v.swift:21:79: error: single-quoted string literal found, use '\"'\n            encoded_message += message[i] + message[vowels_index[message[i] - 'A']]\n                                                                              ^~~\n                                                                              \"A\"\n/tmp/tmphiz6ct3v.swift:15:24: error: empty collection literal requires an explicit type\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13}\n                       ^~\n/tmp/tmphiz6ct3v.swift:15:26: error: cannot find 'int' in scope\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13}\n                         ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char in vowels {\n            encoded += consonants[vowels.Index(char) + 2]\n        } else {\n            encoded += consonants[vowels.Index(char)]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp8yn3pd_e.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmp8yn3pd_e.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmp8yn3pd_e.swift:17:17: error: expected '{' after 'if' condition\n        if char in vowels {\n                ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpn03nt268.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpn03nt268.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUYAEIOU\"\n    var vowels4 = \"AEIOUYAEIOUAEIOU\"\n    \n    var vowels_count = 0\n    var vowels_count2 = 0\n    var vowels_count3 = 0\n    var vowels_count4 = 0\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n        }\n        if message[i] in vowels2 {\n            vowels_count2++\n        }\n        if message[i] in vowels3 {\n            vowels_count3++\n        }\n        if message[i] in vowels4 {\n            vowels_count4++\n        }\n    }\n    \n    var encoded_message = \"\"\n    for i := 0; i < len(message); i++ {\n        if vowels_count == 0 {\n            encoded_message += message[i]\n        } else if vowels_count == 1 {\n            if message[i] in vowels {\n                encoded_message += message[i]\n            } else {\n                encoded_message += message[i] + message[i]\n            }\n        } else if vowels_count == 2 {\n            if message[i] in vowels2 {\n                encoded_message += message[i]\n            } else {\n                encoded_message += message[i] + message[i]\n            }\n        } else if vowels_count == 3 {\n            if message[i] in vowels3 {\n                encoded_message += message[i]\n            } else {\n                encoded_message += message[i] + message[i]\n            }\n        } else if vowels_count == 4 {\n            if message[i] in vowels4 {\n                encoded_message += message[i]\n            } else {\n                encoded_message += message[i] + message[i]\n            }\n        }\n    }\n    \n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpej1mgtle.swift:24:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpej1mgtle.swift:24:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpej1mgtle.swift:24:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpej1mgtle.swift:25:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpej1mgtle.swift:28:23: error: expected '{' after 'if' condition\n        if message[i] in vowels2 {\n                      ^\n/tmp/tmpej1mgtle.swift:31:23: error: expected '{' after 'if' condition\n        if message[i] in vowels3 {\n                      ^\n/tmp/tmpej1mgtle.swift:34:23: error: expected '{' after 'if' condition\n        if message[i] in vowels4 {\n                      ^\n/tmp/tmpej1mgtle.swift:40:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpej1mgtle.swift:40:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpej1mgtle.swift:40:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpej1mgtle.swift:44:27: error: expected '{' after 'if' condition\n            if message[i] in vowels {\n                          ^\n/tmp/tmpej1mgtle.swift:50:27: error: expected '{' after 'if' condition\n            if message[i] in vowels2 {\n                          ^\n/tmp/tmpej1mgtle.swift:56:27: error: expected '{' after 'if' condition\n            if message[i] in vowels3 {\n                          ^\n/tmp/tmpej1mgtle.swift:62:27: error: expected '{' after 'if' condition\n            if message[i] in vowels4 {\n                          ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmphn723rqu/tmphn723rqu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f76c03c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f768fab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f768fa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f768f97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphn723rqu                        0x0000560bb1802307 <unavailable> + 4871\n5    libc.so.6                          0x00002b3f76def460 __libc_start_main + 245\n6    tmphn723rqu                        0x0000560bb1801f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdcwe7l2g.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_index = 0\n    var vowels_count = 0\n    var vowels_index_2 = 0\n    var vowels_count_2 = 0\n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_index = i\n            vowels_count = 1\n        } else {\n            vowels_count = 0\n        }\n        if message[i] in vowels {\n            vowels_index_2 = i\n            vowels_count_2 = 1\n        } else {\n            vowels_count_2 = 0\n        }\n        if vowels_count == 1 && vowels_count_2 == 1 {\n            result += message[i] + message[vowels_index_2]\n        } else if vowels_count == 1 && vowels_count_2 == 0 {\n            result += message[i] + message[vowels_index]\n        } else if vowels_count == 0 && vowels_count_2 == 1 {\n            result += message[i] + message[vowels_index_2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpoyvmmp27.swift:21:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpoyvmmp27.swift:21:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpoyvmmp27.swift:21:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpoyvmmp27.swift:22:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpoyvmmp27.swift:28:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    }).replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpqs6zc6vw.swift:15:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                       ^~~~~~~~\n/tmp/tmpqs6zc6vw.swift:15:65: error: cannot find 'c' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                                ^\n/tmp/tmpqs6zc6vw.swift:16:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n/tmp/tmpqs6zc6vw.swift:17:30: error: cannot find 'function' in scope\n    }).replaceAll(\"[aeiou]\", function(c) {\n                             ^~~~~~~~\n/tmp/tmpqs6zc6vw.swift:17:39: error: cannot find 'c' in scope\n    }).replaceAll(\"[aeiou]\", function(c) {\n                                      ^\n/tmp/tmpqs6zc6vw.swift:18:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.Contains(string(letter)) {\n            result += string(letter) + string(letter[2:])\n        } else {\n            result += string(letter) + string(letter[1:])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp22uoagil.swift:15:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp22uoagil.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmp22uoagil.swift:17:55: error: expected ',' separator\n            result += string(letter) + string(letter[2:])\n                                                      ^\n                                                      ,\n/tmp/tmp22uoagil.swift:17:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[2:])\n                                                      ^\n/tmp/tmp22uoagil.swift:19:55: error: expected ',' separator\n            result += string(letter) + string(letter[1:])\n                                                      ^\n                                                      ,\n/tmp/tmp22uoagil.swift:19:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[1:])\n                                                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmphn723rqu/tmphn723rqu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f76c03c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f768fab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f768fa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f768f97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphn723rqu                        0x0000560bb1802307 <unavailable> + 4871\n5    libc.so.6                          0x00002b3f76def460 __libc_start_main + 245\n6    tmphn723rqu                        0x0000560bb1801f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYAEIOU\"\n    var vowels_4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels_5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels_6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5px_r3il.swift:28:21: error: unterminated string literal\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // your code here\n    return message.toUpperCase()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdm177rid.swift:15:20: error: value of type 'String' has no member 'toUpperCase'\n    return message.toUpperCase()\n           ~~~~~~~ ^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if c in vowels {\n            encoded += consonants[(vowels.index(c) + 2) % len(vowels)] + c\n        } else {\n            encoded += c\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpvkeh_ryt.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpvkeh_ryt.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpvkeh_ryt.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, c := range message {\n        if c == ' ' {\n            result += \" \"\n        } else if c == '.' {\n            result += \".\"\n        } else if c == ',' {\n            result += \",\"\n        } else if c == '!' {\n            result += \"!\"\n        } else if c == '?' {\n            result += \"?\"\n        } else if c == '\\'' {\n            result += \"\\\"\"\n        } else if c == '\\\"' {\n            result += \"\\\"\"\n        } else if c == '\\n' {\n            result += \" \"\n        } else if c == '\\t' {\n            result += \" \"\n        } else if c == '\\r' {\n            result += \" \"\n        } else if c == '\\v' {\n            result += \" \"\n        } else if c == '\\f' {\n            result += \" \"\n        } else if c == '\\b' {\n            result += \" \"\n        } else if c == '\\a' {\n            result += \" \"\n        } else if c == '\\e' {\n            result += \" \"\n        } else if c == '\\0' {\n            result += \" \"\n        } else if c == '\\x0' {\n            result += \" \"\n        } else if c == '\\x1' {\n            result += \" \"\n        } else if c == '\\x2' {\n            result += \" \"\n        } else if c == '\\x3' {\n            result += \" \"\n        } else if c == '\\x4' {\n            result += \" \"\n        } else if c == '\\x5' {\n            result += \" \"\n        } else if c == '\\x6' {\n            result += \" \"\n        } else if c == '\\x7' {\n            result += \" \"\n        } else if c == '\\x8' {\n            result += \" \"\n        } else if c == '\\x9' {\n            result += \" \"\n        } else if c == '\\xA' {\n            result += \" \"\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5fqvajxi.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmp5fqvajxi.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmp5fqvajxi.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c == ' ' {\n                ^~~\n                \" \"\n/tmp/tmp5fqvajxi.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c == '.' {\n                       ^~~\n                       \".\"\n/tmp/tmp5fqvajxi.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ',' {\n                       ^~~\n                       \",\"\n/tmp/tmp5fqvajxi.swift:22:24: error: single-quoted string literal found, use '\"'\n        } else if c == '!' {\n                       ^~~\n                       \"!\"\n/tmp/tmp5fqvajxi.swift:24:24: error: single-quoted string literal found, use '\"'\n        } else if c == '?' {\n                       ^~~\n                       \"?\"\n/tmp/tmp5fqvajxi.swift:26:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\'' {\n                       ^~~~\n                       \"'\"\n/tmp/tmp5fqvajxi.swift:28:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\\"' {\n                       ^~~~\n                       \"\\\"\"\n/tmp/tmp5fqvajxi.swift:30:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\n' {\n                       ^~~~\n                       \"\\n\"\n/tmp/tmp5fqvajxi.swift:32:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\t' {\n                       ^~~~\n                       \"\\t\"\n/tmp/tmp5fqvajxi.swift:34:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\r' {\n                       ^~~~\n                       \"\\r\"\n/tmp/tmp5fqvajxi.swift:36:26: error: invalid escape sequence in literal\n        } else if c == '\\v' {\n                         ^\n/tmp/tmp5fqvajxi.swift:36:24: error: singl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdcwe7l2g.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdcwe7l2g.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i + 2]\n        } else if message[i] in vowels2 {\n            result += message[i] + message[i + 1]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdu8nmj_k.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdu8nmj_k.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdu8nmj_k.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdu8nmj_k.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpdu8nmj_k.swift:19:30: error: expected '{' after 'if' condition\n        } else if message[i] in vowels2 {\n                             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.indexOf(letter) > -1 {\n            result += vowels2[vowels.indexOf(letter) + 2]\n        } else if consonants.indexOf(letter) > -1 {\n            result += consonants2[consonants.indexOf(letter) + 2]\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp1i1je2ea.swift:18:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp1i1je2ea.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char == ' ' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\n' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\t' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\r' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\v' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\f' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\b' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\a' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\'' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\\"' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\\\' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\0' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\u0000' {\n            encoded += \" \"\n            continue\n        }\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpk9ypbzpi.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmpk9ypbzpi.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmpk9ypbzpi.swift:17:20: error: single-quoted string literal found, use '\"'\n        if char == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmpk9ypbzpi.swift:21:20: error: single-quoted string literal found, use '\"'\n        if char == '\\n' {\n                   ^~~~\n                   \"\\n\"\n/tmp/tmpk9ypbzpi.swift:25:20: error: single-quoted string literal found, use '\"'\n        if char == '\\t' {\n                   ^~~~\n                   \"\\t\"\n/tmp/tmpk9ypbzpi.swift:29:20: error: single-quoted string literal found, use '\"'\n        if char == '\\r' {\n                   ^~~~\n                   \"\\r\"\n/tmp/tmpk9ypbzpi.swift:33:22: error: invalid escape sequence in literal\n        if char == '\\v' {\n                     ^\n/tmp/tmpk9ypbzpi.swift:33:20: error: single-quoted string literal found, use '\"'\n        if char == '\\v' {\n                   ^~~~\n                   \"\\v\"\n/tmp/tmpk9ypbzpi.swift:37:22: error: invalid escape sequence in literal\n        if char == '\\f' {\n                     ^\n/tmp/tmpk9ypbzpi.swift:37:20: error: single-quoted string literal found, use '\"'\n        if char == '\\f' {\n                   ^~~~\n                   \"\\f\"\n/tmp/tmpk9ypbzpi.swift:41:22: error: invalid escape sequence in literal\n        if char == '\\b' {\n                     ^\n/tmp/tmpk9ypbzpi.swift:41:20: error: single-quoted string literal found, use '\"'\n        if char == '\\b' {\n                   ^~~~\n                   \"\\b\"\n/tmp/tmpk9ypbzpi.swift:45:22: error: invalid escape sequence in literal\n        if char == '\\a' {\n                     ^\n/tmp/tmpk9ypbzpi.swift:45:20: error: single-quoted string literal found, use '\"'\n        if char == '\\a' {\n                   ^~~~\n                   \"\\a\"\n/tmp/tmpk9ypbzpi.swift:49:20: error: single-quoted string literal found, use ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels3 = \"AEIOU\"\n    var consonants3 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels4 = \"AEIOU\"\n    var consonants4 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels5 = \"AEIOU\"\n    var consonants5 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels6 = \"AEIOU\"\n    var consonants6 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels7 = \"AEIOU\"\n    var consonants7 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels8 = \"AEIOU\"\n    var consonants8 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels9 = \"AEIOU\"\n    var consonants9 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels10 = \"AEIOU\"\n    var consonants10 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels11 = \"AEIOU\"\n    var consonants11 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels12 = \"AEIOU\"\n    var consonants12 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels13 = \"AEIOU\"\n    var consonants13 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels14 = \"AEIOU\"\n    var consonants14 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels15 = \"AEIOU\"\n    var consonants15 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprmsz288b.swift:43:9: error: type annotation missing in pattern\n    var vowels\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if letter == ' ' {\n            result += \" \"\n        } else if strings.Contains(vowels, string(letter)) {\n            result += vowels2[vowels.Index(string(letter)) + 2]\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp7rqkq2a6.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp7rqkq2a6.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmp7rqkq2a6.swift:17:22: error: single-quoted string literal found, use '\"'\n        if letter == ' ' {\n                     ^~~\n                     \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else {\n            result += vowels[vowels.Index(c)]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprkxyj5nq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmprkxyj5nq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmprkxyj5nq.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for _, char := range message {\n        if char in vowels {\n            encoded += consonants[vowels.Index(char) + 2]\n        } else {\n            encoded += consonants[vowels.Index(char)]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpylpa2sro.swift:19:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmpylpa2sro.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmpylpa2sro.swift:20:17: error: expected '{' after 'if' condition\n        if char in vowels {\n                ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.Index(letter) + 2]\n        } else {\n            encoded += consonants[vowels.Index(letter)]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdxuw9vjp.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpdxuw9vjp.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if vowels.indexOf(c) != -1 {\n            result += vowels2[vowels.indexOf(c) + 2]\n        } else if consonants.indexOf(c) != -1 {\n            result += consonants2[consonants.indexOf(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpxiq_hsto.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpxiq_hsto.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, c := range message {\n        if c == ' ' {\n            result += \" \"\n        } else if c == '\\n' {\n            result += \" \"\n        } else if c == '\\t' {\n            result += \" \"\n        } else if c == '\\r' {\n            result += \" \"\n        } else if c == '\\v' {\n            result += \" \"\n        } else if c == '\\f' {\n            result += \" \"\n        } else if c == '\\b' {\n            result += \" \"\n        } else if c == '\\a' {\n            result += \" \"\n        } else if c == '\\0' {\n            result += \" \"\n        } else if c == '\\x00' {\n            result += \" \"\n        } else if c == '\\x01' {\n            result += \" \"\n        } else if c == '\\x02' {\n            result += \" \"\n        } else if c == '\\x03' {\n            result += \" \"\n        } else if c == '\\x04' {\n            result += \" \"\n        } else if c == '\\x05' {\n            result += \" \"\n        } else if c == '\\x06' {\n            result += \" \"\n        } else if c == '\\x07' {\n            result += \" \"\n        } else if c == '\\x08' {\n            result += \" \"\n        } else if c == '\\x09' {\n            result += \" \"\n        } else if c == '\\x0a' {\n            result += \" \"\n        } else if c == '\\x0b' {\n            result += \" \"\n        } else if c == '\\x0c' {\n            result += \" \"\n        } else if c == '\\x0d' {\n            result += \" \"\n        } else if c == '\\x0e' {\n            result += \" \"\n        } else if c == '\\x0f' {\n            result += \" \"\n        } else if\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpzbfsealj.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpzbfsealj.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpzbfsealj.swift:17:17: error: single-quoted string literal found, use '\"'\n        if c == ' ' {\n                ^~~\n                \" \"\n/tmp/tmpzbfsealj.swift:19:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\n' {\n                       ^~~~\n                       \"\\n\"\n/tmp/tmpzbfsealj.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\t' {\n                       ^~~~\n                       \"\\t\"\n/tmp/tmpzbfsealj.swift:23:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\r' {\n                       ^~~~\n                       \"\\r\"\n/tmp/tmpzbfsealj.swift:25:26: error: invalid escape sequence in literal\n        } else if c == '\\v' {\n                         ^\n/tmp/tmpzbfsealj.swift:25:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\v' {\n                       ^~~~\n                       \"\\v\"\n/tmp/tmpzbfsealj.swift:27:26: error: invalid escape sequence in literal\n        } else if c == '\\f' {\n                         ^\n/tmp/tmpzbfsealj.swift:27:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\f' {\n                       ^~~~\n                       \"\\f\"\n/tmp/tmpzbfsealj.swift:29:26: error: invalid escape sequence in literal\n        } else if c == '\\b' {\n                         ^\n/tmp/tmpzbfsealj.swift:29:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\b' {\n                       ^~~~\n                       \"\\b\"\n/tmp/tmpzbfsealj.swift:31:26: error: invalid escape sequence in literal\n        } else if c == '\\a' {\n                         ^\n/tmp/tmpzbfsealj.swift:31:24: error: single-quoted string literal found, use '\"'\n        } else if c == '\\a' {\n                       ^~~~\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += vowels2[vowels.Index(message[i]) + 2]\n        } else if message[i] in consonants {\n            result += consonants2[consonants.Index(message[i]) + 2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpzv4ea84w.swift:18:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpzv4ea84w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpzv4ea84w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpzv4ea84w.swift:19:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpzv4ea84w.swift:21:30: error: expected '{' after 'if' condition\n        } else if message[i] in consonants {\n                             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Write your code here\n    return message.replaceAll(\"[AEIOU]\", function(match) {\n        return String.fromCharCode(match.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpq5zp5v3q.swift:14:42: error: cannot find 'function' in scope\n    return message.replaceAll(\"[AEIOU]\", function(match) {\n                                         ^~~~~~~~\n/tmp/tmpq5zp5v3q.swift:14:51: error: cannot find 'match' in scope\n    return message.replaceAll(\"[AEIOU]\", function(match) {\n                                                  ^~~~~\n/tmp/tmpq5zp5v3q.swift:15:36: error: cannot find 'match' in scope\n        return String.fromCharCode(match.charCodeAt(0) + 2)\n                                   ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels3 = \"AEIOU\"\n    var consonants3 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels4 = \"AEIOU\"\n    var consonants4 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels5 = \"AEIOU\"\n    var consonants5 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels6 = \"AEIOU\"\n    var consonants6 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels7 = \"AEIOU\"\n    var consonants7 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels8 = \"AEIOU\"\n    var consonants8 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels9 = \"AEIOU\"\n    var consonants9 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels10 = \"AEIOU\"\n    var consonants10 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels11 = \"AEIOU\"\n    var consonants11 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels12 = \"AEIOU\"\n    var consonants12 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels13 = \"AEIOU\"\n    var consonants13 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels14 = \"AEIOU\"\n    var consonants14 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels15 = \"AEIOU\"\n    var consonants15 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprmsz288b.swift:43:9: error: type annotation missing in pattern\n    var vowels\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            result += string(letter) + string(letter[2:])\n        } else {\n            result += string(letter) + string(letter[1:])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpkl_20c3i.swift:15:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpkl_20c3i.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmpkl_20c3i.swift:17:55: error: expected ',' separator\n            result += string(letter) + string(letter[2:])\n                                                      ^\n                                                      ,\n/tmp/tmpkl_20c3i.swift:17:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[2:])\n                                                      ^\n/tmp/tmpkl_20c3i.swift:19:55: error: expected ',' separator\n            result += string(letter) + string(letter[1:])\n                                                      ^\n                                                      ,\n/tmp/tmpkl_20c3i.swift:19:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[1:])\n                                                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.Index(letter) + 2]\n        } else {\n            encoded += vowels[vowels.Index(letter) + 2]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpsh45ngol.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpsh45ngol.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpc7onsfdk.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpc7onsfdk.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpc7onsfdk.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpc7onsfdk.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels3 = \"AEIOU\"\n    var consonants3 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels4 = \"AEIOU\"\n    var consonants4 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels5 = \"AEIOU\"\n    var consonants5 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels6 = \"AEIOU\"\n    var consonants6 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels7 = \"AEIOU\"\n    var consonants7 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels8 = \"AEIOU\"\n    var consonants8 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels9 = \"AEIOU\"\n    var consonants9 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels10 = \"AEIOU\"\n    var consonants10 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels11 = \"AEIOU\"\n    var consonants11 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels12 = \"AEIOU\"\n    var consonants12 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels13 = \"AEIOU\"\n    var consonants13 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels14 = \"AEIOU\"\n    var consonants14 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels15 = \"AEIOU\"\n    var consonants15 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprmsz288b.swift:43:9: error: type annotation missing in pattern\n    var vowels\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUYAEIOUY\"\n    var vowels4 = \"AEIOUYAEIOUYAEIOUY\"\n    var vowels5 = \"AEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels6 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels7 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels8 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels9 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels10 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels11 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels12 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels13 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels14 = \"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUY\"\n    var vowels15 = \"AEIOUYAEIOUYAEIOUYAE\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpbxq7uza8.swift:27:20: error: unterminated string literal\n    var vowels15 = \"AEIOUYAEIOUYAEIOUYAE\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else if c in consonants {\n            result += consonants2[consonants.Index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpb_srovvs.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:19:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n/tmp/tmpb_srovvs.swift:21:21: error: expected '{' after 'if' condition\n        } else if c in consonants {\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYX\"\n    var vowels_4 = \"AEIOUYXZ\"\n    var vowels_5 = \"AEIOUYXZV\"\n    var vowels_6 = \"AEIOUYXZVX\"\n    var vowels_7 = \"AEIOUYXZVXC\"\n    var vowels_8 = \"AEIOUYXZVXCD\"\n    var vowels_9 = \"AEIOUYXZVXCDG\"\n    var vowels_10 = \"AEIOUYXZVXCDGX\"\n    var vowels_11 = \"AEIOUYXZVXCDGXH\"\n    var vowels_12 = \"AEIOUYXZVXCDGXHZ\"\n    var vowels_13 = \"AEIOUYXZVXCDGXHZV\"\n    var vowels_14 = \"AEIOUYXZVXCDGXHZVX\"\n    var vowels_15 = \"AEIOUYXZVXCDGXHZVXC\"\n    var vowels_16 = \"AEIOUYXZVXCDGXHZVXCD\"\n    var vowels_17 = \"AEIOUYXZVXCDGXHZVXCDG\"\n    var vowels_18 = \"AEIOUYXZVXCDGXHZVXCDGX\"\n    var vowels_19 = \"AEIOUYXZVXCDGXHZVXCDGXH\"\n    var vowels_20 = \"AEIOUYXZVXCDGXHZVXCDGXHZ\"\n    var vowels_21 = \"AEIOUYXZVXCDGXHZVXCDGXHZV\"\n    var vowels_22 = \"AEIOUYXZVXCDGXHZVXCDGXHZVX\"\n    var vowels_23 = \"AEIOUYXZVXCDGX\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp0pxxt6wz.swift:35:21: error: unterminated string literal\n    var vowels_23 = \"AEIOUYXZVXCDGX\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i + 2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpw57t25r5.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpw57t25r5.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpw57t25r5.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpw57t25r5.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels_2[vowels.index(c) + 2]\n        } else {\n            result += vowels[vowels.index(c)]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpisb4yjpk.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpisb4yjpk.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpisb4yjpk.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.IndexOf(letter) + 2]\n        } else {\n            encoded += vowels[vowels.IndexOf(letter) + 2]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp00lgpt9t.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp00lgpt9t.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.indexOf(letter) != -1 {\n            result += vowels2[vowels.indexOf(letter) + 2]\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpznkitj4a.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpznkitj4a.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else if c in consonants {\n            result += consonants2[consonants.Index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpb_srovvs.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:19:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n/tmp/tmpb_srovvs.swift:21:21: error: expected '{' after 'if' condition\n        } else if c in consonants {\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if strings.Contains(vowels, string(letter)) {\n            result += string(letter) + string(letter[2:])\n        } else if strings.Contains(vowels2, string(letter)) {\n            result += string(letter[2:]) + string(letter)\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpfveeyako.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpfveeyako.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmpfveeyako.swift:18:55: error: expected ',' separator\n            result += string(letter) + string(letter[2:])\n                                                      ^\n                                                      ,\n/tmp/tmpfveeyako.swift:18:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[2:])\n                                                      ^\n/tmp/tmpfveeyako.swift:20:38: error: expected ',' separator\n            result += string(letter[2:]) + string(letter)\n                                     ^\n                                     ,\n/tmp/tmpfveeyako.swift:20:38: error: expected expression in list of expressions\n            result += string(letter[2:]) + string(letter)\n                                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUYAEIOU\"\n    var vowels4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpy2bu1k7z.swift:28:20: error: unterminated string literal\n    var vowels16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    }).replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpmc1pve_8.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                       ^~~~~~~~\n/tmp/tmpmc1pve_8.swift:14:65: error: cannot find 'c' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                                ^\n/tmp/tmpmc1pve_8.swift:15:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n/tmp/tmpmc1pve_8.swift:16:30: error: cannot find 'function' in scope\n    }).replaceAll(\"[aeiou]\", function(c) {\n                             ^~~~~~~~\n/tmp/tmpmc1pve_8.swift:16:39: error: cannot find 'c' in scope\n    }).replaceAll(\"[aeiou]\", function(c) {\n                                      ^\n/tmp/tmpmc1pve_8.swift:17:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmphn723rqu/tmphn723rqu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f76c03c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f768fab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f768fa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f768f97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphn723rqu                        0x0000560bb1802307 <unavailable> + 4871\n5    libc.so.6                          0x00002b3f76def460 __libc_start_main + 245\n6    tmphn723rqu                        0x0000560bb1801f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n        return String.fromCharCode(match.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpygimrtm8.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n                                                       ^~~~~~~~\n/tmp/tmpygimrtm8.swift:14:65: error: cannot find 'match' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n                                                                ^~~~~\n/tmp/tmpygimrtm8.swift:15:36: error: cannot find 'match' in scope\n        return String.fromCharCode(match.charCodeAt(0) + 2)\n                                   ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if letter == \" \" {\n            result += \" \"\n        } else if strings.Contains(vowels, string(letter)) {\n            result += string(letter) + string(letter[2:])\n        } else if strings.Contains(vowels2, string(letter)) {\n            result += string(letter) + string(letter[2:])\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpi_qr1vao.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpi_qr1vao.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmpi_qr1vao.swift:20:55: error: expected ',' separator\n            result += string(letter) + string(letter[2:])\n                                                      ^\n                                                      ,\n/tmp/tmpi_qr1vao.swift:20:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[2:])\n                                                      ^\n/tmp/tmpi_qr1vao.swift:22:55: error: expected ',' separator\n            result += string(letter) + string(letter[2:])\n                                                      ^\n                                                      ,\n/tmp/tmpi_qr1vao.swift:22:55: error: expected expression in list of expressions\n            result += string(letter) + string(letter[2:])\n                                                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels2 = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.indexOf(letter) > -1 {\n            result += vowels2[vowels.indexOf(letter) + 2]\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp86qtc4it.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp86qtc4it.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if vowels.Contains(c) {\n            encoded += consonants[vowels.Index(c) + 2]\n        } else {\n            encoded += consonants[vowels.Index(c)]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp1rx9e6to.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmp1rx9e6to.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var result = \"\"\n    \n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            result += consonants[vowels.Index(letter) + 2] + letter\n        } else {\n            result += letter\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpzewy6499.swift:19:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpzewy6499.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i + 2]\n        } else if message[i] in vowels2 {\n            result += message[i] + message[i + 1]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdu8nmj_k.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdu8nmj_k.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdu8nmj_k.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdu8nmj_k.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpdu8nmj_k.swift:19:30: error: expected '{' after 'if' condition\n        } else if message[i] in vowels2 {\n                             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if strings.Contains(vowels, string(letter)) {\n            result += vowels2[vowels.Index(string(letter))] + string(letter)\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpiu5731oa.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpiu5731oa.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else if c in consonants {\n            result += consonants2[consonants.Index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpb_srovvs.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:19:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n/tmp/tmpb_srovvs.swift:21:21: error: expected '{' after 'if' condition\n        } else if c in consonants {\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            result += consonants[vowels.Index(letter) + 2] + letter\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp07_oasfh.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp07_oasfh.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpw9qabr6t.swift:15:57: error: cannot find 'a' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n                                                        ^\n/tmp/tmpw9qabr6t.swift:15:60: error: cannot find 'i' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n                                                           ^\n/tmp/tmpw9qabr6t.swift:15:63: error: cannot find operator '=>' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n                                                              ^~\n/tmp/tmpw9qabr6t.swift:15:66: error: cannot find 'a' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n                                                                 ^\n/tmp/tmpw9qabr6t.swift:15:84: error: cannot find 'i' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n                                                                                   ^\n/tmp/tmpw9qabr6t.swift:15:20: error: value of type 'String' has no member 'toLowerCase'\n    return message.toLowerCase().replaceAll(\"[aeiou]\", (a, i) => a.toUpperCase() + i.toLowerCase())\n           ~~~~~~~ ^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if vowels.Contains(c) {\n            encoded += consonants[(vowels.IndexOf(c) + 2) % 6]\n        } else {\n            encoded += vowels[vowels.IndexOf(c) + 2]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpypfr0mfs.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpypfr0mfs.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpn03nt268.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpn03nt268.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUY\"\n    var vowels4 = \"AEIOUY\"\n    var vowels5 = \"AEIOUY\"\n    var vowels6 = \"AEIOUY\"\n    var vowels7 = \"AEIOUY\"\n    var vowels8 = \"AEIOUY\"\n    var vowels9 = \"AEIOUY\"\n    var vowels10 = \"AEIOUY\"\n    var vowels11 = \"AEIOUY\"\n    var vowels12 = \"AEIOUY\"\n    var vowels13 = \"AEIOUY\"\n    var vowels14 = \"AEIOUY\"\n    var vowels15 = \"AEIOUY\"\n    var vowels16 = \"AEIOUY\"\n    var vowels17 = \"AEIOUY\"\n    var vowels18 = \"AEIOUY\"\n    var vowels19 = \"AEIOUY\"\n    var vowels20 = \"AEIOUY\"\n    var vowels21 = \"AEIOUY\"\n    var vowels22 = \"AEIOUY\"\n    var vowels23 = \"AEIOUY\"\n    var vowels24 = \"AEIOUY\"\n    var vowels25 = \"AEIOUY\"\n    var vowels26 = \"AEIOUY\"\n    var vowels27 = \"AEIOUY\"\n    var vowels28 = \"AEIOUY\"\n    var vowels29 = \"AEIOUY\"\n    var vowels30 = \"AEIOUY\"\n    var vowels31 = \"AEIOUY\"\n    var vowels32 = \"AEIOUY\"\n    var vowels33 = \"AEIOUY\"\n    var vowels34 = \"AEIOUY\"\n    var vowels35 = \"AEIOUY\"\n    var vowels36 = \"AEIOUY\"\n    var vowels37 = \"AEIOUY\"\n    var vowels38 = \"AEIOUY\"\n    var vowels39 = \"AEIOUY\"\n    var vowels40\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpilav42e3.swift:53:9: error: type annotation missing in pattern\n    var vowels40\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char == ' ' {\n            encoded += \" \"\n        } else if char == '.' {\n            encoded += \" \"\n        } else if char == ',' {\n            encoded += \" \"\n        } else if char == '!' {\n            encoded += \" \"\n        } else if char == '?' {\n            encoded += \" \"\n        } else if char == '\\'' {\n            encoded += \" \"\n        } else if char == '\\\"' {\n            encoded += \" \"\n        } else if char == '\\n' {\n            encoded += \" \"\n        } else if char == '\\t' {\n            encoded += \" \"\n        } else if char == '\\r' {\n            encoded += \" \"\n        } else if char == '\\v' {\n            encoded += \" \"\n        } else if char == '\\f' {\n            encoded += \" \"\n        } else if char == '\\b' {\n            encoded += \" \"\n        } else if char == '\\a' {\n            encoded += \" \"\n        } else if char == '\\0' {\n            encoded += \" \"\n        } else if char == '\\x0' {\n            encoded += \" \"\n        } else if char == '\\x1' {\n            encoded += \" \"\n        } else if char == '\\x2' {\n            encoded += \" \"\n        } else if char == '\\x3' {\n            encoded += \" \"\n        } else if char == '\\x4' {\n            encoded += \" \"\n        } else if char == '\\x5' {\n            encoded += \" \"\n        } else if char == '\\x6' {\n            encoded += \" \"\n        } else if char == '\\x7' {\n            encoded += \" \"\n        } else if char == '\\x8' {\n            encoded += \" \"\n        } else if char == '\\x9' {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpv8iebpko.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmpv8iebpko.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmpv8iebpko.swift:17:20: error: single-quoted string literal found, use '\"'\n        if char == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmpv8iebpko.swift:19:27: error: single-quoted string literal found, use '\"'\n        } else if char == '.' {\n                          ^~~\n                          \".\"\n/tmp/tmpv8iebpko.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ',' {\n                          ^~~\n                          \",\"\n/tmp/tmpv8iebpko.swift:23:27: error: single-quoted string literal found, use '\"'\n        } else if char == '!' {\n                          ^~~\n                          \"!\"\n/tmp/tmpv8iebpko.swift:25:27: error: single-quoted string literal found, use '\"'\n        } else if char == '?' {\n                          ^~~\n                          \"?\"\n/tmp/tmpv8iebpko.swift:27:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\'' {\n                          ^~~~\n                          \"'\"\n/tmp/tmpv8iebpko.swift:29:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\\"' {\n                          ^~~~\n                          \"\\\"\"\n/tmp/tmpv8iebpko.swift:31:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\n' {\n                          ^~~~\n                          \"\\n\"\n/tmp/tmpv8iebpko.swift:33:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\t' {\n                          ^~~~\n                          \"\\t\"\n/tmp/tmpv8iebpko.swift:35:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\r' {\n                          ^~~~\n                          \"\\r\"\n/tmp/tmpv8iebpko.swift:37:29: error: invalid escape sequence in literal\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_index = 0\n    var vowels_count = 0\n    var message_count = 0\n    var encoded_message = \"\"\n    for message_count < len(message) {\n        if message[message_count] in vowels {\n            vowels_index = vowels.index(message[message_count])\n            vowels_count = vowels_count + 2\n            encoded_message = encoded_message + vowels[vowels_index + vowels_count]\n        } else {\n            encoded_message = encoded_message + message[message_count]\n        }\n        message_count = message_count + 1\n    }\n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpc91e7lgd.swift:18:23: error: expected 'in' after for-each pattern\n    for message_count < len(message) {\n                      ^\n/tmp/tmpc91e7lgd.swift:18:23: error: unary operator cannot be separated from its operand\n    for message_count < len(message) {\n                      ^~\n                       \n/tmp/tmpc91e7lgd.swift:19:35: error: expected '{' after 'if' condition\n        if message[message_count] in vowels {\n                                  ^\n/tmp/tmpc91e7lgd.swift:18:23: error: '<' is not a prefix unary operator\n    for message_count < len(message) {\n                      ^\n/tmp/tmpc91e7lgd.swift:18:25: error: cannot find 'len' in scope\n    for message_count < len(message) {\n                        ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmphn723rqu/tmphn723rqu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f76c03c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f768fab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f768fa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f768f97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphn723rqu                        0x0000560bb1802307 <unavailable> + 4871\n5    libc.so.6                          0x00002b3f76def460 __libc_start_main + 245\n6    tmphn723rqu                        0x0000560bb1801f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    \n    var encoded_message = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded_message += message[i] + message[i+2]\n        } else {\n            encoded_message += message[i]\n        }\n    }\n    \n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp7_0gf5ix.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp7_0gf5ix.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp7_0gf5ix.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp7_0gf5ix.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels3 = \"AEIOU\"\n    var consonants3 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels4 = \"AEIOU\"\n    var consonants4 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels5 = \"AEIOU\"\n    var consonants5 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels6 = \"AEIOU\"\n    var consonants6 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels7 = \"AEIOU\"\n    var consonants7 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels8 = \"AEIOU\"\n    var consonants8 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels9 = \"AEIOU\"\n    var consonants9 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels10 = \"AEIOU\"\n    var consonants10 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels11 = \"AEIOU\"\n    var consonants11 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels12 = \"AEIOU\"\n    var consonants12 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels13 = \"AEIOU\"\n    var consonants13 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels14 = \"AEIOU\"\n    var consonants14 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var vowels15 = \"AE\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp3ydju9ph.swift:56:20: error: unterminated string literal\n    var vowels15 = \"AE\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_count = 0\n    var vowels_index = 0\n    var vowels_index_2 = 0\n    var encoded_message = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n            vowels_index = i\n            vowels_index_2 = vowels_index + 2\n            encoded_message += message[i]\n            if vowels_count == 2 {\n                encoded_message += message[vowels_index_2]\n            }\n        } else {\n            encoded_message += message[i]\n        }\n    }\n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp61j_x6qg.swift:20:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp61j_x6qg.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp61j_x6qg.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp61j_x6qg.swift:21:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.index(c) + 2]\n        } else {\n            result += vowels[vowels.index(c)]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpq3yhhl13.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpq3yhhl13.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpq3yhhl13.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_count = 0\n    var vowels_index = 0\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n            vowels_index = i\n        }\n    }\n    \n    var encoded_message = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded_message += message[i + vowels_index]\n        } else {\n            encoded_message += message[i]\n        }\n    }\n    \n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpv64k5z6k.swift:18:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpv64k5z6k.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpv64k5z6k.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpv64k5z6k.swift:19:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpv64k5z6k.swift:27:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpv64k5z6k.swift:27:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpv64k5z6k.swift:27:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpv64k5z6k.swift:28:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    \n    var vowels_count = 0\n    var vowels_count_2 = 0\n    \n    var encoded_message = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n        }\n        if message[i] in vowels_2 {\n            vowels_count_2++\n        }\n        \n        if vowels_count == 0 {\n            encoded_message += message[i]\n        } else if vowels_count_2 == 0 {\n            encoded_message += message[i]\n        } else {\n            encoded_message += message[i]\n            encoded_message += message[i+2]\n        }\n    }\n    \n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpg144yqll.swift:22:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpg144yqll.swift:22:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpg144yqll.swift:22:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpg144yqll.swift:23:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpg144yqll.swift:26:23: error: expected '{' after 'if' condition\n        if message[i] in vowels_2 {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpc7onsfdk.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpc7onsfdk.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpc7onsfdk.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpc7onsfdk.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUAEIOU\"\n    var vowels_3 = \"AEIOUAEIOUAEIOU\"\n    var vowels_4 = \"AEIOUAEIOUAEIOUAEIOU\"\n    var vowels_5 = \"AEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_6 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_7 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_8 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_9 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_10 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_11 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_12 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_13 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_14 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_15 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpvzv8pjaw.swift:28:9: error: type annotation missing in pattern\n    var vowels\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if vowels.indexOf(c) != -1 {\n            encoded += consonants[vowels.indexOf(c) + 2]\n        } else {\n            encoded += c\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpcm5rqwiq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpcm5rqwiq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdcwe7l2g.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUYAEIOU\"\n    var vowels4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpy2bu1k7z.swift:28:20: error: unterminated string literal\n    var vowels16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUY\"\n    var vowels_4 = \"AEIOUY\"\n    \n    var vowels_count = 0\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            vowels_count++\n            if vowels_count == 2 {\n                vowels = vowels_2\n            } else if vowels_count == 3 {\n                vowels = vowels_3\n            } else if vowels_count == 4 {\n                vowels = vowels_4\n            }\n        }\n    }\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            message = message[i+2:] + message[i] + message[i+1]\n        }\n    }\n    \n    return message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpj8la6s0x.swift:21:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpj8la6s0x.swift:21:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpj8la6s0x.swift:21:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpj8la6s0x.swift:22:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpj8la6s0x.swift:34:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpj8la6s0x.swift:34:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpj8la6s0x.swift:34:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpj8la6s0x.swift:35:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmpj8la6s0x.swift:36:34: error: expected ',' separator\n            message = message[i+2:] + message[i] + message[i+1]\n                                 ^\n                                 ,\n/tmp/tmpj8la6s0x.swift:36:34: error: expected expression in list of expressions\n            message = message[i+2:] + message[i] + message[i+1]\n                                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels3 = \"AEIOU\"\n    var consonants3 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels4 = \"AEIOU\"\n    var consonants4 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels5 = \"AEIOU\"\n    var consonants5 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels6 = \"AEIOU\"\n    var consonants6 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels7 = \"AEIOU\"\n    var consonants7 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels8 = \"AEIOU\"\n    var consonants8 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels9 = \"AEIOU\"\n    var consonants9 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels10 = \"AEIOU\"\n    var consonants10 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels11 = \"AEIOU\"\n    var consonants11 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels12 = \"AEIOU\"\n    var consonants12 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels13 = \"AEIOU\"\n    var consonants13 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels14 = \"AEIOU\"\n    var consonants14 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels15 = \"AEIOU\"\n    var consonants15 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmprmsz288b.swift:43:9: error: type annotation missing in pattern\n    var vowels\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYAEIOU\"\n    var vowels_4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels_5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels_6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5px_r3il.swift:28:21: error: unterminated string literal\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Create a new string to hold the encoded message\n    encodedMessage: String = \"\"\n    \n    // Create a new string to hold the vowels\n    vowels: String = \"aeiou\"\n    \n    // Create a new string to hold the consonants\n    consonants: String = \"bcdfghjklmnpqrstvwxyz\"\n    \n    // Create a new string to hold the vowels and consonants\n    vowelsAndConsonants: String = vowels + consonants\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse2: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse3: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse4: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse5: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse6: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse7: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowelsAndConsonantsReverse8: String = vowelsAndConsonants[::-1]\n    \n    // Create a new string to hold the vowels and consonants in reverse\n    vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpkds0knum.swift:15:19: error: consecutive statements on a line must be separated by ';'\n    encodedMessage: String = \"\"\n                  ^\n                  ;\n/tmp/tmpkds0knum.swift:15:19: error: expected expression\n    encodedMessage: String = \"\"\n                  ^\n/tmp/tmpkds0knum.swift:15:5: error: cannot find 'encodedMessage' in scope\n    encodedMessage: String = \"\"\n    ^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n        return match.charAt(2);\n    }).replaceAll(\"[aeiou]\", function(match) {\n        return match.charAt(0);\n    }).replaceAll(\"[aeiou]\", function(match) {\n        return match.charAt(1);\n    });\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpus1wf2j9.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n                                                       ^~~~~~~~\n/tmp/tmpus1wf2j9.swift:14:65: error: cannot find 'match' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(match) {\n                                                                ^~~~~\n/tmp/tmpus1wf2j9.swift:15:16: error: cannot find 'match' in scope\n        return match.charAt(2);\n               ^~~~~\n/tmp/tmpus1wf2j9.swift:16:30: error: cannot find 'function' in scope\n    }).replaceAll(\"[aeiou]\", function(match) {\n                             ^~~~~~~~\n/tmp/tmpus1wf2j9.swift:16:39: error: cannot find 'match' in scope\n    }).replaceAll(\"[aeiou]\", function(match) {\n                                      ^~~~~\n/tmp/tmpus1wf2j9.swift:17:16: error: cannot find 'match' in scope\n        return match.charAt(0);\n               ^~~~~\n/tmp/tmpus1wf2j9.swift:18:30: error: cannot find 'function' in scope\n    }).replaceAll(\"[aeiou]\", function(match) {\n                             ^~~~~~~~\n/tmp/tmpus1wf2j9.swift:18:39: error: cannot find 'match' in scope\n    }).replaceAll(\"[aeiou]\", function(match) {\n                                      ^~~~~\n/tmp/tmpus1wf2j9.swift:19:16: error: cannot find 'match' in scope\n        return match.charAt(1);\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.IndexOf(letter) + 2]\n        } else {\n            encoded += consonants[vowels.IndexOf(letter)]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp6_9ufis7.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp6_9ufis7.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encodedMessage = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encodedMessage += consonants[(vowels.Index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encodedMessage += message[i]\n        }\n    }\n    \n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp80o66pbm.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp80o66pbm.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp80o66pbm.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp80o66pbm.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if vowels.Contains(message[i]) {\n            encoded += consonants[(vowels.Index(message[i]) + 2) % 6]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpl607bjy6.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpl607bjy6.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpl607bjy6.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for i := 0; i < len(message); i++ {\n        if vowels.indexOf(message[i]) != -1 {\n            result += vowels2[vowels.indexOf(message[i]) + 2]\n        } else if consonants.indexOf(message[i]) != -1 {\n            result += consonants2[consonants.indexOf(message[i]) + 2]\n        } else {\n            result += message[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmprxg5wrko.swift:18:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmprxg5wrko.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmprxg5wrko.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for _, letter := range message {\n        if letter in vowels {\n            encoded += vowels[vowels.index(letter) + 2]\n        } else if letter in consonants {\n            encoded += consonants[consonants.index(letter) + 2]\n        } else {\n            encoded += letter\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpxvfj1dio.swift:19:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpxvfj1dio.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmpxvfj1dio.swift:20:19: error: expected '{' after 'if' condition\n        if letter in vowels {\n                  ^\n/tmp/tmpxvfj1dio.swift:22:26: error: expected '{' after 'if' condition\n        } else if letter in consonants {\n                         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels2 = \"AEIOU\"\n    var vowels3 = \"AEIOUAEIOU\"\n    var vowels4 = \"AEIOUAEIOUAEIOU\"\n    var vowels5 = \"AEIOUAEIOUAEIOUAEIOU\"\n    var vowels6 = \"AEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels7 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels8 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels9 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels10 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels11 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels12 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels13 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels14 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels15 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels16 = \"AEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vow\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpiefnw_pl.swift:29:9: error: type annotation missing in pattern\n    var vow\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYAEIOU\"\n    var vowels_4 = \"AEIOUYAEIOUAEIOU\"\n    var vowels_5 = \"AEIOUYAEIOUAEIOUAEIOU\"\n    var vowels_6 = \"AEIOUYAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_7 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_8 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_9 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_10 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_11 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_12 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_13 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_14 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_15 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp5px_r3il.swift:28:21: error: unterminated string literal\n    var vowels_16 = \"AEIOUYAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEI\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.indexOf(letter) != -1 {\n            result += message[vowels.indexOf(letter) + 2]\n        } else {\n            result += message[vowels.indexOf(letter) + 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmp6wqqb823.swift:15:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp6wqqb823.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if letter == ' ' {\n            result += \" \"\n        } else if letter == '.' {\n            result += \".\"\n        } else if letter == ',' {\n            result += \",\"\n        } else if letter == '!' {\n            result += \"!\"\n        } else if letter == '?' {\n            result += \"?\"\n        } else if letter == '\\'' {\n            result += \"'\"\n        } else if letter == '\\\"' {\n            result += \"\\\"\"\n        } else if letter == '\\n' {\n            result += \" \"\n        } else if letter == '\\t' {\n            result += \" \"\n        } else if letter == '\\r' {\n            result += \" \"\n        } else if letter == '\\b' {\n            result += \" \"\n        } else if letter == '\\f' {\n            result += \" \"\n        } else if letter == '\\v' {\n            result += \" \"\n        } else if letter == '\\a' {\n            result += \" \"\n        } else if letter == '\\0' {\n            result += \" \"\n        } else if letter == '\\u00A0' {\n            result += \" \"\n        } else if letter == '\\u00A1' {\n            result += \" \"\n        } else if letter == '\\u00A2' {\n            result += \" \"\n        } else if letter == '\\u00A3' {\n            result += \" \"\n        } else if letter == '\\u00A4' {\n            result += \" \"\n        } else if letter == '\\u00A5' {\n            result += \" \"\n        } else if letter == '\\u00A6' {\n            result += \" \"\n        } else if letter == '\\u00A7' {\n            result += \" \"\n        } else if letter == '\\u00A8' {\n            result += \" \"\n        } else if letter == '\\u00A9' {\n            result += \" \"\n        } else if letter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp2_bh8ebd.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmp2_bh8ebd.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmp2_bh8ebd.swift:17:22: error: single-quoted string literal found, use '\"'\n        if letter == ' ' {\n                     ^~~\n                     \" \"\n/tmp/tmp2_bh8ebd.swift:19:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '.' {\n                            ^~~\n                            \".\"\n/tmp/tmp2_bh8ebd.swift:21:29: error: single-quoted string literal found, use '\"'\n        } else if letter == ',' {\n                            ^~~\n                            \",\"\n/tmp/tmp2_bh8ebd.swift:23:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '!' {\n                            ^~~\n                            \"!\"\n/tmp/tmp2_bh8ebd.swift:25:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '?' {\n                            ^~~\n                            \"?\"\n/tmp/tmp2_bh8ebd.swift:27:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '\\'' {\n                            ^~~~\n                            \"'\"\n/tmp/tmp2_bh8ebd.swift:29:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '\\\"' {\n                            ^~~~\n                            \"\\\"\"\n/tmp/tmp2_bh8ebd.swift:31:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '\\n' {\n                            ^~~~\n                            \"\\n\"\n/tmp/tmp2_bh8ebd.swift:33:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '\\t' {\n                            ^~~~\n                            \"\\t\"\n/tmp/tmp2_bh8ebd.swift:35:29: error: single-quoted string literal found, use '\"'\n        } else if letter == '\\r' {\n                            ^~~~\n                            \"\\r\"\n/tmp/tmp2_b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for _, char := range message {\n        if char in vowels {\n            encoded += consonants[(vowels.index(char) + 2) % len(vowels)] + char\n        } else {\n            encoded += char\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpvxv_4g1h.swift:19:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmpvxv_4g1h.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmpvxv_4g1h.swift:20:17: error: expected '{' after 'if' condition\n        if char in vowels {\n                ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    for _, letter := range message {\n        if letter == ' ' {\n            result += \" \"\n            continue\n        }\n        if letter == '.' {\n            result += \".\"\n            continue\n        }\n        if letter == ',' {\n            result += \",\"\n            continue\n        }\n        if letter == '?' {\n            result += \"?\"\n            continue\n        }\n        if letter == '!' {\n            result += \"!\"\n            continue\n        }\n        if letter == '\\'' {\n            result += \"'\"\n            continue\n        }\n        if letter == '\\\"' {\n            result += \"\\\"\"\n            continue\n        }\n        if letter == '\\n' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\t' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\r' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\b' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\f' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\v' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\a' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\0' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x00' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x01' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x02' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x03' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x04' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x05' {\n            result += \" \"\n            continue\n        }\n        if letter == '\\x06' {\n            result += \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpqo74qkv3.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpqo74qkv3.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n/tmp/tmpqo74qkv3.swift:17:22: error: single-quoted string literal found, use '\"'\n        if letter == ' ' {\n                     ^~~\n                     \" \"\n/tmp/tmpqo74qkv3.swift:21:22: error: single-quoted string literal found, use '\"'\n        if letter == '.' {\n                     ^~~\n                     \".\"\n/tmp/tmpqo74qkv3.swift:25:22: error: single-quoted string literal found, use '\"'\n        if letter == ',' {\n                     ^~~\n                     \",\"\n/tmp/tmpqo74qkv3.swift:29:22: error: single-quoted string literal found, use '\"'\n        if letter == '?' {\n                     ^~~\n                     \"?\"\n/tmp/tmpqo74qkv3.swift:33:22: error: single-quoted string literal found, use '\"'\n        if letter == '!' {\n                     ^~~\n                     \"!\"\n/tmp/tmpqo74qkv3.swift:37:22: error: single-quoted string literal found, use '\"'\n        if letter == '\\'' {\n                     ^~~~\n                     \"'\"\n/tmp/tmpqo74qkv3.swift:41:22: error: single-quoted string literal found, use '\"'\n        if letter == '\\\"' {\n                     ^~~~\n                     \"\\\"\"\n/tmp/tmpqo74qkv3.swift:45:22: error: single-quoted string literal found, use '\"'\n        if letter == '\\n' {\n                     ^~~~\n                     \"\\n\"\n/tmp/tmpqo74qkv3.swift:49:22: error: single-quoted string literal found, use '\"'\n        if letter == '\\t' {\n                     ^~~~\n                     \"\\t\"\n/tmp/tmpqo74qkv3.swift:53:22: error: single-quoted string literal found, use '\"'\n        if letter == '\\r' {\n                     ^~~~\n                     \"\\r\"\n/tmp/tmpqo74qkv3.swift:57:24: error: invalid escape sequence in literal\n        if letter == '\\b' {\n                       ^\n/tmp/tmpqo74qkv3.swift:57:22: error: single-quoted string literal found, us",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels[vowels.index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpmumvcscl.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpmumvcscl.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpmumvcscl.swift:16:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpz51dimqt.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                       ^~~~~~~~\n/tmp/tmpz51dimqt.swift:14:65: error: cannot find 'c' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                                ^\n/tmp/tmpz51dimqt.swift:15:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.Index(letter) + 2]\n        } else {\n            encoded += vowels[vowels.Index(letter) + 2]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpb8zqb81_.swift:19:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpb8zqb81_.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var vowels2 = \"AEIOU\"\n    var consonants2 = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var result = \"\"\n    for _, c := range message {\n        if c in vowels {\n            result += vowels2[vowels.Index(c) + 2]\n        } else if c in consonants {\n            result += consonants2[consonants.Index(c) + 2]\n        } else {\n            result += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpb_srovvs.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpb_srovvs.swift:19:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n/tmp/tmpb_srovvs.swift:21:21: error: expected '{' after 'if' condition\n        } else if c in consonants {\n                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, c := range message {\n        if c in vowels {\n            encoded += consonants[(vowels.index(c) + 2) % len(vowels)] + c\n        } else {\n            encoded += c\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpvkeh_ryt.swift:16:10: error: expected 'in' after for-each pattern\n    for _, c := range message {\n         ^\n/tmp/tmpvkeh_ryt.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, c := range message {\n         ^\n/tmp/tmpvkeh_ryt.swift:17:14: error: expected '{' after 'if' condition\n        if c in vowels {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdcwe7l2g.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpdcwe7l2g.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "tmp4wze1c_7/tmp4wze1c_7.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8dbb8a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8dbb59fb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8dbb59f988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8dbb59e7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4wze1c_7                        0x000055afdfb78307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8dbba94460 __libc_start_main + 245\n6    tmp4wze1c_7                        0x000055afdfb77f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if vowels.Contains(message[i]) {\n            encoded += consonants[(vowels.Index(message[i]) + 2) % 6]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpl607bjy6.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpl607bjy6.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpl607bjy6.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_count = 0\n    var result = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            vowels_count++\n        }\n        if vowels_count == 2 {\n            result += string(vowels[vowels.Index(letter) + 1])\n            vowels_count = 0\n        } else {\n            result += string(letter)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmptt8kytn2.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmptt8kytn2.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char == ' ' {\n            encoded += \" \"\n            continue\n        }\n        if char == '.' {\n            encoded += \".\"\n            continue\n        }\n        if char == ',' {\n            encoded += \",\"\n            continue\n        }\n        if char == '!' {\n            encoded += \"!\"\n            continue\n        }\n        if char == '?' {\n            encoded += \"?\"\n            continue\n        }\n        if char == '\\'' {\n            encoded += \"'\"\n            continue\n        }\n        if char == '\\\"' {\n            encoded += \"\\\"\"\n            continue\n        }\n        if char == '\\n' {\n            encoded += \"n\"\n            continue\n        }\n        if char == '\\t' {\n            encoded += \"t\"\n            continue\n        }\n        if char == '\\r' {\n            encoded += \"r\"\n            continue\n        }\n        if char == '\\b' {\n            encoded += \"b\"\n            continue\n        }\n        if char == '\\f' {\n            encoded += \"f\"\n            continue\n        }\n        if char == '\\v' {\n            encoded += \"v\"\n            continue\n        }\n        if char == '\\a' {\n            encoded += \"a\"\n            continue\n        }\n        if char == '\\0' {\n            encoded += \"0\"\n            continue\n        }\n        if char == '\\x0B' {\n            encoded += \"0\"\n            continue\n        }\n        if char == '\\x0C' {\n            encoded += \"0\"\n            continue\n        }\n        if char == '\\x0E' {\n            encoded += \"0\"\n            continue\n        }\n        if char == '\\x0F' {\n            encoded += \"0\"\n            continue\n        }\n        if char == '\\x10' {\n            encoded += \"0\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpsdl5caoe.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmpsdl5caoe.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmpsdl5caoe.swift:17:20: error: single-quoted string literal found, use '\"'\n        if char == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmpsdl5caoe.swift:21:20: error: single-quoted string literal found, use '\"'\n        if char == '.' {\n                   ^~~\n                   \".\"\n/tmp/tmpsdl5caoe.swift:25:20: error: single-quoted string literal found, use '\"'\n        if char == ',' {\n                   ^~~\n                   \",\"\n/tmp/tmpsdl5caoe.swift:29:20: error: single-quoted string literal found, use '\"'\n        if char == '!' {\n                   ^~~\n                   \"!\"\n/tmp/tmpsdl5caoe.swift:33:20: error: single-quoted string literal found, use '\"'\n        if char == '?' {\n                   ^~~\n                   \"?\"\n/tmp/tmpsdl5caoe.swift:37:20: error: single-quoted string literal found, use '\"'\n        if char == '\\'' {\n                   ^~~~\n                   \"'\"\n/tmp/tmpsdl5caoe.swift:41:20: error: single-quoted string literal found, use '\"'\n        if char == '\\\"' {\n                   ^~~~\n                   \"\\\"\"\n/tmp/tmpsdl5caoe.swift:45:20: error: single-quoted string literal found, use '\"'\n        if char == '\\n' {\n                   ^~~~\n                   \"\\n\"\n/tmp/tmpsdl5caoe.swift:49:20: error: single-quoted string literal found, use '\"'\n        if char == '\\t' {\n                   ^~~~\n                   \"\\t\"\n/tmp/tmpsdl5caoe.swift:53:20: error: single-quoted string literal found, use '\"'\n        if char == '\\r' {\n                   ^~~~\n                   \"\\r\"\n/tmp/tmpsdl5caoe.swift:57:22: error: invalid escape sequence in literal\n        if char == '\\b' {\n                     ^\n/tmp/tmpsdl5caoe.swift:57:20: error: single-quoted string literal found, use '\"'\n        if char == '\\b' {\n                   ^~~~\n            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpz51dimqt.swift:14:56: error: cannot find 'function' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                       ^~~~~~~~\n/tmp/tmpz51dimqt.swift:14:65: error: cannot find 'c' in scope\n    return message.toLowerCase().replaceAll(\"[aeiou]\", function(c) {\n                                                                ^\n/tmp/tmpz51dimqt.swift:15:36: error: cannot find 'c' in scope\n        return String.fromCharCode(c.charCodeAt(0) + 2)\n                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmphn723rqu/tmphn723rqu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f76c03c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f768fab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f768fa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f768f97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphn723rqu                        0x0000560bb1802307 <unavailable> + 4871\n5    libc.so.6                          0x00002b3f76def460 __libc_start_main + 245\n6    tmphn723rqu                        0x0000560bb1801f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char == ' ' {\n            encoded += \" \"\n            continue\n        }\n        if char == '.' {\n            encoded += \".\"\n            continue\n        }\n        if char == ',' {\n            encoded += \",\"\n            continue\n        }\n        if char == '!' {\n            encoded += \"!\"\n            continue\n        }\n        if char == '?' {\n            encoded += \"?\"\n            continue\n        }\n        if char == '\\'' {\n            encoded += \"'\"\n            continue\n        }\n        if char == '\\\"' {\n            encoded += \"\\\"\"\n            continue\n        }\n        if char == '\\n' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\t' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\r' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\b' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\f' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\v' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\a' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\0' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\x0' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\x1' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\x2' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\x3' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\x4' {\n            encoded += \" \"\n            continue\n        }\n        if char == '\\x5' {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmptjjhbb3d.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmptjjhbb3d.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmptjjhbb3d.swift:17:20: error: single-quoted string literal found, use '\"'\n        if char == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmptjjhbb3d.swift:21:20: error: single-quoted string literal found, use '\"'\n        if char == '.' {\n                   ^~~\n                   \".\"\n/tmp/tmptjjhbb3d.swift:25:20: error: single-quoted string literal found, use '\"'\n        if char == ',' {\n                   ^~~\n                   \",\"\n/tmp/tmptjjhbb3d.swift:29:20: error: single-quoted string literal found, use '\"'\n        if char == '!' {\n                   ^~~\n                   \"!\"\n/tmp/tmptjjhbb3d.swift:33:20: error: single-quoted string literal found, use '\"'\n        if char == '?' {\n                   ^~~\n                   \"?\"\n/tmp/tmptjjhbb3d.swift:37:20: error: single-quoted string literal found, use '\"'\n        if char == '\\'' {\n                   ^~~~\n                   \"'\"\n/tmp/tmptjjhbb3d.swift:41:20: error: single-quoted string literal found, use '\"'\n        if char == '\\\"' {\n                   ^~~~\n                   \"\\\"\"\n/tmp/tmptjjhbb3d.swift:45:20: error: single-quoted string literal found, use '\"'\n        if char == '\\n' {\n                   ^~~~\n                   \"\\n\"\n/tmp/tmptjjhbb3d.swift:49:20: error: single-quoted string literal found, use '\"'\n        if char == '\\t' {\n                   ^~~~\n                   \"\\t\"\n/tmp/tmptjjhbb3d.swift:53:20: error: single-quoted string literal found, use '\"'\n        if char == '\\r' {\n                   ^~~~\n                   \"\\r\"\n/tmp/tmptjjhbb3d.swift:57:22: error: invalid escape sequence in literal\n        if char == '\\b' {\n                     ^\n/tmp/tmptjjhbb3d.swift:57:20: error: single-quoted string literal found, use '\"'\n        if char == '\\b' {\n                   ^~~~\n            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var vowels3 = \"AEIOUYX\"\n    var vowels4 = \"AEIOUYXW\"\n    var vowels5 = \"AEIOUYXWV\"\n    var vowels6 = \"AEIOUYXWVZ\"\n    var vowels7 = \"AEIOUYXWVZB\"\n    var vowels8 = \"AEIOUYXWVZBX\"\n    var vowels9 = \"AEIOUYXWVZBXD\"\n    var vowels10 = \"AEIOUYXWVZBXDG\"\n    var vowels11 = \"AEIOUYXWVZBXDGX\"\n    var vowels12 = \"AEIOUYXWVZBXDGXH\"\n    var vowels13 = \"AEIOUYXWVZBXDGXHZ\"\n    var vowels14 = \"AEIOUYXWVZBXDGXHZB\"\n    var vowels15 = \"AEIOUYXWVZBXDGXHZBX\"\n    var vowels16 = \"AEIOUYXWVZBXDGXHZBXD\"\n    var vowels17 = \"AEIOUYXWVZBXDGXHZBXDG\"\n    var vowels18 = \"AEIOUYXWVZBXDGXHZBXDGX\"\n    var vowels19 = \"AEIOUYXWVZBXDGXHZBXDGXH\"\n    var vowels20 = \"AEIOUYXWVZBXDGXHZBXDGXHZ\"\n    var vowels21 = \"AEIOUYXWVZBXDGXHZBXDGXHZB\"\n    var vowels22 = \"AEIOUYXWVZBXDGXHZBXDGXHZBX\"\n    var vowels23 = \"AEIOUYXWVZB\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpm9kzlrqr.swift:36:20: error: unterminated string literal\n    var vowels23 = \"AEIOUYXWVZB\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpn03nt268.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpn03nt268.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var vowels_count = 0\n    var encoded_message = \"\"\n    for i := 0; i < len(message); i++ {\n        if vowels.Contains(message[i]) {\n            vowels_count += 1\n            encoded_message += message[i]\n            if vowels_count == 2 {\n                encoded_message += message[i+2]\n            }\n        } else {\n            encoded_message += message[i].ToUpper()\n        }\n    }\n    return encoded_message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp7hk0tce_.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp7hk0tce_.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp7hk0tce_.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp98274me5.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp98274me5.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp98274me5.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp98274me5.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp9dmxsc1_/tmp9dmxsc1_.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae1c2b01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae1c27f8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae1c27f8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae1c27f77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9dmxsc1_                        0x0000561fc53fc307 <unavailable> + 4871\n5    libc.so.6                          0x00002ae1c2ced460 __libc_start_main + 245\n6    tmp9dmxsc1_                        0x0000561fc53fbf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYX\"\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else if message[i] in vowels_2 {\n            result += message[i] + message[i+1]\n        } else if message[i] in vowels_3 {\n            result += message[i] + message[i+1]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp9det0ddr.swift:20:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp9det0ddr.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp9det0ddr.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp9det0ddr.swift:21:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmp9det0ddr.swift:23:30: error: expected '{' after 'if' condition\n        } else if message[i] in vowels_2 {\n                             ^\n/tmp/tmp9det0ddr.swift:25:30: error: expected '{' after 'if' condition\n        } else if message[i] in vowels_3 {\n                             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp98274me5.swift:19:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp98274me5.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp98274me5.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp98274me5.swift:20:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp32h58g47.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    \n    var encoded = \"\"\n    \n    for _, letter := range message {\n        if vowels.indexOf(letter) != -1 {\n            encoded += consonants[vowels.indexOf(letter) + 2]\n        } else {\n            encoded += letter\n        }\n    }\n    \n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpem2k3fgi.swift:19:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpem2k3fgi.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"aeiouAEIOU\"\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpkt9av_0k.swift:14:26: error: consecutive statements on a line must be separated by ';'\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472\n                         ^\n                         ;\n/tmp/tmpkt9av_0k.swift:14:31: error: consecutive statements on a line must be separated by ';'\n    var vowels_index = []int{0, 2, 4, 5, 7, 9, 11, 13, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "tmp8uia32t_/tmp8uia32t_.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b66c84d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b66c81d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b66c81d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66c81cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8uia32t_                        0x00005605bd93c307 <unavailable> + 4871\n5    libc.so.6                          0x00002b66c86c5460 __libc_start_main + 245\n6    tmp8uia32t_                        0x00005605bd93bf49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            encoded += consonants[(vowels.index(message[i]) + 2) % len(vowels)] + message[i]\n        } else {\n            encoded += message[i]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpn03nt268.swift:16:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpn03nt268.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpn03nt268.swift:17:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels_2 = \"AEIOUY\"\n    var vowels_3 = \"AEIOUYAEIOU\"\n    \n    var vowels_count = 0\n    var vowels_count_2 = 0\n    var vowels_count_3 = 0\n    \n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        \n        if message[i] in vowels {\n            vowels_count++\n        }\n        \n        if message[i] in vowels_2 {\n            vowels_count_2++\n        }\n        \n        if message[i] in vowels_3 {\n            vowels_count_3++\n        }\n        \n        if vowels_count == 0 {\n            result += message[i]\n        } else if vowels_count == 1 {\n            result += message[i] + message[i]\n        } else if vowels_count == 2 {\n            result += message[i] + message[i] + message[i]\n        } else if vowels_count == 3 {\n            result += message[i] + message[i] + message[i] + message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp402b53el.swift:24:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp402b53el.swift:24:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp402b53el.swift:24:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp402b53el.swift:26:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n/tmp/tmp402b53el.swift:30:23: error: expected '{' after 'if' condition\n        if message[i] in vowels_2 {\n                      ^\n/tmp/tmp402b53el.swift:34:23: error: expected '{' after 'if' condition\n        if message[i] in vowels_3 {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, letter := range message {\n        if vowels.Contains(letter) {\n            encoded += consonants[vowels.Index(letter) + 2]\n        } else {\n            encoded += consonants[vowels.Index(letter)]\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "/tmp/tmpdxuw9vjp.swift:16:10: error: expected 'in' after for-each pattern\n    for _, letter := range message {\n         ^\n/tmp/tmpdxuw9vjp.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, letter := range message {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i+2]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpy23k89l6.swift:18:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmpy23k89l6.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpy23k89l6.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmpy23k89l6.swift:19:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var vowels = \"AEIOU\"\n    var vowels2 = \"AEIOUY\"\n    var result = \"\"\n    \n    for i := 0; i < len(message); i++ {\n        if message[i] in vowels {\n            result += message[i] + message[i + 2]\n        } else {\n            result += message[i]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmp480dsm_s.swift:18:12: error: expected type\n    for i := 0; i < len(message); i++ {\n           ^\n            <#type#>\n/tmp/tmp480dsm_s.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp480dsm_s.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(message); i++ {\n           ^\n/tmp/tmp480dsm_s.swift:19:23: error: expected '{' after 'if' condition\n        if message[i] in vowels {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message: \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var vowels = \"AEIOU\"\n    var consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n    var encoded = \"\"\n    for _, char := range message {\n        if char == ' ' {\n            encoded += \" \"\n        } else if char == '.' {\n            encoded += \" \"\n        } else if char == ',' {\n            encoded += \" \"\n        } else if char == '!' {\n            encoded += \" \"\n        } else if char == '?' {\n            encoded += \" \"\n        } else if char == '\\'' {\n            encoded += \" \"\n        } else if char == '\"') {\n            encoded += \" \"\n        } else if char == ';' {\n            encoded += \" \"\n        } else if char == ':' {\n            encoded += \" \"\n        } else if char == '-' {\n            encoded += \" \"\n        } else if char == '_' {\n            encoded += \" \"\n        } else if char == '(' {\n            encoded += \" \"\n        } else if char == ')' {\n            encoded += \" \"\n        } else if char == '{' {\n            encoded += \" \"\n        } else if char == '}' {\n            encoded += \" \"\n        } else if char == '[' {\n            encoded += \" \"\n        } else if char == ']' {\n            encoded += \" \"\n        } else if char == '&' {\n            encoded += \" \"\n        } else if char == '@' {\n            encoded += \" \"\n        } else if char == '#' {\n            encoded += \" \"\n        } else if char == '$' {\n            encoded += \" \"\n        } else if char == '%' {\n            encoded += \" \"\n        } else if char == '^' {\n            encoded += \" \"\n        } else if char == '*' {\n            encoded += \" \"\n        } else if char == '+' {\n            encoded += \" \"\n        } else if char == '=' {\n            encoded += \" \"\n        } else if char == '|' {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "/tmp/tmpy2jj_f9f.swift:16:10: error: expected 'in' after for-each pattern\n    for _, char := range message {\n         ^\n/tmp/tmpy2jj_f9f.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, char := range message {\n         ^\n/tmp/tmpy2jj_f9f.swift:17:20: error: single-quoted string literal found, use '\"'\n        if char == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmpy2jj_f9f.swift:19:27: error: single-quoted string literal found, use '\"'\n        } else if char == '.' {\n                          ^~~\n                          \".\"\n/tmp/tmpy2jj_f9f.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ',' {\n                          ^~~\n                          \",\"\n/tmp/tmpy2jj_f9f.swift:23:27: error: single-quoted string literal found, use '\"'\n        } else if char == '!' {\n                          ^~~\n                          \"!\"\n/tmp/tmpy2jj_f9f.swift:25:27: error: single-quoted string literal found, use '\"'\n        } else if char == '?' {\n                          ^~~\n                          \"?\"\n/tmp/tmpy2jj_f9f.swift:27:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\\'' {\n                          ^~~~\n                          \"'\"\n/tmp/tmpy2jj_f9f.swift:29:27: error: single-quoted string literal found, use '\"'\n        } else if char == '\"') {\n                          ^~~\n                          \"\\\"\"\n/tmp/tmpy2jj_f9f.swift:29:30: error: expected '{' after 'if' condition\n        } else if char == '\"') {\n                             ^\n/tmp/tmpy2jj_f9f.swift:31:27: error: single-quoted string literal found, use '\"'\n        } else if char == ';' {\n                          ^~~\n                          \";\"\n/tmp/tmpy2jj_f9f.swift:33:27: error: single-quoted string literal found, use '\"'\n        } else if char == ':' {\n                          ^~~\n                          \":\"\n/tmp/tmpy2jj_f9f.swift:35:27: error: single-quoted string literal found, use '\"'\n        } else if char == '-' {\n          ",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}