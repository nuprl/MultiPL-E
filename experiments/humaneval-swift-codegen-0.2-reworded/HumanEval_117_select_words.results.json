{
  "name": "HumanEval_117_select_words",
  "language": "swift",
  "prompt": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t\ti += n\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmp134x41kt.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp134x41kt.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp134x41kt.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp134x41kt.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp134x41kt.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp134x41kt.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp134x41kt.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp134x41kt.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp134x41kt.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp134x41kt.swift:33:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) < n {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) == n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t\tif len(s[i:]) > n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpanpdxghg.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpanpdxghg.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpanpdxghg.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpanpdxghg.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpanpdxghg.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpanpdxghg.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpanpdxghg.swift:27:14: error: expected expression in list of expressions\n                if len(s[i:]) < n {\n                           ^\n/tmp/tmpanpdxghg.swift:30:14: error: expected expression in list of expressions\n                if len(s[i:]) == n {\n                           ^\n/tmp/tmpanpdxghg.swift:33:14: error: expected expression in list of expressions\n                if len(s[i:]) > n {\n                           ^\n/tmp/tmpanpdxghg.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpanpdxghg.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpanpdxghg.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpanpdxghg.swift:37:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\tif len(word) == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpdik_ud07.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpdik_ud07.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpdik_ud07.swift:27:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmplualcl73.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmplualcl73.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmplualcl73.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmplualcl73.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplualcl73.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplualcl73.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplualcl73.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmplualcl73.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmplualcl73.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmplualcl73.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif n > 0 {\n\t\t\tn--\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tcontinue\n\t\t}\n\t\tn = 0\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmp6637g5l0.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmp6637g5l0.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmp6637g5l0.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp6637g5l0.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp6637g5l0.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp6637g5l0.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp6637g5l0.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmp6637g5l0.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmp6637g5l0.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmp6637g5l0.swift:19:15: error: expected member name or constructor call after type name\n        var result []String\n                     ^\n/tmp/tmp6637g5l0.swift:19:15: note: add arguments after the type to construct a value of the type\n        var result []String\n                     ^\n                           ()\n/tmp/tmp6637g5l0.swift:19:15: note: use '.self' to reference the type object\n        var result []String\n                     ^\n                           .self\n/tmp/tmp6637g5l0.swift:19:15: warning: expression of type 'String.Type' is unused\n        var result []String\n                     ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t\ti += 1\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpha2xy3oi.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpha2xy3oi.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpha2xy3oi.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpha2xy3oi.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpha2xy3oi.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpha2xy3oi.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpha2xy3oi.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpha2xy3oi.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpha2xy3oi.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpha2xy3oi.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmplhxhp7l2.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmplhxhp7l2.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmplhxhp7l2.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmplhxhp7l2.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplhxhp7l2.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplhxhp7l2.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:29:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:34:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:39:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:44:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:49:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:54:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:59:14: error: single-quoted string literal found, use '\"'\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpondem_k2.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpondem_k2.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpondem_k2.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpondem_k2.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpondem_k2.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpondem_k2.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpondem_k2.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpondem_k2.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []string{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\tbreak\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpf_8u_c65.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []string{}\n             ^\n             ;\n/tmp/tmpf_8u_c65.swift:19:8: error: expected expression\n        words := []string{}\n              ^\n/tmp/tmpf_8u_c65.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpf_8u_c65.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpf_8u_c65.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpf_8u_c65.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpf_8u_c65.swift:19:2: error: cannot find 'words' in scope\n        words := []string{}\n        ^~~~~\n/tmp/tmpf_8u_c65.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpf_8u_c65.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpf_8u_c65.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Fields(s) {\n\t\tif len(word) == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpx221y3ew.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpx221y3ew.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpx221y3ew.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Fields(s) {\n             ^\n/tmp/tmpx221y3ew.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Fields(s) {\n             ^\n/tmp/tmpx221y3ew.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpx221y3ew.swift:25:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = []String{}\n\tvar word = \"\"\n\tvar count = 0\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tif len(word) > 0 {\n\t\t\t\tif count == n {\n\t\t\t\t\twords = append(words, word)\n\t\t\t\t}\n\t\t\t\tword = \"\"\n\t\t\t\tcount = 0\n\t\t\t}\n\t\t} else {\n\t\t\tword += s[i]\n\t\t\tcount++\n\t\t}\n\t}\n\tif len(word) > 0 {\n\t\tif count == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpiudtxoz8.swift:19:16: error: consecutive statements on a line must be separated by ';'\n        var words = []String{}\n                      ^\n                      ;\n/tmp/tmpiudtxoz8.swift:22:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpiudtxoz8.swift:22:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpiudtxoz8.swift:22:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpiudtxoz8.swift:23:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpiudtxoz8.swift:19:14: error: empty collection literal requires an explicit type\n        var words = []String{}\n                    ^~\n/tmp/tmpiudtxoz8.swift:19:16: error: ambiguous use of 'init'\n        var words = []String{}\n                      ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpiudtxoz8.swift:36:5: error: cannot find 'len' in scope\n        if len(word) > 0 {\n           ^~~\n/tmp/tmpiudtxoz8.swift:38:12: error: cannot find 'append' in scope\n                        words = append(words, word)\n                                ^~~~~~\n/tmp/tmpiudtxoz8.swift:41:9: error: cannot convert return expression of type '[Any]' to return type '[String]'\n        return words\n               ^\n/tmp/tmpiudtxoz8.swift:41:9: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n        return words\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif i+n == len(s) {\n\t\t\twords = append(words, s[i:])\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == \" \" {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpn2cnayfq.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpn2cnayfq.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpn2cnayfq.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpn2cnayfq.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpn2cnayfq.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpn2cnayfq.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpn2cnayfq.swift:31:30: error: expected expression in list of expressions\n                        words = append(words, s[i:])\n                                                  ^\n/tmp/tmpn2cnayfq.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpn2cnayfq.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpn2cnayfq.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpn2cnayfq.swift:38:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpondem_k2.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpondem_k2.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpondem_k2.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpondem_k2.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpondem_k2.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpondem_k2.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpondem_k2.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpondem_k2.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tvar count int\n\t\tfor j := i; j < len(s); j++ {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif s[j] == 'a' || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u' {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count == n {\n\t\t\tresult = append(result, s[i:j])\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmp0k1q4g6o.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmp0k1q4g6o.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmp0k1q4g6o.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp0k1q4g6o.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp0k1q4g6o.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp0k1q4g6o.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp0k1q4g6o.swift:24:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n                var count int\n                          ^\n/tmp/tmp0k1q4g6o.swift:24:13: note: join the identifiers together\n                var count int\n                    ~~~~~~^~~\n                    countint\n/tmp/tmp0k1q4g6o.swift:24:13: note: join the identifiers together with camel-case\n                var count int\n                    ~~~~~~^~~\n                    countInt\n/tmp/tmp0k1q4g6o.swift:25:10: error: expected type\n                for j := i; j < len(s); j++ {\n                       ^\n                        <#type#>\n/tmp/tmp0k1q4g6o.swift:25:10: error: expected 'in' after for-each pattern\n                for j := i; j < len(s); j++ {\n                       ^\n/tmp/tmp0k1q4g6o.swift:25:10: error: expected Sequence expression for for-each loop\n                for j := i; j < len(s); j++ {\n                       ^\n/tmp/tmp0k1q4g6o.swift:26:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar res = []String{}\n\tvar words = strings.Split(s, \" \")\n\tfor _, word := range words {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar count = 0\n\t\tfor _, c := range word {\n\t\t\tif c == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcount++\n\t\t}\n\t\tif count == n {\n\t\t\tres = append(res, word)\n\t\t}\n\t}\n\treturn res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpld4z380u.swift:19:14: error: consecutive statements on a line must be separated by ';'\n        var res = []String{}\n                    ^\n                    ;\n/tmp/tmpld4z380u.swift:21:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpld4z380u.swift:21:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpld4z380u.swift:26:8: error: expected 'in' after for-each pattern\n                for _, c := range word {\n                     ^\n/tmp/tmpld4z380u.swift:26:8: error: expected Sequence expression for for-each loop\n                for _, c := range word {\n                     ^\n/tmp/tmpld4z380u.swift:27:12: error: single-quoted string literal found, use '\"'\n                        if c == ' ' {\n                                ^~~\n                                \" \"\n/tmp/tmpld4z380u.swift:19:12: error: empty collection literal requires an explicit type\n        var res = []String{}\n                  ^~\n/tmp/tmpld4z380u.swift:19:14: error: ambiguous use of 'init'\n        var res = []String{}\n                    ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpld4z380u.swift:20:14: error: cannot find 'strings' in scope\n        var words = strings.Split(s, \" \")\n                    ^~~~~~~\n/tmp/tmpld4z380u.swift:36:9: error: cannot convert return expression of type '[Any]' to return type '[String]'\n        return res\n               ^\n/tmp/tmpld4z380u.swift:36:9: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n        return res\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\tvar i int\n\tvar j int\n\tvar k int\n\tvar l int\n\tvar m int\n\tvar n int\n\tvar n_consonants int\n\tvar n_consonant_count int\n\tvar consonant_count int\n\tvar consonant_count_array []int\n\tvar consonant_count_array_length int\n\tvar consonant_count_array_length_max int\n\tvar consonant_count_array_length_min int\n\tvar consonant_count_array_length_sum int\n\tvar consonant_count_array_sum int\n\tvar consonant_count_array_sum_max int\n\tvar consonant_count_array_sum_min int\n\tvar consonant_count_array_sum_sum int\n\tvar consonant_count_array_sum_sum_max int\n\tvar consonant_count_array_sum_sum_min int\n\tvar consonant_count_array_sum_sum_sum int\n\tvar consonant_count_array_sum_sum_sum_max int\n\tvar consonant_count_array_sum_sum_sum_min int\n\tvar consonant_count_array_sum_sum_sum_sum int\n\tvar consonant_count_array_sum_sum_sum_sum_max int\n\tvar consonant_count_array_sum_sum_sum_sum_min int\n\tvar consonant_count_array_sum_sum_sum_sum_sum int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_max int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_min int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_sum int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_sum_max int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_sum_min int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_sum_sum int\n\tvar consonant_count_array_sum_sum_sum_sum_sum_sum_sum_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpabhw0rv6.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpabhw0rv6.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpabhw0rv6.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpabhw0rv6.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpabhw0rv6.swift:21:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i int\n              ^\n/tmp/tmpabhw0rv6.swift:21:8: note: join the identifiers together\n        var i int\n            ~~^~~\n            iint\n/tmp/tmpabhw0rv6.swift:21:8: note: join the identifiers together with camel-case\n        var i int\n            ~~^~~\n            iInt\n/tmp/tmpabhw0rv6.swift:22:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var j int\n              ^\n/tmp/tmpabhw0rv6.swift:22:8: note: join the identifiers together\n        var j int\n            ~~^~~\n            jint\n/tmp/tmpabhw0rv6.swift:22:8: note: join the identifiers together with camel-case\n        var j int\n            ~~^~~\n            jInt\n/tmp/tmpabhw0rv6.swift:23:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var k int\n              ^\n/tmp/tmpabhw0rv6.swift:23:8: note: join the identifiers together\n        var k int\n            ~~^~~\n            kint\n/tmp/tmpabhw0rv6.swift:23:8: note: join the identifiers together with camel-case\n        var k int\n            ~~^~~\n            kInt\n/tmp/tmpabhw0rv6.swift:24:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var l in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\tbreak\n\t\t}\n\t\tif i+1 < len(s) && s[i] == s[i+1] {\n\t\t\twords = append(words, s[i:i+2])\n\t\t\ti++\n\t\t} else {\n\t\t\twords = append(words, s[i:i+1])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpz4l2ep7s.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpz4l2ep7s.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpz4l2ep7s.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpz4l2ep7s.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpz4l2ep7s.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpz4l2ep7s.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpz4l2ep7s.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpz4l2ep7s.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpz4l2ep7s.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpz4l2ep7s.swift:37:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i + n < len(s) {\n\t\t\tif s[i+n] == ' ' {\n\t\t\t\twords = append(words, s[i:i+n])\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmp_k32r45q.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_k32r45q.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_k32r45q.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_k32r45q.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_k32r45q.swift:25:17: error: single-quoted string literal found, use '\"'\n                        if s[i+n] == ' ' {\n                                     ^~~\n                                     \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) < n {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) == n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t\tif len(s[i:]) > n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpanpdxghg.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpanpdxghg.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpanpdxghg.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpanpdxghg.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpanpdxghg.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpanpdxghg.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpanpdxghg.swift:27:14: error: expected expression in list of expressions\n                if len(s[i:]) < n {\n                           ^\n/tmp/tmpanpdxghg.swift:30:14: error: expected expression in list of expressions\n                if len(s[i:]) == n {\n                           ^\n/tmp/tmpanpdxghg.swift:33:14: error: expected expression in list of expressions\n                if len(s[i:]) > n {\n                           ^\n/tmp/tmpanpdxghg.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpanpdxghg.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpanpdxghg.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpanpdxghg.swift:37:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tconsonants := 0\n\t\tfor _, c := range word {\n\t\t\tif c == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconsonants += 1\n\t\t}\n\t\tif consonants == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpfujvehwx.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpfujvehwx.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpfujvehwx.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpfujvehwx.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpfujvehwx.swift:24:13: error: consecutive statements on a line must be separated by ';'\n                consonants := 0\n                          ^\n                          ;\n/tmp/tmpfujvehwx.swift:24:14: error: expected expression\n                consonants := 0\n                           ^\n/tmp/tmpfujvehwx.swift:25:8: error: expected 'in' after for-each pattern\n                for _, c := range word {\n                     ^\n/tmp/tmpfujvehwx.swift:25:8: error: expected Sequence expression for for-each loop\n                for _, c := range word {\n                     ^\n/tmp/tmpfujvehwx.swift:26:12: error: single-quoted string literal found, use '\"'\n                        if c == ' ' {\n                                ^~~\n                                \" \"\n/tmp/tmpfujvehwx.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpfujvehwx.swift:35:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\tif i == len(s)-1 {\n\t\t\twords = append(words, s[i:])\n\t\t} else {\n\t\t\twords = append(words, s[i:i+1])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpu3kl26ks.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpu3kl26ks.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpu3kl26ks.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpu3kl26ks.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpu3kl26ks.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpu3kl26ks.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpu3kl26ks.swift:31:30: error: expected expression in list of expressions\n                        words = append(words, s[i:])\n                                                  ^\n/tmp/tmpu3kl26ks.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpu3kl26ks.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpu3kl26ks.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpu3kl26ks.swift:36:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpbs803i3w.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpbs803i3w.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpbs803i3w.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpbs803i3w.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpbs803i3w.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpbs803i3w.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpbs803i3w.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpbs803i3w.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpbs803i3w.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpbs803i3w.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tfor i < len(s) {\n\t\tif s[i] == ' ' {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tvar j: Int = i\n\t\tfor j < len(s) {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tj++\n\t\t}\n\t\tif j - i == n {\n\t\t\twords = append(words, s[i:j])\n\t\t\ti = j\n\t\t}\n\t\ti++\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp1505jwgv.swift:21:8: error: expected 'in' after for-each pattern\n        for i < len(s) {\n              ^\n/tmp/tmp1505jwgv.swift:21:8: error: unary operator cannot be separated from its operand\n        for i < len(s) {\n              ^~\n               \n/tmp/tmp1505jwgv.swift:22:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp1505jwgv.swift:27:9: error: expected 'in' after for-each pattern\n                for j < len(s) {\n                      ^\n/tmp/tmp1505jwgv.swift:27:9: error: unary operator cannot be separated from its operand\n                for j < len(s) {\n                      ^~\n                       \n/tmp/tmp1505jwgv.swift:28:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n                                   \" \"\n/tmp/tmp1505jwgv.swift:21:8: error: '<' is not a prefix unary operator\n        for i < len(s) {\n              ^\n/tmp/tmp1505jwgv.swift:21:10: error: cannot find 'len' in scope\n        for i < len(s) {\n                ^~~\n/tmp/tmp1505jwgv.swift:27:9: error: '<' is not a prefix unary operator\n                for j < len(s) {\n                      ^\n/tmp/tmp1505jwgv.swift:27:11: error: cannot find 'len' in scope\n                for j < len(s) {\n                        ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n <= len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp_89zagww.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp_89zagww.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp_89zagww.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_89zagww.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_89zagww.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp_89zagww.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp_89zagww.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp_89zagww.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmprww1wos3.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmprww1wos3.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmprww1wos3.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmprww1wos3.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmprww1wos3.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmprww1wos3.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmprww1wos3.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmprww1wos3.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmprww1wos3.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmprww1wos3.swift:35:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int = 0\n\tvar t: Int = 0\n\tvar u: Int = 0\n\tvar v: Int = 0\n\tvar w: Int = 0\n\tvar x: Int = 0\n\tvar y: Int = 0\n\tvar z: Int = 0\n\tvar a: Int = 0\n\tvar b: Int = 0\n\tvar c: Int = 0\n\tvar d: Int = 0\n\tvar e: Int = 0\n\tvar f: Int = 0\n\tvar g: Int = 0\n\tvar h: Int = 0\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int = 0\n\tvar t: Int = 0\n\tvar u: Int = 0\n\tvar v: Int = 0\n\tvar w: Int = 0\n\tvar x: Int = 0\n\tvar y: Int = 0\n\tvar z: Int = 0\n\tvar a: Int = 0\n\tvar b: Int = 0\n\tvar c: Int = 0\n\tvar d: Int = 0\n\tvar e: Int = 0\n\tvar f: Int = 0\n\tvar g: Int = 0\n\tvar h: Int = 0\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpn_reijbq.swift:82:14: error: expected initial value after '='\n        var s: Int =\n                    ^\n/tmp/tmpn_reijbq.swift:46:6: error: invalid redeclaration of 'i'\n        var i: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:20:6: note: 'i' previously declared here\n        var i: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:47:6: error: invalid redeclaration of 'j'\n        var j: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:21:6: note: 'j' previously declared here\n        var j: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:48:6: error: invalid redeclaration of 'k'\n        var k: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:22:6: note: 'k' previously declared here\n        var k: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:49:6: error: invalid redeclaration of 'l'\n        var l: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:23:6: note: 'l' previously declared here\n        var l: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:50:6: error: invalid redeclaration of 'm'\n        var m: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:24:6: note: 'm' previously declared here\n        var m: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:51:6: error: invalid redeclaration of 'n'\n        var n: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:25:6: note: 'n' previously declared here\n        var n: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:52:6: error: invalid redeclaration of 'o'\n        var o: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:26:6: note: 'o' previously declared here\n        var o: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:53:6: error: invalid redeclaration of 'p'\n        var p: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:27:6: note: 'p' previously declared here\n        var p: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:54:6: error: invalid redeclaration of 'q'\n        var q: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:28:6: note: 'q' previously declared here\n        var q: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:55:6: error: invalid redeclaration of 'r'\n        var r: Int = 0\n            ^\n/tmp/t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\tif s[i+n] == ' ' {\n\t\t\t\twords = append(words, s[i:i+n])\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpuvndu5bi.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpuvndu5bi.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpuvndu5bi.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpuvndu5bi.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpuvndu5bi.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpuvndu5bi.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpuvndu5bi.swift:28:17: error: single-quoted string literal found, use '\"'\n                        if s[i+n] == ' ' {\n                                     ^~~\n                                     \" \"\n/tmp/tmpuvndu5bi.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpuvndu5bi.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpuvndu5bi.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpuvndu5bi.swift:33:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int = 0\n\tvar t: Int = 0\n\tvar u: Int = 0\n\tvar v: Int = 0\n\tvar w: Int = 0\n\tvar x: Int = 0\n\tvar y: Int = 0\n\tvar z: Int = 0\n\tvar a: Int = 0\n\tvar b: Int = 0\n\tvar c: Int = 0\n\tvar d: Int = 0\n\tvar e: Int = 0\n\tvar f: Int = 0\n\tvar g: Int = 0\n\tvar h: Int = 0\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int = 0\n\tvar t: Int = 0\n\tvar u: Int = 0\n\tvar v: Int = 0\n\tvar w: Int = 0\n\tvar x: Int = 0\n\tvar y: Int = 0\n\tvar z: Int = 0\n\tvar a: Int = 0\n\tvar b: Int = 0\n\tvar c: Int = 0\n\tvar d: Int = 0\n\tvar e: Int = 0\n\tvar f: Int = 0\n\tvar g: Int = 0\n\tvar h: Int = 0\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpn_reijbq.swift:82:14: error: expected initial value after '='\n        var s: Int =\n                    ^\n/tmp/tmpn_reijbq.swift:46:6: error: invalid redeclaration of 'i'\n        var i: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:20:6: note: 'i' previously declared here\n        var i: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:47:6: error: invalid redeclaration of 'j'\n        var j: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:21:6: note: 'j' previously declared here\n        var j: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:48:6: error: invalid redeclaration of 'k'\n        var k: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:22:6: note: 'k' previously declared here\n        var k: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:49:6: error: invalid redeclaration of 'l'\n        var l: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:23:6: note: 'l' previously declared here\n        var l: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:50:6: error: invalid redeclaration of 'm'\n        var m: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:24:6: note: 'm' previously declared here\n        var m: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:51:6: error: invalid redeclaration of 'n'\n        var n: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:25:6: note: 'n' previously declared here\n        var n: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:52:6: error: invalid redeclaration of 'o'\n        var o: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:26:6: note: 'o' previously declared here\n        var o: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:53:6: error: invalid redeclaration of 'p'\n        var p: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:27:6: note: 'p' previously declared here\n        var p: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:54:6: error: invalid redeclaration of 'q'\n        var q: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:28:6: note: 'q' previously declared here\n        var q: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:55:6: error: invalid redeclaration of 'r'\n        var r: Int = 0\n            ^\n/tmp/t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n <= len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp_89zagww.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp_89zagww.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp_89zagww.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_89zagww.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_89zagww.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp_89zagww.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp_89zagww.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp_89zagww.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\tif len(word) == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpdik_ud07.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpdik_ud07.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpdik_ud07.swift:27:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpondem_k2.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpondem_k2.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpondem_k2.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpondem_k2.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpondem_k2.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpondem_k2.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpondem_k2.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpondem_k2.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\tif len(word) == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpdik_ud07.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpdik_ud07.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpdik_ud07.swift:27:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\twords = strings.Split(s, \" \")\n\tfor _, word := range words {\n\t\tif len(word) > 0 {\n\t\t\tvar count int\n\t\t\tcount = 0\n\t\t\tfor _, c := range word {\n\t\t\t\tif c == ' ' {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcount += 1\n\t\t\t\tif count == n {\n\t\t\t\t\tresult = append(result, word)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpndb7mtlx.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpndb7mtlx.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpndb7mtlx.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpndb7mtlx.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpndb7mtlx.swift:22:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpndb7mtlx.swift:22:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpndb7mtlx.swift:24:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n                        var count int\n                                  ^\n/tmp/tmpndb7mtlx.swift:24:14: note: join the identifiers together\n                        var count int\n                            ~~~~~~^~~\n                            countint\n/tmp/tmpndb7mtlx.swift:24:14: note: join the identifiers together with camel-case\n                        var count int\n                            ~~~~~~^~~\n                            countInt\n/tmp/tmpndb7mtlx.swift:26:9: error: expected 'in' after for-each pattern\n                        for _, c := range word {\n                             ^\n/tmp/tmpndb7mtlx.swift:26:9: error: expected Sequence expression for for-each loop\n                        for _, c := range word {\n                             ^\n/tmp/tmpndb7mtlx.swift:27:13: error: single-quoted string literal found, use '\"'\n                                if c == ' ' {\n                                        ^~~\n                                        \" \"\n/tmp/tmpndb7mtlx.swif",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n <= len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp369697nn.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp369697nn.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp369697nn.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp369697nn.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i + n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpx1wxmbpw.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpx1wxmbpw.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpx1wxmbpw.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpx1wxmbpw.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\tn--\n\t\t\tcontinue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmplhxhp7l2.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmplhxhp7l2.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmplhxhp7l2.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmplhxhp7l2.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplhxhp7l2.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplhxhp7l2.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:29:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:34:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:39:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:44:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:49:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:54:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplhxhp7l2.swift:59:14: error: single-quoted string literal found, use '\"'\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []string{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tconsonants := 0\n\t\tfor _, c := range word {\n\t\t\tif c == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\t\t\t\tconsonants += 1\n\t\t\t}\n\t\t}\n\t\tif consonants == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp16w7o02k.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []string{}\n             ^\n             ;\n/tmp/tmp16w7o02k.swift:19:8: error: expected expression\n        words := []string{}\n              ^\n/tmp/tmp16w7o02k.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmp16w7o02k.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmp16w7o02k.swift:24:13: error: consecutive statements on a line must be separated by ';'\n                consonants := 0\n                          ^\n                          ;\n/tmp/tmp16w7o02k.swift:24:14: error: expected expression\n                consonants := 0\n                           ^\n/tmp/tmp16w7o02k.swift:25:8: error: expected 'in' after for-each pattern\n                for _, c := range word {\n                     ^\n/tmp/tmp16w7o02k.swift:25:8: error: expected Sequence expression for for-each loop\n                for _, c := range word {\n                     ^\n/tmp/tmp16w7o02k.swift:26:12: error: single-quoted string literal found, use '\"'\n                        if c == ' ' {\n                                ^~~\n                                \" \"\n/tmp/tmp16w7o02k.swift:29:12: error: single-quoted string literal found, use '\"'\n                        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                                ^~~\n                                \"a\"\n/tmp/tmp16w7o02k.swift:29:24: error: single-quoted string literal found, use '\"'\n                        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                                            ^~~\n                                            \"e\"\n/tmp/tmp16w7o02k.swift:29:36: error: single-quoted string literal found, use '\"'\n                        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                                                        ^~~",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif i+n == len(s) {\n\t\t\twords = append(words, s[i:])\n\t\t\tbreak\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpc8huigmw.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpc8huigmw.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpc8huigmw.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpc8huigmw.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpc8huigmw.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpc8huigmw.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpc8huigmw.swift:31:30: error: expected expression in list of expressions\n                        words = append(words, s[i:])\n                                                  ^\n/tmp/tmpc8huigmw.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpc8huigmw.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpc8huigmw.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpc8huigmw.swift:36:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmprww1wos3.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmprww1wos3.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmprww1wos3.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmprww1wos3.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmprww1wos3.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmprww1wos3.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmprww1wos3.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmprww1wos3.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmprww1wos3.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmprww1wos3.swift:35:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n <= len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp_89zagww.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp_89zagww.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp_89zagww.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_89zagww.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_89zagww.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp_89zagww.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp_89zagww.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp_89zagww.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\tif len(word) == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpdik_ud07.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpdik_ud07.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpdik_ud07.swift:27:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = []String{}\n\tvar word = \"\"\n\tvar count = 0\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\tif len(word) > 0 {\n\t\t\t\twords = append(words, word)\n\t\t\t\tword = \"\"\n\t\t\t\tcount = 0\n\t\t\t}\n\t\t} else {\n\t\t\tcount++\n\t\t\tif count == n {\n\t\t\t\twords = append(words, word)\n\t\t\t\tword = \"\"\n\t\t\t\tcount = 0\n\t\t\t}\n\t\t\tword += string(c)\n\t\t}\n\t}\n\tif len(word) > 0 {\n\t\twords = append(words, word)\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp1nattuqr.swift:19:16: error: consecutive statements on a line must be separated by ';'\n        var words = []String{}\n                      ^\n                      ;\n/tmp/tmp1nattuqr.swift:22:7: error: expected 'in' after for-each pattern\n        for _, c := range s {\n             ^\n/tmp/tmp1nattuqr.swift:22:7: error: expected Sequence expression for for-each loop\n        for _, c := range s {\n             ^\n/tmp/tmp1nattuqr.swift:23:11: error: single-quoted string literal found, use '\"'\n                if c == ' ' {\n                        ^~~\n                        \" \"\n/tmp/tmp1nattuqr.swift:19:14: error: empty collection literal requires an explicit type\n        var words = []String{}\n                    ^~\n/tmp/tmp1nattuqr.swift:19:16: error: ambiguous use of 'init'\n        var words = []String{}\n                      ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmp1nattuqr.swift:39:5: error: cannot find 'len' in scope\n        if len(word) > 0 {\n           ^~~\n/tmp/tmp1nattuqr.swift:40:11: error: cannot find 'append' in scope\n                words = append(words, word)\n                        ^~~~~~\n/tmp/tmp1nattuqr.swift:42:9: error: cannot convert return expression of type '[Any]' to return type '[String]'\n        return words\n               ^\n/tmp/tmp1nattuqr.swift:42:9: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n        return words\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpofnypc8_.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpofnypc8_.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpofnypc8_.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpofnypc8_.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:27:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:30:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:33:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:36:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:39:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:42:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:45:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:48:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpofnypc8_.swift:51:14: error: single-quoted string literal fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmphrux3kmy.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmphrux3kmy.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmphrux3kmy.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmphrux3kmy.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmphrux3kmy.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmphrux3kmy.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmphrux3kmy.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmphrux3kmy.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmphrux3kmy.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmphrux3kmy.swift:34:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\tvar i int\n\tfor i = 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\tfor i = 0; i < len(words); i++ {\n\t\tif len(words[i]) == n {\n\t\t\tresult = append(result, words[i])\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpwg6mjjiu.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpwg6mjjiu.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpwg6mjjiu.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpwg6mjjiu.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpwg6mjjiu.swift:21:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i int\n              ^\n/tmp/tmpwg6mjjiu.swift:21:8: note: join the identifiers together\n        var i int\n            ~~^~~\n            iint\n/tmp/tmpwg6mjjiu.swift:21:8: note: join the identifiers together with camel-case\n        var i int\n            ~~^~~\n            iInt\n/tmp/tmpwg6mjjiu.swift:22:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(s); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwg6mjjiu.swift:23:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpwg6mjjiu.swift:28:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(words); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwg6mjjiu.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpwg6mjjiu.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmpwg6mjjiu.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmpwg6mjjiu.swift:19:15: error: expected member name or constructor call after type name\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []string{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len(word) == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpr95t5nmi.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []string{}\n             ^\n             ;\n/tmp/tmpr95t5nmi.swift:19:8: error: expected expression\n        words := []string{}\n              ^\n/tmp/tmpr95t5nmi.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpr95t5nmi.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpr95t5nmi.swift:19:2: error: cannot find 'words' in scope\n        words := []string{}\n        ^~~~~\n/tmp/tmpr95t5nmi.swift:28:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tfor i < len(s) {\n\t\tif s[i] == ' ' {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tvar j: Int = i\n\t\tfor j < i+n {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tj++\n\t\t}\n\t\tif j == i+n {\n\t\t\twords = append(words, s[i:j])\n\t\t\ti = j\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpmqrb4kmc.swift:21:8: error: expected 'in' after for-each pattern\n        for i < len(s) {\n              ^\n/tmp/tmpmqrb4kmc.swift:21:8: error: unary operator cannot be separated from its operand\n        for i < len(s) {\n              ^~\n               \n/tmp/tmpmqrb4kmc.swift:22:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpmqrb4kmc.swift:30:9: error: expected 'in' after for-each pattern\n                for j < i+n {\n                      ^\n/tmp/tmpmqrb4kmc.swift:30:9: error: unary operator cannot be separated from its operand\n                for j < i+n {\n                      ^~\n                       \n/tmp/tmpmqrb4kmc.swift:31:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n                                   \" \"\n/tmp/tmpmqrb4kmc.swift:21:8: error: '<' is not a prefix unary operator\n        for i < len(s) {\n              ^\n/tmp/tmpmqrb4kmc.swift:21:10: error: cannot find 'len' in scope\n        for i < len(s) {\n                ^~~\n/tmp/tmpmqrb4kmc.swift:30:9: error: '<' is not a prefix unary operator\n                for j < i+n {\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\tvar i int\n\tfor i = 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\tfor i = 0; i < len(words); i++ {\n\t\tif len(words[i]) == n {\n\t\t\tresult = append(result, words[i])\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpwg6mjjiu.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpwg6mjjiu.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpwg6mjjiu.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpwg6mjjiu.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpwg6mjjiu.swift:21:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i int\n              ^\n/tmp/tmpwg6mjjiu.swift:21:8: note: join the identifiers together\n        var i int\n            ~~^~~\n            iint\n/tmp/tmpwg6mjjiu.swift:21:8: note: join the identifiers together with camel-case\n        var i int\n            ~~^~~\n            iInt\n/tmp/tmpwg6mjjiu.swift:22:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(s); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwg6mjjiu.swift:23:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpwg6mjjiu.swift:28:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(words); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwg6mjjiu.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpwg6mjjiu.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmpwg6mjjiu.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmpwg6mjjiu.swift:19:15: error: expected member name or constructor call after type name\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = []String{}\n\tvar word = \"\"\n\tvar count = 0\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\tif count == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t\tword = \"\"\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount++\n\t\t\tword += string(c)\n\t\t}\n\t}\n\tif count == n {\n\t\twords = append(words, word)\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpgg7rq6fr.swift:19:16: error: consecutive statements on a line must be separated by ';'\n        var words = []String{}\n                      ^\n                      ;\n/tmp/tmpgg7rq6fr.swift:22:7: error: expected 'in' after for-each pattern\n        for _, c := range s {\n             ^\n/tmp/tmpgg7rq6fr.swift:22:7: error: expected Sequence expression for for-each loop\n        for _, c := range s {\n             ^\n/tmp/tmpgg7rq6fr.swift:23:11: error: single-quoted string literal found, use '\"'\n                if c == ' ' {\n                        ^~~\n                        \" \"\n/tmp/tmpgg7rq6fr.swift:19:14: error: empty collection literal requires an explicit type\n        var words = []String{}\n                    ^~\n/tmp/tmpgg7rq6fr.swift:19:16: error: ambiguous use of 'init'\n        var words = []String{}\n                      ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpgg7rq6fr.swift:35:11: error: cannot find 'append' in scope\n                words = append(words, word)\n                        ^~~~~~\n/tmp/tmpgg7rq6fr.swift:37:9: error: cannot convert return expression of type '[Any]' to return type '[String]'\n        return words\n               ^\n/tmp/tmpgg7rq6fr.swift:37:9: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n        return words\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\tvar i int\n\tfor i = 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tif len(words) == n {\n\t\t\t\tresult = append(result, words)\n\t\t\t}\n\t\t\twords = []String{}\n\t\t} else {\n\t\t\twords = append(words, s[i:i+1])\n\t\t}\n\t}\n\tif len(words) == n {\n\t\tresult = append(result, words)\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpjtoglsie.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpjtoglsie.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpjtoglsie.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpjtoglsie.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpjtoglsie.swift:21:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i int\n              ^\n/tmp/tmpjtoglsie.swift:21:8: note: join the identifiers together\n        var i int\n            ~~^~~\n            iint\n/tmp/tmpjtoglsie.swift:21:8: note: join the identifiers together with camel-case\n        var i int\n            ~~^~~\n            iInt\n/tmp/tmpjtoglsie.swift:22:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(s); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjtoglsie.swift:23:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpjtoglsie.swift:27:14: error: consecutive statements on a line must be separated by ';'\n                        words = []String{}\n                                  ^\n                                  ;\n/tmp/tmpjtoglsie.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpjtoglsie.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmpjtoglsie.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmpjtoglsie.swift:19:15: error: expected member n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar word: String\n\tvar i: Int\n\tvar j: Int\n\tvar count: Int\n\tvar c: String\n\t\n\tfor i = 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tcount = 0\n\t\tfor j = i; j < len(s); j++ {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t\n\t\t\tc = s[j]\n\t\t\tif c.is_vowel() {\n\t\t\t\tcount++\n\t\t\t}\n\t\t\t\n\t\t\tif count == n {\n\t\t\t\tword = s[i:j]\n\t\t\t\twords.append(word)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpnqwh2fdt.swift:26:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(s); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnqwh2fdt.swift:27:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpnqwh2fdt.swift:32:3: error: C-style for statement has been removed in Swift 3\n                for j = i; j < len(s); j++ {\n                ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnqwh2fdt.swift:33:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n                                   \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) >= n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t\ti += n - 1\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp04_vylqt.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp04_vylqt.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp04_vylqt.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp04_vylqt.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp04_vylqt.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp04_vylqt.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp04_vylqt.swift:27:14: error: expected expression in list of expressions\n                if len(s[i:]) >= n {\n                           ^\n/tmp/tmp04_vylqt.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp04_vylqt.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp04_vylqt.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp04_vylqt.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Fields(s) {\n\t\tif len(word) == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpx221y3ew.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpx221y3ew.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpx221y3ew.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Fields(s) {\n             ^\n/tmp/tmpx221y3ew.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Fields(s) {\n             ^\n/tmp/tmpx221y3ew.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpx221y3ew.swift:25:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar word: String\n\tvar i: Int\n\tvar j: Int\n\tvar c: Int\n\tvar count: Int = 0\n\tfor i = 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tword = \"\"\n\t\tfor j = i; j < len(s); j++ {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tword += s[j]\n\t\t}\n\t\tc = 0\n\t\tfor _, v := range word {\n\t\t\tif v == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc += 1\n\t\t}\n\t\tif c == n {\n\t\t\tcount += 1\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp1i51sxs0.swift:25:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < len(s); i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1i51sxs0.swift:26:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp1i51sxs0.swift:30:3: error: C-style for statement has been removed in Swift 3\n                for j = i; j < len(s); j++ {\n                ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1i51sxs0.swift:31:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n                                   \" \"\n/tmp/tmp1i51sxs0.swift:37:8: error: expected 'in' after for-each pattern\n                for _, v := range word {\n                     ^\n/tmp/tmp1i51sxs0.swift:37:8: error: expected Sequence expression for for-each loop\n                for _, v := range word {\n                     ^\n/tmp/tmp1i51sxs0.swift:38:12: error: single-quoted string literal found, use '\"'\n                        if v == ' ' {\n                                ^~~\n                                \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i + n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpx1wxmbpw.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpx1wxmbpw.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpx1wxmbpw.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpx1wxmbpw.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpbs803i3w.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpbs803i3w.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpbs803i3w.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpbs803i3w.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpbs803i3w.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpbs803i3w.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpbs803i3w.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpbs803i3w.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpbs803i3w.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpbs803i3w.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n <= len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp_89zagww.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp_89zagww.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp_89zagww.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_89zagww.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_89zagww.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp_89zagww.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp_89zagww.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp_89zagww.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\tif count_consonants(word) == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp1pdgh36n.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp1pdgh36n.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp1pdgh36n.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmp1pdgh36n.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmp1pdgh36n.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp1pdgh36n.swift:27:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Fields(s) {\n\t\tif len(word) == n {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpx221y3ew.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpx221y3ew.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpx221y3ew.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Fields(s) {\n             ^\n/tmp/tmpx221y3ew.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Fields(s) {\n             ^\n/tmp/tmpx221y3ew.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpx221y3ew.swift:25:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\tif s[i+n] == ' ' {\n\t\t\t\twords = append(words, s[i:i+n])\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpuvndu5bi.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpuvndu5bi.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpuvndu5bi.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpuvndu5bi.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpuvndu5bi.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpuvndu5bi.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpuvndu5bi.swift:28:17: error: single-quoted string literal found, use '\"'\n                        if s[i+n] == ' ' {\n                                     ^~~\n                                     \" \"\n/tmp/tmpuvndu5bi.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpuvndu5bi.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpuvndu5bi.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpuvndu5bi.swift:33:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = []String{}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\tbreak\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\twords = append(words, \"\")\n\t\t} else {\n\t\t\twords = append(words, s[i:i+1])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpssct2wb3.swift:19:16: error: consecutive statements on a line must be separated by ';'\n        var words = []String{}\n                      ^\n                      ;\n/tmp/tmpssct2wb3.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpssct2wb3.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpssct2wb3.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpssct2wb3.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpssct2wb3.swift:27:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpssct2wb3.swift:19:14: error: empty collection literal requires an explicit type\n        var words = []String{}\n                    ^~\n/tmp/tmpssct2wb3.swift:19:16: error: ambiguous use of 'init'\n        var words = []String{}\n                      ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpssct2wb3.swift:33:9: error: cannot convert return expression of type '[Any]' to return type '[String]'\n        return words\n               ^\n/tmp/tmpssct2wb3.swift:33:9: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n        return words\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n <= len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp_89zagww.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmp_89zagww.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmp_89zagww.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_89zagww.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_89zagww.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_89zagww.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmp_89zagww.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmp_89zagww.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmp_89zagww.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) >= n {\n\t\t\tresult = append(result, s[i:i+n])\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmph4o0z410.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmph4o0z410.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmph4o0z410.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmph4o0z410.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmph4o0z410.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmph4o0z410.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmph4o0z410.swift:24:14: error: expected expression in list of expressions\n                if len(s[i:]) >= n {\n                           ^\n/tmp/tmph4o0z410.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmph4o0z410.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmph4o0z410.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmph4o0z410.swift:19:15: error: expected member name or constructor call after type name\n        var result []String\n                     ^\n/tmp/tmph4o0z410.swift:19:15: note: add arguments after the type to construct a value of the type\n        var result []String\n                     ^\n                           ()\n/tmp/tmph4o0z410.swift:19:15: note: use '.self' to reference the type object\n        var result []String\n                     ^\n                           .self\n/tmp/tmph4o0z410.swift:19:15: warning: expression of type 'String.Type' is unused\n        var result []String\n                     ^~~~~",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpondem_k2.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpondem_k2.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpondem_k2.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpondem_k2.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpondem_k2.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpondem_k2.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpondem_k2.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpondem_k2.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\twords = append(words, s[i:])\n\t\t\tbreak\n\t\t}\n\t\tif n > 0 {\n\t\t\tn--\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\twords = append(words, s[i:i+1])\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\twords = append(words, s[i:])\n\t\t\tbreak\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmptny79l08.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmptny79l08.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmptny79l08.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmptny79l08.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmptny79l08.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmptny79l08.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmptny79l08.swift:25:30: error: expected expression in list of expressions\n                        words = append(words, s[i:])\n                                                  ^\n/tmp/tmptny79l08.swift:31:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmptny79l08.swift:34:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmptny79l08.swift:35:30: error: expected expression in list of expressions\n                        words = append(words, s[i:])\n                                                  ^\n/tmp/tmptny79l08.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmptny79l08.swift:39:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t\ti += 1\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpha2xy3oi.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpha2xy3oi.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpha2xy3oi.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpha2xy3oi.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpha2xy3oi.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpha2xy3oi.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpha2xy3oi.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpha2xy3oi.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpha2xy3oi.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpha2xy3oi.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) >= n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpwvsx5g7x.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpwvsx5g7x.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpwvsx5g7x.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpwvsx5g7x.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpwvsx5g7x.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpwvsx5g7x.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpwvsx5g7x.swift:27:14: error: expected expression in list of expressions\n                if len(s[i:]) >= n {\n                           ^\n/tmp/tmpwvsx5g7x.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpwvsx5g7x.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpwvsx5g7x.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpwvsx5g7x.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\tif len(word) == n {\n\t\t\t\twords = append(words, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpdik_ud07.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpdik_ud07.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpdik_ud07.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpdik_ud07.swift:27:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar res = []String{}\n\tif len(s) == 0 {\n\t\treturn res\n\t}\n\tvar words = strings.Split(s, \" \")\n\tfor _, word := range words {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar count = 0\n\t\tfor _, c := range word {\n\t\t\tif c == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcount += 1\n\t\t}\n\t\tif count == n {\n\t\t\tres = append(res, word)\n\t\t}\n\t}\n\treturn res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpm9446ufr.swift:19:14: error: consecutive statements on a line must be separated by ';'\n        var res = []String{}\n                    ^\n                    ;\n/tmp/tmpm9446ufr.swift:24:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpm9446ufr.swift:24:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpm9446ufr.swift:29:8: error: expected 'in' after for-each pattern\n                for _, c := range word {\n                     ^\n/tmp/tmpm9446ufr.swift:29:8: error: expected Sequence expression for for-each loop\n                for _, c := range word {\n                     ^\n/tmp/tmpm9446ufr.swift:30:12: error: single-quoted string literal found, use '\"'\n                        if c == ' ' {\n                                ^~~\n                                \" \"\n/tmp/tmpm9446ufr.swift:19:12: error: empty collection literal requires an explicit type\n        var res = []String{}\n                  ^~\n/tmp/tmpm9446ufr.swift:19:14: error: ambiguous use of 'init'\n        var res = []String{}\n                    ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpm9446ufr.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpm9446ufr.swift:21:10: error: cannot convert return expression of type '[Any]' to return type '[String]'\n                return res\n                       ^\n/tmp/tmpm9446ufr.swift:21:10: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n                return res\n                       ^\n/tmp/tmpm9446ufr.swift:23:14: error: cannot find 'strings' in scope\n        var words = strings.Split(s, \" \")\n                    ^~~~~~~\n/tmp/tmpm9446ufr.swift:39:9: error: cannot convert return expression of type '[Any]' to ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == \" \" {\n\t\t\tcontinue\n\t\t}\n\t\twords = append(words, s[i:i+n])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpvosx3npr.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpvosx3npr.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpvosx3npr.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpvosx3npr.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpvosx3npr.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpvosx3npr.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpvosx3npr.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpvosx3npr.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpvosx3npr.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpvosx3npr.swift:35:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\twords = strings.Split(s, \" \")\n\tfor i := 0; i < len(words); i++ {\n\t\tif len(words[i]) > n {\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, words[i])\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp4bu4othe.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmp4bu4othe.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmp4bu4othe.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmp4bu4othe.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmp4bu4othe.swift:22:9: error: expected type\n        for i := 0; i < len(words); i++ {\n               ^\n                <#type#>\n/tmp/tmp4bu4othe.swift:22:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(words); i++ {\n               ^\n/tmp/tmp4bu4othe.swift:22:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(words); i++ {\n               ^\n/tmp/tmp4bu4othe.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmp4bu4othe.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmp4bu4othe.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmp4bu4othe.swift:19:15: error: expected member name or constructor call after type name\n        var result []String\n                     ^\n/tmp/tmp4bu4othe.swift:19:15: note: add arguments after the type to construct a value of the type\n        var result []String\n                     ^\n                           ()\n/tmp/tmp4bu4othe.swift:19:15: note: use '.self' to reference the type object\n        var result []String\n                     ^\n                           .self\n/tmp/tmp4bu4othe.swift:19:15: warning: expression of type 'String.Type' is unused\n        var result []String\n          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\twords = strings.Split(s, \" \")\n\tfor _, word := range words {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar count int\n\t\tfor _, c := range word {\n\t\t\tif c == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcount++\n\t\t}\n\t\tif count == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpeb9q0tp3.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpeb9q0tp3.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpeb9q0tp3.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpeb9q0tp3.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpeb9q0tp3.swift:22:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpeb9q0tp3.swift:22:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpeb9q0tp3.swift:26:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n                var count int\n                          ^\n/tmp/tmpeb9q0tp3.swift:26:13: note: join the identifiers together\n                var count int\n                    ~~~~~~^~~\n                    countint\n/tmp/tmpeb9q0tp3.swift:26:13: note: join the identifiers together with camel-case\n                var count int\n                    ~~~~~~^~~\n                    countInt\n/tmp/tmpeb9q0tp3.swift:27:8: error: expected 'in' after for-each pattern\n                for _, c := range word {\n                     ^\n/tmp/tmpeb9q0tp3.swift:27:8: error: expected Sequence expression for for-each loop\n                for _, c := range word {\n                     ^\n/tmp/tmpeb9q0tp3.swift:28:12: error: single-quoted string literal found, use '\"'\n                        if c == ' ' {\n                                ^~~\n                                \" \"\n/tmp/tmpeb9q0tp3.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpeb9q0tp3.swift:19:13",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tresult = append(result, s[i:])\n\t\t\tbreak\n\t\t}\n\t\tif n > 0 {\n\t\t\tn--\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i:i+1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp94z0pjvy.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmp94z0pjvy.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmp94z0pjvy.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp94z0pjvy.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp94z0pjvy.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp94z0pjvy.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp94z0pjvy.swift:25:32: error: expected expression in list of expressions\n                        result = append(result, s[i:])\n                                                    ^\n/tmp/tmp94z0pjvy.swift:31:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp94z0pjvy.swift:36:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp94z0pjvy.swift:41:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp94z0pjvy.swift:46:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp94z0pjvy.swift:51:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp94z0pjvy.swift:56:14: error: single-quoted string literal found, us",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmplualcl73.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmplualcl73.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmplualcl73.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmplualcl73.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplualcl73.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplualcl73.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplualcl73.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmplualcl73.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmplualcl73.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmplualcl73.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\tif s[i+n] == ' ' {\n\t\t\t\twords = append(words, s[i:i+n])\n\t\t\t\ti += n\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\twords = append(words, s[i:])\n\t\tbreak\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpv8txf0zk.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpv8txf0zk.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpv8txf0zk.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpv8txf0zk.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpv8txf0zk.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpv8txf0zk.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpv8txf0zk.swift:28:17: error: single-quoted string literal found, use '\"'\n                        if s[i+n] == ' ' {\n                                     ^~~\n                                     \" \"\n/tmp/tmpv8txf0zk.swift:34:29: error: expected expression in list of expressions\n                words = append(words, s[i:])\n                                          ^\n/tmp/tmpv8txf0zk.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpv8txf0zk.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpv8txf0zk.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpv8txf0zk.swift:37:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(s[i:]) >= n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpwvsx5g7x.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpwvsx5g7x.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpwvsx5g7x.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpwvsx5g7x.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpwvsx5g7x.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpwvsx5g7x.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpwvsx5g7x.swift:27:14: error: expected expression in list of expressions\n                if len(s[i:]) >= n {\n                           ^\n/tmp/tmpwvsx5g7x.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpwvsx5g7x.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpwvsx5g7x.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpwvsx5g7x.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n > len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif n == 0 {\n\t\t\twords = append(words, s[i:i+n])\n\t\t\tbreak\n\t\t}\n\t\tif s[i:i+n] == s[i+n:i+n+n] {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmps9ou6rvo.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmps9ou6rvo.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmps9ou6rvo.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmps9ou6rvo.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmps9ou6rvo.swift:31:23: error: expected ',' separator\n                if s[i:i+n] == s[i+n:i+n+n] {\n                                    ^\n                                    ,\n/tmp/tmps9ou6rvo.swift:31:23: error: expected expression in list of expressions\n                if s[i:i+n] == s[i+n:i+n+n] {\n                                    ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\twords = append(words, s[i:])\n\t\t\tbreak\n\t\t}\n\t\tif n > 0 {\n\t\t\tn--\n\t\t}\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif s[i] == s[j] {\n\t\t\t\tn--\n\t\t\t}\n\t\t\tif n == 0 {\n\t\t\t\twords = append(words, s[i:j])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpyc670lqr.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpyc670lqr.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpyc670lqr.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpyc670lqr.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpyc670lqr.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpyc670lqr.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpyc670lqr.swift:28:30: error: expected expression in list of expressions\n                        words = append(words, s[i:])\n                                                  ^\n/tmp/tmpyc670lqr.swift:34:10: error: expected type\n                for j := i + 1; j < len(s); j++ {\n                       ^\n                        <#type#>\n/tmp/tmpyc670lqr.swift:34:10: error: expected 'in' after for-each pattern\n                for j := i + 1; j < len(s); j++ {\n                       ^\n/tmp/tmpyc670lqr.swift:34:10: error: expected Sequence expression for for-each loop\n                for j := i + 1; j < len(s); j++ {\n                       ^\n/tmp/tmpyc670lqr.swift:35:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n                                   \" \"\n/tmp/tmpyc670lqr.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpyc670lqr.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpyc670lqr.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpyc670lqr.swift:47:9: error: ca",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\twords = strings.Split(s, \" \")\n\tfor _, word := range words {\n\t\tif len(word) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar count int\n\t\tfor _, c := range word {\n\t\t\tif c == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcount++\n\t\t}\n\t\tif count == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpeb9q0tp3.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpeb9q0tp3.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpeb9q0tp3.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpeb9q0tp3.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpeb9q0tp3.swift:22:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpeb9q0tp3.swift:22:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpeb9q0tp3.swift:26:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n                var count int\n                          ^\n/tmp/tmpeb9q0tp3.swift:26:13: note: join the identifiers together\n                var count int\n                    ~~~~~~^~~\n                    countint\n/tmp/tmpeb9q0tp3.swift:26:13: note: join the identifiers together with camel-case\n                var count int\n                    ~~~~~~^~~\n                    countInt\n/tmp/tmpeb9q0tp3.swift:27:8: error: expected 'in' after for-each pattern\n                for _, c := range word {\n                     ^\n/tmp/tmpeb9q0tp3.swift:27:8: error: expected Sequence expression for for-each loop\n                for _, c := range word {\n                     ^\n/tmp/tmpeb9q0tp3.swift:28:12: error: single-quoted string literal found, use '\"'\n                        if c == ' ' {\n                                ^~~\n                                \" \"\n/tmp/tmpeb9q0tp3.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpeb9q0tp3.swift:19:13",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result []String\n    var words []String\n    var i int\n    for i = 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            words = append(words, s[:i])\n            s = s[i+1:]\n            i = 0\n        }\n    }\n    words = append(words, s)\n    for i = 0; i < len(words); i++ {\n        if len(words[i]) >= n {\n            result = append(result, words[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpamyp8kwd.swift:19:15: error: consecutive statements on a line must be separated by ';'\n    var result []String\n              ^\n              ;\n/tmp/tmpamyp8kwd.swift:19:18: error: consecutive statements on a line must be separated by ';'\n    var result []String\n                 ^\n                 ;\n/tmp/tmpamyp8kwd.swift:20:14: error: consecutive statements on a line must be separated by ';'\n    var words []String\n             ^\n             ;\n/tmp/tmpamyp8kwd.swift:20:17: error: consecutive statements on a line must be separated by ';'\n    var words []String\n                ^\n                ;\n/tmp/tmpamyp8kwd.swift:21:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpamyp8kwd.swift:21:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpamyp8kwd.swift:21:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpamyp8kwd.swift:22:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(s); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpamyp8kwd.swift:23:20: error: single-quoted string literal found, use '\"'\n        if s[i] == ' ' {\n                   ^~~\n                   \" \"\n/tmp/tmpamyp8kwd.swift:24:37: error: expected expression in list of expressions\n            words = append(words, s[:i])\n                                    ^\n/tmp/tmpamyp8kwd.swift:25:22: error: expected ',' separator\n            s = s[i+1:]\n                     ^\n                     ,\n/tmp/tmpamyp8kwd.swift:25:22: error: expected expression in list of expressions\n            s = s[i+1:]\n                     ^\n/tmp/tmpamyp8kwd.swift:30:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(words); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpamyp8kwd.swift:19:9: error: type annotation missing in pattern\n    var result []String\n        ^\n/tmp/tmpamyp8kwd.swift:19:16: error: empty collection literal requires ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\tfor _, word := range strings.Split(s, \" \") {\n\t\tif len(word) > 0 {\n\t\t\twords = append(words, word)\n\t\t}\n\t}\n\tfor _, word := range words {\n\t\tif len(word) == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpwcpllntw.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpwcpllntw.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpwcpllntw.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpwcpllntw.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpwcpllntw.swift:21:7: error: expected 'in' after for-each pattern\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpwcpllntw.swift:21:7: error: expected Sequence expression for for-each loop\n        for _, word := range strings.Split(s, \" \") {\n             ^\n/tmp/tmpwcpllntw.swift:26:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpwcpllntw.swift:26:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpwcpllntw.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpwcpllntw.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmpwcpllntw.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmpwcpllntw.swift:19:15: error: expected member name or constructor call after type name\n        var result []String\n                     ^\n/tmp/tmpwcpllntw.swift:19:15: note: add arguments after the type to construct a value of the type\n        var result []String\n                     ^\n                           ()\n/tmp/tmpwcpllntw.swift:19:15: note: use '.self' to reference the type object\n        var result []String\n                     ^\n         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\tif i+1 < len(s) && s[i] == s[i+1] {\n\t\t\twords = append(words, s[i:i+2])\n\t\t\ti += 2\n\t\t} else {\n\t\t\twords = append(words, s[i:i+1])\n\t\t\ti += 1\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpt74jnwyn.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpt74jnwyn.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpt74jnwyn.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpt74jnwyn.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpt74jnwyn.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpt74jnwyn.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpt74jnwyn.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpt74jnwyn.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpt74jnwyn.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpt74jnwyn.swift:38:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\tbreak\n\t\t}\n\t\tif len(s[i:]) >= n {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpe9p5wpo2.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpe9p5wpo2.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpe9p5wpo2.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpe9p5wpo2.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpe9p5wpo2.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpe9p5wpo2.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpe9p5wpo2.swift:27:14: error: expected expression in list of expressions\n                if len(s[i:]) >= n {\n                           ^\n/tmp/tmpe9p5wpo2.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpe9p5wpo2.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int = 0\n\tvar t: Int = 0\n\tvar u: Int = 0\n\tvar v: Int = 0\n\tvar w: Int = 0\n\tvar x: Int = 0\n\tvar y: Int = 0\n\tvar z: Int = 0\n\tvar a: Int = 0\n\tvar b: Int = 0\n\tvar c: Int = 0\n\tvar d: Int = 0\n\tvar e: Int = 0\n\tvar f: Int = 0\n\tvar g: Int = 0\n\tvar h: Int = 0\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int = 0\n\tvar t: Int = 0\n\tvar u: Int = 0\n\tvar v: Int = 0\n\tvar w: Int = 0\n\tvar x: Int = 0\n\tvar y: Int = 0\n\tvar z: Int = 0\n\tvar a: Int = 0\n\tvar b: Int = 0\n\tvar c: Int = 0\n\tvar d: Int = 0\n\tvar e: Int = 0\n\tvar f: Int = 0\n\tvar g: Int = 0\n\tvar h: Int = 0\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar l: Int = 0\n\tvar m: Int = 0\n\tvar n: Int = 0\n\tvar o: Int = 0\n\tvar p: Int = 0\n\tvar q: Int = 0\n\tvar r: Int = 0\n\tvar s: Int =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpn_reijbq.swift:82:14: error: expected initial value after '='\n        var s: Int =\n                    ^\n/tmp/tmpn_reijbq.swift:46:6: error: invalid redeclaration of 'i'\n        var i: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:20:6: note: 'i' previously declared here\n        var i: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:47:6: error: invalid redeclaration of 'j'\n        var j: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:21:6: note: 'j' previously declared here\n        var j: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:48:6: error: invalid redeclaration of 'k'\n        var k: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:22:6: note: 'k' previously declared here\n        var k: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:49:6: error: invalid redeclaration of 'l'\n        var l: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:23:6: note: 'l' previously declared here\n        var l: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:50:6: error: invalid redeclaration of 'm'\n        var m: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:24:6: note: 'm' previously declared here\n        var m: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:51:6: error: invalid redeclaration of 'n'\n        var n: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:25:6: note: 'n' previously declared here\n        var n: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:52:6: error: invalid redeclaration of 'o'\n        var o: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:26:6: note: 'o' previously declared here\n        var o: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:53:6: error: invalid redeclaration of 'p'\n        var p: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:27:6: note: 'p' previously declared here\n        var p: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:54:6: error: invalid redeclaration of 'q'\n        var q: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:28:6: note: 'q' previously declared here\n        var q: Int = 0\n            ^\n/tmp/tmpn_reijbq.swift:55:6: error: invalid redeclaration of 'r'\n        var r: Int = 0\n            ^\n/tmp/t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif len(words) == n {\n\t\t\treturn words\n\t\t}\n\t\twords = append(words, s[i:i+1])\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpondem_k2.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpondem_k2.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpondem_k2.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpondem_k2.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpondem_k2.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpondem_k2.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpondem_k2.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpondem_k2.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpondem_k2.swift:32:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif n == 0 {\n\t\t\t\twords = append(words, s[i:j])\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tn--\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpf7sl8lrc.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmpf7sl8lrc.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmpf7sl8lrc.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpf7sl8lrc.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpf7sl8lrc.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmpf7sl8lrc.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpf7sl8lrc.swift:27:10: error: expected type\n                for j := i + 1; j < len(s); j++ {\n                       ^\n                        <#type#>\n/tmp/tmpf7sl8lrc.swift:27:10: error: expected 'in' after for-each pattern\n                for j := i + 1; j < len(s); j++ {\n                       ^\n/tmp/tmpf7sl8lrc.swift:27:10: error: expected Sequence expression for for-each loop\n                for j := i + 1; j < len(s); j++ {\n                       ^\n/tmp/tmpf7sl8lrc.swift:28:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n                                   \" \"\n/tmp/tmpf7sl8lrc.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmpf7sl8lrc.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmpf7sl8lrc.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmpf7sl8lrc.swift:38:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i + n < len(s) {\n\t\t\tif s[i+n] == ' ' {\n\t\t\t\tresult = append(result, s[i:i+n])\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp65u8gwy1.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmp65u8gwy1.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmp65u8gwy1.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp65u8gwy1.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp65u8gwy1.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp65u8gwy1.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp65u8gwy1.swift:25:17: error: single-quoted string literal found, use '\"'\n                        if s[i+n] == ' ' {\n                                     ^~~\n                                     \" \"\n/tmp/tmp65u8gwy1.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmp65u8gwy1.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmp65u8gwy1.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmp65u8gwy1.swift:19:15: error: expected member name or constructor call after type name\n        var result []String\n                     ^\n/tmp/tmp65u8gwy1.swift:19:15: note: add arguments after the type to construct a value of the type\n        var result []String\n                     ^\n                           ()\n/tmp/tmp65u8gwy1.swift:19:15: note: use '.self' to reference the type object\n        var result []String\n                     ^\n                           .self\n/tmp/tmp65u8gwy1.swift:19:15: warning: expression of type 'String.Type' is u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar word: String = \"\"\n\tvar word_length: Int = 0\n\tvar word_count: Int = 0\n\tvar word_index: Int = 0\n\tvar word_index_end: Int = 0\n\tvar word_index_start: Int = 0\n\tvar word_index_end_new: Int = 0\n\tvar word_index_start_new: Int = 0\n\tvar word_index_end_new_new: Int = 0\n\tvar word_index_start_new_new: Int = 0\n\tvar word_index_end_new_new_new: Int = 0\n\tvar word_index_start_new_new_new_new: Int = 0\n\tvar word_index_end_new_new_new_new_new: Int = 0\n\tvar word_index_start_new_new_new_new_new_new: Int = 0\n\tvar word_index_end_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_start_new_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_end_new_new_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_start_new_new_new_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_end_new_new_new_new_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_start_new_new_new_new_new_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_end_new_new_new_new_new_new_new_new_new_new_new_new_new_new: Int = 0\n\tvar word_index_start_new_new_new_new_new_new_new_new_new_new_new_new_new_new_new_new: Int = 0\n\tvar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp5acvakny.swift:45:5: error: expected pattern\n        var\n           ^\n/tmp/tmp5acvakny.swift:19:6: warning: variable 'words' was never used; consider replacing with '_' or removing it\n        var words: [String] = []\n            ^~~~~\n            _\n/tmp/tmp5acvakny.swift:20:6: warning: variable 'i' was never used; consider replacing with '_' or removing it\n        var i: Int = 0\n            ^\n            _\n/tmp/tmp5acvakny.swift:21:6: warning: variable 'j' was never used; consider replacing with '_' or removing it\n        var j: Int = 0\n            ^\n            _\n/tmp/tmp5acvakny.swift:22:6: warning: variable 'k' was never used; consider replacing with '_' or removing it\n        var k: Int = 0\n            ^\n            _\n/tmp/tmp5acvakny.swift:23:6: warning: variable 'word' was never used; consider replacing with '_' or removing it\n        var word: String = \"\"\n            ^~~~\n            _\n/tmp/tmp5acvakny.swift:24:6: warning: variable 'word_length' was never used; consider replacing with '_' or removing it\n        var word_length: Int = 0\n            ^~~~~~~~~~~\n            _\n/tmp/tmp5acvakny.swift:25:6: warning: variable 'word_count' was never used; consider replacing with '_' or removing it\n        var word_count: Int = 0\n            ^~~~~~~~~~\n            _\n/tmp/tmp5acvakny.swift:26:6: warning: variable 'word_index' was never used; consider replacing with '_' or removing it\n        var word_index: Int = 0\n            ^~~~~~~~~~\n            _\n/tmp/tmp5acvakny.swift:27:6: warning: variable 'word_index_end' was never used; consider replacing with '_' or removing it\n        var word_index_end: Int = 0\n            ^~~~~~~~~~~~~~\n            _\n/tmp/tmp5acvakny.swift:28:6: warning: variable 'word_index_start' was never used; consider replacing with '_' or removing it\n        var word_index_start: Int = 0\n            ^~~~~~~~~~~~~~~~\n            _\n/tmp/tmp5acvakny.swift:29:6: warning: variable 'word_index_end_new' was never used; consider replacing with '_' or removing it\n        var word_index_end_new: In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\twords = strings.Split(s, \" \")\n\tfor _, word := range words {\n\t\tif len(word) > 0 {\n\t\t\tif len(word) == n {\n\t\t\t\tresult = append(result, word)\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpkzfk2671.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmpkzfk2671.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmpkzfk2671.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmpkzfk2671.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmpkzfk2671.swift:22:7: error: expected 'in' after for-each pattern\n        for _, word := range words {\n             ^\n/tmp/tmpkzfk2671.swift:22:7: error: expected Sequence expression for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpkzfk2671.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmpkzfk2671.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmpkzfk2671.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n                   ^~\n/tmp/tmpkzfk2671.swift:19:15: error: expected member name or constructor call after type name\n        var result []String\n                     ^\n/tmp/tmpkzfk2671.swift:19:15: note: add arguments after the type to construct a value of the type\n        var result []String\n                     ^\n                           ()\n/tmp/tmpkzfk2671.swift:19:15: note: use '.self' to reference the type object\n        var result []String\n                     ^\n                           .self\n/tmp/tmpkzfk2671.swift:19:15: warning: expression of type 'String.Type' is unused\n        var result []String\n                     ^~~~~~\n/tmp/tmpkzfk2671.swift:20:6: error: type annotation missing in pattern\n        var words []String\n            ^\n/tmp/tmpkzfk2671.s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tresult = append(result, s[i:])\n\t\t\tbreak\n\t\t}\n\t\tif n > 0 {\n\t\t\tn--\n\t\t}\n\t\tif s[i] == ' ' {\n\t\t\tresult = append(result, s[i+1:])\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmppl9cb8m2.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmppl9cb8m2.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmppl9cb8m2.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmppl9cb8m2.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmppl9cb8m2.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmppl9cb8m2.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmppl9cb8m2.swift:25:32: error: expected expression in list of expressions\n                        result = append(result, s[i:])\n                                                    ^\n/tmp/tmppl9cb8m2.swift:31:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmppl9cb8m2.swift:32:33: error: expected ',' separator\n                        result = append(result, s[i+1:])\n                                                     ^\n                                                     ,\n/tmp/tmppl9cb8m2.swift:32:33: error: expected expression in list of expressions\n                        result = append(result, s[i+1:])\n                                                     ^\n/tmp/tmppl9cb8m2.swift:19:6: error: type annotation missing in pattern\n        var result []String\n            ^\n/tmp/tmppl9cb8m2.swift:19:13: error: empty collection literal requires an explicit type\n        var result []String\n                   ^~\n/tmp/tmppl9cb8m2.swift:19:13: warning: expression of type '[Any]' is unused\n        var result []String\n     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words: [String] = []\n\tvar i: Int = 0\n\tvar j: Int = 0\n\tvar k: Int = 0\n\tvar word: String = \"\"\n\tfor i < len(s) {\n\t\tif s[i] == ' ' {\n\t\t\tif len(word) > 0 {\n\t\t\t\twords = append(words, word)\n\t\t\t\tword = \"\"\n\t\t\t}\n\t\t\ti++\n\t\t} else {\n\t\t\tif len(word) == 0 {\n\t\t\t\tword = \"\"\n\t\t\t\tj = i\n\t\t\t\tk = 0\n\t\t\t}\n\t\t\tif s[i] == s[j] {\n\t\t\t\tk++\n\t\t\t\tif k == n {\n\t\t\t\t\twords = append(words, word)\n\t\t\t\t\tword = \"\"\n\t\t\t\t\tk = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(word) > 0 {\n\t\t\t\t\twords = append(words, word)\n\t\t\t\t\tword = \"\"\n\t\t\t\t}\n\t\t\t\tk = 0\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\tif len(word) > 0 {\n\t\twords = append(words, word)\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmpiyk5wd6d.swift:24:8: error: expected 'in' after for-each pattern\n        for i < len(s) {\n              ^\n/tmp/tmpiyk5wd6d.swift:24:8: error: unary operator cannot be separated from its operand\n        for i < len(s) {\n              ^~\n               \n/tmp/tmpiyk5wd6d.swift:25:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmpiyk5wd6d.swift:24:8: error: '<' is not a prefix unary operator\n        for i < len(s) {\n              ^\n/tmp/tmpiyk5wd6d.swift:24:10: error: cannot find 'len' in scope\n        for i < len(s) {\n                ^~~\n/tmp/tmpiyk5wd6d.swift:54:5: error: cannot find 'len' in scope\n        if len(word) > 0 {\n           ^~~\n/tmp/tmpiyk5wd6d.swift:55:11: error: cannot find 'append' in scope\n                words = append(words, word)\n                        ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tvar count int\n\t\tfor j := i; j < len(s); j++ {\n\t\t\tif s[j] == ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif s[j] == s[i] {\n\t\t\t\tcount++\n\t\t\t\tif count == n {\n\t\t\t\t\tresult = append(result, s[i:j])\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmp_mdcolok.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmp_mdcolok.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmp_mdcolok.swift:20:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmp_mdcolok.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_mdcolok.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmp_mdcolok.swift:21:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmp_mdcolok.swift:24:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n                var count int\n                          ^\n/tmp/tmp_mdcolok.swift:24:13: note: join the identifiers together\n                var count int\n                    ~~~~~~^~~\n                    countint\n/tmp/tmp_mdcolok.swift:24:13: note: join the identifiers together with camel-case\n                var count int\n                    ~~~~~~^~~\n                    countInt\n/tmp/tmp_mdcolok.swift:25:10: error: expected type\n                for j := i; j < len(s); j++ {\n                       ^\n                        <#type#>\n/tmp/tmp_mdcolok.swift:25:10: error: expected 'in' after for-each pattern\n                for j := i; j < len(s); j++ {\n                       ^\n/tmp/tmp_mdcolok.swift:25:10: error: expected Sequence expression for for-each loop\n                for j := i; j < len(s); j++ {\n                       ^\n/tmp/tmp_mdcolok.swift:26:15: error: single-quoted string literal found, use '\"'\n                        if s[j] == ' ' {\n                                   ^~~\n              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\twords := []String{}\n\tif len(s) == 0 {\n\t\treturn words\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif i+n < len(s) {\n\t\t\twords = append(words, s[i:i+n])\n\t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmplualcl73.swift:19:7: error: consecutive statements on a line must be separated by ';'\n        words := []String{}\n             ^\n             ;\n/tmp/tmplualcl73.swift:19:8: error: expected expression\n        words := []String{}\n              ^\n/tmp/tmplualcl73.swift:23:9: error: expected type\n        for i := 0; i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmplualcl73.swift:23:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplualcl73.swift:23:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmplualcl73.swift:24:14: error: single-quoted string literal found, use '\"'\n                if s[i] == ' ' {\n                           ^~~\n                           \" \"\n/tmp/tmplualcl73.swift:19:2: error: cannot find 'words' in scope\n        words := []String{}\n        ^~~~~\n/tmp/tmplualcl73.swift:20:5: error: cannot find 'len' in scope\n        if len(s) == 0 {\n           ^~~\n/tmp/tmplualcl73.swift:21:10: error: cannot find 'words' in scope\n                return words\n                       ^~~~~\n/tmp/tmplualcl73.swift:31:9: error: cannot find 'words' in scope\n        return words\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpnn659_hh.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpmjxsrldq.swift:20:9: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmpzmazq_ca.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292934,
      "stdout": "",
      "stderr": "/tmp/tmphp0h8k6f.swift:20:1: error: missing return in global function expected to return '[String]'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: Implement this function\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "tmpyy86p6mq/tmpyy86p6mq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afe3f3b3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afe3f0aab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afe3f0aa988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afe3f0a97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpyy86p6mq                        0x0000557fa8c694c4 <unavailable> + 5316\n5    libc.so.6                          0x00002afe3f59f460 __libc_start_main + 245\n6    tmpyy86p6mq                        0x0000557fa8c690c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns an array of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty array.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\", n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\", n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\", n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n/// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result []String\n\tvar words []String\n\tvar i int\n\tvar j int\n\tvar count int\n\twords = strings.Split(s, \" \")\n\tfor i = 0; i < len(words); i++ {\n\t\tfor j = 0; j < len(words[i]); j++ {\n\t\t\tif is_consonant(words[i][j]) {\n\t\t\t\tcount++\n\t\t\t\tif count == n {\n\t\t\t\t\tresult = append(result, words[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "/tmp/tmppji5elgq.swift:19:12: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                  ^\n                  ;\n/tmp/tmppji5elgq.swift:19:15: error: consecutive statements on a line must be separated by ';'\n        var result []String\n                     ^\n                     ;\n/tmp/tmppji5elgq.swift:20:11: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                 ^\n                 ;\n/tmp/tmppji5elgq.swift:20:14: error: consecutive statements on a line must be separated by ';'\n        var words []String\n                    ^\n                    ;\n/tmp/tmppji5elgq.swift:21:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i int\n              ^\n/tmp/tmppji5elgq.swift:21:8: note: join the identifiers together\n        var i int\n            ~~^~~\n            iint\n/tmp/tmppji5elgq.swift:21:8: note: join the identifiers together with camel-case\n        var i int\n            ~~^~~\n            iInt\n/tmp/tmppji5elgq.swift:22:8: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var j int\n              ^\n/tmp/tmppji5elgq.swift:22:8: note: join the identifiers together\n        var j int\n            ~~^~~\n            jint\n/tmp/tmppji5elgq.swift:22:8: note: join the identifiers together with camel-case\n        var j int\n            ~~^~~\n            jInt\n/tmp/tmppji5elgq.swift:23:12: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var count int\n                  ^\n/tmp/tmppji5elgq.swift:23:12: note: join the identifiers together\n        var count int\n            ~~~~~~^~~\n            countint\n/tmp/tmppji5elgq.swift:23:12: note: join the identifiers together with camel-case\n        var count int\n            ~~~~~~^~~\n            countInt\n/tmp/tmppji5elgq.swift:25:2: error: C-style for statement has been removed in Swift 3\n        for i = 0; i < l",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}