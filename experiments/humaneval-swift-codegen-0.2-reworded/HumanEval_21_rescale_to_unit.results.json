{
  "name": "HumanEval_21_rescale_to_unit",
  "language": "swift",
  "prompt": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i, number := range numbers {\n        numbers[i] = (number - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr2hig4ze.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpr2hig4ze.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpis38395r.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpis38395r.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpis38395r.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpis38395r.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpis38395r.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min {\n\t\t\tmin = numbers[i]\n\t\t}\n\t\tif numbers[i] > max {\n\t\t\tmax = numbers[i]\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp61nzltbl.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp61nzltbl.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp61nzltbl.swift:9:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp61nzltbl.swift:9:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:9:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp61nzltbl.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpdoz5q8j4.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpdoz5q8j4.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpdoz5q8j4.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpdoz5q8j4.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmpdoz5q8j4.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpdoz5q8j4.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpdoz5q8j4.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpvswd_01c.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpvswd_01c.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpvswd_01c.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpvswd_01c.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpvswd_01c.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpvswd_01c.swift:17:12: error: no exact matches in call to initializer \n    return [Double]([min, max])\n           ^\n/tmp/tmpvswd_01c.swift:17:12: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n    return [Double]([min, max])\n           ^\n/tmp/tmpvswd_01c.swift:17:22: error: generic parameter 'T' could not be inferred\n    return [Double]([min, max])\n                     ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    let min = numbers[0]\n    let max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    return [min, (max - min) / (max - min)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppfegg74p.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppfegg74p.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppfegg74p.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i := range numbers {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmj0jepjb.swift:10:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpmj0jepjb.swift:10:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpmj0jepjb.swift:12:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpmj0jepjb.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpmj0jepjb.swift:20:12: error: expected type\n    for i := range numbers {\n           ^\n            <#type#>\n/tmp/tmpmj0jepjb.swift:20:12: error: expected 'in' after for-each pattern\n    for i := range numbers {\n           ^\n/tmp/tmpmj0jepjb.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := range numbers {\n           ^\n/tmp/tmpmj0jepjb.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmpmj0jepjb.swift:10:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var result = make([]Double, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i] - min_value\n        result[i] /= max_value - min_value\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpc3glmfzc.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpc3glmfzc.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpc3glmfzc.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpc3glmfzc.swift:17:25: error: expected ',' separator\n    var result = make([]Double, len(numbers))\n                        ^\n                        ,\n/tmp/tmpc3glmfzc.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpc3glmfzc.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpc3glmfzc.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpc3glmfzc.swift:17:18: error: cannot find 'make' in scope\n    var result = make([]Double, len(numbers))\n                 ^~~~\n/tmp/tmpc3glmfzc.swift:17:33: error: cannot find 'len' in scope\n    var result = make([]Double, len(numbers))\n                                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var rescaled_numbers = make([]Double, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        rescaled_numbers[i] = (numbers[i] - min_value) / (max_value - min_value)\n    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprq4r2ma8.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:35: error: expected ',' separator\n    var rescaled_numbers = make([]Double, len(numbers))\n                                  ^\n                                  ,\n/tmp/tmprq4r2ma8.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:28: error: cannot find 'make' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                           ^~~~\n/tmp/tmprq4r2ma8.swift:17:43: error: cannot find 'len' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmptlk_1v2z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmptlk_1v2z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmptlk_1v2z.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min_value := numbers[0]\n    max_value := numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    return [min_value] + map(func(value: Double) Double {\n        return (value - min_value) / (max_value - min_value)\n    }, numbers) + [max_value]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpv41r5vno.swift:10:14: error: consecutive statements on a line must be separated by ';'\n    min_value := numbers[0]\n             ^\n             ;\n/tmp/tmpv41r5vno.swift:10:15: error: expected expression\n    min_value := numbers[0]\n              ^\n/tmp/tmpv41r5vno.swift:12:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpv41r5vno.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpv41r5vno.swift:20:30: error: expected expression in list of expressions\n    return [min_value] + map(func(value: Double) Double {\n                             ^\n/tmp/tmpv41r5vno.swift:20:34: error: expected identifier in function declaration\n    return [min_value] + map(func(value: Double) Double {\n                                 ^\n/tmp/tmpv41r5vno.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmpv41r5vno.swift:10:5: error: cannot find 'min_value' in scope\n    min_value := numbers[0]\n    ^~~~~~~~~\n/tmp/tmpv41r5vno.swift:20:13: error: cannot find 'min_value' in scope\n    return [min_value] + map(func(value: Double) Double {\n            ^~~~~~~~~\n/tmp/tmpv41r5vno.swift:20:26: error: cannot find 'map' in scope\n    return [min_value] + map(func(value: Double) Double {\n                         ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min_value) * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp4v36h3re.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp4v36h3re.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp4v36h3re.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp4v36h3re.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp4v36h3re.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp4v36h3re.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] /= max - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpuyw2hjq5.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([Double]([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpl_f96lk_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpl_f96lk_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpl_f96lk_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_f96lk_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_f96lk_.swift:18:1: error: expected expression in container literal\n}\n^\n/tmp/tmpl_f96lk_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpl_f96lk_.swift:17:18: error: no exact matches in call to initializer \n        return [Double]([Double]([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmptlk_1v2z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmptlk_1v2z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmptlk_1v2z.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    let min = numbers[0]\n    let max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    let scale = 1.0 / (max - min)\n    let result = []\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i] - min)\n    }\n    for i := 0; i < len(result); i++ {\n        result[i] = result[i] * scale\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpp98jip9c.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpp98jip9c.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpp98jip9c.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpp98jip9c.swift:19:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpp98jip9c.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpp98jip9c.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpp98jip9c.swift:22:12: error: expected type\n    for i := 0; i < len(result); i++ {\n           ^\n            <#type#>\n/tmp/tmpp98jip9c.swift:22:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(result); i++ {\n           ^\n/tmp/tmpp98jip9c.swift:22:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(result); i++ {\n           ^\n/tmp/tmpp98jip9c.swift:18:18: error: empty collection literal requires an explicit type\n    let result = []\n                 ^~\n/tmp/tmpp98jip9c.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Double]'\n    return result\n           ^\n/tmp/tmpp98jip9c.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Double') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double] {\n\t\tmin,\n\t\t(max - min) / (max - min),\n\t\t0.0,\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6u4mz6kj.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp6u4mz6kj.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp6u4mz6kj.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6u4mz6kj.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6u4mz6kj.swift:17:17: error: consecutive statements on a line must be separated by ';'\n        return [Double] {\n                       ^\n                       ;\n/tmp/tmp6u4mz6kj.swift:18:6: error: consecutive statements on a line must be separated by ';'\n                min,\n                   ^\n                   ;\n/tmp/tmp6u4mz6kj.swift:18:6: error: expected expression\n                min,\n                   ^\n/tmp/tmp6u4mz6kj.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp6u4mz6kj.swift:17:9: error: cannot convert return expression of type '[Double].Type' to return type '[Double]'\n        return [Double] {\n               ^~~~~~~~\n/tmp/tmp6u4mz6kj.swift:18:3: error: generic parameter 'T' could not be inferred\n                min,\n                ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp6u4mz6kj.swift:17:18: error: closure expression is unused\n        return [Double] {\n                        ^\n/tmp/tmp6u4mz6kj.swift:17:18: note: did you mean to use a 'do' statement?\n        return [Double] {\n                        ^\n                        do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpl7brm483.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpl7brm483.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpl7brm483.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl7brm483.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl7brm483.swift:20:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl7brm483.swift:20:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpl7brm483.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpl7brm483.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpl7brm483.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double] {\n\t\tmin,\n\t\t(max - min) / (max - min),\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpk6kxr7na.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpk6kxr7na.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpk6kxr7na.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpk6kxr7na.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpk6kxr7na.swift:17:17: error: consecutive statements on a line must be separated by ';'\n        return [Double] {\n                       ^\n                       ;\n/tmp/tmpk6kxr7na.swift:18:6: error: consecutive statements on a line must be separated by ';'\n                min,\n                   ^\n                   ;\n/tmp/tmpk6kxr7na.swift:18:6: error: expected expression\n                min,\n                   ^\n/tmp/tmpk6kxr7na.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpk6kxr7na.swift:17:9: error: cannot convert return expression of type '[Double].Type' to return type '[Double]'\n        return [Double] {\n               ^~~~~~~~\n/tmp/tmpk6kxr7na.swift:18:3: error: generic parameter 'T' could not be inferred\n                min,\n                ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpk6kxr7na.swift:17:18: error: closure expression is unused\n        return [Double] {\n                        ^\n/tmp/tmpk6kxr7na.swift:17:18: note: did you mean to use a 'do' statement?\n        return [Double] {\n                        ^\n                        do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpzlbtaw7q.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpzlbtaw7q.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i, number := range numbers {\n        numbers[i] = (number - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr2hig4ze.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpr2hig4ze.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i, number := range numbers {\n        numbers[i] = (number - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr2hig4ze.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpr2hig4ze.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpxurvjmcp.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpxurvjmcp.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpxurvjmcp.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpxurvjmcp.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpxurvjmcp.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmpxurvjmcp.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmpxurvjmcp.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmpxurvjmcp.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min {\n\t\t\tmin = numbers[i]\n\t\t}\n\t\tif numbers[i] > max {\n\t\t\tmax = numbers[i]\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpk3yejk_9.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpk3yejk_9.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpk3yejk_9.swift:9:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpk3yejk_9.swift:9:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpk3yejk_9.swift:9:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpk3yejk_9.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpk3yejk_9.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpk3yejk_9.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpk3yejk_9.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp49aya75d.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp49aya75d.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp49aya75d.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp49aya75d.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp49aya75d.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp49aya75d.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp49aya75d.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp49aya75d.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        number -= min\n        number /= (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmplx9g4sf4.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmplx9g4sf4.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmplx9g4sf4.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:17:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale - min_value\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpist60b_5.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpist60b_5.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpist60b_5.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpist60b_5.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpist60b_5.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpist60b_5.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmptlk_1v2z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmptlk_1v2z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmptlk_1v2z.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpnuobvsp0.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpnuobvsp0.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpnuobvsp0.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var rescaled_numbers = make([]Double, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        rescaled_numbers[i] = numbers[i] - min_value\n        rescaled_numbers[i] /= max_value - min_value\n    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpvuniq0hv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpvuniq0hv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpvuniq0hv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpvuniq0hv.swift:17:35: error: expected ',' separator\n    var rescaled_numbers = make([]Double, len(numbers))\n                                  ^\n                                  ,\n/tmp/tmpvuniq0hv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpvuniq0hv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpvuniq0hv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpvuniq0hv.swift:17:28: error: cannot find 'make' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                           ^~~~\n/tmp/tmpvuniq0hv.swift:17:43: error: cannot find 'len' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpzlbtaw7q.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpzlbtaw7q.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    let min = numbers[0]\n    let max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    let scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpq51i6iev.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpq51i6iev.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpq51i6iev.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpq51i6iev.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpq51i6iev.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpq51i6iev.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    let min = numbers[0]\n    let max = numbers[0]\n    for i in numbers {\n        if i < min {\n            min = i\n        }\n        if i > max {\n            max = i\n        }\n    }\n    let scale = 1.0 / (max - min)\n    for i in numbers {\n        numbers[i] = (i - min) * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp_s6y3m21.swift:11:13: error: cannot assign to value: 'min' is a 'let' constant\n            min = i\n            ^~~\n/tmp/tmp_s6y3m21.swift:7:5: note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n    ^~~\n    var\n/tmp/tmp_s6y3m21.swift:14:13: error: cannot assign to value: 'max' is a 'let' constant\n            max = i\n            ^~~\n/tmp/tmp_s6y3m21.swift:8:5: note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n    ^~~\n    var\n/tmp/tmp_s6y3m21.swift:19:17: error: cannot convert value of type 'Double' to expected argument type 'Int'\n        numbers[i] = (i - min) * scale\n                ^\n                Int( )\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpix_ar08z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpix_ar08z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpix_ar08z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpix_ar08z.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n/tmp/tmpix_ar08z.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmptlk_1v2z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmptlk_1v2z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmptlk_1v2z.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpdoz5q8j4.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpdoz5q8j4.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpdoz5q8j4.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpdoz5q8j4.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmpdoz5q8j4.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpdoz5q8j4.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpdoz5q8j4.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpvswd_01c.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpvswd_01c.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpvswd_01c.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpvswd_01c.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpvswd_01c.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpvswd_01c.swift:17:12: error: no exact matches in call to initializer \n    return [Double]([min, max])\n           ^\n/tmp/tmpvswd_01c.swift:17:12: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n    return [Double]([min, max])\n           ^\n/tmp/tmpvswd_01c.swift:17:22: error: generic parameter 'T' could not be inferred\n    return [Double]([min, max])\n                     ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / 2, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpq05a8dqx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpq05a8dqx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n                          ,\n/tmp/tmpq05a8dqx.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n                                    ;\n/tmp/tmpq05a8dqx.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n/tmp/tmpq05a8dqx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpq05a8dqx.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] /= max - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpuyw2hjq5.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpix077zuj.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpix077zuj.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min_value) * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp4v36h3re.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp4v36h3re.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp4v36h3re.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp4v36h3re.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp4v36h3re.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp4v36h3re.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpis38395r.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpis38395r.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpis38395r.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpis38395r.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpis38395r.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, num := range numbers {\n        if num < min {\n            min = num\n        }\n        if num > max {\n            max = num\n        }\n    }\n    return [Double] {\n        min,\n        (max - min) / (len(numbers) - 1),\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp2g7wxayh.swift:10:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmp2g7wxayh.swift:10:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmp2g7wxayh.swift:12:10: error: expected 'in' after for-each pattern\n    for _, num := range numbers {\n         ^\n/tmp/tmp2g7wxayh.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, num := range numbers {\n         ^\n/tmp/tmp2g7wxayh.swift:20:20: error: consecutive statements on a line must be separated by ';'\n    return [Double] {\n                   ^\n                   ;\n/tmp/tmp2g7wxayh.swift:21:12: error: consecutive statements on a line must be separated by ';'\n        min,\n           ^\n           ;\n/tmp/tmp2g7wxayh.swift:21:12: error: expected expression\n        min,\n           ^\n/tmp/tmp2g7wxayh.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmp2g7wxayh.swift:10:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp2g7wxayh.swift:20:12: error: cannot convert return expression of type '[Double].Type' to return type '[Double]'\n    return [Double] {\n           ^~~~~~~~\n/tmp/tmp2g7wxayh.swift:21:9: error: generic parameter 'T' could not be inferred\n        min,\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp2g7wxayh.swift:20:21: error: closure expression is unused\n    return [Double] {\n                    ^\n/tmp/tmp2g7wxayh.swift:20:21: note: did you mean to use a 'do' statement?\n    return [Double] {\n                    ^\n                    do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var rescaled_numbers = make([]Double, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        rescaled_numbers[i] = (numbers[i] - min_value) / (max_value - min_value)\n    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprq4r2ma8.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:35: error: expected ',' separator\n    var rescaled_numbers = make([]Double, len(numbers))\n                                  ^\n                                  ,\n/tmp/tmprq4r2ma8.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:28: error: cannot find 'make' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                           ^~~~\n/tmp/tmprq4r2ma8.swift:17:43: error: cannot find 'len' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpvnl1do_q.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpvnl1do_q.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpvnl1do_q.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpvnl1do_q.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpvnl1do_q.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpvnl1do_q.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpldenh8k8.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpldenh8k8.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpldenh8k8.swift:17:9: error: no exact matches in call to initializer \n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:9: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:19: error: generic parameter 'T' could not be inferred\n        return [Double]([min, max])\n                         ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i, number := range numbers {\n        numbers[i] = (number - min) * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpf9lth3ht.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpf9lth3ht.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpf9lth3ht.swift:18:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmpf9lth3ht.swift:18:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / 2, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpq05a8dqx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpq05a8dqx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n                          ,\n/tmp/tmpq05a8dqx.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n                                    ;\n/tmp/tmpq05a8dqx.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n/tmp/tmpq05a8dqx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpq05a8dqx.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, v := range numbers {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t\tif v > max {\n\t\t\tmax = v\n\t\t}\n\t}\n\tfor i, v := range numbers {\n\t\tnumbers[i] = v - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpfqt3h7q7.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpfqt3h7q7.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpfqt3h7q7.swift:9:7: error: expected 'in' after for-each pattern\n        for _, v := range numbers {\n             ^\n/tmp/tmpfqt3h7q7.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, v := range numbers {\n             ^\n/tmp/tmpfqt3h7q7.swift:17:7: error: expected 'in' after for-each pattern\n        for i, v := range numbers {\n             ^\n/tmp/tmpfqt3h7q7.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, v := range numbers {\n             ^\n/tmp/tmpfqt3h7q7.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / 2, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpq05a8dqx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpq05a8dqx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n                          ,\n/tmp/tmpq05a8dqx.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n                                    ;\n/tmp/tmpq05a8dqx.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n/tmp/tmpq05a8dqx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpq05a8dqx.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpix_ar08z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpix_ar08z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpix_ar08z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpix_ar08z.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n/tmp/tmpix_ar08z.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpix077zuj.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpix077zuj.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpldenh8k8.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpldenh8k8.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpldenh8k8.swift:17:9: error: no exact matches in call to initializer \n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:9: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:19: error: generic parameter 'T' could not be inferred\n        return [Double]([min, max])\n                         ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpp5amvi31.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpp5amvi31.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpp5amvi31.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpp5amvi31.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpp5amvi31.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpp5amvi31.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp9felo8u7.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp9felo8u7.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp9felo8u7.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp9felo8u7.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp9felo8u7.swift:20:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9felo8u7.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp9felo8u7.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp9felo8u7.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9felo8u7.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9felo8u7.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        panic(\"rescale_to_unit: array must have at least two elements\")\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i := range numbers {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp8j8121la.swift:10:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmp8j8121la.swift:10:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmp8j8121la.swift:12:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp8j8121la.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp8j8121la.swift:20:12: error: expected type\n    for i := range numbers {\n           ^\n            <#type#>\n/tmp/tmp8j8121la.swift:20:12: error: expected 'in' after for-each pattern\n    for i := range numbers {\n           ^\n/tmp/tmp8j8121la.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := range numbers {\n           ^\n/tmp/tmp8j8121la.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmp8j8121la.swift:8:9: error: cannot find 'panic' in scope\n        panic(\"rescale_to_unit: array must have at least two elements\")\n        ^~~~~\n/tmp/tmp8j8121la.swift:10:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp_d971gom.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp_d971gom.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp_d971gom.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp_d971gom.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp_d971gom.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp_d971gom.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([Double]{min, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpylggvdjq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpylggvdjq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpylggvdjq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpylggvdjq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpylggvdjq.swift:17:26: error: expected ',' separator\n        return [Double]([Double]{min, max})\n                                ^\n                                ,\n/tmp/tmpylggvdjq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([Double]{min, max})\n                                    ^\n                                    ;\n/tmp/tmpylggvdjq.swift:17:30: error: expected expression\n        return [Double]([Double]{min, max})\n                                    ^\n/tmp/tmpylggvdjq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpylggvdjq.swift:17:17: error: missing argument labels 'unsafeUninitializedCapacity:initializingWith:' in call\n        return [Double]([Double]{min, max})\n                       ^\n                        unsafeUninitializedCapacity:  initializingWith: \n/tmp/tmpylggvdjq.swift:17:27: error: generic parameter 'T' could not be inferred\n        return [Double]([Double]{min, max})\n                                 ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, v := range numbers {\n        if v < min {\n            min = v\n        }\n        if v > max {\n            max = v\n        }\n    }\n    for i, v := range numbers {\n        numbers[i] = (v - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpoxapw_on.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpoxapw_on.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpoxapw_on.swift:9:10: error: expected 'in' after for-each pattern\n    for _, v := range numbers {\n         ^\n/tmp/tmpoxapw_on.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, v := range numbers {\n         ^\n/tmp/tmpoxapw_on.swift:17:10: error: expected 'in' after for-each pattern\n    for i, v := range numbers {\n         ^\n/tmp/tmpoxapw_on.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, v := range numbers {\n         ^\n/tmp/tmpoxapw_on.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp4mk7l2ml.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp4mk7l2ml.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp4mk7l2ml.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp4mk7l2ml.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp4mk7l2ml.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4mk7l2ml.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp4mk7l2ml.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp4mk7l2ml.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp9felo8u7.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp9felo8u7.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp9felo8u7.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp9felo8u7.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp9felo8u7.swift:20:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9felo8u7.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp9felo8u7.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp9felo8u7.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9felo8u7.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9felo8u7.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] /= max - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpuyw2hjq5.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    let min = numbers[0]\n    let max = numbers[0]\n    for i in numbers {\n        if i < min {\n            min = i\n        }\n        if i > max {\n            max = i\n        }\n    }\n    let scale = 1.0 / (max - min)\n    let result = []\n    for i in numbers {\n        result.append(i * scale)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpmg4umh8f.swift:11:13: error: cannot assign to value: 'min' is a 'let' constant\n            min = i\n            ^~~\n/tmp/tmpmg4umh8f.swift:7:5: note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n    ^~~\n    var\n/tmp/tmpmg4umh8f.swift:14:13: error: cannot assign to value: 'max' is a 'let' constant\n            max = i\n            ^~~\n/tmp/tmpmg4umh8f.swift:8:5: note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n    ^~~\n    var\n/tmp/tmpmg4umh8f.swift:18:18: error: empty collection literal requires an explicit type\n    let result = []\n                 ^~\n/tmp/tmpmg4umh8f.swift:20:16: error: cannot use mutating member on immutable value: 'result' is a 'let' constant\n        result.append(i * scale)\n        ~~~~~~ ^\n/tmp/tmpmg4umh8f.swift:18:5: note: change 'let' to 'var' to make it mutable\n    let result = []\n    ^~~\n    var\n/tmp/tmpmg4umh8f.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Double]'\n    return result\n           ^\n/tmp/tmpmg4umh8f.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Double') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin_value := numbers[0]\n\tmax_value := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_value {\n\t\t\tmin_value = number\n\t\t}\n\t\tif number > max_value {\n\t\t\tmax_value = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min_value\n\t\tnumbers[i] /= max_value - min_value\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpwqcprvt5.swift:7:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmpwqcprvt5.swift:7:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmpwqcprvt5.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpwqcprvt5.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpwqcprvt5.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpwqcprvt5.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpwqcprvt5.swift:7:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpohpy8gzg.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpohpy8gzg.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpohpy8gzg.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min {\n\t\t\tmin = numbers[i]\n\t\t}\n\t\tif numbers[i] > max {\n\t\t\tmax = numbers[i]\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp6c4lqxwi.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp6c4lqxwi.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp6c4lqxwi.swift:9:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp6c4lqxwi.swift:9:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp6c4lqxwi.swift:9:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp6c4lqxwi.swift:20:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp6c4lqxwi.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp6c4lqxwi.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp6c4lqxwi.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp6c4lqxwi.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n/tmp/tmp6c4lqxwi.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min_value := numbers[0]\n    max_value := numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    if min_value == max_value {\n        return numbers\n    }\n    for _, value := range numbers {\n        value -= min_value\n        value /= (max_value - min_value)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp3or7i083.swift:10:14: error: consecutive statements on a line must be separated by ';'\n    min_value := numbers[0]\n             ^\n             ;\n/tmp/tmp3or7i083.swift:10:15: error: expected expression\n    min_value := numbers[0]\n              ^\n/tmp/tmp3or7i083.swift:12:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmp3or7i083.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmp3or7i083.swift:23:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmp3or7i083.swift:23:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmp3or7i083.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmp3or7i083.swift:10:5: error: cannot find 'min_value' in scope\n    min_value := numbers[0]\n    ^~~~~~~~~\n/tmp/tmp3or7i083.swift:20:8: error: cannot find 'min_value' in scope\n    if min_value == max_value {\n       ^~~~~~~~~\n/tmp/tmp3or7i083.swift:20:21: error: cannot find 'max_value' in scope\n    if min_value == max_value {\n                    ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    // Write your code here\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "tmpoc7dszf4/tmpoc7dszf4.swift:24: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b4b0944bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b4b09142b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b4b09142988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b4b091417b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpoc7dszf4                        0x000055ca391f0443 <unavailable> + 5187\n5    libc.so.6                          0x00002b4b09637460 __libc_start_main + 245\n6    tmpoc7dszf4                        0x000055ca391f0049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale - min_value\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpist60b_5.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpist60b_5.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpist60b_5.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpist60b_5.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpist60b_5.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpist60b_5.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpdoz5q8j4.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpdoz5q8j4.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpdoz5q8j4.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpdoz5q8j4.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmpdoz5q8j4.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmpdoz5q8j4.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpdoz5q8j4.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpdoz5q8j4.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpix077zuj.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpix077zuj.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpohpy8gzg.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpohpy8gzg.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpohpy8gzg.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpzlbtaw7q.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpzlbtaw7q.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpzlbtaw7q.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp49aya75d.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp49aya75d.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp49aya75d.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp49aya75d.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp49aya75d.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp49aya75d.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp49aya75d.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp49aya75d.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmptlk_1v2z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmptlk_1v2z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmptlk_1v2z.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmptlk_1v2z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpxurvjmcp.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpxurvjmcp.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpxurvjmcp.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpxurvjmcp.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpxurvjmcp.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmpxurvjmcp.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmpxurvjmcp.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmpxurvjmcp.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min) * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpwi2742bg.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpwi2742bg.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpwi2742bg.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpwi2742bg.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpwi2742bg.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpwi2742bg.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for _, number := range numbers {\n        number -= min\n        number /= (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmplx9g4sf4.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmplx9g4sf4.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmplx9g4sf4.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:17:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmplx9g4sf4.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp9felo8u7.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp9felo8u7.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp9felo8u7.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp9felo8u7.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp9felo8u7.swift:20:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9felo8u7.swift:20:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp9felo8u7.swift:20:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp9felo8u7.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9felo8u7.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9felo8u7.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, v := range numbers {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t\tif v > max {\n\t\t\tmax = v\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp3uorw7su.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp3uorw7su.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp3uorw7su.swift:9:7: error: expected 'in' after for-each pattern\n        for _, v := range numbers {\n             ^\n/tmp/tmp3uorw7su.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, v := range numbers {\n             ^\n/tmp/tmp3uorw7su.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmp3uorw7su.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmp3uorw7su.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmp3uorw7su.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min_value := numbers[0]\n    max_value := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] /= (max_value - min_value)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpqe2xivzr.swift:7:14: error: consecutive statements on a line must be separated by ';'\n    min_value := numbers[0]\n             ^\n             ;\n/tmp/tmpqe2xivzr.swift:7:15: error: expected expression\n    min_value := numbers[0]\n              ^\n/tmp/tmpqe2xivzr.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpqe2xivzr.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpqe2xivzr.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpqe2xivzr.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpqe2xivzr.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpqe2xivzr.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpqe2xivzr.swift:7:5: error: cannot find 'min_value' in scope\n    min_value := numbers[0]\n    ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var rescaled_numbers = make([]Double, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        rescaled_numbers[i] = (numbers[i] - min_value) / (max_value - min_value)\n    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprq4r2ma8.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:35: error: expected ',' separator\n    var rescaled_numbers = make([]Double, len(numbers))\n                                  ^\n                                  ,\n/tmp/tmprq4r2ma8.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:28: error: cannot find 'make' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                           ^~~~\n/tmp/tmprq4r2ma8.swift:17:43: error: cannot find 'len' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([Double]([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpl_f96lk_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpl_f96lk_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpl_f96lk_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_f96lk_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_f96lk_.swift:18:1: error: expected expression in container literal\n}\n^\n/tmp/tmpl_f96lk_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpl_f96lk_.swift:17:18: error: no exact matches in call to initializer \n        return [Double]([Double]([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    return [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpvswd_01c.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpvswd_01c.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpvswd_01c.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpvswd_01c.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpvswd_01c.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpvswd_01c.swift:17:12: error: no exact matches in call to initializer \n    return [Double]([min, max])\n           ^\n/tmp/tmpvswd_01c.swift:17:12: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n    return [Double]([min, max])\n           ^\n/tmp/tmpvswd_01c.swift:17:22: error: generic parameter 'T' could not be inferred\n    return [Double]([min, max])\n                     ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / 2, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpq05a8dqx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpq05a8dqx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n                          ,\n/tmp/tmpq05a8dqx.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n                                    ;\n/tmp/tmpq05a8dqx.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n/tmp/tmpq05a8dqx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpq05a8dqx.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, v := range numbers {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t\tif v > max {\n\t\t\tmax = v\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, v := range numbers {\n\t\tv -= min\n\t\tv /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpup5g_04e.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpup5g_04e.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpup5g_04e.swift:9:7: error: expected 'in' after for-each pattern\n        for _, v := range numbers {\n             ^\n/tmp/tmpup5g_04e.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, v := range numbers {\n             ^\n/tmp/tmpup5g_04e.swift:20:7: error: expected 'in' after for-each pattern\n        for _, v := range numbers {\n             ^\n/tmp/tmpup5g_04e.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, v := range numbers {\n             ^\n/tmp/tmpup5g_04e.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpup5g_04e.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n/tmp/tmpup5g_04e.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpvnl1do_q.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpvnl1do_q.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpvnl1do_q.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpvnl1do_q.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpvnl1do_q.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpvnl1do_q.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp_d971gom.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp_d971gom.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp_d971gom.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp_d971gom.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp_d971gom.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp_d971gom.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min_value := numbers[0]\n    max_value := numbers[0]\n    for _, number := range numbers {\n        if number < min_value {\n            min_value = number\n        }\n        if number > max_value {\n            max_value = number\n        }\n    }\n    for i := range numbers {\n        numbers[i] = (numbers[i] - min_value) / (max_value - min_value)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp1q72v74k.swift:10:14: error: consecutive statements on a line must be separated by ';'\n    min_value := numbers[0]\n             ^\n             ;\n/tmp/tmp1q72v74k.swift:10:15: error: expected expression\n    min_value := numbers[0]\n              ^\n/tmp/tmp1q72v74k.swift:12:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp1q72v74k.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp1q72v74k.swift:20:12: error: expected type\n    for i := range numbers {\n           ^\n            <#type#>\n/tmp/tmp1q72v74k.swift:20:12: error: expected 'in' after for-each pattern\n    for i := range numbers {\n           ^\n/tmp/tmp1q72v74k.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := range numbers {\n           ^\n/tmp/tmp1q72v74k.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmp1q72v74k.swift:10:5: error: cannot find 'min_value' in scope\n    min_value := numbers[0]\n    ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / 2, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpq05a8dqx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpq05a8dqx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpq05a8dqx.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n                          ,\n/tmp/tmpq05a8dqx.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n                                    ;\n/tmp/tmpq05a8dqx.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / 2, max})\n                                    ^\n/tmp/tmpq05a8dqx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpq05a8dqx.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / 2, max})\n                          ^\n/tmp/tmpq05a8dqx.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpnuobvsp0.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpnuobvsp0.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpnuobvsp0.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpldenh8k8.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpldenh8k8.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpldenh8k8.swift:17:9: error: no exact matches in call to initializer \n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:9: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:19: error: generic parameter 'T' could not be inferred\n        return [Double]([min, max])\n                         ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpix_ar08z.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpix_ar08z.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpix_ar08z.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpix_ar08z.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpix_ar08z.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n/tmp/tmpix_ar08z.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / 2, (max + min) / 2, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp8uydefy9.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp8uydefy9.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp8uydefy9.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp8uydefy9.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp8uydefy9.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / 2, (max + min) / 2, max})\n                          ^\n                          ,\n/tmp/tmp8uydefy9.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / 2, (max + min) / 2, max})\n                                    ^\n                                    ;\n/tmp/tmp8uydefy9.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / 2, (max + min) / 2, max})\n                                    ^\n/tmp/tmp8uydefy9.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp8uydefy9.swift:17:27: error: generic parameter 'T' could not be inferred\n        return [Double]([]Double{min, (max - min) / 2, (max + min) / 2, max})\n                                 ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp8uydefy9.swift:17:9: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / 2, (max + min) / 2, max})\n               ^\n/tmp/tmp8uydefy9.swift:17:9: note: found candidate with type '(Double, Int) -> [Double]'\n        return [Double]([]Double{min, (max - min) / 2, (max + min)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([min, max])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpldenh8k8.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpldenh8k8.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpldenh8k8.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpldenh8k8.swift:17:9: error: no exact matches in call to initializer \n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:9: note: found candidate with type '(Array<(_, _) -> _>) -> Array<Double>'\n        return [Double]([min, max])\n               ^\n/tmp/tmpldenh8k8.swift:17:19: error: generic parameter 'T' could not be inferred\n        return [Double]([min, max])\n                         ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpnuobvsp0.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpnuobvsp0.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpnuobvsp0.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpnuobvsp0.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] *= scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppb3nu2rv.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmppb3nu2rv.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmppb3nu2rv.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double] {\n\t\t(number - min) / (max - min)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpt3tshh7v.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpt3tshh7v.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpt3tshh7v.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpt3tshh7v.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpt3tshh7v.swift:17:17: error: consecutive statements on a line must be separated by ';'\n        return [Double] {\n                       ^\n                       ;\n/tmp/tmpt3tshh7v.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpt3tshh7v.swift:17:9: error: cannot convert return expression of type '[Double].Type' to return type '[Double]'\n        return [Double] {\n               ^~~~~~~~\n/tmp/tmpt3tshh7v.swift:18:4: error: cannot find 'number' in scope\n                (number - min) / (max - min)\n                 ^~~~~~\n/tmp/tmpt3tshh7v.swift:17:18: error: closure expression is unused\n        return [Double] {\n                        ^\n/tmp/tmpt3tshh7v.swift:17:18: note: did you mean to use a 'do' statement?\n        return [Double] {\n                        ^\n                        do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max - min)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpp5amvi31.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpp5amvi31.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpp5amvi31.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpp5amvi31.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpp5amvi31.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpp5amvi31.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min_value\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6tviw31w.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp6tviw31w.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmp6tviw31w.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        panic(\"rescale_to_unit: array must have at least two elements\")\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, v := range numbers {\n        if v < min {\n            min = v\n        }\n        if v > max {\n            max = v\n        }\n    }\n    if max == min {\n        return numbers\n    }\n    for _, v := range numbers {\n        v -= min\n        v /= (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp68x1b3hc.swift:10:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmp68x1b3hc.swift:10:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmp68x1b3hc.swift:12:10: error: expected 'in' after for-each pattern\n    for _, v := range numbers {\n         ^\n/tmp/tmp68x1b3hc.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, v := range numbers {\n         ^\n/tmp/tmp68x1b3hc.swift:23:10: error: expected 'in' after for-each pattern\n    for _, v := range numbers {\n         ^\n/tmp/tmp68x1b3hc.swift:23:10: error: expected Sequence expression for for-each loop\n    for _, v := range numbers {\n         ^\n/tmp/tmp68x1b3hc.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmp68x1b3hc.swift:8:9: error: cannot find 'panic' in scope\n        panic(\"rescale_to_unit: array must have at least two elements\")\n        ^~~~~\n/tmp/tmp68x1b3hc.swift:10:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp68x1b3hc.swift:20:8: error: generic parameter 'T' could not be inferred\n    if max == min {\n       ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp68x1b3hc.swift:20:12: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n    if max == min {\n       ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i := range numbers {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmj0jepjb.swift:10:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpmj0jepjb.swift:10:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpmj0jepjb.swift:12:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpmj0jepjb.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpmj0jepjb.swift:20:12: error: expected type\n    for i := range numbers {\n           ^\n            <#type#>\n/tmp/tmpmj0jepjb.swift:20:12: error: expected 'in' after for-each pattern\n    for i := range numbers {\n           ^\n/tmp/tmpmj0jepjb.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := range numbers {\n           ^\n/tmp/tmpmj0jepjb.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmpmj0jepjb.swift:10:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpozzeuq5g.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpozzeuq5g.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpozzeuq5g.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpozzeuq5g.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpozzeuq5g.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpozzeuq5g.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpozzeuq5g.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpozzeuq5g.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, (max - min) / (max - min)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpmv904unq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpmv904unq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpmv904unq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpmv904unq.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n                          ,\n/tmp/tmpmv904unq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n                                    ;\n/tmp/tmpmv904unq.swift:17:30: error: expected expression\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                                    ^\n/tmp/tmpmv904unq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpmv904unq.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, (max - min) / (max - min)})\n                          ^\n/tmp/tmpmv904unq.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        re",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i := range numbers {\n\t\tnumbers[i] = (numbers[i] - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmppbzsvhhx.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmppbzsvhhx.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected type\n        for i := range numbers {\n               ^\n                <#type#>\n/tmp/tmppbzsvhhx.swift:17:9: error: expected 'in' after for-each pattern\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := range numbers {\n               ^\n/tmp/tmppbzsvhhx.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([Double]([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpl_f96lk_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpl_f96lk_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpl_f96lk_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_f96lk_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_f96lk_.swift:18:1: error: expected expression in container literal\n}\n^\n/tmp/tmpl_f96lk_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpl_f96lk_.swift:17:18: error: no exact matches in call to initializer \n        return [Double]([Double]([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])([Double])(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpis38395r.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpis38395r.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpis38395r.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpis38395r.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpis38395r.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpis38395r.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min {\n\t\t\tmin = numbers[i]\n\t\t}\n\t\tif numbers[i] > max {\n\t\t\tmax = numbers[i]\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp61nzltbl.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp61nzltbl.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp61nzltbl.swift:9:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp61nzltbl.swift:9:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:9:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp61nzltbl.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double] {\n\t\tmin,\n\t\t(max - min) / (max - min),\n\t\t0.0,\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp6u4mz6kj.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp6u4mz6kj.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp6u4mz6kj.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6u4mz6kj.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6u4mz6kj.swift:17:17: error: consecutive statements on a line must be separated by ';'\n        return [Double] {\n                       ^\n                       ;\n/tmp/tmp6u4mz6kj.swift:18:6: error: consecutive statements on a line must be separated by ';'\n                min,\n                   ^\n                   ;\n/tmp/tmp6u4mz6kj.swift:18:6: error: expected expression\n                min,\n                   ^\n/tmp/tmp6u4mz6kj.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp6u4mz6kj.swift:17:9: error: cannot convert return expression of type '[Double].Type' to return type '[Double]'\n        return [Double] {\n               ^~~~~~~~\n/tmp/tmp6u4mz6kj.swift:18:3: error: generic parameter 'T' could not be inferred\n                min,\n                ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp6u4mz6kj.swift:17:18: error: closure expression is unused\n        return [Double] {\n                        ^\n/tmp/tmp6u4mz6kj.swift:17:18: note: did you mean to use a 'do' statement?\n        return [Double] {\n                        ^\n                        do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp77g5oxty.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp77g5oxty.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp77g5oxty.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp77g5oxty.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp77g5oxty.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp77g5oxty.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp77g5oxty.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number < min {\n            min = number\n        }\n        if number > max {\n            max = number\n        }\n    }\n    for i, number := range numbers {\n        numbers[i] = (number - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr2hig4ze.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpr2hig4ze.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n/tmp/tmpr2hig4ze.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var rescaled_numbers = make([]Double, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        rescaled_numbers[i] = (numbers[i] - min_value) / (max_value - min_value)\n    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprq4r2ma8.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:35: error: expected ',' separator\n    var rescaled_numbers = make([]Double, len(numbers))\n                                  ^\n                                  ,\n/tmp/tmprq4r2ma8.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmprq4r2ma8.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmprq4r2ma8.swift:17:28: error: cannot find 'make' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                           ^~~~\n/tmp/tmprq4r2ma8.swift:17:43: error: cannot find 'len' in scope\n    var rescaled_numbers = make([]Double, len(numbers))\n                                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] - min\n        numbers[i] /= max - min\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpuyw2hjq5.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpuyw2hjq5.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n        }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n    }\n    return [Double] {\n        min,\n        (max - min) / (max - min),\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmp4hp9ges4.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmp4hp9ges4.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp4hp9ges4.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmp4hp9ges4.swift:17:20: error: consecutive statements on a line must be separated by ';'\n    return [Double] {\n                   ^\n                   ;\n/tmp/tmp4hp9ges4.swift:18:12: error: consecutive statements on a line must be separated by ';'\n        min,\n           ^\n           ;\n/tmp/tmp4hp9ges4.swift:18:12: error: expected expression\n        min,\n           ^\n/tmp/tmp4hp9ges4.swift:17:12: error: cannot convert return expression of type '[Double].Type' to return type '[Double]'\n    return [Double] {\n           ^~~~~~~~\n/tmp/tmp4hp9ges4.swift:17:21: error: closure expression is unused\n    return [Double] {\n                    ^\n/tmp/tmp4hp9ges4.swift:17:21: note: did you mean to use a 'do' statement?\n    return [Double] {\n                    ^\n                    do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([Double]{min, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpylggvdjq.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpylggvdjq.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpylggvdjq.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpylggvdjq.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpylggvdjq.swift:17:26: error: expected ',' separator\n        return [Double]([Double]{min, max})\n                                ^\n                                ,\n/tmp/tmpylggvdjq.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([Double]{min, max})\n                                    ^\n                                    ;\n/tmp/tmpylggvdjq.swift:17:30: error: expected expression\n        return [Double]([Double]{min, max})\n                                    ^\n/tmp/tmpylggvdjq.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpylggvdjq.swift:17:17: error: missing argument labels 'unsafeUninitializedCapacity:initializingWith:' in call\n        return [Double]([Double]{min, max})\n                       ^\n                        unsafeUninitializedCapacity:  initializingWith: \n/tmp/tmpylggvdjq.swift:17:27: error: generic parameter 'T' could not be inferred\n        return [Double]([Double]{min, max})\n                                 ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = number - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpr839gbyn.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpr839gbyn.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpr839gbyn.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    var scale = 1.0 / (max_value - min_value)\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = numbers[i] * scale\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpfe6drl48.swift:9:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpfe6drl48.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpfe6drl48.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpfe6drl48.swift:18:12: error: expected type\n    for i := 0; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpfe6drl48.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(numbers); i++ {\n           ^\n/tmp/tmpfe6drl48.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tnumbers[i] = (number - min) / (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmprplze6_t.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmprplze6_t.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmprplze6_t.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:17:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmprplze6_t.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n        if number > max {\n            max = number\n        }\n        if number < min {\n            min = number\n        }\n    }\n    for i, number := range numbers {\n        numbers[i] = (number - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpcmv_6lcr.swift:7:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpcmv_6lcr.swift:7:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpcmv_6lcr.swift:9:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpcmv_6lcr.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpcmv_6lcr.swift:17:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmpcmv_6lcr.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n/tmp/tmpcmv_6lcr.swift:7:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\tif max == min {\n\t\treturn numbers\n\t}\n\tfor _, number := range numbers {\n\t\tnumber -= min\n\t\tnumber /= (max - min)\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmpz20v0uo_.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpz20v0uo_.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpz20v0uo_.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:5: error: generic parameter 'T' could not be inferred\n        if max == min {\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpz20v0uo_.swift:17:9: error: binary operator '==' cannot be applied to two '(_, _) -> _' operands\n        if max == min {\n           ~~~ ^  ~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min {\n\t\t\tmin = number\n\t\t}\n\t\tif number > max {\n\t\t\tmax = number\n\t\t}\n\t}\n\treturn [Double]([]Double{min, max})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpy92c_7gb.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmpy92c_7gb.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmpy92c_7gb.swift:9:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpy92c_7gb.swift:9:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpy92c_7gb.swift:17:20: error: expected ',' separator\n        return [Double]([]Double{min, max})\n                          ^\n                          ,\n/tmp/tmpy92c_7gb.swift:17:30: error: consecutive statements on a line must be separated by ';'\n        return [Double]([]Double{min, max})\n                                    ^\n                                    ;\n/tmp/tmpy92c_7gb.swift:17:30: error: expected expression\n        return [Double]([]Double{min, max})\n                                    ^\n/tmp/tmpy92c_7gb.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpy92c_7gb.swift:17:20: error: no exact matches in call to initializer \n        return [Double]([]Double{min, max})\n                          ^\n/tmp/tmpy92c_7gb.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, max})\n                          ^\n/tmp/tmpy92c_7gb.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Double'\n        return [Double]([]Double{min, max})\n                          ^\n/tmp/tmpy92c_7gb.swift:17:20: note: found candidate with type '(@escaping () -> (_, _) -> _) -> Optional<Double>'\n        return [Double]([]Double{min, max})\n                          ^\n/tmp/tmpy92c_7gb.swift:17:27: error: generic parameter 'T' could not b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, v := range numbers {\n        if v < min {\n            min = v\n        }\n        if v > max {\n            max = v\n        }\n    }\n    for i := range numbers {\n        numbers[i] = (numbers[i] - min) / (max - min)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292851,
      "stdout": "",
      "stderr": "/tmp/tmpbntnco2i.swift:10:8: error: consecutive statements on a line must be separated by ';'\n    min := numbers[0]\n       ^\n       ;\n/tmp/tmpbntnco2i.swift:10:9: error: expected expression\n    min := numbers[0]\n        ^\n/tmp/tmpbntnco2i.swift:12:10: error: expected 'in' after for-each pattern\n    for _, v := range numbers {\n         ^\n/tmp/tmpbntnco2i.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, v := range numbers {\n         ^\n/tmp/tmpbntnco2i.swift:20:12: error: expected type\n    for i := range numbers {\n           ^\n            <#type#>\n/tmp/tmpbntnco2i.swift:20:12: error: expected 'in' after for-each pattern\n    for i := range numbers {\n           ^\n/tmp/tmpbntnco2i.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := range numbers {\n           ^\n/tmp/tmpbntnco2i.swift:7:8: error: cannot find 'len' in scope\n    if len(numbers) < 2 {\n       ^~~\n/tmp/tmpbntnco2i.swift:10:5: error: generic parameter 'T' could not be inferred\n    min := numbers[0]\n    ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given array of numbers (of at least two elements), apply a linear transform to that array,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min {\n\t\t\tmin = numbers[i]\n\t\t}\n\t\tif numbers[i] > max {\n\t\t\tmax = numbers[i]\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tnumbers[i] = numbers[i] - min\n\t\tnumbers[i] /= max - min\n\t}\n\treturn numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
      "timestamp": 1664292850,
      "stdout": "",
      "stderr": "/tmp/tmp61nzltbl.swift:7:5: error: consecutive statements on a line must be separated by ';'\n        min := numbers[0]\n           ^\n           ;\n/tmp/tmp61nzltbl.swift:7:6: error: expected expression\n        min := numbers[0]\n            ^\n/tmp/tmp61nzltbl.swift:9:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp61nzltbl.swift:9:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:9:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:17:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp61nzltbl.swift:17:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:17:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp61nzltbl.swift:7:2: error: generic parameter 'T' could not be inferred\n        min := numbers[0]\n        ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}