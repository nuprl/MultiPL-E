{
  "name": "HumanEval_25_factorize",
  "language": "swift",
  "prompt": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpwvks3ho3.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpwvks3ho3.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpwvks3ho3.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpwvks3ho3.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpwvks3ho3.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpwvks3ho3.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpwvks3ho3.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpwvks3ho3.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpwvks3ho3.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{2}\n    }\n    if n == 3 {\n        return [Int]{3}\n    }\n    if n == 4 {\n        return [Int]{2, 2}\n    }\n    if n == 5 {\n        return [Int]{5}\n    }\n    if n == 6 {\n        return [Int]{2, 3}\n    }\n    if n == 7 {\n        return [Int]{7}\n    }\n    if n == 8 {\n        return [Int]{2, 2, 2}\n    }\n    if n == 9 {\n        return [Int]{3, 3}\n    }\n    if n == 10 {\n        return [Int]{5, 2}\n    }\n    if n == 11 {\n        return [Int]{11}\n    }\n    if n == 12 {\n        return [Int]{2, 2, 2, 2}\n    }\n    if n == 13 {\n        return [Int]{13}\n    }\n    if n == 14 {\n        return [Int]{2, 7}\n    }\n    if n == 15 {\n        return [Int]{3, 5}\n    }\n    if n == 16 {\n        return [Int]{2, 2, 2, 2, 2}\n    }\n    if n == 17 {\n        return [Int]{17}\n    }\n    if n == 18 {\n        return [Int]{2, 3, 3}\n    }\n    if n == 19 {\n        return [Int]{19}\n    }\n    if n == 20 {\n        return [Int]{2, 2, 2, 2, 2, 2}\n    }\n    if n == 21 {\n        return [Int]{3, 3, 3}\n    }\n    if n == 22 {\n        return [Int]{2, 7, 2}\n    }\n    if n == 23 {\n        return [Int]{23}\n    }\n    if n == 24 {\n        return [Int]{2, 2, 2, 2, 2,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp84_k3tz5.swift:13:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:16:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:19:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:22:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2}\n                      ^\n                      ;\n/tmp/tmp84_k3tz5.swift:22:23: error: expected expression\n        return [Int]{2, 2}\n                      ^\n/tmp/tmp84_k3tz5.swift:25:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{5}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmp84_k3tz5.swift:28:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmp84_k3tz5.swift:31:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{7}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:34:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2, 2}\n                    ^\n                    ;\n/tmp/tmp84_k3tz5.swift:34:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2, 2}\n                      ^\n                      ;\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpy0cnoxii.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpy0cnoxii.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpy0cnoxii.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpy0cnoxii.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpy0cnoxii.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpy0cnoxii.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpy0cnoxii.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [Int]{1}\n    }\n    factors := [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp0iujwfxy.swift:13:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp0iujwfxy.swift:15:12: error: consecutive statements on a line must be separated by ';'\n    factors := [Int]{}\n           ^\n           ;\n/tmp/tmp0iujwfxy.swift:15:13: error: expected expression\n    factors := [Int]{}\n            ^\n/tmp/tmp0iujwfxy.swift:16:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp0iujwfxy.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp0iujwfxy.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp0iujwfxy.swift:13:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp0iujwfxy.swift:13:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp0iujwfxy.swift:13:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp0iujwfxy.swift:15:5: error: cannot find 'factors' in scope\n    factors := [Int]{}\n    ^~~~~~~\n/tmp/tmp0iujwfxy.swift:22:12: error: cannot find 'factors' in scope\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpy0cnoxii.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpy0cnoxii.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpy0cnoxii.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpy0cnoxii.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpy0cnoxii.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpy0cnoxii.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpy0cnoxii.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn = n / i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpzbpmf954.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpzbpmf954.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpzbpmf954.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpzbpmf954.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpzbpmf954.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpzbpmf954.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpzbpmf954.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpzbpmf954.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpzbpmf954.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5u2b1vrr.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmp5u2b1vrr.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmp5u2b1vrr.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmp5u2b1vrr.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmp5u2b1vrr.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n/tmp/tmp5u2b1vrr.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor n > 1 {\n\t\tfor i := 2; i < n; i++ {\n\t\t\tif n%i == 0 {\n\t\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t\t\tn /= i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpg6x4rvwv.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpg6x4rvwv.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpg6x4rvwv.swift:13:8: error: expected 'in' after for-each pattern\n        for n > 1 {\n              ^\n/tmp/tmpg6x4rvwv.swift:13:8: error: unary operator cannot be separated from its operand\n        for n > 1 {\n              ^~\n               \n/tmp/tmpg6x4rvwv.swift:14:10: error: expected type\n                for i := 2; i < n; i++ {\n                       ^\n                        <#type#>\n/tmp/tmpg6x4rvwv.swift:14:10: error: expected 'in' after for-each pattern\n                for i := 2; i < n; i++ {\n                       ^\n/tmp/tmpg6x4rvwv.swift:14:10: error: expected Sequence expression for for-each loop\n                for i := 2; i < n; i++ {\n                       ^\n/tmp/tmpg6x4rvwv.swift:16:33: error: expected ',' separator\n                                factors = append(factors, []int{i, n / i})\n                                                            ^\n                                                            ,\n/tmp/tmpg6x4rvwv.swift:16:38: error: consecutive statements on a line must be separated by ';'\n                                factors = append(factors, []int{i, n / i})\n                                                                 ^\n                                                                 ;\n/tmp/tmpg6x4rvwv.swift:16:38: error: expected expression\n                                factors = append(factors, []int{i, n / i})\n                                                                 ^\n/tmp/tmpg6x4rvwv.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpg6x4rvwv.swift:13:8: error: '>' is not a prefix unary operator\n        for n > 1 {\n              ^\n/tmp/tmpg6x4rvwv.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpnm1b2ifl.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpnm1b2ifl.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpnm1b2ifl.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpnm1b2ifl.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{2}\n    }\n    if n == 3 {\n        return [Int]{3}\n    }\n    if n == 4 {\n        return [Int]{2, 2}\n    }\n    if n == 5 {\n        return [Int]{5}\n    }\n    if n == 6 {\n        return [Int]{2, 3}\n    }\n    if n == 7 {\n        return [Int]{7}\n    }\n    if n == 8 {\n        return [Int]{2, 2, 2}\n    }\n    if n == 9 {\n        return [Int]{3, 3}\n    }\n    if n == 10 {\n        return [Int]{5, 2}\n    }\n    if n == 11 {\n        return [Int]{11}\n    }\n    if n == 12 {\n        return [Int]{2, 2, 2, 2}\n    }\n    if n == 13 {\n        return [Int]{13}\n    }\n    if n == 14 {\n        return [Int]{2, 7}\n    }\n    if n == 15 {\n        return [Int]{3, 5}\n    }\n    if n == 16 {\n        return [Int]{2, 2, 2, 2, 2}\n    }\n    if n == 17 {\n        return [Int]{17}\n    }\n    if n == 18 {\n        return [Int]{2, 3, 3}\n    }\n    if n == 19 {\n        return [Int]{19}\n    }\n    if n == 20 {\n        return [Int]{2, 2, 2, 2, 2, 2}\n    }\n    if n == 21 {\n        return [Int]{3, 3, 7}\n    }\n    if n == 22 {\n        return [Int]{2, 2, 2, 2, 2, 2, 2}\n    }\n    if n == 23 {\n        return [Int]{23}\n    }\n    if n == 24 {\n        return [Int]{2,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2aa_dlcr.swift:13:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:16:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:19:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:22:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2}\n                      ^\n                      ;\n/tmp/tmp2aa_dlcr.swift:22:23: error: expected expression\n        return [Int]{2, 2}\n                      ^\n/tmp/tmp2aa_dlcr.swift:25:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{5}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmp2aa_dlcr.swift:28:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmp2aa_dlcr.swift:31:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{7}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:34:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2, 2}\n                    ^\n                    ;\n/tmp/tmp2aa_dlcr.swift:34:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 2, 2}\n                      ^\n                      ;\n/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor n%2 == 0 {\n\t\tfactors = append(factors, 2)\n\t\tn /= 2\n\t}\n\tfor n%3 == 0 {\n\t\tfactors = append(factors, 3)\n\t\tn /= 3\n\t}\n\tfor n%5 == 0 {\n\t\tfactors = append(factors, 5)\n\t\tn /= 5\n\t}\n\tfor n%7 == 0 {\n\t\tfactors = append(factors, 7)\n\t\tn /= 7\n\t}\n\tfor n%11 == 0 {\n\t\tfactors = append(factors, 11)\n\t\tn /= 11\n\t}\n\tfor n%13 == 0 {\n\t\tfactors = append(factors, 13)\n\t\tn /= 13\n\t}\n\tfor n%17 == 0 {\n\t\tfactors = append(factors, 17)\n\t\tn /= 17\n\t}\n\tfor n%19 == 0 {\n\t\tfactors = append(factors, 19)\n\t\tn /= 19\n\t}\n\tfor n%23 == 0 {\n\t\tfactors = append(factors, 23)\n\t\tn /= 23\n\t}\n\tfor n%29 == 0 {\n\t\tfactors = append(factors, 29)\n\t\tn /= 29\n\t}\n\tfor n%31 == 0 {\n\t\tfactors = append(factors, 31)\n\t\tn /= 31\n\t}\n\tfor n%37 == 0 {\n\t\tfactors = append(factors, 37)\n\t\tn /= 37\n\t}\n\tfor n%41 == 0 {\n\t\tfactors = append(factors, 41)\n\t\tn /= 41\n\t}\n\tfor n%43 == 0 {\n\t\tfactors = append(factors, 43)\n\t\tn /= 43\n\t}\n\tfor n%47 == 0 {\n\t\tfactors = append(factors, 47)\n\t\tn /= 47\n\t}\n\tfor n%53 == 0 {\n\t\tfactors = append(factors, 53)\n\t\tn /= 53\n\t}\n\tfor n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp_dqgcepm.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp_dqgcepm.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp_dqgcepm.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected 'in' after for-each pattern\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected expression after unary operator\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected 'in' after for-each pattern\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected expression after unary operator\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected 'in' after for-each pattern\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected expression after unary operator\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected 'in' after for-each pattern\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected expression after unary operator\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected 'in' after for-each pattern\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected expression after unary operator\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected 'in' after for-each pattern\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected expression after unary operator\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected 'in' after for-each pattern\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected expression after unary operator\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [Int]{1}\n    }\n    factors := [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp0iujwfxy.swift:13:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp0iujwfxy.swift:15:12: error: consecutive statements on a line must be separated by ';'\n    factors := [Int]{}\n           ^\n           ;\n/tmp/tmp0iujwfxy.swift:15:13: error: expected expression\n    factors := [Int]{}\n            ^\n/tmp/tmp0iujwfxy.swift:16:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp0iujwfxy.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp0iujwfxy.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp0iujwfxy.swift:13:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp0iujwfxy.swift:13:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp0iujwfxy.swift:13:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp0iujwfxy.swift:15:5: error: cannot find 'factors' in scope\n    factors := [Int]{}\n    ^~~~~~~\n/tmp/tmp0iujwfxy.swift:22:12: error: cannot find 'factors' in scope\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int]\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpdna65nde.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int]\n               ^\n               ;\n/tmp/tmpdna65nde.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmpdna65nde.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpdna65nde.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpdna65nde.swift:12:9: error: type annotation missing in pattern\n    var factors [Int]\n        ^\n/tmp/tmpdna65nde.swift:12:17: error: expected member name or constructor call after type name\n    var factors [Int]\n                ^\n/tmp/tmpdna65nde.swift:12:21: note: add arguments after the type to construct a value of the type\n    var factors [Int]\n                    ^\n                     ()\n/tmp/tmpdna65nde.swift:12:21: note: use '.self' to reference the type object\n    var factors [Int]\n                    ^\n                     .self\n/tmp/tmpdna65nde.swift:12:17: warning: expression of type '[Int].Type' is unused\n    var factors [Int]\n                ^~~~~\n/tmp/tmpdna65nde.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp3r3mqezw.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp3r3mqezw.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp3r3mqezw.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp3r3mqezw.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp3r3mqezw.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp3r3mqezw.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp3r3mqezw.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp3r3mqezw.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp3r3mqezw.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp3r3mqezw.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpnm1b2ifl.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpnm1b2ifl.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpnm1b2ifl.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpnm1b2ifl.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpwvks3ho3.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpwvks3ho3.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpwvks3ho3.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpwvks3ho3.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpwvks3ho3.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpwvks3ho3.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpwvks3ho3.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpwvks3ho3.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpwvks3ho3.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpk3r9o5ba.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]\n                  ^\n/tmp/tmpk3r9o5ba.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]\n                      ^\n                       ()\n/tmp/tmpk3r9o5ba.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]\n                      ^\n                       .self\n/tmp/tmpk3r9o5ba.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpno9a6nuo.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpno9a6nuo.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpno9a6nuo.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:3: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpno9a6nuo.swift:20:20: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                                 ^~~~~~~\n/tmp/tmpno9a6nuo.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp1vo66ffn.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp1vo66ffn.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp1vo66ffn.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp1vo66ffn.swift:16:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp1vo66ffn.swift:16:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp1vo66ffn.swift:16:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp1vo66ffn.swift:13:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{1}\n                       ^~~~~\n/tmp/tmp1vo66ffn.swift:13:15: error: closure expression is unused\n                return [Int]{1}\n                            ^\n/tmp/tmp1vo66ffn.swift:13:15: note: did you mean to use a 'do' statement?\n                return [Int]{1}\n                            ^\n                            do \n/tmp/tmp1vo66ffn.swift:15:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmp1vo66ffn.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpx9qmf27y.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpx9qmf27y.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpx9qmf27y.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpx9qmf27y.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpx9qmf27y.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpx9qmf27y.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpx9qmf27y.swift:20:3: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                ^~~~~~~\n/tmp/tmpx9qmf27y.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpx9qmf27y.swift:20:20: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                                 ^~~~~~~\n/tmp/tmpx9qmf27y.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn = n / i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpt2qu8hkw.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpt2qu8hkw.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpt2qu8hkw.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpt2qu8hkw.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpt2qu8hkw.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpt2qu8hkw.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpt2qu8hkw.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpt2qu8hkw.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpt2qu8hkw.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpryanrb8o.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmpryanrb8o.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpryanrb8o.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpryanrb8o.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]\n                  ^\n/tmp/tmpryanrb8o.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]\n                      ^\n                       ()\n/tmp/tmpryanrb8o.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]\n                      ^\n                       .self\n/tmp/tmpryanrb8o.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmpryanrb8o.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpx9qmf27y.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpx9qmf27y.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpx9qmf27y.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpx9qmf27y.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpx9qmf27y.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpx9qmf27y.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpx9qmf27y.swift:20:3: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                ^~~~~~~\n/tmp/tmpx9qmf27y.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpx9qmf27y.swift:20:20: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                                 ^~~~~~~\n/tmp/tmpx9qmf27y.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpno9a6nuo.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpno9a6nuo.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpno9a6nuo.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:3: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpno9a6nuo.swift:20:20: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                                 ^~~~~~~\n/tmp/tmpno9a6nuo.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [Int]{}\n    }\n    factors := [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpu2kwj7uq.swift:13:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpu2kwj7uq.swift:15:12: error: consecutive statements on a line must be separated by ';'\n    factors := [Int]{}\n           ^\n           ;\n/tmp/tmpu2kwj7uq.swift:15:13: error: expected expression\n    factors := [Int]{}\n            ^\n/tmp/tmpu2kwj7uq.swift:16:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpu2kwj7uq.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpu2kwj7uq.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpu2kwj7uq.swift:13:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpu2kwj7uq.swift:13:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpu2kwj7uq.swift:13:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpu2kwj7uq.swift:15:5: error: cannot find 'factors' in scope\n    factors := [Int]{}\n    ^~~~~~~\n/tmp/tmpu2kwj7uq.swift:22:12: error: cannot find 'factors' in scope\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5u2b1vrr.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmp5u2b1vrr.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmp5u2b1vrr.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmp5u2b1vrr.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmp5u2b1vrr.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n/tmp/tmp5u2b1vrr.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpd7xo7qh1.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpd7xo7qh1.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpd7xo7qh1.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpd7xo7qh1.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpd7xo7qh1.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpd7xo7qh1.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpd7xo7qh1.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpd7xo7qh1.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpd7xo7qh1.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor n%2 == 0 {\n\t\tfactors = append(factors, 2)\n\t\tn /= 2\n\t}\n\tfor n%3 == 0 {\n\t\tfactors = append(factors, 3)\n\t\tn /= 3\n\t}\n\tfor n%5 == 0 {\n\t\tfactors = append(factors, 5)\n\t\tn /= 5\n\t}\n\tfor n%7 == 0 {\n\t\tfactors = append(factors, 7)\n\t\tn /= 7\n\t}\n\tfor n%11 == 0 {\n\t\tfactors = append(factors, 11)\n\t\tn /= 11\n\t}\n\tfor n%13 == 0 {\n\t\tfactors = append(factors, 13)\n\t\tn /= 13\n\t}\n\tfor n%17 == 0 {\n\t\tfactors = append(factors, 17)\n\t\tn /= 17\n\t}\n\tfor n%19 == 0 {\n\t\tfactors = append(factors, 19)\n\t\tn /= 19\n\t}\n\tfor n%23 == 0 {\n\t\tfactors = append(factors, 23)\n\t\tn /= 23\n\t}\n\tfor n%29 == 0 {\n\t\tfactors = append(factors, 29)\n\t\tn /= 29\n\t}\n\tfor n%31 == 0 {\n\t\tfactors = append(factors, 31)\n\t\tn /= 31\n\t}\n\tfor n%37 == 0 {\n\t\tfactors = append(factors, 37)\n\t\tn /= 37\n\t}\n\tfor n%41 == 0 {\n\t\tfactors = append(factors, 41)\n\t\tn /= 41\n\t}\n\tfor n%43 == 0 {\n\t\tfactors = append(factors, 43)\n\t\tn /= 43\n\t}\n\tfor n%47 == 0 {\n\t\tfactors = append(factors, 47)\n\t\tn /= 47\n\t}\n\tfor n%53 == 0 {\n\t\tfactors = append(factors, 53)\n\t\tn /= 53\n\t}\n\tfor n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp_dqgcepm.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp_dqgcepm.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp_dqgcepm.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected 'in' after for-each pattern\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected expression after unary operator\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected 'in' after for-each pattern\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected expression after unary operator\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected 'in' after for-each pattern\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected expression after unary operator\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected 'in' after for-each pattern\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected expression after unary operator\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected 'in' after for-each pattern\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected expression after unary operator\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected 'in' after for-each pattern\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected expression after unary operator\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected 'in' after for-each pattern\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected expression after unary operator\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp0i2vbyob.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmp0i2vbyob.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmp0i2vbyob.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp0i2vbyob.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp0i2vbyob.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp0i2vbyob.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmp0i2vbyob.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmp0i2vbyob.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmp0i2vbyob.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmp0i2vbyob.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor n%2 == 0 {\n\t\tfactors = append(factors, 2)\n\t\tn /= 2\n\t}\n\tfor n%3 == 0 {\n\t\tfactors = append(factors, 3)\n\t\tn /= 3\n\t}\n\tfor n%5 == 0 {\n\t\tfactors = append(factors, 5)\n\t\tn /= 5\n\t}\n\tfor n%7 == 0 {\n\t\tfactors = append(factors, 7)\n\t\tn /= 7\n\t}\n\tfor n%11 == 0 {\n\t\tfactors = append(factors, 11)\n\t\tn /= 11\n\t}\n\tfor n%13 == 0 {\n\t\tfactors = append(factors, 13)\n\t\tn /= 13\n\t}\n\tfor n%17 == 0 {\n\t\tfactors = append(factors, 17)\n\t\tn /= 17\n\t}\n\tfor n%19 == 0 {\n\t\tfactors = append(factors, 19)\n\t\tn /= 19\n\t}\n\tfor n%23 == 0 {\n\t\tfactors = append(factors, 23)\n\t\tn /= 23\n\t}\n\tfor n%29 == 0 {\n\t\tfactors = append(factors, 29)\n\t\tn /= 29\n\t}\n\tfor n%31 == 0 {\n\t\tfactors = append(factors, 31)\n\t\tn /= 31\n\t}\n\tfor n%37 == 0 {\n\t\tfactors = append(factors, 37)\n\t\tn /= 37\n\t}\n\tfor n%41 == 0 {\n\t\tfactors = append(factors, 41)\n\t\tn /= 41\n\t}\n\tfor n%43 == 0 {\n\t\tfactors = append(factors, 43)\n\t\tn /= 43\n\t}\n\tfor n%47 == 0 {\n\t\tfactors = append(factors, 47)\n\t\tn /= 47\n\t}\n\tfor n%53 == 0 {\n\t\tfactors = append(factors, 53)\n\t\tn /= 53\n\t}\n\tfor n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp_dqgcepm.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp_dqgcepm.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp_dqgcepm.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected 'in' after for-each pattern\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected expression after unary operator\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected 'in' after for-each pattern\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected expression after unary operator\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected 'in' after for-each pattern\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected expression after unary operator\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected 'in' after for-each pattern\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected expression after unary operator\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected 'in' after for-each pattern\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected expression after unary operator\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected 'in' after for-each pattern\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected expression after unary operator\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected 'in' after for-each pattern\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected expression after unary operator\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpi9n_dnd3.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmpi9n_dnd3.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmpi9n_dnd3.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmpi9n_dnd3.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmpi9n_dnd3.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpi9n_dnd3.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmpi9n_dnd3.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmpi9n_dnd3.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmpi9n_dnd3.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmpi9n_dnd3.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn = n / i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp8rm4afv9.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp8rm4afv9.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp8rm4afv9.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp8rm4afv9.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp8rm4afv9.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp8rm4afv9.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp8rm4afv9.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp8rm4afv9.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpy0cnoxii.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpy0cnoxii.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpy0cnoxii.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpy0cnoxii.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpy0cnoxii.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpy0cnoxii.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpy0cnoxii.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5u2b1vrr.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmp5u2b1vrr.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmp5u2b1vrr.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmp5u2b1vrr.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmp5u2b1vrr.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n/tmp/tmp5u2b1vrr.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5u2b1vrr.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmp5u2b1vrr.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmp5u2b1vrr.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmp5u2b1vrr.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmp5u2b1vrr.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n/tmp/tmp5u2b1vrr.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpno9a6nuo.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpno9a6nuo.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpno9a6nuo.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:3: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpno9a6nuo.swift:20:20: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                                 ^~~~~~~\n/tmp/tmpno9a6nuo.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int]\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp6gcnx3mv.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int]\n               ^\n               ;\n/tmp/tmp6gcnx3mv.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp6gcnx3mv.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp6gcnx3mv.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp6gcnx3mv.swift:12:9: error: type annotation missing in pattern\n    var factors [Int]\n        ^\n/tmp/tmp6gcnx3mv.swift:12:17: error: expected member name or constructor call after type name\n    var factors [Int]\n                ^\n/tmp/tmp6gcnx3mv.swift:12:21: note: add arguments after the type to construct a value of the type\n    var factors [Int]\n                    ^\n                     ()\n/tmp/tmp6gcnx3mv.swift:12:21: note: use '.self' to reference the type object\n    var factors [Int]\n                    ^\n                     .self\n/tmp/tmp6gcnx3mv.swift:12:17: warning: expression of type '[Int].Type' is unused\n    var factors [Int]\n                ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp1vo66ffn.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp1vo66ffn.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp1vo66ffn.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp1vo66ffn.swift:16:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp1vo66ffn.swift:16:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp1vo66ffn.swift:16:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp1vo66ffn.swift:13:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{1}\n                       ^~~~~\n/tmp/tmp1vo66ffn.swift:13:15: error: closure expression is unused\n                return [Int]{1}\n                            ^\n/tmp/tmp1vo66ffn.swift:13:15: note: did you mean to use a 'do' statement?\n                return [Int]{1}\n                            ^\n                            do \n/tmp/tmp1vo66ffn.swift:15:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmp1vo66ffn.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn = n / i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp8rm4afv9.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp8rm4afv9.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp8rm4afv9.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp8rm4afv9.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp8rm4afv9.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp8rm4afv9.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp8rm4afv9.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp8rm4afv9.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpb0f3_scg.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmpb0f3_scg.swift:15:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpb0f3_scg.swift:16:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpb0f3_scg.swift:16:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpb0f3_scg.swift:16:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpb0f3_scg.swift:13:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{1}\n                       ^~~~~\n/tmp/tmpb0f3_scg.swift:13:15: error: closure expression is unused\n                return [Int]{1}\n                            ^\n/tmp/tmpb0f3_scg.swift:13:15: note: did you mean to use a 'do' statement?\n                return [Int]{1}\n                            ^\n                            do \n/tmp/tmpb0f3_scg.swift:15:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpb0f3_scg.swift:15:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpb0f3_scg.swift:15:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpb0f3_scg.swift:15:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpb0f3_scg.swift:15:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpfnc08ci6.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpfnc08ci6.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpfnc08ci6.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpfnc08ci6.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpfnc08ci6.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpfnc08ci6.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpfnc08ci6.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpfnc08ci6.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpnm1b2ifl.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpnm1b2ifl.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpnm1b2ifl.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpnm1b2ifl.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpnm1b2ifl.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpno9a6nuo.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpno9a6nuo.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpno9a6nuo.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpno9a6nuo.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:3: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                ^~~~~~~\n/tmp/tmpno9a6nuo.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmpno9a6nuo.swift:20:20: error: cannot find 'factors' in scope\n                factors = append(factors, n)\n                                 ^~~~~~~\n/tmp/tmpno9a6nuo.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor n%2 == 0 {\n\t\tfactors = append(factors, 2)\n\t\tn /= 2\n\t}\n\tfor n%3 == 0 {\n\t\tfactors = append(factors, 3)\n\t\tn /= 3\n\t}\n\tfor n%5 == 0 {\n\t\tfactors = append(factors, 5)\n\t\tn /= 5\n\t}\n\tfor n%7 == 0 {\n\t\tfactors = append(factors, 7)\n\t\tn /= 7\n\t}\n\tfor n%11 == 0 {\n\t\tfactors = append(factors, 11)\n\t\tn /= 11\n\t}\n\tfor n%13 == 0 {\n\t\tfactors = append(factors, 13)\n\t\tn /= 13\n\t}\n\tfor n%17 == 0 {\n\t\tfactors = append(factors, 17)\n\t\tn /= 17\n\t}\n\tfor n%19 == 0 {\n\t\tfactors = append(factors, 19)\n\t\tn /= 19\n\t}\n\tfor n%23 == 0 {\n\t\tfactors = append(factors, 23)\n\t\tn /= 23\n\t}\n\tfor n%29 == 0 {\n\t\tfactors = append(factors, 29)\n\t\tn /= 29\n\t}\n\tfor n%31 == 0 {\n\t\tfactors = append(factors, 31)\n\t\tn /= 31\n\t}\n\tfor n%37 == 0 {\n\t\tfactors = append(factors, 37)\n\t\tn /= 37\n\t}\n\tfor n%41 == 0 {\n\t\tfactors = append(factors, 41)\n\t\tn /= 41\n\t}\n\tfor n%43 == 0 {\n\t\tfactors = append(factors, 43)\n\t\tn /= 43\n\t}\n\tfor n%47 == 0 {\n\t\tfactors = append(factors, 47)\n\t\tn /= 47\n\t}\n\tfor n%53 == 0 {\n\t\tfactors = append(factors, 53)\n\t\tn /= 53\n\t}\n\tfor n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp_dqgcepm.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp_dqgcepm.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp_dqgcepm.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected 'in' after for-each pattern\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected expression after unary operator\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected 'in' after for-each pattern\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected expression after unary operator\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected 'in' after for-each pattern\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected expression after unary operator\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected 'in' after for-each pattern\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected expression after unary operator\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected 'in' after for-each pattern\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected expression after unary operator\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected 'in' after for-each pattern\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected expression after unary operator\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected 'in' after for-each pattern\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected expression after unary operator\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int]\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpdna65nde.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int]\n               ^\n               ;\n/tmp/tmpdna65nde.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmpdna65nde.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpdna65nde.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpdna65nde.swift:12:9: error: type annotation missing in pattern\n    var factors [Int]\n        ^\n/tmp/tmpdna65nde.swift:12:17: error: expected member name or constructor call after type name\n    var factors [Int]\n                ^\n/tmp/tmpdna65nde.swift:12:21: note: add arguments after the type to construct a value of the type\n    var factors [Int]\n                    ^\n                     ()\n/tmp/tmpdna65nde.swift:12:21: note: use '.self' to reference the type object\n    var factors [Int]\n                    ^\n                     .self\n/tmp/tmpdna65nde.swift:12:17: warning: expression of type '[Int].Type' is unused\n    var factors [Int]\n                ^~~~~\n/tmp/tmpdna65nde.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34ilvr0p.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmp34ilvr0p.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmp34ilvr0p.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmp34ilvr0p.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmp34ilvr0p.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmp34ilvr0p.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmp34ilvr0p.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int]\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp6gcnx3mv.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int]\n               ^\n               ;\n/tmp/tmp6gcnx3mv.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp6gcnx3mv.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp6gcnx3mv.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp6gcnx3mv.swift:12:9: error: type annotation missing in pattern\n    var factors [Int]\n        ^\n/tmp/tmp6gcnx3mv.swift:12:17: error: expected member name or constructor call after type name\n    var factors [Int]\n                ^\n/tmp/tmp6gcnx3mv.swift:12:21: note: add arguments after the type to construct a value of the type\n    var factors [Int]\n                    ^\n                     ()\n/tmp/tmp6gcnx3mv.swift:12:21: note: use '.self' to reference the type object\n    var factors [Int]\n                    ^\n                     .self\n/tmp/tmp6gcnx3mv.swift:12:17: warning: expression of type '[Int].Type' is unused\n    var factors [Int]\n                ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp9k3hs0vg.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmp9k3hs0vg.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp9k3hs0vg.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmp9k3hs0vg.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmp9k3hs0vg.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmp9k3hs0vg.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpk3r9o5ba.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]\n                  ^\n/tmp/tmpk3r9o5ba.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]\n                      ^\n                       ()\n/tmp/tmpk3r9o5ba.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]\n                      ^\n                       .self\n/tmp/tmpk3r9o5ba.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := make([][]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, []int{i, n / i})\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpixbuvqwx.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := make([][]int, 0)\n               ^\n               ;\n/tmp/tmpixbuvqwx.swift:12:10: error: expected expression\n        factors := make([][]int, 0)\n                ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmpixbuvqwx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmpixbuvqwx.swift:15:32: error: expected ',' separator\n                        factors = append(factors, []int{i, n / i})\n                                                    ^\n                                                    ,\n/tmp/tmpixbuvqwx.swift:15:37: error: consecutive statements on a line must be separated by ';'\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n                                                         ;\n/tmp/tmpixbuvqwx.swift:15:37: error: expected expression\n                        factors = append(factors, []int{i, n / i})\n                                                         ^\n/tmp/tmpixbuvqwx.swift:12:2: error: cannot find 'factors' in scope\n        factors := make([][]int, 0)\n        ^~~~~~~\n/tmp/tmpixbuvqwx.swift:18:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpk3r9o5ba.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]\n                  ^\n/tmp/tmpk3r9o5ba.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]\n                      ^\n                       ()\n/tmp/tmpk3r9o5ba.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]\n                      ^\n                       .self\n/tmp/tmpk3r9o5ba.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpk3r9o5ba.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpk3r9o5ba.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]\n                  ^\n/tmp/tmpk3r9o5ba.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]\n                      ^\n                       ()\n/tmp/tmpk3r9o5ba.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]\n                      ^\n                       .self\n/tmp/tmpk3r9o5ba.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpy0cnoxii.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmpy0cnoxii.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpy0cnoxii.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpy0cnoxii.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmpy0cnoxii.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmpy0cnoxii.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmpy0cnoxii.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmpy0cnoxii.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpat4n8x9w.swift:12:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmpat4n8x9w.swift:12:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpat4n8x9w.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpat4n8x9w.swift:12:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmpat4n8x9w.swift:19:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpi9n_dnd3.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmpi9n_dnd3.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmpi9n_dnd3.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmpi9n_dnd3.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmpi9n_dnd3.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpi9n_dnd3.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmpi9n_dnd3.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpi9n_dnd3.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmpi9n_dnd3.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmpi9n_dnd3.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmpi9n_dnd3.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors [Int] = [Int]{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpwyfhaz1t.swift:12:16: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n               ^\n               ;\n/tmp/tmpwyfhaz1t.swift:12:30: error: consecutive statements on a line must be separated by ';'\n    var factors [Int] = [Int]{}\n                             ^\n                             ;\n/tmp/tmpwyfhaz1t.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmpwyfhaz1t.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpwyfhaz1t.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpwyfhaz1t.swift:12:9: error: type annotation missing in pattern\n    var factors [Int] = [Int]{}\n        ^\n/tmp/tmpwyfhaz1t.swift:12:17: error: cannot assign to immutable expression of type '[Int].Type'\n    var factors [Int] = [Int]{}\n                ^~~~~\n/tmp/tmpwyfhaz1t.swift:12:30: error: closure expression is unused\n    var factors [Int] = [Int]{}\n                             ^\n/tmp/tmpwyfhaz1t.swift:12:30: note: did you mean to use a 'do' statement?\n    var factors [Int] = [Int]{}\n                             ^\n                             do \n/tmp/tmpwyfhaz1t.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5ufmqr23.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5ufmqr23.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5ufmqr23.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp5ufmqr23.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp5ufmqr23.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp5ufmqr23.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp5ufmqr23.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp1vo66ffn.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp1vo66ffn.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp1vo66ffn.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp1vo66ffn.swift:16:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp1vo66ffn.swift:16:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp1vo66ffn.swift:16:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp1vo66ffn.swift:13:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{1}\n                       ^~~~~\n/tmp/tmp1vo66ffn.swift:13:15: error: closure expression is unused\n                return [Int]{1}\n                            ^\n/tmp/tmp1vo66ffn.swift:13:15: note: did you mean to use a 'do' statement?\n                return [Int]{1}\n                            ^\n                            do \n/tmp/tmp1vo66ffn.swift:15:2: error: cannot find 'factors' in scope\n        factors := [Int]{}\n        ^~~~~~~\n/tmp/tmp1vo66ffn.swift:22:9: error: cannot find 'factors' in scope\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpryanrb8o.swift:13:12: error: expected type\n    for i := 2; i < n; i++ {\n           ^\n            <#type#>\n/tmp/tmpryanrb8o.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpryanrb8o.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i < n; i++ {\n           ^\n/tmp/tmpryanrb8o.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]\n                  ^\n/tmp/tmpryanrb8o.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]\n                      ^\n                       ()\n/tmp/tmpryanrb8o.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]\n                      ^\n                       .self\n/tmp/tmpryanrb8o.swift:20:19: error: cannot find 'append' in scope\n        factors = append(factors, n)\n                  ^~~~~~\n/tmp/tmpryanrb8o.swift:22:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tif n == 1 {\n\t\treturn [Int]{1}\n\t}\n\tfactors := [Int]{}\n\tfor n%2 == 0 {\n\t\tfactors = append(factors, 2)\n\t\tn /= 2\n\t}\n\tfor n%3 == 0 {\n\t\tfactors = append(factors, 3)\n\t\tn /= 3\n\t}\n\tfor n%5 == 0 {\n\t\tfactors = append(factors, 5)\n\t\tn /= 5\n\t}\n\tfor n%7 == 0 {\n\t\tfactors = append(factors, 7)\n\t\tn /= 7\n\t}\n\tfor n%11 == 0 {\n\t\tfactors = append(factors, 11)\n\t\tn /= 11\n\t}\n\tfor n%13 == 0 {\n\t\tfactors = append(factors, 13)\n\t\tn /= 13\n\t}\n\tfor n%17 == 0 {\n\t\tfactors = append(factors, 17)\n\t\tn /= 17\n\t}\n\tfor n%19 == 0 {\n\t\tfactors = append(factors, 19)\n\t\tn /= 19\n\t}\n\tfor n%23 == 0 {\n\t\tfactors = append(factors, 23)\n\t\tn /= 23\n\t}\n\tfor n%29 == 0 {\n\t\tfactors = append(factors, 29)\n\t\tn /= 29\n\t}\n\tfor n%31 == 0 {\n\t\tfactors = append(factors, 31)\n\t\tn /= 31\n\t}\n\tfor n%37 == 0 {\n\t\tfactors = append(factors, 37)\n\t\tn /= 37\n\t}\n\tfor n%41 == 0 {\n\t\tfactors = append(factors, 41)\n\t\tn /= 41\n\t}\n\tfor n%43 == 0 {\n\t\tfactors = append(factors, 43)\n\t\tn /= 43\n\t}\n\tfor n%47 == 0 {\n\t\tfactors = append(factors, 47)\n\t\tn /= 47\n\t}\n\tfor n%53 == 0 {\n\t\tfactors = append(factors, 53)\n\t\tn /= 53\n\t}\n\tfor n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp_dqgcepm.swift:13:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmp_dqgcepm.swift:15:9: error: consecutive statements on a line must be separated by ';'\n        factors := [Int]{}\n               ^\n               ;\n/tmp/tmp_dqgcepm.swift:15:10: error: expected expression\n        factors := [Int]{}\n                ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected 'in' after for-each pattern\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:16:7: error: expected expression after unary operator\n        for n%2 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected 'in' after for-each pattern\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:20:7: error: expected expression after unary operator\n        for n%3 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected 'in' after for-each pattern\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:24:7: error: expected expression after unary operator\n        for n%5 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected 'in' after for-each pattern\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:28:7: error: expected expression after unary operator\n        for n%7 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected 'in' after for-each pattern\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:32:7: error: expected expression after unary operator\n        for n%11 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected 'in' after for-each pattern\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:36:7: error: expected expression after unary operator\n        for n%13 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected 'in' after for-each pattern\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm.swift:40:7: error: expected expression after unary operator\n        for n%17 == 0 {\n             ^\n/tmp/tmp_dqgcepm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp34y_ncxu.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp34y_ncxu.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp34y_ncxu.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp34y_ncxu.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp34y_ncxu.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp34y_ncxu.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n/tmp/tmp34y_ncxu.swift:22:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int] = [Int]{}\n\tfor i := 2; i < n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp5u2b1vrr.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                   ^\n                   ;\n/tmp/tmp5u2b1vrr.swift:12:27: error: consecutive statements on a line must be separated by ';'\n        var factors [Int] = [Int]{}\n                                 ^\n                                 ;\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp5u2b1vrr.swift:12:6: error: type annotation missing in pattern\n        var factors [Int] = [Int]{}\n            ^\n/tmp/tmp5u2b1vrr.swift:12:14: error: cannot assign to immutable expression of type '[Int].Type'\n        var factors [Int] = [Int]{}\n                    ^~~~~\n/tmp/tmp5u2b1vrr.swift:12:27: error: closure expression is unused\n        var factors [Int] = [Int]{}\n                                 ^\n/tmp/tmp5u2b1vrr.swift:12:27: note: did you mean to use a 'do' statement?\n        var factors [Int] = [Int]{}\n                                 ^\n                                 do \n/tmp/tmp5u2b1vrr.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors [Int]\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp99wlfjes.swift:12:13: error: consecutive statements on a line must be separated by ';'\n        var factors [Int]\n                   ^\n                   ;\n/tmp/tmp99wlfjes.swift:13:9: error: expected type\n        for i := 2; i < n; i++ {\n               ^\n                <#type#>\n/tmp/tmp99wlfjes.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i++ {\n               ^\n/tmp/tmp99wlfjes.swift:12:6: error: type annotation missing in pattern\n        var factors [Int]\n            ^\n/tmp/tmp99wlfjes.swift:12:14: error: expected member name or constructor call after type name\n        var factors [Int]\n                    ^\n/tmp/tmp99wlfjes.swift:12:18: note: add arguments after the type to construct a value of the type\n        var factors [Int]\n                        ^\n                         ()\n/tmp/tmp99wlfjes.swift:12:18: note: use '.self' to reference the type object\n        var factors [Int]\n                        ^\n                         .self\n/tmp/tmp99wlfjes.swift:12:14: warning: expression of type '[Int].Type' is unused\n        var factors [Int]\n                    ^~~~~\n/tmp/tmp99wlfjes.swift:20:13: error: cannot find 'append' in scope\n                factors = append(factors, n)\n                          ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpm6mlabhp.swift:12:24: error: unexpected '{' in declaration\n    var factors = [Int]{}\n                       ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm6mlabhp.swift:13:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:13:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm6mlabhp.swift:12:19: error: expected member name or constructor call after type name\n    var factors = [Int]{}\n                  ^\n/tmp/tmpm6mlabhp.swift:12:23: note: add arguments after the type to construct a value of the type\n    var factors = [Int]{}\n                      ^\n                       ()\n/tmp/tmpm6mlabhp.swift:12:23: note: use '.self' to reference the type object\n    var factors = [Int]{}\n                      ^\n                       .self\n/tmp/tmpm6mlabhp.swift:19:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return factors\n           ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmp2ktzebrx.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmp2ktzebrx.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmp2ktzebrx.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmp2ktzebrx.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmp2ktzebrx.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmp2ktzebrx.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return array of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be arrayed number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(n: 8)\n/// [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n/// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors = [Int]{}\n\tfor i := 2; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn /= i\n\t\t}\n\t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "/tmp/tmpp5bhfrec.swift:12:21: error: unexpected '{' in declaration\n        var factors = [Int]{}\n                           ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected type\n        for i := 2; i <= n; i++ {\n               ^\n                <#type#>\n/tmp/tmpp5bhfrec.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 2; i <= n; i++ {\n               ^\n/tmp/tmpp5bhfrec.swift:12:16: error: expected member name or constructor call after type name\n        var factors = [Int]{}\n                      ^\n/tmp/tmpp5bhfrec.swift:12:20: note: add arguments after the type to construct a value of the type\n        var factors = [Int]{}\n                          ^\n                           ()\n/tmp/tmpp5bhfrec.swift:12:20: note: use '.self' to reference the type object\n        var factors = [Int]{}\n                          ^\n                           .self\n/tmp/tmpp5bhfrec.swift:19:9: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return factors\n               ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}