{
  "name": "HumanEval_119_match_parens",
  "language": "swift",
  "prompt": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var parens int\n    var balance int\n    var result string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n    }\n    if parens == 0 {\n        return \"Yes\"\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            balance++\n        } else if lst[i] == \")\" {\n            balance--\n        }\n    }\n    if balance == 0 {\n        return \"Yes\"\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            balance++\n        } else if lst[i] == \")\" {\n            balance--\n        }\n    }\n    if balance == 0 {\n        return \"Yes\"\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            balance++\n        } else if lst[i] == \")\" {\n            balance--\n        }\n    }\n    if balance == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpbji4l9_n.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpbji4l9_n.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpbji4l9_n.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpbji4l9_n.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmpbji4l9_n.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmpbji4l9_n.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmpbji4l9_n.swift:18:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var parens int\n               ^\n/tmp/tmpbji4l9_n.swift:18:16: note: join the identifiers together\n    var parens int\n        ~~~~~~~^~~\n        parensint\n/tmp/tmpbji4l9_n.swift:18:16: note: join the identifiers together with camel-case\n    var parens int\n        ~~~~~~~^~~\n        parensInt\n/tmp/tmpbji4l9_n.swift:19:17: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var balance int\n                ^\n/tmp/tmpbji4l9_n.swift:19:17: note: join the identifiers together\n    var balance int\n        ~~~~~~~~^~~\n        balanceint\n/tmp/tmpbji4l9_n.swift:19:17: note: join the identifiers together with camel-case\n    var balance int\n        ~~~~~~~~^~~\n        balanceInt\n/tmp/tmpbji4l9_n.swift:20:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmpbji4l9_n.swift:20:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmpbji4l9_n.swift:20:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var res = make([]bool, len(lst))\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res[i] = true\n        } else if lst[i] == \")\" {\n            res[i] = false\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if res[i] {\n            for j = i + 1; j < len(lst); j++ {\n                if lst[j] == \"(\" {\n                    res[j] = true\n                } else if lst[j] == \")\" {\n                    res[j] = false\n                }\n            }\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if res[i] {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpiqic14sa.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpiqic14sa.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpiqic14sa.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpiqic14sa.swift:17:22: error: expected ',' separator\n    var res = make([]bool, len(lst))\n                     ^\n                     ,\n/tmp/tmpiqic14sa.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqic14sa.swift:25:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqic14sa.swift:27:13: error: C-style for statement has been removed in Swift 3\n            for j = i + 1; j < len(lst); j++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqic14sa.swift:36:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiqic14sa.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpiqic14sa.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpiqic14sa.swift:17:15: error: cannot find 'make' in scope\n    var res = make([]bool, len(lst))\n              ^~~~\n/tmp/tmpiqic14sa.swift:17:22: error: cannot find 'bool' in scope\n    var res = make([]bool, len(lst))\n                     ^~~~\n/tmp/tmpiqic14sa.swift:17:28: error: cannot find 'len' in scope\n    var res = make([]bool, len(lst))\n                           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpje54tkqk.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpje54tkqk.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpje54tkqk.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpje54tkqk.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpje54tkqk.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpje54tkqk.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\"\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp54u7shxg.swift:17:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp54u7shxg.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp54u7shxg.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp54u7shxg.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp54u7shxg.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp54u7shxg.swift:17:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp54u7shxg.swift:17:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    for i := len(lst) - 1; i >= 0; i-- {\n        if lst[i] == \")\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpjavaa53w.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpjavaa53w.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpjavaa53w.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpjavaa53w.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpjavaa53w.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpjavaa53w.swift:24:12: error: expected type\n    for i := len(lst) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpjavaa53w.swift:24:12: error: expected 'in' after for-each pattern\n    for i := len(lst) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpjavaa53w.swift:24:12: error: expected Sequence expression for for-each loop\n    for i := len(lst) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpjavaa53w.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpjavaa53w.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpjavaa53w.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpjavaa53w.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    for _, s := range lst {\n        if s == \"(\" {\n            parens++\n        } else if s == \")\" {\n            parens--\n        }\n    }\n    if parens == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpnijf97z0.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpnijf97z0.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            result += s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpc4hs3qas.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpc4hs3qas.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpc4hs3qas.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpc4hs3qas.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpc4hs3qas.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpc4hs3qas.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    for i := 1; i < len(lst)-1; i++ {\n        if lst[i] == \"(\" && lst[i-1] == \")\" {\n            return \"No\"\n        }\n        if lst[i] == \"(\" && lst[i+1] == \")\" {\n            return \"No\"\n        }\n        if lst[i] == \")\" && lst[i-1] == \"(\" {\n            return \"No\"\n        }\n        if lst[i] == \")\" && lst[i+1] == \"(\" {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpem1v9scx.swift:28:12: error: expected type\n    for i := 1; i < len(lst)-1; i++ {\n           ^\n            <#type#>\n/tmp/tmpem1v9scx.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(lst)-1; i++ {\n           ^\n/tmp/tmpem1v9scx.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(lst)-1; i++ {\n           ^\n/tmp/tmpem1v9scx.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpem1v9scx.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmpem1v9scx.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqycx6b7t.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqycx6b7t.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpqycx6b7t.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpqycx6b7t.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpqycx6b7t.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqycx6b7t.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqycx6b7t.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var i = 0\n    var j = 0\n    var res = \"\"\n    for i < len(lst) {\n        if lst[i] == '(' {\n            parens += 1\n        } else if lst[i] == ')' {\n            parens -= 1\n        }\n        if parens == 0 {\n            res += lst[i]\n            i += 1\n        } else {\n            i += 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpi_21p6w3.swift:20:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpi_21p6w3.swift:20:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpi_21p6w3.swift:21:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpi_21p6w3.swift:23:29: error: single-quoted string literal found, use '\"'\n        } else if lst[i] == ')' {\n                            ^~~\n                            \")\"\n/tmp/tmpi_21p6w3.swift:20:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmpi_21p6w3.swift:20:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmphc8uquxe.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmphc8uquxe.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmphc8uquxe.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphc8uquxe.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphc8uquxe.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphc8uquxe.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmphc8uquxe.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpgglr3naq.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpgglr3naq.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpgglr3naq.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpgglr3naq.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpgglr3naq.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpgglr3naq.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack []int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            if len(stack) == 0 {\n                return \"No\"\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpselw46l2.swift:16:14: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n             ^\n             ;\n/tmp/tmpselw46l2.swift:16:17: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n                ^\n                ;\n/tmp/tmpselw46l2.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpselw46l2.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpselw46l2.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpselw46l2.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpselw46l2.swift:24:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpselw46l2.swift:16:9: error: type annotation missing in pattern\n    var stack []int\n        ^\n/tmp/tmpselw46l2.swift:16:15: error: empty collection literal requires an explicit type\n    var stack []int\n              ^~\n/tmp/tmpselw46l2.swift:16:15: warning: expression of type '[Any]' is unused\n    var stack []int\n              ^~\n/tmp/tmpselw46l2.swift:16:17: error: cannot find 'int' in scope\n    var stack []int\n                ^~~\n/tmp/tmpselw46l2.swift:27:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n        if len(stack) == 0 {\n            result += s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpc2arpxg0.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpc2arpxg0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpc2arpxg0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpc2arpxg0.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpc2arpxg0.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpc2arpxg0.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var i int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n        } else if lst[i] == \")\" {\n            if result == \"\" {\n                return \"No\"\n            } else {\n                result = result[:len(result) - 1]\n            }\n        }\n    }\n    if result == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp5ddejyv7.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmp5ddejyv7.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp5ddejyv7.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmp5ddejyv7.swift:17:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmp5ddejyv7.swift:17:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmp5ddejyv7.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ddejyv7.swift:25:33: error: expected expression in list of expressions\n                result = result[:len(result) - 1]\n                                ^\n/tmp/tmp5ddejyv7.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmp5ddejyv7.swift:17:9: error: type annotation missing in pattern\n    var i int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var parens int\n    var str string\n    var res string\n    for i = 0; i < len(lst); i++ {\n        str = lst[i]\n        if str[0] == '(' {\n            parens++\n        } else {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n    }\n    for j = 0; j < len(lst); j++ {\n        str = lst[j]\n        if str[0] == '(' {\n            parens++\n        } else {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpyil765s0.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpyil765s0.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpyil765s0.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpyil765s0.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmpyil765s0.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmpyil765s0.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmpyil765s0.swift:18:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var parens int\n               ^\n/tmp/tmpyil765s0.swift:18:16: note: join the identifiers together\n    var parens int\n        ~~~~~~~^~~\n        parensint\n/tmp/tmpyil765s0.swift:18:16: note: join the identifiers together with camel-case\n    var parens int\n        ~~~~~~~^~~\n        parensInt\n/tmp/tmpyil765s0.swift:19:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var str string\n            ^\n/tmp/tmpyil765s0.swift:19:13: note: join the identifiers together\n    var str string\n        ~~~~^~~~~~\n        strstring\n/tmp/tmpyil765s0.swift:19:13: note: join the identifiers together with camel-case\n    var str string\n        ~~~~^~~~~~\n        strString\n/tmp/tmpyil765s0.swift:20:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res string\n            ^\n/tmp/tmpyil765s0.swift:20:13: note: join the identifiers together\n    var res string\n        ~~~~^~~~~~\n        resstring\n/tmp/tmpyil765s0.swift:20:13: note: join the identifiers together with camel-case\n    var res string\n        ~~~~^~~~~~\n        resString\n/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpk3j8nfd0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpk3j8nfd0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpk3j8nfd0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n        } else {\n            result += \")\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp_zh39kvn.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmp_zh39kvn.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp_zh39kvn.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp_zh39kvn.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp_zh39kvn.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp_zh39kvn.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var left, right int\n    for _, s := range lst {\n        if s == \"(\" {\n            left++\n        } else {\n            right++\n        }\n        if left > right {\n            res += \"No\"\n            return res\n        }\n    }\n    res += \"Yes\"\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpzbnb75e7.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpzbnb75e7.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpzbnb75e7.swift:17:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpzbnb75e7.swift:17:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpzbnb75e7.swift:17:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpzbnb75e7.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpzbnb75e7.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpzbnb75e7.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpzbnb75e7.swift:17:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpzbnb75e7.swift:17:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res = \"\"\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack.push(0)\n        } else if s == \")\" {\n            stack.pop()\n        } else {\n            stack[len(stack) - 1]++\n        }\n        if len(stack) == 0 {\n            res += \"Yes\"\n            break\n        }\n    }\n    if len(stack) != 0 {\n        res += \"No\"\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp52f7tgqa.swift:17:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp52f7tgqa.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp52f7tgqa.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp52f7tgqa.swift:17:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp52f7tgqa.swift:17:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp52f7tgqa.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var count int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            count++\n        } else if lst[i] == \")\" {\n            count--\n        }\n        if count < 0 {\n            return \"No\"\n        }\n        result += lst[i]\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmphb966yn7.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmphb966yn7.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmphb966yn7.swift:17:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmphb966yn7.swift:17:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmphb966yn7.swift:17:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmphb966yn7.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmphb966yn7.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphb966yn7.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphb966yn7.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmphb966yn7.swift:17:9: error: type annotation missing in pattern\n    var count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        } else {\n            stack[len(stack) - 1]++\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1c53sa4y.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp1c53sa4y.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp1c53sa4y.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp1c53sa4y.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp1c53sa4y.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp1c53sa4y.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp1c53sa4y.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var i = 0\n    for i < len(lst) {\n        if lst[i] == '(' {\n            parens++\n        } else if lst[i] == ')' {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n        i++\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpe276yjle.swift:18:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpe276yjle.swift:18:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpe276yjle.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpe276yjle.swift:21:29: error: single-quoted string literal found, use '\"'\n        } else if lst[i] == ')' {\n                            ^~~\n                            \")\"\n/tmp/tmpe276yjle.swift:18:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmpe276yjle.swift:18:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"No\"\n    }\n    for i := 1; i < len(lst) - 1; i++ {\n        if lst[i] == \")\" {\n            if lst[i - 1] == \"(\" {\n                return \"No\"\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpua61rpr4.swift:28:12: error: expected type\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpua61rpr4.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n/tmp/tmpua61rpr4.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n/tmp/tmpua61rpr4.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpua61rpr4.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmpua61rpr4.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var str = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            parens += 1\n        } else if s == \")\" {\n            parens -= 1\n        }\n        str += s\n    }\n    return parens == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpha_u4zv5.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpha_u4zv5.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n        if left == right {\n            result += lst[i]\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp890oeil_.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmp890oeil_.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp890oeil_.swift:17:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmp890oeil_.swift:17:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmp890oeil_.swift:17:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmp890oeil_.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp890oeil_.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp890oeil_.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp890oeil_.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmp890oeil_.swift:17:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmp890oeil_.swift:17:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var result = make([]bool, len(lst))\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            j = i\n            for j < len(lst) {\n                if lst[j] == \")\" {\n                    result[j] = true\n                    break\n                }\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \")\" {\n            j = i\n            for j < len(lst) {\n                if lst[j] == \"(\" {\n                    result[j] = true\n                    break\n                }\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if result[i] == false {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpktpsa0eo.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpktpsa0eo.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpktpsa0eo.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpktpsa0eo.swift:17:25: error: expected ',' separator\n    var result = make([]bool, len(lst))\n                        ^\n                        ,\n/tmp/tmpktpsa0eo.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktpsa0eo.swift:21:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmpktpsa0eo.swift:21:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmpktpsa0eo.swift:33:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktpsa0eo.swift:36:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmpktpsa0eo.swift:36:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmpktpsa0eo.swift:48:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktpsa0eo.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpktpsa0eo.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpktpsa0eo.swift:17:18: error: cannot find 'make' in scope\n    var result = make([]bool, len(lst))\n                 ^~~~\n/tmp/tmpktpsa0eo.swift:17:25: error: cannot find 'bool' in scope\n    var result = make([]bool, len(lst))\n                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2o_ok2cv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2o_ok2cv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp2o_ok2cv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 1)\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                return \"Yes\"\n            }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp48ffptxp.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp48ffptxp.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp48ffptxp.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp48ffptxp.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp48ffptxp.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp48ffptxp.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp48ffptxp.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpi9evi4j6.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpi9evi4j6.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpi9evi4j6.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpi9evi4j6.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpi9evi4j6.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                return \"Yes\"\n            }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpi45ogwgs.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpi45ogwgs.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpi45ogwgs.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpi45ogwgs.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpi45ogwgs.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpi45ogwgs.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpi45ogwgs.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpi45ogwgs.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var count int\n    var result string\n    var left string\n    var right string\n    var left_count int\n    var right_count int\n    var left_balanced bool\n    var right_balanced bool\n    var left_balanced_count int\n    var right_balanced_count int\n    var left_balanced_count_2 int\n    var right_balanced_count_2 int\n    var left_balanced_count_3 int\n    var right_balanced_count_3 int\n    var left_balanced_count_4 int\n    var right_balanced_count_4 int\n    var left_balanced_count_5 int\n    var right_balanced_count_5 int\n    var left_balanced_count_6 int\n    var right_balanced_count_6 int\n    var left_balanced_count_7 int\n    var right_balanced_count_7 int\n    var left_balanced_count_8 int\n    var right_balanced_count_8 int\n    var left_balanced_count_9 int\n    var right_balanced_count_9 int\n    var left_balanced_count_10 int\n    var right_balanced_count_10 int\n    var left_balanced_count_11 int\n    var right_balanced_count_11 int\n    var left_balanced_count_12 int\n    var right_balanced_count_12 int\n    var left_balanced_count_13 int\n    var right_balanced_count_13 int\n    var left_balanced_count_14 int\n    var right_balanced_count_14 int\n    var left_balanced_count_15 int\n    var right_balanced_count_15 int\n    var left_balanced_count_16 int\n    var right_balanced_count_16 int\n    var left_balanced_count_17 int\n    var right_balanced_count_17 int\n    var left_balanced_count_18 int\n    var right_balanced_count_18 int\n    var left_balanced_count_19 int\n    var right_balanced_count_19 int\n    var left_balanced_count_20 int\n    var right_balanced_count_20 int\n    var left_balanced_count_21 int\n    var right_balanced_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpt61agote.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpt61agote.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpt61agote.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpt61agote.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmpt61agote.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmpt61agote.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmpt61agote.swift:18:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmpt61agote.swift:18:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmpt61agote.swift:18:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmpt61agote.swift:19:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmpt61agote.swift:19:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmpt61agote.swift:19:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpt61agote.swift:20:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left string\n             ^\n/tmp/tmpt61agote.swift:20:14: note: join the identifiers together\n    var left string\n        ~~~~~^~~~~~\n        leftstring\n/tmp/tmpt61agote.swift:20:14: note: join the identifiers together with camel-case\n    var left string\n        ~~~~~^~~~~~",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, len(stack))\n        }\n        if len(stack) == 0 {\n            result += s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqtocltuy.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqtocltuy.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqtocltuy.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqtocltuy.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpqtocltuy.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqtocltuy.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpsvnrh11d.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpsvnrh11d.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpsvnrh11d.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpsvnrh11d.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsvnrh11d.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsvnrh11d.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpsvnrh11d.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var i = 0\n    var j = 0\n    for i < len(lst) {\n        if lst[i] == '(' {\n            parens++\n        } else if lst[i] == ')' {\n            parens--\n        }\n        if parens == 0 {\n            j = i\n            break\n        }\n        i++\n    }\n    if parens == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp7bbls2u9.swift:19:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmp7bbls2u9.swift:19:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmp7bbls2u9.swift:20:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp7bbls2u9.swift:22:29: error: single-quoted string literal found, use '\"'\n        } else if lst[i] == ')' {\n                            ^~~\n                            \")\"\n/tmp/tmp7bbls2u9.swift:19:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmp7bbls2u9.swift:19:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqfahjipx.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqfahjipx.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqfahjipx.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqfahjipx.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpqfahjipx.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpmq5f4eft.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpmq5f4eft.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpmq5f4eft.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpmq5f4eft.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpmq5f4eft.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpmq5f4eft.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpk3j8nfd0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpk3j8nfd0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpk3j8nfd0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst) - 1] == \")\" {\n        return \"Yes\"\n    }\n    if lst[0] == \")\" && lst[len(lst) - 1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst) - 1] == \"(\" {\n        return match_parens(lst[1:])\n    }\n    if lst[0] == \")\" && lst[len(lst) - 1] == \")\" {\n        return match_parens(lst[1:])\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmplokl2bku.swift:29:34: error: expected ',' separator\n        return match_parens(lst[1:])\n                                 ^\n                                 ,\n/tmp/tmplokl2bku.swift:29:34: error: expected expression in list of expressions\n        return match_parens(lst[1:])\n                                 ^\n/tmp/tmplokl2bku.swift:32:34: error: expected ',' separator\n        return match_parens(lst[1:])\n                                 ^\n                                 ,\n/tmp/tmplokl2bku.swift:32:34: error: expected expression in list of expressions\n        return match_parens(lst[1:])\n                                 ^\n/tmp/tmplokl2bku.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmplokl2bku.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmplokl2bku.swift:22:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst) - 1] == \")\" {\n                            ^~~\n/tmp/tmplokl2bku.swift:25:29: error: cannot find 'len' in scope\n    if lst[0] == \")\" && lst[len(lst) - 1] == \"(\" {\n                            ^~~\n/tmp/tmplokl2bku.swift:28:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst) - 1] == \"(\" {\n                            ^~~\n/tmp/tmplokl2bku.swift:29:29: error: missing argument label 'lst:' in call\n        return match_parens(lst[1:])\n                            ^\n                            lst: \n/tmp/tmplokl2bku.swift:29:32: error: cannot convert value of type 'String' to expected argument type '[String]'\n        return match_parens(lst[1:])\n                               ^\n/tmp/tmplokl2bku.swift:31:29: error: cannot find 'len' in scope\n    if lst[0] == \")\" && lst[len(lst) - 1] == \")\" {\n                            ^~~\n/tmp/tmplokl2bku.swift:32:29: error: missing argument label 'lst:' in call\n        return match_parens(lst[1:])\n                            ^\n                            lst: \n/tmp/tmplokl2bku.swift:32:32: error: cannot convert value of type 'String' to expected argumen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpndxka2kr.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpndxka2kr.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpndxka2kr.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpndxka2kr.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpndxka2kr.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpndxka2kr.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpndxka2kr.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, len(stack))\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmph4jqpbkb.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmph4jqpbkb.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmph4jqpbkb.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmph4jqpbkb.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmph4jqpbkb.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmph4jqpbkb.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmph4jqpbkb.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpk3j8nfd0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpk3j8nfd0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpk3j8nfd0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpbbfcnjhz.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpbbfcnjhz.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var res string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            j = i\n            for j < len(lst) && lst[j] != \")\" {\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            res += lst[i:j+1]\n            i = j + 1\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpt175s_pd.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpt175s_pd.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpt175s_pd.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpt175s_pd.swift:17:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res string\n            ^\n/tmp/tmpt175s_pd.swift:17:13: note: join the identifiers together\n    var res string\n        ~~~~^~~~~~\n        resstring\n/tmp/tmpt175s_pd.swift:17:13: note: join the identifiers together with camel-case\n    var res string\n        ~~~~^~~~~~\n        resString\n/tmp/tmpt175s_pd.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt175s_pd.swift:21:19: error: expected 'in' after for-each pattern\n            for j < len(lst) && lst[j] != \")\" {\n                  ^\n/tmp/tmpt175s_pd.swift:21:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) && lst[j] != \")\" {\n                  ^~\n                   \n/tmp/tmpt175s_pd.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpt175s_pd.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpt175s_pd.swift:17:9: error: type annotation missing in pattern\n    var res string\n        ^\n/tmp/tmpt175s_pd.swift:21:19: error: '<' is not a prefix unary operator\n            for j < len(lst) && lst[j] != \")\" {\n                  ^\n/tmp/tmpt175s_pd.swift:21:21: error: cannot find 'len' in scope\n            for j < len(lst) && lst[j] != \")\" {\n                    ^~~\n/tmp/tmpt175s_pd.swift:21:30: error: for-in loop requires 'Bool' to conform to 'Sequence'\n            for j < len(lst) && lst[j] != \")\" {\n                  ~~~~~~~~~",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else if lst[i] == \")\" {\n            if len(stack) == 0 {\n                return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp213wfftn.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp213wfftn.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp213wfftn.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp213wfftn.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp213wfftn.swift:24:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp213wfftn.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp213wfftn.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp213wfftn.swift:27:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpsvnrh11d.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpsvnrh11d.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpsvnrh11d.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpsvnrh11d.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsvnrh11d.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsvnrh11d.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpsvnrh11d.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n        if left == right {\n            res += lst[i]\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpfmyjwbj7.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpfmyjwbj7.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpfmyjwbj7.swift:17:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpfmyjwbj7.swift:17:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpfmyjwbj7.swift:17:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpfmyjwbj7.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpfmyjwbj7.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpfmyjwbj7.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpfmyjwbj7.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpfmyjwbj7.swift:17:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpfmyjwbj7.swift:17:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \")\" {\n            res += \"(\"\n        } else if s == \"(\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpdx1o2j9y.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpdx1o2j9y.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpdx1o2j9y.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpdx1o2j9y.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpdx1o2j9y.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var i = 0\n    for i < len(lst) {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n        i++\n    }\n    if parens == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpgcnoh4xj.swift:18:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpgcnoh4xj.swift:18:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpgcnoh4xj.swift:18:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmpgcnoh4xj.swift:18:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]++\n        }\n        if len(stack) == 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp7m8l503v.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp7m8l503v.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp7m8l503v.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp7m8l503v.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp7m8l503v.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp7m8l503v.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp7m8l503v.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var parens []int\n    for _, s := range lst {\n        if s == \"(\" {\n            parens = append(parens, len(res))\n        } else {\n            if len(parens) == 0 {\n                return \"No\"\n            }\n            if parens[len(parens)-1] == len(res) {\n                res += s\n            } else {\n                return \"No\"\n            }\n            parens = parens[0:len(parens)-1]\n        }\n    }\n    if len(parens) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp7kggvx_p.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp7kggvx_p.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp7kggvx_p.swift:17:15: error: consecutive statements on a line must be separated by ';'\n    var parens []int\n              ^\n              ;\n/tmp/tmp7kggvx_p.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    var parens []int\n                 ^\n                 ;\n/tmp/tmp7kggvx_p.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp7kggvx_p.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp7kggvx_p.swift:30:30: error: expected ',' separator\n            parens = parens[0:len(parens)-1]\n                             ^\n                             ,\n/tmp/tmp7kggvx_p.swift:30:30: error: expected expression in list of expressions\n            parens = parens[0:len(parens)-1]\n                             ^\n/tmp/tmp7kggvx_p.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmp7kggvx_p.swift:17:9: error: type annotation missing in pattern\n    var parens []int\n        ^\n/tmp/tmp7kggvx_p.swift:17:16: error: empty collection literal requires an explicit type\n    var parens []int\n               ^~\n/tmp/tmp7kggvx_p.swift:17:16: warning: expression of type '[Any]' is unused\n    var parens []int\n               ^~\n/tmp/tmp7kggvx_p.swift:17:18: error: cannot find 'int' in scope\n    var parens []int\n                 ^~~\n/tmp/tmp7kggvx_p.swift:33:8: error: cannot find 'len' in scope\n    if len(parens) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n        if left == right {\n            res += lst[i]\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpg0sdqumw.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpg0sdqumw.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpg0sdqumw.swift:17:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpg0sdqumw.swift:17:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpg0sdqumw.swift:17:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpg0sdqumw.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpg0sdqumw.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpg0sdqumw.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpg0sdqumw.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpg0sdqumw.swift:17:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpg0sdqumw.swift:17:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        } else {\n            stack[len(stack) - 1]++\n        }\n        result += s\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp4rmseffd.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp4rmseffd.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp4rmseffd.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp4rmseffd.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp4rmseffd.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp4rmseffd.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp4rmseffd.swift:28:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpsvnrh11d.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpsvnrh11d.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpsvnrh11d.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpsvnrh11d.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsvnrh11d.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsvnrh11d.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpsvnrh11d.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmphc8uquxe.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmphc8uquxe.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmphc8uquxe.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphc8uquxe.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphc8uquxe.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphc8uquxe.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmphc8uquxe.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp7azt7pff.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp7azt7pff.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp7azt7pff.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp7azt7pff.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp7azt7pff.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp7azt7pff.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp7azt7pff.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp7azt7pff.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var count int\n    var result bool\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            count++\n        } else {\n            count--\n        }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n    for j = 0; j < len(lst); j++ {\n        if lst[j] == \")\" {\n            count--\n        } else {\n            count++\n        }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmppvkubsey.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmppvkubsey.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmppvkubsey.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmppvkubsey.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmppvkubsey.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmppvkubsey.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmppvkubsey.swift:18:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmppvkubsey.swift:18:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmppvkubsey.swift:18:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmppvkubsey.swift:19:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result bool\n               ^\n/tmp/tmppvkubsey.swift:19:16: note: join the identifiers together\n    var result bool\n        ~~~~~~~^~~~\n        resultbool\n/tmp/tmppvkubsey.swift:19:16: note: join the identifiers together with camel-case\n    var result bool\n        ~~~~~~~^~~~\n        resultBool\n/tmp/tmppvkubsey.swift:20:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppvkubsey.swift:30:5: error: C-style for statement has been removed in Swift 3\n    for j = 0; j < len(lst); j++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppvkubsey.swift:16:9: error: type annotation missing in pattern\n    var i int\n        ^\n/tmp/tmppvkubsey.swift",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpo_vq4yjp.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpo_vq4yjp.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmpo_vq4yjp.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n/tmp/tmpo_vq4yjp.swift:31:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n/tmp/tmpo_vq4yjp.swift:37:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpndxka2kr.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpndxka2kr.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpndxka2kr.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpndxka2kr.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpndxka2kr.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpndxka2kr.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpndxka2kr.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n            if len(stack) == 0 {\n                return \"No\"\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpkaxsme89.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpkaxsme89.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpkaxsme89.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpkaxsme89.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpkaxsme89.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpkaxsme89.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpkaxsme89.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpkaxsme89.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpk3j8nfd0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpk3j8nfd0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpk3j8nfd0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                return \"Yes\"\n            }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpnm9a8ecy.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpnm9a8ecy.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpnm9a8ecy.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpnm9a8ecy.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpnm9a8ecy.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpnm9a8ecy.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpnm9a8ecy.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpbbfcnjhz.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpbbfcnjhz.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var i int\n    var j int\n    var p int\n    var q int\n    var parens int\n    var balance int\n    var parens_stack []int\n    var balance_stack []int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            parens_stack = append(parens_stack, parens)\n            balance_stack = append(balance_stack, balance)\n            parens = 0\n            balance = 0\n        } else if lst[i] == \")\" {\n            balance = balance_stack[len(balance_stack) - 1]\n            balance_stack = balance_stack[:len(balance_stack) - 1]\n            parens = parens_stack[len(parens_stack) - 1]\n            parens_stack = parens_stack[:len(parens_stack) - 1]\n            if balance == 0 {\n                result = result + lst[i]\n            }\n        } else {\n            balance = balance + 1\n        }\n    }\n    if balance == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpwwbuf6qu.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmpwwbuf6qu.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpwwbuf6qu.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpwwbuf6qu.swift:17:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpwwbuf6qu.swift:17:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpwwbuf6qu.swift:18:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmpwwbuf6qu.swift:18:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmpwwbuf6qu.swift:18:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmpwwbuf6qu.swift:19:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var p int\n          ^\n/tmp/tmpwwbuf6qu.swift:19:11: note: join the identifiers together\n    var p int\n        ~~^~~\n        pint\n/tmp/tmpwwbuf6qu.swift:19:11: note: join the identifiers together with camel-case\n    var p int\n        ~~^~~\n        pInt\n/tmp/tmpwwbuf6qu.swift:20:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var q int\n          ^\n/tmp/tmpwwbuf6qu.swift:20:11: note: join the identifiers together\n    var q int\n        ~~^~~\n        qint\n/tmp/tmpwwbuf6qu.swift:20:11: note: join the identifiers together with camel-case\n    var q int\n        ~~^~~\n        qInt\n/tmp/tmpwwbuf6qu.swift:21:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var parens int\n               ^\n/tmp/tmpwwbuf6qu.swift:21:16: note: jo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2o_ok2cv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2o_ok2cv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp2o_ok2cv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\"\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack.append(1)\n        } else if lst[i] == \")\" {\n            stack.pop()\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpyexkdi2t.swift:17:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpyexkdi2t.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpyexkdi2t.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpyexkdi2t.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpyexkdi2t.swift:17:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpyexkdi2t.swift:17:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpt23rhx57.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpt23rhx57.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpt23rhx57.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpt23rhx57.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpt23rhx57.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpt23rhx57.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpt23rhx57.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp02f20gqc.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp02f20gqc.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp02f20gqc.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp02f20gqc.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp02f20gqc.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp02f20gqc.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp9hivxueh.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp9hivxueh.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp9hivxueh.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp9hivxueh.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp9hivxueh.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp9hivxueh.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp9hivxueh.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2o_ok2cv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2o_ok2cv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp2o_ok2cv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            j = i\n            for j < len(lst) {\n                if lst[j] == ')' {\n                    break\n                }\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            lst[i] = ')'\n            lst[j] = '('\n            i = j\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpsfihtpif.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpsfihtpif.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpsfihtpif.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpsfihtpif.swift:17:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsfihtpif.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpsfihtpif.swift:20:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmpsfihtpif.swift:20:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmpsfihtpif.swift:21:30: error: single-quoted string literal found, use '\"'\n                if lst[j] == ')' {\n                             ^~~\n                             \")\"\n/tmp/tmpsfihtpif.swift:29:22: error: single-quoted string literal found, use '\"'\n            lst[i] = ')'\n                     ^~~\n                     \")\"\n/tmp/tmpsfihtpif.swift:30:22: error: single-quoted string literal found, use '\"'\n            lst[j] = '('\n                     ^~~\n                     \"(\"\n/tmp/tmpsfihtpif.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpsfihtpif.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpsfihtpif.swift:20:19: error: '<' is not a prefix unary operator\n            for j < len(lst) {\n                  ^\n/tmp/tmpsfihtpif.swift:20:21: error: cannot find 'len' in scope\n            for j < len(lst) {\n                    ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var stack []int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpuun5rpio.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmpuun5rpio.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpuun5rpio.swift:17:14: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n             ^\n             ;\n/tmp/tmpuun5rpio.swift:17:17: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n                ^\n                ;\n/tmp/tmpuun5rpio.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpuun5rpio.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpuun5rpio.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpuun5rpio.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpuun5rpio.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmpuun5rpio.swift:17:9: error: type annotation missing in pattern\n    var stack []int\n        ^\n/tmp/tmpuun5rpio.swift:17:15: error: empty collection literal requires an explicit type\n    var stack []int\n              ^~\n/tmp/tmpuun5rpio.swift:17:15: warning: expression of type '[Any]' is unused\n    var stack []int\n              ^~\n/tmp/tmpuun5rpio.swift:17:17: error: cannot find 'int' in scope\n    var stack []int\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var i = 0\n    for i < len(lst) {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n        i++\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpj9f09ijf.swift:18:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpj9f09ijf.swift:18:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpj9f09ijf.swift:18:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmpj9f09ijf.swift:18:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpt23rhx57.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpt23rhx57.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpt23rhx57.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpt23rhx57.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpt23rhx57.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpt23rhx57.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpt23rhx57.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var count int\n    var result string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            count++\n        } else if lst[i] == \")\" {\n            count--\n        }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n        } else if lst[i] == \")\" {\n            result += \")\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp99jvp209.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmp99jvp209.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmp99jvp209.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmp99jvp209.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmp99jvp209.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmp99jvp209.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmp99jvp209.swift:18:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmp99jvp209.swift:18:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmp99jvp209.swift:18:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmp99jvp209.swift:19:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmp99jvp209.swift:19:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmp99jvp209.swift:19:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp99jvp209.swift:20:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp99jvp209.swift:30:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp99jvp209.swift:16:9: error: type annotation missing in pattern\n    var i int\n        ^\n/tmp/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqfahjipx.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqfahjipx.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqfahjipx.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqfahjipx.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpqfahjipx.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var res bool\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            j = i\n            res = true\n        } else if lst[i] == ')' {\n            if !res {\n                return \"No\"\n            }\n            res = false\n        }\n    }\n    if res {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpppxmg1ht.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpppxmg1ht.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpppxmg1ht.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpppxmg1ht.swift:17:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res bool\n            ^\n/tmp/tmpppxmg1ht.swift:17:13: note: join the identifiers together\n    var res bool\n        ~~~~^~~~\n        resbool\n/tmp/tmpppxmg1ht.swift:17:13: note: join the identifiers together with camel-case\n    var res bool\n        ~~~~^~~~\n        resBool\n/tmp/tmpppxmg1ht.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpppxmg1ht.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpppxmg1ht.swift:22:29: error: single-quoted string literal found, use '\"'\n        } else if lst[i] == ')' {\n                            ^~~\n                            \")\"\n/tmp/tmpppxmg1ht.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpppxmg1ht.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpppxmg1ht.swift:17:9: error: type annotation missing in pattern\n    var res bool\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var stack []int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpuun5rpio.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmpuun5rpio.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpuun5rpio.swift:17:14: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n             ^\n             ;\n/tmp/tmpuun5rpio.swift:17:17: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n                ^\n                ;\n/tmp/tmpuun5rpio.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpuun5rpio.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpuun5rpio.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpuun5rpio.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpuun5rpio.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmpuun5rpio.swift:17:9: error: type annotation missing in pattern\n    var stack []int\n        ^\n/tmp/tmpuun5rpio.swift:17:15: error: empty collection literal requires an explicit type\n    var stack []int\n              ^~\n/tmp/tmpuun5rpio.swift:17:15: warning: expression of type '[Any]' is unused\n    var stack []int\n              ^~\n/tmp/tmpuun5rpio.swift:17:17: error: cannot find 'int' in scope\n    var stack []int\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack []int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp4qtiacs7.swift:16:14: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n             ^\n             ;\n/tmp/tmp4qtiacs7.swift:16:17: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n                ^\n                ;\n/tmp/tmp4qtiacs7.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp4qtiacs7.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp4qtiacs7.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp4qtiacs7.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp4qtiacs7.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp4qtiacs7.swift:16:9: error: type annotation missing in pattern\n    var stack []int\n        ^\n/tmp/tmp4qtiacs7.swift:16:15: error: empty collection literal requires an explicit type\n    var stack []int\n              ^~\n/tmp/tmp4qtiacs7.swift:16:15: warning: expression of type '[Any]' is unused\n    var stack []int\n              ^~\n/tmp/tmp4qtiacs7.swift:16:17: error: cannot find 'int' in scope\n    var stack []int\n                ^~~\n/tmp/tmp4qtiacs7.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                return \"No\"\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpm8b56u5w.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpm8b56u5w.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpm8b56u5w.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpm8b56u5w.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpm8b56u5w.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpm8b56u5w.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpm8b56u5w.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpm8b56u5w.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp02f20gqc.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp02f20gqc.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp02f20gqc.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp02f20gqc.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp02f20gqc.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp02f20gqc.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var res String\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            j = i\n            for j < len(lst) {\n                if lst[j] == \")\" {\n                    break\n                }\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            res += lst[i:j+1]\n            i = j + 1\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp7rmacfuc.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmp7rmacfuc.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmp7rmacfuc.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmp7rmacfuc.swift:17:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp7rmacfuc.swift:17:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp7rmacfuc.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7rmacfuc.swift:21:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmp7rmacfuc.swift:21:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmp7rmacfuc.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmp7rmacfuc.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmp7rmacfuc.swift:17:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmp7rmacfuc.swift:21:19: error: '<' is not a prefix unary operator\n            for j < len(lst) {\n                  ^\n/tmp/tmp7rmacfuc.swift:21:21: error: cannot find 'len' in scope\n            for j < len(lst) {\n                    ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\"\n    var left = 0\n    var right = 0\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else if lst[i] == \")\" {\n            right++\n        }\n        if left == right {\n            result += lst[i]\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpiw2irogr.swift:19:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpiw2irogr.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpiw2irogr.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqfahjipx.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqfahjipx.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqfahjipx.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqfahjipx.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpqfahjipx.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i = 0\n    var j = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpwwvtf0cp.swift:101:8: error: expected pattern\n    var\n       ^\n/tmp/tmpwwvtf0cp.swift:37:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:16:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:38:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:17:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:44:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:18:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:45:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:19:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:46:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:20:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:47:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:21:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:48:9: error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:22:9: note: 't' previously declared here\n    var t = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:49:9: error: invalid redeclaration of 'u'\n    var u = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:23:9: note: 'u' previously declared here\n    var u = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:50:9: error: invalid redeclaration of 'v'\n    var v = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:24:9: note: 'v' previously declared here\n    var v = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:51:9: error: invalid redeclaration of 'w'\n    var w = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:25:9: note: 'w' previously declared here\n    var w = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:52:9: error: invalid redeclaration of 'x'\n    var x = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:26:9: note: 'x' previously declared here\n    var x = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:53:9: e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpsuj64p4k.swift:16:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpsuj64p4k.swift:16:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpsuj64p4k.swift:16:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpsuj64p4k.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpsuj64p4k.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsuj64p4k.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsuj64p4k.swift:16:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpsuj64p4k.swift:16:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpb45dww7m.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpb45dww7m.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpb45dww7m.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpb45dww7m.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmpb45dww7m.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmpb45dww7m.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmpb45dww7m.swift:18:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var k int\n          ^\n/tmp/tmpb45dww7m.swift:18:11: note: join the identifiers together\n    var k int\n        ~~^~~\n        kint\n/tmp/tmpb45dww7m.swift:18:11: note: join the identifiers together with camel-case\n    var k int\n        ~~^~~\n        kInt\n/tmp/tmpb45dww7m.swift:19:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var l int\n          ^\n/tmp/tmpb45dww7m.swift:19:11: note: join the identifiers together\n    var l int\n        ~~^~~\n        lint\n/tmp/tmpb45dww7m.swift:19:11: note: join the identifiers together with camel-case\n    var l int\n        ~~^~~\n        lInt\n/tmp/tmpb45dww7m.swift:20:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var m int\n          ^\n/tmp/tmpb45dww7m.swift:20:11: note: join the identifiers together\n    var m int\n        ~~^~~\n        mint\n/tmp/tmpb45dww7m.swift:20:11: note: join the identifiers together with camel-case\n    var m int\n        ~~^~~\n        mInt\n/tmp/tmpb45dww7m.swift:21:11: error: found an unexpected second identifier in variable declaration; is there an accide",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmprn32x8qz.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmprn32x8qz.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmprn32x8qz.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmprn32x8qz.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmprn32x8qz.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmprn32x8qz.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmprn32x8qz.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack.push(0)\n        } else if s == \")\" {\n            if stack.pop() == 0 {\n                result += \"No\"\n                break\n            }\n        } else {\n            stack[len(stack) - 1]++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmppxjfdxht.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmppxjfdxht.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmppxjfdxht.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmppxjfdxht.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmppxjfdxht.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack []int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpnjzl5p5q.swift:16:14: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n             ^\n             ;\n/tmp/tmpnjzl5p5q.swift:16:17: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n                ^\n                ;\n/tmp/tmpnjzl5p5q.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpnjzl5p5q.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpnjzl5p5q.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpnjzl5p5q.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpnjzl5p5q.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpnjzl5p5q.swift:16:9: error: type annotation missing in pattern\n    var stack []int\n        ^\n/tmp/tmpnjzl5p5q.swift:16:15: error: empty collection literal requires an explicit type\n    var stack []int\n              ^~\n/tmp/tmpnjzl5p5q.swift:16:15: warning: expression of type '[Any]' is unused\n    var stack []int\n              ^~\n/tmp/tmpnjzl5p5q.swift:16:17: error: cannot find 'int' in scope\n    var stack []int\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp5rgivtsa.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp5rgivtsa.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp5rgivtsa.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp5rgivtsa.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp5rgivtsa.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp5rgivtsa.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp5rgivtsa.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpje54tkqk.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpje54tkqk.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpje54tkqk.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpje54tkqk.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpje54tkqk.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpje54tkqk.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpihekvnc6.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpihekvnc6.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpihekvnc6.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpihekvnc6.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpihekvnc6.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpihekvnc6.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmpihekvnc6.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        } else {\n            stack[len(stack) - 1]++\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1c53sa4y.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp1c53sa4y.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp1c53sa4y.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp1c53sa4y.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp1c53sa4y.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp1c53sa4y.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp1c53sa4y.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]++\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp39tkt3l2.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp39tkt3l2.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp39tkt3l2.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp39tkt3l2.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp39tkt3l2.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp39tkt3l2.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp39tkt3l2.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp39tkt3l2.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp5rgivtsa.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp5rgivtsa.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp5rgivtsa.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp5rgivtsa.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp5rgivtsa.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp5rgivtsa.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp5rgivtsa.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var i = 0\n    for i < len(lst) {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n        i++\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpj9f09ijf.swift:18:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpj9f09ijf.swift:18:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpj9f09ijf.swift:18:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmpj9f09ijf.swift:18:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else if lst[i] == \")\" {\n            right++\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpmhomsx2y.swift:16:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpmhomsx2y.swift:16:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpmhomsx2y.swift:16:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpmhomsx2y.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpmhomsx2y.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpmhomsx2y.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpmhomsx2y.swift:16:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpmhomsx2y.swift:16:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2o_ok2cv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2o_ok2cv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2o_ok2cv.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp2o_ok2cv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpi6iivj9p.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpi6iivj9p.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpi6iivj9p.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpi6iivj9p.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpi6iivj9p.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpi6iivj9p.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var stack Stack\n    for _, s := range lst {\n        if s == \"(\" {\n            stack.Push(s)\n        } else if s == \")\" {\n            if stack.IsEmpty() {\n                return \"No\"\n            }\n            result += stack.Pop()\n        }\n    }\n    if stack.IsEmpty() {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmppu1bsme7.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmppu1bsme7.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmppu1bsme7.swift:17:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var stack Stack\n              ^\n/tmp/tmppu1bsme7.swift:17:15: note: join the identifiers together\n    var stack Stack\n        ~~~~~~^~~~~\n        stackStack\n/tmp/tmppu1bsme7.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmppu1bsme7.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmppu1bsme7.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmppu1bsme7.swift:17:9: error: type annotation missing in pattern\n    var stack Stack\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n        if left == right {\n            res += lst[i]\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpg0sdqumw.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpg0sdqumw.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpg0sdqumw.swift:17:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpg0sdqumw.swift:17:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpg0sdqumw.swift:17:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpg0sdqumw.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpg0sdqumw.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpg0sdqumw.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpg0sdqumw.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpg0sdqumw.swift:17:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpg0sdqumw.swift:17:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var i int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpw5y7uds6.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpw5y7uds6.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpw5y7uds6.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpw5y7uds6.swift:17:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpw5y7uds6.swift:17:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpw5y7uds6.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw5y7uds6.swift:25:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmpw5y7uds6.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpw5y7uds6.swift:17:9: error: type annotation missing in pattern\n    var i int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack []int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp442z0tli.swift:16:14: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n             ^\n             ;\n/tmp/tmp442z0tli.swift:16:17: error: consecutive statements on a line must be separated by ';'\n    var stack []int\n                ^\n                ;\n/tmp/tmp442z0tli.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp442z0tli.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp442z0tli.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp442z0tli.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp442z0tli.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp442z0tli.swift:16:9: error: type annotation missing in pattern\n    var stack []int\n        ^\n/tmp/tmp442z0tli.swift:16:15: error: empty collection literal requires an explicit type\n    var stack []int\n              ^~\n/tmp/tmp442z0tli.swift:16:15: warning: expression of type '[Any]' is unused\n    var stack []int\n              ^~\n/tmp/tmp442z0tli.swift:16:17: error: cannot find 'int' in scope\n    var stack []int\n                ^~~\n/tmp/tmp442z0tli.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var result string\n    for i < len(lst) {\n        if lst[i] == '(' {\n            j = i\n            for j < len(lst) {\n                if lst[j] == ')' {\n                    break\n                }\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            result += lst[i:j+1]\n            i = j + 1\n        } else {\n            i++\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpfr5cdfdg.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpfr5cdfdg.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpfr5cdfdg.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpfr5cdfdg.swift:17:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmpfr5cdfdg.swift:17:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmpfr5cdfdg.swift:17:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpfr5cdfdg.swift:18:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpfr5cdfdg.swift:18:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpfr5cdfdg.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpfr5cdfdg.swift:21:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmpfr5cdfdg.swift:21:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmpfr5cdfdg.swift:22:30: error: single-quoted string literal found, use '\"'\n                if lst[j] == ')' {\n                             ^~~\n                             \")\"\n/tmp/tmpfr5cdfdg.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpfr5cdfdg.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpfr5cdfdg.swift:17:9: error: type annotation missing in pattern\n    var result string\n        ^\n/tmp/tmpfr5cdfdg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \")\" {\n            res += \"(\"\n        } else {\n            res += s\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmprim4k23o.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmprim4k23o.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmprim4k23o.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmprim4k23o.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmprim4k23o.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var result string\n    for i < len(lst) {\n        if lst[i] == \"(\" {\n            j = i\n            for j < len(lst) {\n                if lst[j] == \")\" {\n                    break\n                }\n                j += 1\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            result += lst[i] + lst[j]\n            i = j + 1\n        } else {\n            result += lst[i]\n            i += 1\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpr_yq8vw6.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpr_yq8vw6.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpr_yq8vw6.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpr_yq8vw6.swift:17:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmpr_yq8vw6.swift:17:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmpr_yq8vw6.swift:17:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpr_yq8vw6.swift:18:11: error: expected 'in' after for-each pattern\n    for i < len(lst) {\n          ^\n/tmp/tmpr_yq8vw6.swift:18:11: error: unary operator cannot be separated from its operand\n    for i < len(lst) {\n          ^~\n           \n/tmp/tmpr_yq8vw6.swift:21:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmpr_yq8vw6.swift:21:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmpr_yq8vw6.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpr_yq8vw6.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpr_yq8vw6.swift:17:9: error: type annotation missing in pattern\n    var result string\n        ^\n/tmp/tmpr_yq8vw6.swift:18:11: error: '<' is not a prefix unary operator\n    for i < len(lst) {\n          ^\n/tmp/tmpr_yq8vw6.swift:18:13: error: cannot find 'len' in scope\n    for i < len(lst) {\n            ^~~\n/tmp/tmpr_yq8vw6.swift:21:19: error: '<' is not a prefix unary operator\n            for j < len(lst) {\n                  ^\n/tmp/tmpr_yq8vw6.swift:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \")\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpykplblu0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpykplblu0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpykplblu0.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpykplblu0.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpykplblu0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\"\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack.append(1)\n        } else if lst[i] == ')' {\n            stack.pop()\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpuic2nria.swift:17:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpuic2nria.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpuic2nria.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpuic2nria.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpuic2nria.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpuic2nria.swift:21:29: error: single-quoted string literal found, use '\"'\n        } else if lst[i] == ')' {\n                            ^~~\n                            \")\"\n/tmp/tmpuic2nria.swift:17:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpuic2nria.swift:17:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpuic2nria.swift:28:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n        if left == right {\n            res += lst[i]\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpfmyjwbj7.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpfmyjwbj7.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpfmyjwbj7.swift:17:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpfmyjwbj7.swift:17:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpfmyjwbj7.swift:17:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpfmyjwbj7.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpfmyjwbj7.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpfmyjwbj7.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpfmyjwbj7.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpfmyjwbj7.swift:17:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpfmyjwbj7.swift:17:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var res = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += 1\n        }\n        if len(stack) == 0 {\n            res += \"Yes\"\n            break\n        }\n    }\n    if len(stack) > 0 {\n        res += \"No\"\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpy_p5rro0.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpy_p5rro0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpy_p5rro0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpy_p5rro0.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpy_p5rro0.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpy_p5rro0.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpy_p5rro0.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) > 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                return \"No\"\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpzr3ozvou.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpzr3ozvou.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpzr3ozvou.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpzr3ozvou.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpzr3ozvou.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpzr3ozvou.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpzr3ozvou.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    var count int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            count++\n        } else if lst[i] == \")\" {\n            count--\n        }\n        if count < 0 {\n            return \"No\"\n        }\n        result += lst[i]\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmphb966yn7.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmphb966yn7.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmphb966yn7.swift:17:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmphb966yn7.swift:17:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmphb966yn7.swift:17:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmphb966yn7.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmphb966yn7.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphb966yn7.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphb966yn7.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n/tmp/tmphb966yn7.swift:17:9: error: type annotation missing in pattern\n    var count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n            if len(stack) == 0 {\n                res += \"Yes\"\n                break\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmphss7erp4.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmphss7erp4.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmphss7erp4.swift:17:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmphss7erp4.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmphss7erp4.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphss7erp4.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphss7erp4.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphss7erp4.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmphss7erp4.swift:17:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmphss7erp4.swift:17:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            }\n            res = res[:len(res)-1]\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0om79gkx.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp0om79gkx.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp0om79gkx.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0om79gkx.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0om79gkx.swift:24:23: error: expected expression in list of expressions\n            res = res[:len(res)-1]\n                      ^\n/tmp/tmp0om79gkx.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpk3j8nfd0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpk3j8nfd0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpk3j8nfd0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp5rgivtsa.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp5rgivtsa.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp5rgivtsa.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp5rgivtsa.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp5rgivtsa.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp5rgivtsa.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp5rgivtsa.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpm309hejd.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpm309hejd.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpm309hejd.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpm309hejd.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpm309hejd.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left, right int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else {\n            right++\n        }\n    }\n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpsuj64p4k.swift:16:21: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var left, right int\n                    ^\n/tmp/tmpsuj64p4k.swift:16:21: note: join the identifiers together\n    var left, right int\n              ~~~~~~^~~\n              rightint\n/tmp/tmpsuj64p4k.swift:16:21: note: join the identifiers together with camel-case\n    var left, right int\n              ~~~~~~^~~\n              rightInt\n/tmp/tmpsuj64p4k.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpsuj64p4k.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsuj64p4k.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpsuj64p4k.swift:16:9: error: type annotation missing in pattern\n    var left, right int\n        ^\n/tmp/tmpsuj64p4k.swift:16:15: error: type annotation missing in pattern\n    var left, right int\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpi6iivj9p.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpi6iivj9p.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpi6iivj9p.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpi6iivj9p.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpi6iivj9p.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpi6iivj9p.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var i int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpfy0hllaw.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpfy0hllaw.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpfy0hllaw.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpfy0hllaw.swift:17:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpfy0hllaw.swift:17:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpfy0hllaw.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfy0hllaw.swift:25:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpfy0hllaw.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpfy0hllaw.swift:17:9: error: type annotation missing in pattern\n    var i int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]++\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp39tkt3l2.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp39tkt3l2.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp39tkt3l2.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp39tkt3l2.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp39tkt3l2.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp39tkt3l2.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp39tkt3l2.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp39tkt3l2.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \"()\" {\n        return \"Yes\"\n    }\n    if lst[1] == \"()\" {\n        return \"No\"\n    }\n    if lst[0] == \"()\" {\n        return \"No\"\n    }\n    if lst[1] == \"()\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"()\" {\n        return \"No\"\n    }\n    if lst[1] == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpgm4y9hr_.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpgm4y9hr_.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst)-1] == \")\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst)-1] == \")\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst)-1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst)-1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len(lst)-1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[len\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp_7aush40.swift:74:1: error: expected ']' in expression list\n}\n^\n/tmp/tmp_7aush40.swift:73:28: note: to match this opening '['\n    if lst[0] == \"(\" && lst[len\n                           ^\n/tmp/tmp_7aush40.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmp_7aush40.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmp_7aush40.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n/tmp/tmp_7aush40.swift:28:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst)-1] == \")\" {\n                            ^~~\n/tmp/tmp_7aush40.swift:34:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n/tmp/tmp_7aush40.swift:37:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst)-1] == \")\" {\n                            ^~~\n/tmp/tmp_7aush40.swift:43:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n/tmp/tmp_7aush40.swift:46:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst)-1] == \"(\" {\n                            ^~~\n/tmp/tmp_7aush40.swift:52:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n/tmp/tmp_7aush40.swift:55:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst)-1] == \"(\" {\n                            ^~~\n/tmp/tmp_7aush40.swift:61:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n/tmp/tmp_7aush40.swift:64:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len(lst)-1] == \"(\" {\n                            ^~~\n/tmp/tmp_7aush40.swift:70:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n/tmp/tmp_7aush40.swift:73:29: error: cannot find 'len' in scope\n    if lst[0] == \"(\" && lst[len\n                            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" && lst[1] == \")\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" && lst[1] == \")\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" && lst[1] == \"(\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp38d9xsfg.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmp38d9xsfg.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n    }\n    if parens == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpzu7gcgz6.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpzu7gcgz6.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpzu7gcgz6.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res = \"\"\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack.append(1)\n        } else {\n            stack.pop()\n            if stack.len() == 0 {\n                res += \"Yes\"\n                break\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpd93_zshp.swift:17:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpd93_zshp.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpd93_zshp.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpd93_zshp.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpd93_zshp.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpd93_zshp.swift:17:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpd93_zshp.swift:17:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    \n    var res = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpw69g_ti5.swift:21:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpw69g_ti5.swift:21:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpw69g_ti5.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpdc0ffp8d.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpdc0ffp8d.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpdc0ffp8d.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpdc0ffp8d.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpdc0ffp8d.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpdc0ffp8d.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpdc0ffp8d.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpt23rhx57.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpt23rhx57.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpt23rhx57.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpt23rhx57.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpt23rhx57.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpt23rhx57.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpt23rhx57.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmphk6wbj4_.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmphk6wbj4_.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmphk6wbj4_.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmphk6wbj4_.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphk6wbj4_.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmphk6wbj4_.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmphk6wbj4_.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmptuvgu_kk.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmptuvgu_kk.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmptuvgu_kk.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmptuvgu_kk.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmptuvgu_kk.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmptuvgu_kk.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack.append(1)\n        } else if lst[i] == \")\" {\n            stack.pop()\n        }\n        if len(stack) == 0 {\n            result += lst[i]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpbw4xn_4z.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpbw4xn_4z.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpbw4xn_4z.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpbw4xn_4z.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpbw4xn_4z.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpbw4xn_4z.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpbw4xn_4z.swift:28:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var count int\n    var result string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            count++\n        } else if lst[i] == \")\" {\n            count--\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            for j = i + 1; j < len(lst); j++ {\n                if lst[j] == \")\" {\n                    break\n                }\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            result += lst[i]\n            result += lst[j]\n            i = j\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp_ba8dc6p.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmp_ba8dc6p.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmp_ba8dc6p.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmp_ba8dc6p.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmp_ba8dc6p.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmp_ba8dc6p.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmp_ba8dc6p.swift:18:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmp_ba8dc6p.swift:18:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmp_ba8dc6p.swift:18:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmp_ba8dc6p.swift:19:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmp_ba8dc6p.swift:19:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmp_ba8dc6p.swift:19:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp_ba8dc6p.swift:20:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_ba8dc6p.swift:30:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_ba8dc6p.swift:32:13: error: C-style for statement has been removed in Swift 3\n            for ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n        } else if lst[i] == \")\" {\n            if result == \"\" {\n                return \"No\"\n            } else {\n                result = result[:len(result)-1]\n            }\n        }\n    }\n    if result == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp8hbiwjjv.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmp8hbiwjjv.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp8hbiwjjv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp8hbiwjjv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp8hbiwjjv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp8hbiwjjv.swift:24:33: error: expected expression in list of expressions\n                result = result[:len(result)-1]\n                                ^\n/tmp/tmp8hbiwjjv.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp5rgivtsa.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp5rgivtsa.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp5rgivtsa.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp5rgivtsa.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp5rgivtsa.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp5rgivtsa.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp5rgivtsa.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp5rgivtsa.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" && lst[1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \")\" && lst[1] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" && lst[1] == \")\" {\n        return \"Yes\"\n    }\n    if lst[0] == \"(\" && lst[1] == \")\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpd7cnsqtv.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpd7cnsqtv.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    var i int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else {\n            res += \")\"\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpqxnmqp9n.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpqxnmqp9n.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpqxnmqp9n.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpqxnmqp9n.swift:17:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpqxnmqp9n.swift:17:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpqxnmqp9n.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqxnmqp9n.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n/tmp/tmpqxnmqp9n.swift:17:9: error: type annotation missing in pattern\n    var i int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) == 0 {\n                return \"No\"\n            }\n            if lst[i] == ')' {\n                if stack[len(stack) - 1] == i {\n                    stack = stack[:len(stack) - 1]\n                } else {\n                    return \"No\"\n                }\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp70c8yz1x.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp70c8yz1x.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp70c8yz1x.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp70c8yz1x.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp70c8yz1x.swift:18:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmp70c8yz1x.swift:24:26: error: single-quoted string literal found, use '\"'\n            if lst[i] == ')' {\n                         ^~~\n                         \")\"\n/tmp/tmp70c8yz1x.swift:26:35: error: expected expression in list of expressions\n                    stack = stack[:len(stack) - 1]\n                                  ^\n/tmp/tmp70c8yz1x.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp70c8yz1x.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i = 0\n    var j = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpwwvtf0cp.swift:101:8: error: expected pattern\n    var\n       ^\n/tmp/tmpwwvtf0cp.swift:37:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:16:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:38:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:17:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:44:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:18:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:45:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:19:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:46:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:20:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:47:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:21:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:48:9: error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:22:9: note: 't' previously declared here\n    var t = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:49:9: error: invalid redeclaration of 'u'\n    var u = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:23:9: note: 'u' previously declared here\n    var u = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:50:9: error: invalid redeclaration of 'v'\n    var v = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:24:9: note: 'v' previously declared here\n    var v = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:51:9: error: invalid redeclaration of 'w'\n    var w = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:25:9: note: 'w' previously declared here\n    var w = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:52:9: error: invalid redeclaration of 'x'\n    var x = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:26:9: note: 'x' previously declared here\n    var x = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:53:9: e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            result += s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpc4hs3qas.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpc4hs3qas.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpc4hs3qas.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpc4hs3qas.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpc4hs3qas.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpc4hs3qas.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst)-1] == \"(\" {\n        return \"No\"\n    }\n    for i := 1; i < len(lst)-1; i++ {\n        if lst[i] == \"(\" && lst[i+1] == \")\" {\n            lst[i] = \")\"\n            lst[i+1] = \"(\"\n        }\n    }\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] == \"(\" && lst[i+1] == \")\" {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmphux1v9cd.swift:28:12: error: expected type\n    for i := 1; i < len(lst)-1; i++ {\n           ^\n            <#type#>\n/tmp/tmphux1v9cd.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(lst)-1; i++ {\n           ^\n/tmp/tmphux1v9cd.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(lst)-1; i++ {\n           ^\n/tmp/tmphux1v9cd.swift:34:12: error: expected type\n    for i := 0; i < len(lst)-1; i++ {\n           ^\n            <#type#>\n/tmp/tmphux1v9cd.swift:34:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst)-1; i++ {\n           ^\n/tmp/tmphux1v9cd.swift:34:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst)-1; i++ {\n           ^\n/tmp/tmphux1v9cd.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmphux1v9cd.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmphux1v9cd.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst)-1] == \"(\" {\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \"(\" {\n            res += \"(\"\n        } else if s == \")\" {\n            res += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp2gehqxo3.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp2gehqxo3.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp2gehqxo3.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp2gehqxo3.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var parens = make([]int, len(lst))\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            parens[i] = 1\n        } else {\n            parens[i] = -1\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if parens[i] == 1 {\n            for j = i + 1; j < len(lst); j++ {\n                if lst[j] == '(' {\n                    parens[j] = 1\n                } else {\n                    parens[j] = -1\n                }\n            }\n        }\n    }\n    for i = 0; i < len(lst); i++ {\n        if parens[i] == -1 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpwsd094ze.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpwsd094ze.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpwsd094ze.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpwsd094ze.swift:17:25: error: expected ',' separator\n    var parens = make([]int, len(lst))\n                        ^\n                        ,\n/tmp/tmpwsd094ze.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwsd094ze.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpwsd094ze.swift:25:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwsd094ze.swift:27:13: error: C-style for statement has been removed in Swift 3\n            for j = i + 1; j < len(lst); j++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwsd094ze.swift:28:30: error: single-quoted string literal found, use '\"'\n                if lst[j] == '(' {\n                             ^~~\n                             \"(\"\n/tmp/tmpwsd094ze.swift:36:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwsd094ze.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpwsd094ze.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpwsd094ze.swift:17:18: error: cannot find 'make' in scope\n    var parens = make([]int, len(lst))\n                 ^~~~\n/tmp/tmpwsd094ze.swift:17:25: error: cannot find 'int' in scope\n    var parens = make([]int, len(lst))\n                        ^~~\n/tmp/tmpwsd094ze.swift:17:30: error: cannot find ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i = 0\n    var j = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpwwvtf0cp.swift:101:8: error: expected pattern\n    var\n       ^\n/tmp/tmpwwvtf0cp.swift:37:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:16:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:38:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:17:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:44:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:18:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:45:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:19:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:46:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:20:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:47:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:21:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:48:9: error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:22:9: note: 't' previously declared here\n    var t = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:49:9: error: invalid redeclaration of 'u'\n    var u = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:23:9: note: 'u' previously declared here\n    var u = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:50:9: error: invalid redeclaration of 'v'\n    var v = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:24:9: note: 'v' previously declared here\n    var v = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:51:9: error: invalid redeclaration of 'w'\n    var w = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:25:9: note: 'w' previously declared here\n    var w = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:52:9: error: invalid redeclaration of 'x'\n    var x = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:26:9: note: 'x' previously declared here\n    var x = 0\n        ^\n/tmp/tmpwwvtf0cp.swift:53:9: e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp37r47pvv.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp37r47pvv.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp37r47pvv.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp37r47pvv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp37r47pvv.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmp37r47pvv.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for i, c := range lst {\n        if c == '(' {\n            stack = append(stack, i)\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpn90ir1iv.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmpn90ir1iv.swift:17:10: error: expected 'in' after for-each pattern\n    for i, c := range lst {\n         ^\n/tmp/tmpn90ir1iv.swift:17:10: error: expected Sequence expression for for-each loop\n    for i, c := range lst {\n         ^\n/tmp/tmpn90ir1iv.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpn90ir1iv.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpn90ir1iv.swift:24:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpn90ir1iv.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmpn90ir1iv.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmpn90ir1iv.swift:27:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n        } else {\n            result += \")\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp_zh39kvn.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmp_zh39kvn.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp_zh39kvn.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp_zh39kvn.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp_zh39kvn.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp_zh39kvn.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for _, s := range lst {\n        if s == \")\" {\n            res += \"(\"\n        } else {\n            res += s\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp646ce30i.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmp646ce30i.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmp646ce30i.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp646ce30i.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp646ce30i.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]++\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp39tkt3l2.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp39tkt3l2.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp39tkt3l2.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp39tkt3l2.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp39tkt3l2.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp39tkt3l2.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp39tkt3l2.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmp39tkt3l2.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "tmpn0flq4mx/tmpn0flq4mx.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad7ca3dbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad7ca0d2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad7ca0d2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad7ca0d17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpn0flq4mx                        0x00005648709b7610 <unavailable> + 5648\n5    libc.so.6                          0x00002ad7ca5c7460 __libc_start_main + 245\n6    tmpn0flq4mx                        0x00005648709b7089 <unavailable> + 4233\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    \n    var result = \"\"\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        \n        if len(stack) == 0 {\n            result += \"Yes\"\n            break\n        }\n        \n        if lst[i] == \")\" {\n            stack[len(stack)-1]++\n        } else {\n            stack[len(stack)-1]--\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmplk23u9l2.swift:21:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmplk23u9l2.swift:22:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmplk23u9l2.swift:22:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmplk23u9l2.swift:22:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmplk23u9l2.swift:26:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmplk23u9l2.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmplk23u9l2.swift:21:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmplk23u9l2.swift:21:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack) == 0 {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmphc8uquxe.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmphc8uquxe.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmphc8uquxe.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphc8uquxe.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmphc8uquxe.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphc8uquxe.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmphc8uquxe.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var parens int\n    var s string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n    }\n    if parens == 0 {\n        return \"Yes\"\n    }\n    for j = 0; j < len(lst); j++ {\n        if lst[j] == \"(\" {\n            parens++\n        } else if lst[j] == \")\" {\n            parens--\n        }\n        if parens == 0 {\n            s += lst[j]\n            break\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpfwlc5frg.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmpfwlc5frg.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmpfwlc5frg.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmpfwlc5frg.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmpfwlc5frg.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmpfwlc5frg.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmpfwlc5frg.swift:18:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var parens int\n               ^\n/tmp/tmpfwlc5frg.swift:18:16: note: join the identifiers together\n    var parens int\n        ~~~~~~~^~~\n        parensint\n/tmp/tmpfwlc5frg.swift:18:16: note: join the identifiers together with camel-case\n    var parens int\n        ~~~~~~~^~~\n        parensInt\n/tmp/tmpfwlc5frg.swift:19:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var s string\n          ^\n/tmp/tmpfwlc5frg.swift:19:11: note: join the identifiers together\n    var s string\n        ~~^~~~~~\n        sstring\n/tmp/tmpfwlc5frg.swift:19:11: note: join the identifiers together with camel-case\n    var s string\n        ~~^~~~~~\n        sString\n/tmp/tmpfwlc5frg.swift:20:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfwlc5frg.swift:30:5: error: C-style for statement has been removed in Swift 3\n    for j = 0; j < len(lst); j++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfwlc5frg.swift:16:9: error: type annotation missing in pattern\n    var i int\n        ^\n/tmp/tmpfwlc5frg.swift:17:9: error: type",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            parens++\n        } else if s == \")\" {\n            parens--\n        }\n        result += s\n    }\n    return parens == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmps4ur_t_6.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmps4ur_t_6.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return \"Yes\" if len(stack) == 0 else \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpgdl79tkc.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpgdl79tkc.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpgdl79tkc.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpgdl79tkc.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpgdl79tkc.swift:24:17: error: consecutive statements on a line must be separated by ';'\n    return \"Yes\" if len(stack) == 0 else \"No\"\n                ^\n                ;\n/tmp/tmpgdl79tkc.swift:24:37: error: unexpected 'else' immediately following 'if' condition\n    return \"Yes\" if len(stack) == 0 else \"No\"\n                                    ^\n/tmp/tmpgdl79tkc.swift:24:37: note: remove 'else' to execute the braced block of statements when the condition is true\n    return \"Yes\" if len(stack) == 0 else \"No\"\n                                    ^~~~~\n                                    \n/tmp/tmpgdl79tkc.swift:24:42: error: expected '{' after 'if' condition\n    return \"Yes\" if len(stack) == 0 else \"No\"\n                                         ^\n/tmp/tmpgdl79tkc.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpgdl79tkc.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpgdl79tkc.swift:24:21: error: cannot find 'len' in scope\n    return \"Yes\" if len(stack) == 0 else \"No\"\n                    ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp_7y5wgrc.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp_7y5wgrc.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp_7y5wgrc.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp_7y5wgrc.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp_7y5wgrc.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp_7y5wgrc.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp_7y5wgrc.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"No\"\n    }\n    if lst[0] == \"(\" {\n        return \"Yes\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"Yes\"\n    }\n    for i := 1; i < len(lst) - 1; i++ {\n        if lst[i] == \"(\" {\n            if lst[i + 1] == \")\" {\n                lst[i] = \")\"\n                lst[i + 1] = \"(\"\n                return match_parens(lst)\n            }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpe4s6pjjb.swift:34:12: error: expected type\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpe4s6pjjb.swift:34:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n/tmp/tmpe4s6pjjb.swift:34:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n/tmp/tmpe4s6pjjb.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpe4s6pjjb.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmpe4s6pjjb.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n/tmp/tmpe4s6pjjb.swift:31:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            result += s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp8elxxlqb.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmp8elxxlqb.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp8elxxlqb.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp8elxxlqb.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp8elxxlqb.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmp8elxxlqb.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var res = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]++\n        }\n        if len(stack) == 0 {\n            res += \"Yes\"\n            break\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpmtafq14b.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpmtafq14b.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpmtafq14b.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpmtafq14b.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpmtafq14b.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpmtafq14b.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result String\n    for _, s := range lst {\n        if s == \"(\" {\n            result += \"(\"\n        } else if s == \")\" {\n            result += \")\"\n        } else {\n            return \"No\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpjw8n75uu.swift:16:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result String\n               ^\n/tmp/tmpjw8n75uu.swift:16:16: note: join the identifiers together\n    var result String\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmpjw8n75uu.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpjw8n75uu.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpjw8n75uu.swift:16:9: error: type annotation missing in pattern\n    var result String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqfahjipx.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqfahjipx.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqfahjipx.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqfahjipx.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpqfahjipx.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]++\n        }\n        if len(stack) == 0 {\n            result += s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpkhkxqc0g.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpkhkxqc0g.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpkhkxqc0g.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpkhkxqc0g.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpkhkxqc0g.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpkhkxqc0g.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n    }\n    if lst[0] == \")\" {\n        return \"No\"\n    }\n    if lst[len(lst) - 1] == \"(\" {\n        return \"No\"\n    }\n    for i := 1; i < len(lst) - 1; i++ {\n        if lst[i] == \")\" && lst[i - 1] == \"(\" {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpfmtj2b28.swift:28:12: error: expected type\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpfmtj2b28.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n/tmp/tmpfmtj2b28.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(lst) - 1; i++ {\n           ^\n/tmp/tmpfmtj2b28.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n/tmp/tmpfmtj2b28.swift:19:8: error: cannot find 'len' in scope\n    if len(lst) == 1 {\n       ^~~\n/tmp/tmpfmtj2b28.swift:25:12: error: cannot find 'len' in scope\n    if lst[len(lst) - 1] == \"(\" {\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var res bool\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == '(' {\n            j = i\n            res = true\n        } else {\n            if res {\n                res = false\n                for j < len(lst) {\n                    if lst[j] == '(' {\n                        break\n                    }\n                    j++\n                }\n                if j == len(lst) {\n                    return \"Yes\"\n                }\n            }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpu6atnbdb.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpu6atnbdb.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpu6atnbdb.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpu6atnbdb.swift:17:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res bool\n            ^\n/tmp/tmpu6atnbdb.swift:17:13: note: join the identifiers together\n    var res bool\n        ~~~~^~~~\n        resbool\n/tmp/tmpu6atnbdb.swift:17:13: note: join the identifiers together with camel-case\n    var res bool\n        ~~~~^~~~\n        resBool\n/tmp/tmpu6atnbdb.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu6atnbdb.swift:19:22: error: single-quoted string literal found, use '\"'\n        if lst[i] == '(' {\n                     ^~~\n                     \"(\"\n/tmp/tmpu6atnbdb.swift:25:23: error: expected 'in' after for-each pattern\n                for j < len(lst) {\n                      ^\n/tmp/tmpu6atnbdb.swift:25:23: error: unary operator cannot be separated from its operand\n                for j < len(lst) {\n                      ^~\n                       \n/tmp/tmpu6atnbdb.swift:26:34: error: single-quoted string literal found, use '\"'\n                    if lst[j] == '(' {\n                                 ^~~\n                                 \"(\"\n/tmp/tmpu6atnbdb.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpu6atnbdb.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpu6atnbdb.swift:17:9: error: type annotation missing in pattern\n    var res bool\n        ^\n/tmp/tmpu6atnbdb.swift:25:23: error: '<' is not a prefix unary operator\n                for j < len(lst) {\n            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res String\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            res += \"(\"\n        } else if lst[i] == \")\" {\n            if res == \"\" {\n                return \"No\"\n            } else {\n                res = res[:len(res)-1]\n            }\n        }\n    }\n    if res == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpk3j8nfd0.swift:16:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res String\n            ^\n/tmp/tmpk3j8nfd0.swift:16:13: note: join the identifiers together\n    var res String\n        ~~~~^~~~~~\n        resString\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpk3j8nfd0.swift:24:27: error: expected expression in list of expressions\n                res = res[:len(res)-1]\n                          ^\n/tmp/tmpk3j8nfd0.swift:16:9: error: type annotation missing in pattern\n    var res String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp_7y5wgrc.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{}\n                  ^\n                  ;\n/tmp/tmp_7y5wgrc.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp_7y5wgrc.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmp_7y5wgrc.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp_7y5wgrc.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{}\n                ^~\n/tmp/tmp_7y5wgrc.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{}\n                  ^~~\n/tmp/tmp_7y5wgrc.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else if lst[i] == \")\" {\n            stack = stack[:len(stack) - 1]\n        } else {\n            stack[len(stack) - 1]++\n        }\n        if len(stack) == 0 {\n            result += \"Yes\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpbcvn4nma.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpbcvn4nma.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpbcvn4nma.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpbcvn4nma.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpbcvn4nma.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpbcvn4nma.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpbcvn4nma.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res = \"\"\n    var left = 0\n    var right = 0\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            left++\n        } else if lst[i] == \")\" {\n            right++\n        }\n    }\n    if left == right {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp3ouo2_n9.swift:19:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp3ouo2_n9.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp3ouo2_n9.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                result += \"Yes\"\n                break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpico814nd.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpico814nd.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpico814nd.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpico814nd.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpico814nd.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpico814nd.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpico814nd.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqfahjipx.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqfahjipx.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqfahjipx.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqfahjipx.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpqfahjipx.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += 1\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpfcfhqc54.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpfcfhqc54.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpfcfhqc54.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpfcfhqc54.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpfcfhqc54.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpfcfhqc54.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpfcfhqc54.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 0)\n        } else if s == \")\" {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, len(stack))\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmph4jqpbkb.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmph4jqpbkb.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmph4jqpbkb.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmph4jqpbkb.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmph4jqpbkb.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmph4jqpbkb.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmph4jqpbkb.swift:26:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack = append(stack, 0)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                result += \"Yes\"\n                break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpico814nd.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpico814nd.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpico814nd.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpico814nd.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpico814nd.swift:22:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpico814nd.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpico814nd.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i int\n    var j int\n    var count int\n    var result string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            count++\n        } else if lst[i] == \")\" {\n            count--\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            for j = i + 1; j < len(lst); j++ {\n                if lst[j] == \")\" {\n                    break\n                }\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            result += lst[i] + lst[j]\n            i = j\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp55_wl3of.swift:16:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i int\n          ^\n/tmp/tmp55_wl3of.swift:16:11: note: join the identifiers together\n    var i int\n        ~~^~~\n        iint\n/tmp/tmp55_wl3of.swift:16:11: note: join the identifiers together with camel-case\n    var i int\n        ~~^~~\n        iInt\n/tmp/tmp55_wl3of.swift:17:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var j int\n          ^\n/tmp/tmp55_wl3of.swift:17:11: note: join the identifiers together\n    var j int\n        ~~^~~\n        jint\n/tmp/tmp55_wl3of.swift:17:11: note: join the identifiers together with camel-case\n    var j int\n        ~~^~~\n        jInt\n/tmp/tmp55_wl3of.swift:18:15: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var count int\n              ^\n/tmp/tmp55_wl3of.swift:18:15: note: join the identifiers together\n    var count int\n        ~~~~~~^~~\n        countint\n/tmp/tmp55_wl3of.swift:18:15: note: join the identifiers together with camel-case\n    var count int\n        ~~~~~~^~~\n        countInt\n/tmp/tmp55_wl3of.swift:19:16: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var result string\n               ^\n/tmp/tmp55_wl3of.swift:19:16: note: join the identifiers together\n    var result string\n        ~~~~~~~^~~~~~\n        resultstring\n/tmp/tmp55_wl3of.swift:19:16: note: join the identifiers together with camel-case\n    var result string\n        ~~~~~~~^~~~~~\n        resultString\n/tmp/tmp55_wl3of.swift:20:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp55_wl3of.swift:30:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp55_wl3of.swift:32:13: error: C-style for statement has been removed in Swift 3\n            for ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var i, j int\n    var res string\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            j = i\n            for j < len(lst) {\n                if lst[j] == \")\" {\n                    break\n                }\n                j++\n            }\n            if j == len(lst) {\n                return \"No\"\n            }\n            res += match_parens(lst[i+1:j])\n            i = j\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpam8qot9o.swift:16:14: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var i, j int\n             ^\n/tmp/tmpam8qot9o.swift:16:14: note: join the identifiers together\n    var i, j int\n           ~~^~~\n           jint\n/tmp/tmpam8qot9o.swift:16:14: note: join the identifiers together with camel-case\n    var i, j int\n           ~~^~~\n           jInt\n/tmp/tmpam8qot9o.swift:17:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var res string\n            ^\n/tmp/tmpam8qot9o.swift:17:13: note: join the identifiers together\n    var res string\n        ~~~~^~~~~~\n        resstring\n/tmp/tmpam8qot9o.swift:17:13: note: join the identifiers together with camel-case\n    var res string\n        ~~~~^~~~~~\n        resString\n/tmp/tmpam8qot9o.swift:18:5: error: C-style for statement has been removed in Swift 3\n    for i = 0; i < len(lst); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpam8qot9o.swift:21:19: error: expected 'in' after for-each pattern\n            for j < len(lst) {\n                  ^\n/tmp/tmpam8qot9o.swift:21:19: error: unary operator cannot be separated from its operand\n            for j < len(lst) {\n                  ^~\n                   \n/tmp/tmpam8qot9o.swift:30:40: error: expected ',' separator\n            res += match_parens(lst[i+1:j])\n                                       ^\n                                       ,\n/tmp/tmpam8qot9o.swift:30:40: error: expected expression in list of expressions\n            res += match_parens(lst[i+1:j])\n                                       ^\n/tmp/tmpam8qot9o.swift:16:9: error: type annotation missing in pattern\n    var i, j int\n        ^\n/tmp/tmpam8qot9o.swift:16:12: error: type annotation missing in pattern\n    var i, j int\n           ^\n/tmp/tmpam8qot9o.swift:17:9: error: type annotation missing in pattern\n    var res string\n        ^\n/tmp/tmpam8qot9o.swift:21:19: error: '<' is not a prefix unary operator\n            for j < len(lst) {\n                  ^\n/",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = []int{0}\n    for _, s := range lst {\n        if s == \"(\" {\n            stack = append(stack, 1)\n        } else if s == \")\" {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpqfahjipx.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []int{0}\n                  ^\n                  ;\n/tmp/tmpqfahjipx.swift:17:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n/tmp/tmpqfahjipx.swift:21:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpqfahjipx.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []int{0}\n                ^~\n/tmp/tmpqfahjipx.swift:16:19: error: cannot find 'int' in scope\n    var stack = []int{0}\n                  ^~~\n/tmp/tmpqfahjipx.swift:24:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = 0\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            parens++\n        } else if lst[i] == \")\" {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n        result += lst[i]\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpqk69es24.swift:18:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmpqk69es24.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmpqk69es24.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n    \n    var left = 0\n    var right = 0\n    var result = \"\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\") {\n            left++\n        } else if lst[i] == \")\" {\n            right++\n        } else {\n            result += lst[i]\n        }\n        \n        if left == right {\n            left = 0\n            right = 0\n        }\n    }\n    \n    if left == right {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp54y5d_8a.swift:23:12: error: expected type\n    for i := 0; i < len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp54y5d_8a.swift:23:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp54y5d_8a.swift:23:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp54y5d_8a.swift:24:25: error: expected '{' after 'if' condition\n        if lst[i] == \"(\") {\n                        ^\n/tmp/tmp54y5d_8a.swift:16:8: error: cannot find 'len' in scope\n    if len(lst) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given an array of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst: [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n/// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res = \"\"\n    var parens = 0\n    for _, s := range lst {\n        if s == \"(\" {\n            parens++\n        } else if s == \")\" {\n            parens--\n        }\n        if parens < 0 {\n            return \"No\"\n        }\n        res += s\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp8w0ev5m0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, s := range lst {\n         ^\n/tmp/tmp8w0ev5m0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, s := range lst {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}