{
  "name": "HumanEval_49_modp",
  "language": "swift",
  "prompt": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpr94ts20f/tmpr94ts20f.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad3c7029c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad3c6d20b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad3c6d20988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad3c6d1f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpr94ts20f                        0x0000555de633124d <unavailable> + 4685\n5    libc.so.6                          0x00002ad3c7215460 __libc_start_main + 245\n6    tmpr94ts20f                        0x0000555de6330ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return modp(-n, p)\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpger8as4k.swift:21:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjmtsr0bq/tmpjmtsr0bq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b097f470c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b097f167b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b097f167988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b097f1667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjmtsr0bq                        0x000055e2aabc02cd <unavailable> + 4813\n5    libc.so.6                          0x00002b097f65c460 __libc_start_main + 245\n6    tmpjmtsr0bq                        0x000055e2aabbfef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpa85_afdb/tmpa85_afdb.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b907e5abc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b907e2a2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b907e2a2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b907e2a17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpa85_afdb                        0x0000562f2ac462cd <unavailable> + 4813\n5    libc.so.6                          0x00002b907e797460 __libc_start_main + 245\n6    tmpa85_afdb                        0x0000562f2ac45ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpo8me8lic/tmpo8me8lic.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfe67a7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfe649eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abfe649e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abfe649d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpo8me8lic                        0x000056005d9d32cd <unavailable> + 4813\n5    libc.so.6                          0x00002abfe6993460 __libc_start_main + 245\n6    tmpo8me8lic                        0x000056005d9d2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpu5zczmft.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n/tmp/tmpu5zczmft.swift:20:21: error: missing argument labels 'n:p:' in call\n    return (n * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpcejkzt44.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n/tmp/tmpcejkzt44.swift:20:26: error: missing argument labels 'n:p:' in call\n    return (n % p) * modp(n / p, p)\n                         ^\n                          n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpw2zp154a/tmpw2zp154a.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab1fff10c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab1ffc07b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab1ffc07988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab1ffc067b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpw2zp154a                        0x000055bbf17c92cd <unavailable> + 4813\n5    libc.so.6                          0x00002ab2000fc460 __libc_start_main + 245\n6    tmpw2zp154a                        0x000055bbf17c8ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  } else if n < 0 {\n    return modp(p - n, p)\n  } else {\n    return modp(n % p, p)\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpzyk563mz.swift:17:16: error: missing argument labels 'n:p:' in call\n    return modp(p - n, p)\n               ^\n                n:     p: \n/tmp/tmpzyk563mz.swift:19:16: error: missing argument labels 'n:p:' in call\n    return modp(n % p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpsff3hx1s.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpi0v1poe7.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n/tmp/tmpi0v1poe7.swift:23:26: error: missing argument labels 'n:p:' in call\n    return (n % p) * modp(n / p, p)\n                         ^\n                          n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbufw342w/tmpbufw342w.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b70e10a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b70e0d9fb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b70e0d9f988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b70e0d9e7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbufw342w                        0x0000561ac962a24d <unavailable> + 4685\n5    libc.so.6                          0x00002b70e1294460 __libc_start_main + 245\n6    tmpbufw342w                        0x0000561ac9629ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if p < 0 {\n    return modp(n, -p)\n  }\n  if n < p {\n    return modp(n, p)\n  }\n  return modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpjdywylhf.swift:27:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmpjdywylhf.swift:30:16: error: missing argument labels 'n:p:' in call\n    return modp(n, -p)\n               ^\n                n: p: \n/tmp/tmpjdywylhf.swift:33:16: error: missing argument labels 'n:p:' in call\n    return modp(n, p)\n               ^\n                n: p: \n/tmp/tmpjdywylhf.swift:35:14: error: missing argument labels 'n:p:' in call\n  return modp(n - p, p)\n             ^\n              n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp2uqi55sv.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmp2uqi55sv.swift:20:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  } else if n < 0 {\n    return modp(-n, p)\n  } else if n >= p {\n    return n % p\n  } else {\n    return (n * modp(n - 1, p)) % p\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpxr80djx4.swift:17:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmpxr80djx4.swift:21:21: error: missing argument labels 'n:p:' in call\n    return (n * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp_qt5pmlk/tmp_qt5pmlk.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6f8648dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6f86184b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6f86184988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6f861837b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp_qt5pmlk                        0x000055836783424d <unavailable> + 4685\n5    libc.so.6                          0x00002b6f86679460 __libc_start_main + 245\n6    tmp_qt5pmlk                        0x0000558367833ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpb_755fts/tmpb_755fts.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abb9939ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abb99091b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abb99091988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abb990907b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpb_755fts                        0x000055e4b19942cd <unavailable> + 4813\n5    libc.so.6                          0x00002abb99586460 __libc_start_main + 245\n6    tmpb_755fts                        0x000055e4b1993ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmptqk3tomu.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmptqk3tomu.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmptqk3tomu.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbufw342w/tmpbufw342w.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b70e10a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b70e0d9fb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b70e0d9f988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b70e0d9e7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbufw342w                        0x0000561ac962a24d <unavailable> + 4685\n5    libc.so.6                          0x00002b70e1294460 __libc_start_main + 245\n6    tmpbufw342w                        0x0000561ac9629ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdpm8siih.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdpm8siih.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpdpm8siih.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpqdr0xiu0/tmpqdr0xiu0.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aac747bec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aac744b5b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aac744b5988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aac744b47b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqdr0xiu0                        0x000055a32e27f24d <unavailable> + 4685\n5    libc.so.6                          0x00002aac749aa460 __libc_start_main + 245\n6    tmpqdr0xiu0                        0x000055a32e27eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpb_755fts/tmpb_755fts.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abb9939ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abb99091b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abb99091988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abb990907b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpb_755fts                        0x000055e4b19942cd <unavailable> + 4813\n5    libc.so.6                          0x00002abb99586460 __libc_start_main + 245\n6    tmpb_755fts                        0x000055e4b1993ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == p {\n    return 0\n  }\n  if n < 0 {\n    n = -n\n  }\n  if p < 0 {\n    p = -p\n  }\n  if n < p {\n    return 0\n  }\n  return 1 + (n - 1) * modp(n - 1, p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpyf5saoom.swift:24:5: error: cannot assign to value: 'n' is a 'let' constant\n    n = -n\n    ^\n/tmp/tmpyf5saoom.swift:27:5: error: cannot assign to value: 'p' is a 'let' constant\n    p = -p\n    ^\n/tmp/tmpyf5saoom.swift:32:28: error: missing argument labels 'n:p:' in call\n  return 1 + (n - 1) * modp(n - 1, p) % p\n                           ^\n                            n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpr94ts20f/tmpr94ts20f.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad3c7029c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad3c6d20b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad3c6d20988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad3c6d1f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpr94ts20f                        0x0000555de633124d <unavailable> + 4685\n5    libc.so.6                          0x00002ad3c7215460 __libc_start_main + 245\n6    tmpr94ts20f                        0x0000555de6330ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpb_755fts/tmpb_755fts.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abb9939ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abb99091b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abb99091988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abb990907b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpb_755fts                        0x000055e4b19942cd <unavailable> + 4813\n5    libc.so.6                          0x00002abb99586460 __libc_start_main + 245\n6    tmpb_755fts                        0x000055e4b1993ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpkhnzvzzi.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n/tmp/tmpkhnzvzzi.swift:20:19: error: missing argument labels 'n:p:' in call\n  return (n * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdpm8siih.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdpm8siih.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpdpm8siih.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjh6ky4ql/tmpjh6ky4ql.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b67e27a2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b67e2499b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b67e2499988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b67e24987b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjh6ky4ql                        0x000055c07a9ef2cd <unavailable> + 4813\n5    libc.so.6                          0x00002b67e298e460 __libc_start_main + 245\n6    tmpjh6ky4ql                        0x000055c07a9eeef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpxk2n4a0g.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxk2n4a0g.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpxk2n4a0g.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n / p) * p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp0z829n0e/tmp0z829n0e.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002add7b062c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002add7ad59b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002add7ad59988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002add7ad587b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0z829n0e                        0x00005597cf6dd2cd <unavailable> + 4813\n5    libc.so.6                          0x00002add7b24e460 __libc_start_main + 245\n6    tmp0z829n0e                        0x00005597cf6dcef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 0 {\n        return modp(n, -p)\n    }\n    if p == 1 {\n        return n\n    }\n    if p == 2 {\n        return n & 1\n    }\n    if p == 3 {\n        return (n * n) & 1\n    }\n    if p == 4 {\n        return (n * n * n) & 1\n    }\n    if p == 5 {\n        return (n * n * n * n) & 1\n    }\n    if p == 6 {\n        return (n * n * n * n * n) & 1\n    }\n    if p == 7 {\n        return (n * n * n * n * n * n) & 1\n    }\n    if p == 8 {\n        return (n * n * n * n * n * n * n) & 1\n    }\n    if p == 9 {\n        return (n * n * n * n * n * n * n * n) & 1\n    }\n    if p == 10 {\n        return (n * n * n * n * n * n * n * n * n) & 1\n    }\n    if p == 11 {\n        return (n * n * n * n * n * n * n * n * n * n) & 1\n    }\n    if p == 12 {\n        return (n * n * n * n * n * n * n * n * n * n * n) & 1\n    }\n    if p == 13 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n    }\n    if p == 14 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n    }\n    if p == 15 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp4rt1dj9e.swift:92:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp4rt1dj9e.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp4rt1dj9e.swift:21:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n/tmp/tmp4rt1dj9e.swift:24:20: error: missing argument labels 'n:p:' in call\n        return modp(n, -p)\n                   ^\n                    n: p: \n/tmp/tmp4rt1dj9e.swift:74:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjh6ky4ql/tmpjh6ky4ql.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b67e27a2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b67e2499b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b67e2499988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b67e24987b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjh6ky4ql                        0x000055c07a9ef2cd <unavailable> + 4813\n5    libc.so.6                          0x00002b67e298e460 __libc_start_main + 245\n6    tmpjh6ky4ql                        0x000055c07a9eeef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpmw8g3ft8.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n/tmp/tmpmw8g3ft8.swift:20:24: error: missing argument labels 'n:p:' in call\n  return (n % p) * modp(n / p, p)\n                       ^\n                        n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        n = -n\n    }\n    if p < 0 {\n        p = -p\n    }\n    if p == 1 {\n        return n\n    }\n    if p == 2 {\n        return n % 2\n    }\n    if p == 3 {\n        return (n * n) % 3\n    }\n    if p == 4 {\n        return (n * n * n) % 4\n    }\n    if p == 5 {\n        return (n * n * n * n) % 5\n    }\n    if p == 6 {\n        return (n * n * n * n * n) % 6\n    }\n    if p == 7 {\n        return (n * n * n * n * n * n) % 7\n    }\n    if p == 8 {\n        return (n * n * n * n * n * n * n) % 8\n    }\n    if p == 9 {\n        return (n * n * n * n * n * n * n * n) % 9\n    }\n    if p == 10 {\n        return (n * n * n * n * n * n * n * n * n) % 10\n    }\n    if p == 11 {\n        return (n * n * n * n * n * n * n * n * n * n) % 11\n    }\n    if p == 12 {\n        return (n * n * n * n * n * n * n * n * n * n * n) % 12\n    }\n    if p == 13 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n) % 13\n    }\n    if p == 14 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n * n) % 14\n    }\n    if p == 15 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) % 15\n    }\n    if p == 16 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp4b_kp9ic.swift:93:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp4b_kp9ic.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp4b_kp9ic.swift:21:9: error: cannot assign to value: 'n' is a 'let' constant\n        n = -n\n        ^\n/tmp/tmp4b_kp9ic.swift:24:9: error: cannot assign to value: 'p' is a 'let' constant\n        p = -p\n        ^\n/tmp/tmp4b_kp9ic.swift:75:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpyq78d9m8.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if n == p {\n        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return p * p\n    }\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p)\n    }\n    return modp(n - 1, p) * modp(n - 1, p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpej_dav6s.swift:21:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n/tmp/tmpej_dav6s.swift:33:20: error: missing argument labels 'n:p:' in call\n        return modp(n / 2, p) * modp(n / 2, p)\n                   ^\n                    n:     p: \n/tmp/tmpej_dav6s.swift:33:37: error: missing argument labels 'n:p:' in call\n        return modp(n / 2, p) * modp(n / 2, p)\n                                    ^\n                                     n:     p: \n/tmp/tmpej_dav6s.swift:35:16: error: missing argument labels 'n:p:' in call\n    return modp(n - 1, p) * modp(n - 1, p) % p\n               ^\n                n:     p: \n/tmp/tmpej_dav6s.swift:35:33: error: missing argument labels 'n:p:' in call\n    return modp(n - 1, p) * modp(n - 1, p) % p\n                                ^\n                                 n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpm96ki__a/tmpm96ki__a.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aaf095b4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaf092abb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaf092ab988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaf092aa7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm96ki__a                        0x00005600d72ca2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aaf097a0460 __libc_start_main + 245\n6    tmpm96ki__a                        0x00005600d72c9ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp9jfnv8zp.swift:122:7: error: expected expression, var, or let in 'if' condition\n    if\n      ^\n/tmp/tmp9jfnv8zp.swift:18:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp_qt5pmlk/tmp_qt5pmlk.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6f8648dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6f86184b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6f86184988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6f861837b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp_qt5pmlk                        0x000055836783424d <unavailable> + 4685\n5    libc.so.6                          0x00002b6f86679460 __libc_start_main + 245\n6    tmp_qt5pmlk                        0x0000558367833ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpcavc3bgm.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpxk2n4a0g.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxk2n4a0g.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpxk2n4a0g.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n >= p {\n        return n % p\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpumgczy07.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpo8me8lic/tmpo8me8lic.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfe67a7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfe649eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abfe649e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abfe649d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpo8me8lic                        0x000056005d9d32cd <unavailable> + 4813\n5    libc.so.6                          0x00002abfe6993460 __libc_start_main + 245\n6    tmpo8me8lic                        0x000056005d9d2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpm0ux61zy.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpqdr0xiu0/tmpqdr0xiu0.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aac747bec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aac744b5b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aac744b5988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aac744b47b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqdr0xiu0                        0x000055a32e27f24d <unavailable> + 4685\n5    libc.so.6                          0x00002aac749aa460 __libc_start_main + 245\n6    tmpqdr0xiu0                        0x000055a32e27eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 2 {\n        return n % 2\n    }\n    if p == 3 {\n        return n % 3\n    }\n    if p == 4 {\n        return n % 4\n    }\n    if p == 5 {\n        return n % 5\n    }\n    if p == 6 {\n        return n % 6\n    }\n    if p == 7 {\n        return n % 7\n    }\n    if p == 8 {\n        return n % 8\n    }\n    if p == 9 {\n        return n % 9\n    }\n    if p == 10 {\n        return n % 10\n    }\n    if p == 11 {\n        return n % 11\n    }\n    if p == 12 {\n        return n % 12\n    }\n    if p == 13 {\n        return n % 13\n    }\n    if p == 14 {\n        return n % 14\n    }\n    if p == 15 {\n        return n % 15\n    }\n    if p == 16 {\n        return n % 16\n    }\n    if p == 17 {\n        return n % 17\n    }\n    if p == 18 {\n        return n % 18\n    }\n    if p == 19 {\n        return n % 19\n    }\n    if p == 20 {\n        return n % 20\n    }\n    if p == 21 {\n        return n % 21\n    }\n    if p == 22 {\n        return n % 22\n    }\n    if p == 23 {\n        return n % 23\n    }\n    if p == 24 {\n        return n % 24\n    }\n    if p == 25 {\n        return n % 25\n    }\n    if p == 26 {\n        return n % 26\n    }\n    if p == 27 {\n        return n % 27\n    }\n    if p == 28 {\n        return n % 28\n    }\n    if p == 29 {\n        return n % 29\n    }\n    if p == 30 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpqj6zk_7v.swift:133:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpqj6zk_7v.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpqj6zk_7v.swift:115:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  if n >= p {\n    return n % p\n  }\n  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp5p8r7owm.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdrq_bmu7.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpcavc3bgm.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n < 0 {\n    return modp(-n, p)\n  }\n  return (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp2oqtd8ji.swift:21:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmp2oqtd8ji.swift:23:24: error: missing argument labels 'n:p:' in call\n  return (n % p) * modp(n / p, p)\n                       ^\n                        n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp__tn511g.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpm0ux61zy.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpm96ki__a/tmpm96ki__a.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aaf095b4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaf092abb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaf092ab988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaf092aa7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm96ki__a                        0x00005600d72ca2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aaf097a0460 __libc_start_main + 245\n6    tmpm96ki__a                        0x00005600d72c9ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpsff3hx1s.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp95pj8d5_.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpnuqeiuh1/tmpnuqeiuh1.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b279c737c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b279c42eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b279c42e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b279c42d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpnuqeiuh1                        0x0000562e68ea32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b279c923460 __libc_start_main + 245\n6    tmpnuqeiuh1                        0x0000562e68ea2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpwba8_g4p/tmpwba8_g4p.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b98dc2aac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b98dbfa1b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b98dbfa1988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b98dbfa07b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpwba8_g4p                        0x000055d3ea35724d <unavailable> + 4685\n5    libc.so.6                          0x00002b98dc496460 __libc_start_main + 245\n6    tmpwba8_g4p                        0x000055d3ea356ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpo8me8lic/tmpo8me8lic.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfe67a7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfe649eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abfe649e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abfe649d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpo8me8lic                        0x000056005d9d32cd <unavailable> + 4813\n5    libc.so.6                          0x00002abfe6993460 __libc_start_main + 245\n6    tmpo8me8lic                        0x000056005d9d2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpo8me8lic/tmpo8me8lic.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfe67a7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfe649eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abfe649e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abfe649d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpo8me8lic                        0x000056005d9d32cd <unavailable> + 4813\n5    libc.so.6                          0x00002abfe6993460 __libc_start_main + 245\n6    tmpo8me8lic                        0x000056005d9d2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpyq78d9m8.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpxv6ptx7q/tmpxv6ptx7q.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2b12d89c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2b12a80b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2b12a80988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2b12a7f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxv6ptx7q                        0x0000564a74f2424d <unavailable> + 4685\n5    libc.so.6                          0x00002b2b12f75460 __libc_start_main + 245\n6    tmpxv6ptx7q                        0x0000564a74f23ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpxk2n4a0g.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxk2n4a0g.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpxk2n4a0g.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    return (n % p) + (n / p) * p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpddpdmtnp.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpb_755fts/tmpb_755fts.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abb9939ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abb99091b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abb99091988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abb990907b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpb_755fts                        0x000055e4b19942cd <unavailable> + 4813\n5    libc.so.6                          0x00002abb99586460 __libc_start_main + 245\n6    tmpb_755fts                        0x000055e4b1993ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 1\n    }\n    if p == 2 {\n        return n % 2\n    }\n    if p == 3 {\n        return n % 3\n    }\n    if p == 4 {\n        return n % 4\n    }\n    if p == 5 {\n        return n % 5\n    }\n    if p == 6 {\n        return n % 6\n    }\n    if p == 7 {\n        return n % 7\n    }\n    if p == 8 {\n        return n % 8\n    }\n    if p == 9 {\n        return n % 9\n    }\n    if p == 10 {\n        return n % 10\n    }\n    if p == 11 {\n        return n % 11\n    }\n    if p == 12 {\n        return n % 12\n    }\n    if p == 13 {\n        return n % 13\n    }\n    if p == 14 {\n        return n % 14\n    }\n    if p == 15 {\n        return n % 15\n    }\n    if p == 16 {\n        return n % 16\n    }\n    if p == 17 {\n        return n % 17\n    }\n    if p == 18 {\n        return n % 18\n    }\n    if p == 19 {\n        return n % 19\n    }\n    if p == 20 {\n        return n % 20\n    }\n    if p == 21 {\n        return n % 21\n    }\n    if p == 22 {\n        return n % 22\n    }\n    if p == 23 {\n        return n % 23\n    }\n    if p == 24 {\n        return n % 24\n    }\n    if p == 25 {\n        return n % 25\n    }\n    if p == 26 {\n        return n % 26\n    }\n    if p == 27 {\n        return n % 27\n    }\n    if p == 28 {\n        return n % 28\n    }\n    if p == 29 {\n        return n % 29\n    }\n    if p == 30 {\n        return n % 30\n    }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpcn9k95in.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpjx_gacu_.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmpjx_gacu_.swift:20:24: error: missing argument labels 'n:p:' in call\n  return (n % p) * modp(n / p, p)\n                       ^\n                        n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if p == 2 {\n        return n % 2\n    }\n    if p == 3 {\n        return (n * n) % 3\n    }\n    if p == 4 {\n        return (n * n * n) % 4\n    }\n    if p == 5 {\n        return (n * n * n * n) % 5\n    }\n    if p == 6 {\n        return (n * n * n * n * n) % 6\n    }\n    if p == 7 {\n        return (n * n * n * n * n * n) % 7\n    }\n    if p == 8 {\n        return (n * n * n * n * n * n * n) % 8\n    }\n    if p == 9 {\n        return (n * n * n * n * n * n * n * n) % 9\n    }\n    if p == 10 {\n        return (n * n * n * n * n * n * n * n * n) % 10\n    }\n    if p == 11 {\n        return (n * n * n * n * n * n * n * n * n * n) % 11\n    }\n    if p == 12 {\n        return (n * n * n * n * n * n * n * n * n * n * n) % 12\n    }\n    if p == 13 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n) % 13\n    }\n    if p == 14 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n * n) % 14\n    }\n    if p == 15 {\n        return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) % 15\n    }\n    if p == 16 {\n        return (n * n * n * n *\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp8jhnrtv5.swift:70:1: error: expected expression after operator\n}\n^\n/tmp/tmp8jhnrtv5.swift:91:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp8jhnrtv5.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp8jhnrtv5.swift:18:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n/tmp/tmp8jhnrtv5.swift:69:16: error: cannot convert return expression of type '()' to return type 'Int'\n        return (n * n * n * n *\n               ^~~~~~~~~~~~~~~~\n/tmp/tmp8jhnrtv5.swift:73:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 1\n    }\n    if p == 2 {\n        return n % 2\n    }\n    if p == 3 {\n        return n % 3\n    }\n    if p == 4 {\n        return n % 4\n    }\n    if p == 5 {\n        return n % 5\n    }\n    if p == 6 {\n        return n % 6\n    }\n    if p == 7 {\n        return n % 7\n    }\n    if p == 8 {\n        return n % 8\n    }\n    if p == 9 {\n        return n % 9\n    }\n    if p == 10 {\n        return n % 10\n    }\n    if p == 11 {\n        return n % 11\n    }\n    if p == 12 {\n        return n % 12\n    }\n    if p == 13 {\n        return n % 13\n    }\n    if p == 14 {\n        return n % 14\n    }\n    if p == 15 {\n        return n % 15\n    }\n    if p == 16 {\n        return n % 16\n    }\n    if p == 17 {\n        return n % 17\n    }\n    if p == 18 {\n        return n % 18\n    }\n    if p == 19 {\n        return n % 19\n    }\n    if p == 20 {\n        return n % 20\n    }\n    if p == 21 {\n        return n % 21\n    }\n    if p == 22 {\n        return n % 22\n    }\n    if p == 23 {\n        return n % 23\n    }\n    if p == 24 {\n        return n % 24\n    }\n    if p == 25 {\n        return n % 25\n    }\n    if p == 26 {\n        return n % 26\n    }\n    if p == 27 {\n        return n % 27\n    }\n    if p == 28 {\n        return n % 28\n    }\n    if p == 29 {\n        return n % 29\n    }\n    if p == 30 {\n        return n % 30\n    }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpcn9k95in.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpm0ux61zy.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 1\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  if p == 2 {\n    return n\n  }\n  if p == 3 {\n    return (n * n) % p\n  }\n  if p == 4 {\n    return (n * n * n) % p\n  }\n  if p == 5 {\n    return (n * n * n * n) % p\n  }\n  if p == 6 {\n    return (n * n * n * n * n) % p\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) % p\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) % p\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) % p\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) % p\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) % p\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) % p\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) % p\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) % p\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) % p\n  }\n  if p == 16 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp84uxf8ye.swift:93:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp84uxf8ye.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp84uxf8ye.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmp84uxf8ye.swift:75:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpb_755fts/tmpb_755fts.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abb9939ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abb99091b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abb99091988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abb990907b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpb_755fts                        0x000055e4b19942cd <unavailable> + 4813\n5    libc.so.6                          0x00002abb99586460 __libc_start_main + 245\n6    tmpb_755fts                        0x000055e4b1993ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdpm8siih.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdpm8siih.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpdpm8siih.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdpm8siih.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdpm8siih.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpdpm8siih.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n = -n\n    }\n    if p < 0 {\n        p = -p\n    }\n    if p == 0 {\n        return 0\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpy53q0_ck.swift:15:9: error: cannot assign to value: 'n' is a 'let' constant\n        n = -n\n        ^\n/tmp/tmpy53q0_ck.swift:18:9: error: cannot assign to value: 'p' is a 'let' constant\n        p = -p\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    return (n % p) + (n / p) * p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpddpdmtnp.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjmtsr0bq/tmpjmtsr0bq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b097f470c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b097f167b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b097f167988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b097f1667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjmtsr0bq                        0x000055e2aabc02cd <unavailable> + 4813\n5    libc.so.6                          0x00002b097f65c460 __libc_start_main + 245\n6    tmpjmtsr0bq                        0x000055e2aabbfef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpbe3_p881.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmpbe3_p881.swift:23:24: error: missing argument labels 'n:p:' in call\n  return (n % p) * modp(n / p, p)\n                       ^\n                        n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpn8qk0hed/tmpn8qk0hed.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad93f273c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad93ef6ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad93ef6a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad93ef697b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpn8qk0hed                        0x00005574de0d124d <unavailable> + 4685\n5    libc.so.6                          0x00002ad93f45f460 __libc_start_main + 245\n6    tmpn8qk0hed                        0x00005574de0d0ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n = -n\n    }\n    if p < 0 {\n        p = -p\n    }\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p ==\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp6303v1z0.swift:123:1: error: expected expression after operator\n}\n^\n/tmp/tmp6303v1z0.swift:15:9: error: cannot assign to value: 'n' is a 'let' constant\n        n = -n\n        ^\n/tmp/tmp6303v1z0.swift:18:9: error: cannot assign to value: 'p' is a 'let' constant\n        p = -p\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(-n, p)\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp4l_cgpqw.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdpm8siih.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdpm8siih.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpdpm8siih.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpm96ki__a/tmpm96ki__a.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aaf095b4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaf092abb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaf092ab988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaf092aa7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm96ki__a                        0x00005600d72ca2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aaf097a0460 __libc_start_main + 245\n6    tmpm96ki__a                        0x00005600d72c9ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n = -n\n    }\n    if p < 0 {\n        p = -p\n    }\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return p * p\n    }\n    if p == 2 {\n        return n\n    }\n    if p == 3 {\n        return n * n\n    }\n    if p == 4 {\n        return n * n * n\n    }\n    if p == 5 {\n        return n * n * n * n\n    }\n    if p == 6 {\n        return n * n * n * n * n\n    }\n    if p == 7 {\n        return n * n * n * n * n * n\n    }\n    if p == 8 {\n        return n * n * n * n * n * n * n\n    }\n    if p == 9 {\n        return n * n * n * n * n * n * n * n\n    }\n    if p == 10 {\n        return n * n * n * n * n * n * n * n * n\n    }\n    if p == 11 {\n        return n * n * n * n * n * n * n * n * n * n\n    }\n    if p == 12 {\n        return n * n * n * n * n * n * n * n * n * n * n\n    }\n    if p == 13 {\n        return n * n * n * n * n * n * n * n * n * n * n * n\n    }\n    if p == 14 {\n        return n * n * n * n * n * n * n * n * n * n * n * n * n\n    }\n    if p == 15 {\n        return n * n * n * n * n * n * n * n * n * n * n * n * n * n\n    }\n    if p == 16 {\n        return n * n * n * n * n * n * n * n * n * n * n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp37how2is.swift:100:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp37how2is.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp37how2is.swift:15:9: error: cannot assign to value: 'n' is a 'let' constant\n        n = -n\n        ^\n/tmp/tmp37how2is.swift:18:9: error: cannot assign to value: 'p' is a 'let' constant\n        p = -p\n        ^\n/tmp/tmp37how2is.swift:82:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp_qt5pmlk/tmp_qt5pmlk.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6f8648dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6f86184b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6f86184988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6f861837b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp_qt5pmlk                        0x000055836783424d <unavailable> + 4685\n5    libc.so.6                          0x00002b6f86679460 __libc_start_main + 245\n6    tmp_qt5pmlk                        0x0000558367833ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    n = -n\n  }\n  if p < 0 {\n    p = -p\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return 1 + (n % p) * modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpoxeb1ugh.swift:15:5: error: cannot assign to value: 'n' is a 'let' constant\n    n = -n\n    ^\n/tmp/tmpoxeb1ugh.swift:18:5: error: cannot assign to value: 'p' is a 'let' constant\n    p = -p\n    ^\n/tmp/tmpoxeb1ugh.swift:26:28: error: missing argument labels 'n:p:' in call\n  return 1 + (n % p) * modp(n / p, p)\n                           ^\n                            n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmphg2vsrtj.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpxv6ptx7q/tmpxv6ptx7q.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2b12d89c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2b12a80b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2b12a80988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2b12a7f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxv6ptx7q                        0x0000564a74f2424d <unavailable> + 4685\n5    libc.so.6                          0x00002b2b12f75460 __libc_start_main + 245\n6    tmpxv6ptx7q                        0x0000564a74f23ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n = -n\n    }\n    if p < 0 {\n        p = -p\n    }\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n        return 0\n    }\n    return (n * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp1d3gtnlv.swift:15:9: error: cannot assign to value: 'n' is a 'let' constant\n        n = -n\n        ^\n/tmp/tmp1d3gtnlv.swift:18:9: error: cannot assign to value: 'p' is a 'let' constant\n        p = -p\n        ^\n/tmp/tmp1d3gtnlv.swift:29:21: error: missing argument labels 'n:p:' in call\n    return (n * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpn8qk0hed/tmpn8qk0hed.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad93f273c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad93ef6ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad93ef6a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad93ef697b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpn8qk0hed                        0x00005574de0d124d <unavailable> + 4685\n5    libc.so.6                          0x00002ad93f45f460 __libc_start_main + 245\n6    tmpn8qk0hed                        0x00005574de0d0ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpm96ki__a/tmpm96ki__a.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aaf095b4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaf092abb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaf092ab988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaf092aa7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm96ki__a                        0x00005600d72ca2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aaf097a0460 __libc_start_main + 245\n6    tmpm96ki__a                        0x00005600d72c9ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 1\n    }\n    if p == 2 {\n        return n % 2\n    }\n    if p == 3 {\n        return n % 3\n    }\n    if p == 4 {\n        return n % 4\n    }\n    if p == 5 {\n        return n % 5\n    }\n    if p == 6 {\n        return n % 6\n    }\n    if p == 7 {\n        return n % 7\n    }\n    if p == 8 {\n        return n % 8\n    }\n    if p == 9 {\n        return n % 9\n    }\n    if p == 10 {\n        return n % 10\n    }\n    if p == 11 {\n        return n % 11\n    }\n    if p == 12 {\n        return n % 12\n    }\n    if p == 13 {\n        return n % 13\n    }\n    if p == 14 {\n        return n % 14\n    }\n    if p == 15 {\n        return n % 15\n    }\n    if p == 16 {\n        return n % 16\n    }\n    if p == 17 {\n        return n % 17\n    }\n    if p == 18 {\n        return n % 18\n    }\n    if p == 19 {\n        return n % 19\n    }\n    if p == 20 {\n        return n % 20\n    }\n    if p == 21 {\n        return n % 21\n    }\n    if p == 22 {\n        return n % 22\n    }\n    if p == 23 {\n        return n % 23\n    }\n    if p == 24 {\n        return n % 24\n    }\n    if p == 25 {\n        return n % 25\n    }\n    if p == 26 {\n        return n % 26\n    }\n    if p == 27 {\n        return n % 27\n    }\n    if p == 28 {\n        return n % 28\n    }\n    if p == 29 {\n        return n % 29\n    }\n    if p == 30 {\n        return n % 30\n    }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpcn9k95in.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp7841pred/tmp7841pred.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0c893a4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0c8909bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0c8909b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0c8909a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7841pred                        0x0000561d176a224d <unavailable> + 4685\n5    libc.so.6                          0x00002b0c89590460 __libc_start_main + 245\n6    tmp7841pred                        0x0000561d176a1ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjmtsr0bq/tmpjmtsr0bq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b097f470c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b097f167b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b097f167988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b097f1667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjmtsr0bq                        0x000055e2aabc02cd <unavailable> + 4813\n5    libc.so.6                          0x00002b097f65c460 __libc_start_main + 245\n6    tmpjmtsr0bq                        0x000055e2aabbfef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpxv6ptx7q/tmpxv6ptx7q.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2b12d89c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2b12a80b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2b12a80988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2b12a7f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxv6ptx7q                        0x0000564a74f2424d <unavailable> + 4685\n5    libc.so.6                          0x00002b2b12f75460 __libc_start_main + 245\n6    tmpxv6ptx7q                        0x0000564a74f23ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp35ks3h4a.swift:20:24: error: missing argument labels 'n:p:' in call\n  return (n % p) * modp(n / p, p) % p\n                       ^\n                        n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpm96ki__a/tmpm96ki__a.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aaf095b4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaf092abb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaf092ab988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaf092aa7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpm96ki__a                        0x00005600d72ca2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aaf097a0460 __libc_start_main + 245\n6    tmpm96ki__a                        0x00005600d72c9ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  } else {\n    return (p * modp(n - 1, p)) % p\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpri3gslzi.swift:17:21: error: missing argument labels 'n:p:' in call\n    return (p * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n % p) * p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjl2hqb1u/tmpjl2hqb1u.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acf8bf23c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acf8bc1ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acf8bc1a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acf8bc197b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjl2hqb1u                        0x0000558638db324d <unavailable> + 4685\n5    libc.so.6                          0x00002acf8c10f460 __libc_start_main + 245\n6    tmpjl2hqb1u                        0x0000558638db2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return modp(n % p, p)\n    }\n    return (n % p) * (p - 1) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpro7d9g0o.swift:21:20: error: missing argument labels 'n:p:' in call\n        return modp(n % p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpdpm8siih.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdpm8siih.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpdpm8siih.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n < 0 {\n    return modp(p - n, p)\n  }\n  return modp(n % p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp43qqsih4.swift:21:16: error: missing argument labels 'n:p:' in call\n    return modp(p - n, p)\n               ^\n                n:     p: \n/tmp/tmp43qqsih4.swift:23:14: error: missing argument labels 'n:p:' in call\n  return modp(n % p, p)\n             ^\n              n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjmtsr0bq/tmpjmtsr0bq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b097f470c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b097f167b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b097f167988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b097f1667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjmtsr0bq                        0x000055e2aabc02cd <unavailable> + 4813\n5    libc.so.6                          0x00002b097f65c460 __libc_start_main + 245\n6    tmpjmtsr0bq                        0x000055e2aabbfef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpxte6ppkm.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n                    n:  p: \n/tmp/tmpxte6ppkm.swift:20:21: error: missing argument labels 'n:p:' in call\n    return (n * modp(n - 1, p)) % p\n                    ^\n                     n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 2 {\n        return 1\n    }\n    if n == 2 {\n        return p\n    }\n    if p == 3 {\n        return 2\n    }\n    if n == 3 {\n        return p\n    }\n    if p == 4 {\n        return 3\n    }\n    if n == 4 {\n        return p\n    }\n    if p == 5 {\n        return 4\n    }\n    if n == 5 {\n        return p\n    }\n    if p == 6 {\n        return 5\n    }\n    if n == 6 {\n        return p\n    }\n    if p == 7 {\n        return 6\n    }\n    if n == 7 {\n        return p\n    }\n    if p == 8 {\n        return 7\n    }\n    if n == 8 {\n        return p\n    }\n    if p == 9 {\n        return 8\n    }\n    if n == 9 {\n        return p\n    }\n    if p == 10 {\n        return 9\n    }\n    if n == 10 {\n        return p\n    }\n    if p == 11 {\n        return 10\n    }\n    if n == 11 {\n        return p\n    }\n    if p == 12 {\n        return 11\n    }\n    if n == 12 {\n        return p\n    }\n    if p == 13 {\n        return 12\n    }\n    if n == 13 {\n        return p\n    }\n    if p == 14 {\n        return 13\n    }\n    if n == 14 {\n        return p\n    }\n    if p == 15 {\n        return 14\n    }\n    if n == 15 {\n        return p\n    }\n    if p == 16 {\n        return 15\n    }\n    if n == 16 {\n        return p\n    }\n    if p == 17 {\n        return 16\n    }\n    if n == 17 {\n        return p\n    }\n    if p == 18 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp7cs0plj_.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp7cs0plj_.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmp7cs0plj_.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpnuqeiuh1/tmpnuqeiuh1.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b279c737c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b279c42eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b279c42e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b279c42d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpnuqeiuh1                        0x0000562e68ea32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b279c923460 __libc_start_main + 245\n6    tmpnuqeiuh1                        0x0000562e68ea2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjmtsr0bq/tmpjmtsr0bq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b097f470c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b097f167b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b097f167988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b097f1667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjmtsr0bq                        0x000055e2aabc02cd <unavailable> + 4813\n5    libc.so.6                          0x00002b097f65c460 __libc_start_main + 245\n6    tmpjmtsr0bq                        0x000055e2aabbfef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpd118ksl5/tmpd118ksl5.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b645b61ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b645b315b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b645b315988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b645b3147b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd118ksl5                        0x000055a23cb9224d <unavailable> + 4685\n5    libc.so.6                          0x00002b645b80a460 __libc_start_main + 245\n6    tmpd118ksl5                        0x000055a23cb91ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n < 0 {\n    return modp(n + p, p)\n  }\n  return (n % p) + (n / p) * p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpipmrplgm.swift:15:16: error: missing argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n                n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpxk2n4a0g.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxk2n4a0g.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpxk2n4a0g.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpt0bif53i/tmpt0bif53i.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad72276c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad71f6db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aad71f6d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aad71f6c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpt0bif53i                        0x000055d7283ed2cd <unavailable> + 4813\n5    libc.so.6                          0x00002aad72462460 __libc_start_main + 245\n6    tmpt0bif53i                        0x000055d7283ecef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpo8me8lic/tmpo8me8lic.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfe67a7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfe649eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abfe649e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abfe649d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpo8me8lic                        0x000056005d9d32cd <unavailable> + 4813\n5    libc.so.6                          0x00002abfe6993460 __libc_start_main + 245\n6    tmpo8me8lic                        0x000056005d9d2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpxk2n4a0g.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxk2n4a0g.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpxk2n4a0g.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p * modp(n - 1, p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293296,
      "stdout": "",
      "stderr": "/tmp/tmpyl1rlut1.swift:17:19: error: missing argument labels 'n:p:' in call\n  return (p * modp(n - 1, p)) % p\n                  ^\n                   n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpjmtsr0bq/tmpjmtsr0bq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b097f470c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b097f167b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b097f167988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b097f1667b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpjmtsr0bq                        0x000055e2aabc02cd <unavailable> + 4813\n5    libc.so.6                          0x00002b097f65c460 __libc_start_main + 245\n6    tmpjmtsr0bq                        0x000055e2aabbfef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpnuqeiuh1/tmpnuqeiuh1.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b279c737c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b279c42eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b279c42e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b279c42d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpnuqeiuh1                        0x0000562e68ea32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b279c923460 __libc_start_main + 245\n6    tmpnuqeiuh1                        0x0000562e68ea2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmp4xoib6vr/tmp4xoib6vr.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b969b36bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b969b062b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b969b062988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b969b0617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4xoib6vr                        0x0000564cd14192cd <unavailable> + 4813\n5    libc.so.6                          0x00002b969b557460 __libc_start_main + 245\n6    tmp4xoib6vr                        0x0000564cd1418ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpqt9l96ww/tmpqt9l96ww.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5694180c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5693e77b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5693e77988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5693e767b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqt9l96ww                        0x000055b5e881924d <unavailable> + 4685\n5    libc.so.6                          0x00002b569436c460 __libc_start_main + 245\n6    tmpqt9l96ww                        0x000055b5e8818ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  } else if n < 0 {\n    return modp(-n, p)\n  } else {\n    return (n % p) * modp(n / p, p)\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpasi_j_oi.swift:17:16: error: missing argument labels 'n:p:' in call\n    return modp(-n, p)\n               ^\n                n:  p: \n/tmp/tmpasi_j_oi.swift:19:26: error: missing argument labels 'n:p:' in call\n    return (n % p) * modp(n / p, p)\n                         ^\n                          n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (p - 1) * modp(n - 1, p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmp0uliwxi2.swift:17:24: error: missing argument labels 'n:p:' in call\n  return (p - 1) * modp(n - 1, p) % p\n                       ^\n                        n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n + p, p)\n    }\n    return (n % p) + (n / p) * p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpddpdmtnp.swift:15:20: error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n                   ^\n                    n:     p: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if p == 3 {\n        return 2\n    }\n    if p == 4 {\n        return 3\n    }\n    if p == 5 {\n        return 4\n    }\n    if p == 6 {\n        return 5\n    }\n    if p == 7 {\n        return 6\n    }\n    if p == 8 {\n        return 7\n    }\n    if p == 9 {\n        return 8\n    }\n    if p == 10 {\n        return 9\n    }\n    if p == 11 {\n        return 10\n    }\n    if p == 12 {\n        return 11\n    }\n    if p == 13 {\n        return 12\n    }\n    if p == 14 {\n        return 13\n    }\n    if p == 15 {\n        return 14\n    }\n    if p == 16 {\n        return 15\n    }\n    if p == 17 {\n        return 16\n    }\n    if p == 18 {\n        return 17\n    }\n    if p == 19 {\n        return 18\n    }\n    if p == 20 {\n        return 19\n    }\n    if p == 21 {\n        return 20\n    }\n    if p == 22 {\n        return 21\n    }\n    if p == 23 {\n        return 22\n    }\n    if p == 24 {\n        return 23\n    }\n    if p == 25 {\n        return 24\n    }\n    if p == 26 {\n        return 25\n    }\n    if p == 27 {\n        return 26\n    }\n    if p == 28 {\n        return 27\n    }\n    if p == 29 {\n        return 28\n    }\n    if p == 30 {\n        return 29\n    }\n    if p == 31 {\n        return 30\n    }\n    if p == 32 {\n        return 31\n    }\n    if p == 33 {\n        return 32\n    }\n    if p == 34 {\n        return 33\n    }\n    if p == 35 {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwyscjhc7.swift:145:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwyscjhc7.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwyscjhc7.swift:127:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n = -n\n    }\n    if p < 0 {\n        p = -p\n    }\n    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return p\n    }\n    if n == 3 {\n        return (p * p) % p\n    }\n    if n == 4 {\n        return (p * p * p) % p\n    }\n    if n == 5 {\n        return (p * p * p * p) % p\n    }\n    if n == 6 {\n        return (p * p * p * p * p) % p\n    }\n    if n == 7 {\n        return (p * p * p * p * p * p) % p\n    }\n    if n == 8 {\n        return (p * p * p * p * p * p * p) % p\n    }\n    if n == 9 {\n        return (p * p * p * p * p * p * p * p) % p\n    }\n    if n == 10 {\n        return (p * p * p * p * p * p * p * p * p) % p\n    }\n    if n == 11 {\n        return (p * p * p * p * p * p * p * p * p * p) % p\n    }\n    if n == 12 {\n        return (p * p * p * p * p * p * p * p * p * p * p) % p\n    }\n    if n == 13 {\n        return (p * p * p * p * p * p * p * p * p * p * p * p) % p\n    }\n    if n == 14 {\n        return (p * p * p * p * p * p * p * p * p * p * p * p * p) % p\n    }\n    if n == 15 {\n        return (p * p * p * p * p * p * p * p * p * p * p * p * p * p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "/tmp/tmpwd8y5bc3.swift:94:31: error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpwd8y5bc3.swift:13:34: note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n/tmp/tmpwd8y5bc3.swift:15:9: error: cannot assign to value: 'n' is a 'let' constant\n        n = -n\n        ^\n/tmp/tmpwd8y5bc3.swift:18:9: error: cannot assign to value: 'p' is a 'let' constant\n        p = -p\n        ^\n/tmp/tmpwd8y5bc3.swift:76:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpbfcfssiw/tmpbfcfssiw.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b45cbcbbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b45cb9b2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b45cb9b2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b45cb9b17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpbfcfssiw                        0x000055c800cb32cd <unavailable> + 4813\n5    libc.so.6                          0x00002b45cbea7460 __libc_start_main + 245\n6    tmpbfcfssiw                        0x000055c800cb2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n/// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  return (n % p + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
      "timestamp": 1664293297,
      "stdout": "",
      "stderr": "tmpw2zp154a/tmpw2zp154a.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab1fff10c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab1ffc07b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab1ffc07988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab1ffc067b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpw2zp154a                        0x000055bbf17c92cd <unavailable> + 4813\n5    libc.so.6                          0x00002ab2000fc460 __libc_start_main + 245\n6    tmpw2zp154a                        0x000055bbf17c8ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    }
  ]
}