{
  "name": "HumanEval_61_correct_bracketing",
  "language": "swift",
  "prompt": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpvhklx_zl.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpvhklx_zl.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpvhklx_zl.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpvhklx_zl.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpvhklx_zl.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpvhklx_zl.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpvhklx_zl.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpvhklx_zl.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpvhklx_zl.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpvhklx_zl.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpvhklx_zl.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpvhklx_zl.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_set []int\n    var closing_bracket_stack_set []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_set []int\n    var closing_bracket_stack_index_set []int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_set []int\n    var closing_bracket_stack_index_stack_set []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_set []int\n    var closing_bracket_stack_index_stack_index_set []int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_set []int\n    var closing_bracket_stack_index_stack_index_stack_set []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_set []int\n    var closing_bracket_stack_index_stack_index_stack_index_set []int\n    var opening_bracket_stack_index_stack_index_stack_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpwpzqrnl6.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpwpzqrnl6.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpwpzqrnl6.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpwpzqrnl6.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpwpzqrnl6.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpwpzqrnl6.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpwpzqrnl6.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpwpzqrnl6.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpwpzqrnl6.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpwpzqrnl6.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpwpzqrnl6.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpwpzqrnl6.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var open_brackets = 0\n    var close_brackets = 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            close_brackets += 1\n        }\n    }\n    return open_brackets == close_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3oaf0oro.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp3oaf0oro.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp3oaf0oro.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp3oaf0oro.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpma8d4muv.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpma8d4muv.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpma8d4muv.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpma8d4muv.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpscl9614b.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpscl9614b.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpscl9614b.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpscl9614b.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpscl9614b.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpscl9614b.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpscl9614b.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpscl9614b.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpscl9614b.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpscl9614b.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpaz3ilthm.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpaz3ilthm.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpaz3ilthm.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpaz3ilthm.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpaz3ilthm.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpaz3ilthm.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpaz3ilthm.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpaz3ilthm.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpaz3ilthm.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpaz3ilthm.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpaz3ilthm.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpaz3ilthm.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpd8ibci3n.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpd8ibci3n.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpd8ibci3n.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpd8ibci3n.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpd8ibci3n.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpd8ibci3n.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpd8ibci3n.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpd8ibci3n.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpd8ibci3n.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpd8ibci3n.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_in_string int\n    var closing_bracket_index_in_string int\n    var opening_bracket_index_in_string_2 int\n    var closing_bracket_index_in_string_2 int\n    var opening_bracket_index_in_string_3 int\n    var closing_bracket_index_in_string_3 int\n    var opening_bracket_index_in_string_4 int\n    var closing_bracket_index_in_string_4 int\n    var opening_bracket_index_in_string_5 int\n    var closing_bracket_index_in_string_5 int\n    var opening_bracket_index_in_string_6 int\n    var closing_bracket_index_in_string_6 int\n    var opening_bracket_index_in_string_7 int\n    var closing_bracket_index_in_string_7 int\n    var opening_bracket_index_in_string_8 int\n    var closing_bracket_index_in_string_8 int\n    var opening_bracket_index_in_string_9 int\n    var closing_bracket_index_in_string_9 int\n    var opening_bracket_index_in_string_10 int\n    var closing_bracket_index_in_string_10 int\n    var opening_bracket_index_in_string_11 int\n    var closing_bracket_index_in_string_11 int\n    var opening_bracket_index_in_string_12 int\n    var closing_bracket_index_in_string_12 int\n    var opening_bracket_index_in_string_13 int\n    var closing_bracket_index_in_string_13 int\n    var opening_bracket_index_in_string_14 int\n    var closing_bracket_index_in_string_14 int\n    var opening_bracket_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpryksp8z0.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpryksp8z0.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpryksp8z0.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpryksp8z0.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpryksp8z0.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpryksp8z0.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpryksp8z0.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpryksp8z0.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpryksp8z0.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpryksp8z0.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpryksp8z0.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpryksp8z0.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == ')' {\n            closing_bracket_count++\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    \n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    \n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpcf9nwbcm.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpcf9nwbcm.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpcf9nwbcm.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpcf9nwbcm.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpcf9nwbcm.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpcf9nwbcm.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpcf9nwbcm.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpcf9nwbcm.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpcf9nwbcm.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpcf9nwbcm.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpcf9nwbcm.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpcf9nwbcm.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    for opening_bracket_index, opening_bracket := range brackets {\n        if opening_bracket == '(' {\n            opening_bracket_count += 1\n        }\n    }\n    for closing_bracket_index, closing_bracket := range brackets {\n        if closing_bracket == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for opening_bracket_index, opening_bracket := range brackets {\n        if opening_bracket == '(' {\n            opening_bracket_count -= 1\n        }\n    }\n    for closing_bracket_index, closing_bracket := range brackets {\n        if closing_bracket == ')' {\n            closing_bracket_count -= 1\n        }\n    }\n    if opening_bracket_count != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpi3iz1bvr.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpi3iz1bvr.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpi3iz1bvr.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpi3iz1bvr.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpi3iz1bvr.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpi3iz1bvr.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpi3iz1bvr.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpi3iz1bvr.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpi3iz1bvr.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpi3iz1bvr.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpi3iz1bvr.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpi3iz1bvr.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if r == stack[len(stack) - 1] {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpsf7pbux2.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpsf7pbux2.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpsf7pbux2.swift:17:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpsf7pbux2.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpsf7pbux2.swift:18:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpsf7pbux2.swift:25:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpsf7pbux2.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpsf7pbux2.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpsf7pbux2.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    opening_brackets := make([]int, 0)\n    closing_brackets := make([]int, 0)\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_brackets = append(opening_brackets, i)\n        } else if brackets[i] == ')' {\n            closing_brackets = append(closing_brackets, i)\n        }\n    }\n    \n    if len(opening_brackets) != len(closing_brackets) {\n        return false\n    }\n    \n    for i := 0; i < len(opening_brackets); i++ {\n        if opening_brackets[i] != closing_brackets[i] + 1 {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp4k274fh4.swift:17:21: error: consecutive statements on a line must be separated by ';'\n    opening_brackets := make([]int, 0)\n                    ^\n                    ;\n/tmp/tmp4k274fh4.swift:17:22: error: expected expression\n    opening_brackets := make([]int, 0)\n                     ^\n/tmp/tmp4k274fh4.swift:20:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp4k274fh4.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp4k274fh4.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp4k274fh4.swift:21:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp4k274fh4.swift:23:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp4k274fh4.swift:32:12: error: expected type\n    for i := 0; i < len(opening_brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp4k274fh4.swift:32:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(opening_brackets); i++ {\n           ^\n/tmp/tmp4k274fh4.swift:32:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(opening_brackets); i++ {\n           ^\n/tmp/tmp4k274fh4.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp4k274fh4.swift:17:5: error: cannot find 'opening_brackets' in scope\n    opening_brackets := make([]int, 0)\n    ^~~~~~~~~~~~~~~~\n/tmp/tmp4k274fh4.swift:28:8: error: cannot find 'len' in scope\n    if len(opening_brackets) != len(closing_brackets) {\n       ^~~\n/tmp/tmp4k274fh4.swift:28:12: error: cannot find 'opening_brackets' in scope\n    if len(opening_brackets) != len(closing_brackets) {\n           ^~~~~~~~~~~~~~~~\n/tmp/tmp4k274fh4.swift:28:33: error: cannot fin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp34p6xjl9.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp34p6xjl9.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        }\n        if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmplu9p2ub1.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmplu9p2ub1.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmplu9p2ub1.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmplu9p2ub1.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmplu9p2ub1.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmplu9p2ub1.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqkzl5pmj.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpqkzl5pmj.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpqkzl5pmj.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpqkzl5pmj.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqkzl5pmj.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqkzl5pmj.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpqkzl5pmj.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpqkzl5pmj.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpqkzl5pmj.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpdmqtvz4d.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpdmqtvz4d.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpdmqtvz4d.swift:17:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpdmqtvz4d.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpdmqtvz4d.swift:18:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpdmqtvz4d.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpdmqtvz4d.swift:27:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpdmqtvz4d.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpdmqtvz4d.swift:30:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpdmqtvz4d.swift:30:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if r == stack[len(stack) - 1] {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    \n    if len(stack) == 0 {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp7b1rb3un.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp7b1rb3un.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp7b1rb3un.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmp7b1rb3un.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmp7b1rb3un.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp7b1rb3un.swift:26:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmp7b1rb3un.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp7b1rb3un.swift:33:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n/tmp/tmp7b1rb3un.swift:33:12: error: cannot find 'stack' in scope\n    if len(stack) == 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpma8d4muv.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpma8d4muv.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpma8d4muv.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpma8d4muv.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if r == stack[len(stack) - 1] {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmppmw2yh38.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmppmw2yh38.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmppmw2yh38.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmppmw2yh38.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmppmw2yh38.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmppmw2yh38.swift:26:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmppmw2yh38.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmppmw2yh38.swift:32:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmppmw2yh38.swift:32:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpma8d4muv.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpma8d4muv.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpma8d4muv.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpma8d4muv.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpe5t89jjd.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpe5t89jjd.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpe5t89jjd.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpe5t89jjd.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpe5t89jjd.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpe5t89jjd.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpe5t89jjd.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpe5t89jjd.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpe5t89jjd.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpe5t89jjd.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpe5t89jjd.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmpe5t89jjd.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    for _, c := range brackets {\n        if c == '(' {\n            opening_bracket_count += 1\n        } else if c == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpvdjobul0.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpvdjobul0.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpvdjobul0.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpvdjobul0.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, char)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmptlj3ukw6.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmptlj3ukw6.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmptlj3ukw6.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmptlj3ukw6.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmptlj3ukw6.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmptlj3ukw6.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmptlj3ukw6.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmptlj3ukw6.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmptlj3ukw6.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmptlj3ukw6.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpaz3ilthm.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpaz3ilthm.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpaz3ilthm.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpaz3ilthm.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpaz3ilthm.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpaz3ilthm.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpaz3ilthm.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpaz3ilthm.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpaz3ilthm.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpaz3ilthm.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpaz3ilthm.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpaz3ilthm.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := range brackets {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i -= 1 {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp8dfn0kyz.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp8dfn0kyz.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp8dfn0kyz.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp8dfn0kyz.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp8dfn0kyz.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp8dfn0kyz.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp8dfn0kyz.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp8dfn0kyz.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp8dfn0kyz.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp8dfn0kyz.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp8dfn0kyz.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp8dfn0kyz.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count++\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp4avc1n8i.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp4avc1n8i.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp4avc1n8i.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp4avc1n8i.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp4avc1n8i.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp4avc1n8i.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp4avc1n8i.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp4avc1n8i.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp4avc1n8i.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp4avc1n8i.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp4avc1n8i.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp4avc1n8i.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbzvbvz9a.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbzvbvz9a.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbzvbvz9a.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpbzvbvz9a.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpbzvbvz9a.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpbzvbvz9a.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpbzvbvz9a.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpbzvbvz9a.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbzvbvz9a.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, char)\n        } else if char == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp9rfryqu8.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp9rfryqu8.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp9rfryqu8.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp9rfryqu8.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp9rfryqu8.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp9rfryqu8.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp9rfryqu8.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp9rfryqu8.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp9rfryqu8.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp9rfryqu8.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpt2c1453r.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpt2c1453r.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpt2c1453r.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpt2c1453r.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpt2c1453r.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpt2c1453r.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpt2c1453r.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpt2c1453r.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpt2c1453r.swift:29:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, char)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpnvu7d5fs.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpnvu7d5fs.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpnvu7d5fs.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpnvu7d5fs.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpnvu7d5fs.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpnvu7d5fs.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpnvu7d5fs.swift:27:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpnvu7d5fs.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpnvu7d5fs.swift:30:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpnvu7d5fs.swift:30:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpt2c1453r.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpt2c1453r.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpt2c1453r.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpt2c1453r.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpt2c1453r.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpt2c1453r.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpt2c1453r.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpt2c1453r.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpt2c1453r.swift:29:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == ')' {\n            closing_bracket_count++\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp568dewv_.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp568dewv_.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp568dewv_.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp568dewv_.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp568dewv_.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp568dewv_.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp568dewv_.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp568dewv_.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp568dewv_.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp568dewv_.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp568dewv_.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp568dewv_.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpzt9b17_a.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpzt9b17_a.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpzt9b17_a.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpzt9b17_a.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpzt9b17_a.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpzt9b17_a.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpzt9b17_a.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpzt9b17_a.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpzt9b17_a.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpzt9b17_a.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpzt9b17_a.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpzt9b17_a.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpt2c1453r.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpt2c1453r.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpt2c1453r.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpt2c1453r.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpt2c1453r.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpt2c1453r.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpt2c1453r.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpt2c1453r.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpt2c1453r.swift:29:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        }\n        if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmplu9p2ub1.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmplu9p2ub1.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmplu9p2ub1.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmplu9p2ub1.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmplu9p2ub1.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmplu9p2ub1.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpji768vxd.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpji768vxd.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpji768vxd.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpji768vxd.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpji768vxd.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpji768vxd.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpji768vxd.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpji768vxd.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpji768vxd.swift:27:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if r == stack[len(stack) - 1] {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpsf7pbux2.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpsf7pbux2.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpsf7pbux2.swift:17:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpsf7pbux2.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpsf7pbux2.swift:18:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpsf7pbux2.swift:25:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpsf7pbux2.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpsf7pbux2.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpsf7pbux2.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3ya3kufi.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3ya3kufi.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3ya3kufi.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp3ya3kufi.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp3ya3kufi.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp3ya3kufi.swift:20:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp3ya3kufi.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3ya3kufi.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqkzl5pmj.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpqkzl5pmj.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpqkzl5pmj.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpqkzl5pmj.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqkzl5pmj.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqkzl5pmj.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpqkzl5pmj.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpqkzl5pmj.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpqkzl5pmj.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp2o33ucxn.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp2o33ucxn.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp2o33ucxn.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp2o33ucxn.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp2o33ucxn.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp2o33ucxn.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp2o33ucxn.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp2o33ucxn.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp2o33ucxn.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        }\n        if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmplu9p2ub1.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmplu9p2ub1.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmplu9p2ub1.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmplu9p2ub1.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmplu9p2ub1.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmplu9p2ub1.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack:=make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            stack = append(stack, i)\n        } else if brackets[i] == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmphra_6s9h.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=make([]int, 0)\n         ^\n         ;\n/tmp/tmphra_6s9h.swift:17:10: error: expected expression\n    stack:=make([]int, 0)\n         ^\n/tmp/tmphra_6s9h.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=make([]int, 0)\n          ^\n            \n/tmp/tmphra_6s9h.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmphra_6s9h.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmphra_6s9h.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmphra_6s9h.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmphra_6s9h.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmphra_6s9h.swift:25:29: error: expected ',' separator\n            stack = stack[0 : len(stack)-1]\n                            ^\n                           ,\n/tmp/tmphra_6s9h.swift:25:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack)-1]\n                            ^\n/tmp/tmphra_6s9h.swift:17:5: error: cannot find 'stack' in scope\n    stack:=make([]int, 0)\n    ^~~~~\n/tmp/tmphra_6s9h.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmphra_6s9h.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp6rqf_tel.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp6rqf_tel.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp6rqf_tel.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp6rqf_tel.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6rqf_tel.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6rqf_tel.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp6rqf_tel.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp6rqf_tel.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp6rqf_tel.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            if brackets[last] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpexnq2rkz.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := make([]int, 0)\n         ^\n         ;\n/tmp/tmpexnq2rkz.swift:16:11: error: expected expression\n    stack := make([]int, 0)\n          ^\n/tmp/tmpexnq2rkz.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpexnq2rkz.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpexnq2rkz.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpexnq2rkz.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpexnq2rkz.swift:24:17: error: consecutive statements on a line must be separated by ';'\n            last := stack[len(stack) - 1]\n                ^\n                ;\n/tmp/tmpexnq2rkz.swift:24:18: error: expected expression\n            last := stack[len(stack) - 1]\n                 ^\n/tmp/tmpexnq2rkz.swift:25:34: error: single-quoted string literal found, use '\"'\n            if brackets[last] != '(' {\n                                 ^~~\n                                 \"(\"\n/tmp/tmpexnq2rkz.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpexnq2rkz.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpexnq2rkz.swift:16:5: error: cannot find 'stack' in scope\n    stack := make([]int, 0)\n    ^~~~~\n/tmp/tmpexnq2rkz.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpexnq2rkz.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_stack); i++ {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpcv3z6n8g.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpcv3z6n8g.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpcv3z6n8g.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpcv3z6n8g.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpcv3z6n8g.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpcv3z6n8g.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpcv3z6n8g.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpcv3z6n8g.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpcv3z6n8g.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpcv3z6n8g.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpcv3z6n8g.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpcv3z6n8g.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp34p6xjl9.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp34p6xjl9.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpvhklx_zl.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpvhklx_zl.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpvhklx_zl.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpvhklx_zl.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpvhklx_zl.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpvhklx_zl.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpvhklx_zl.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpvhklx_zl.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpvhklx_zl.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpvhklx_zl.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpvhklx_zl.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpvhklx_zl.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp419aoy25.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp419aoy25.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp419aoy25.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp419aoy25.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp419aoy25.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmp419aoy25.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp419aoy25.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp419aoy25.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp419aoy25.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp419aoy25.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp419aoy25.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmp419aoy25.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmphbmvbx39.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmphbmvbx39.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmphbmvbx39.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmphbmvbx39.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmphbmvbx39.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmphbmvbx39.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmphbmvbx39.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphbmvbx39.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmphbmvbx39.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmphbmvbx39.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var stack []rune\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if r == ')' {\n                if stack[len(stack) - 1] != '(' {\n                    return false\n                }\n                stack = stack[:len(stack) - 1]\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp5jsylyzy.swift:16:14: error: consecutive statements on a line must be separated by ';'\n    var stack []rune\n             ^\n             ;\n/tmp/tmp5jsylyzy.swift:16:17: error: consecutive statements on a line must be separated by ';'\n    var stack []rune\n                ^\n                ;\n/tmp/tmp5jsylyzy.swift:17:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmp5jsylyzy.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmp5jsylyzy.swift:18:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp5jsylyzy.swift:24:21: error: single-quoted string literal found, use '\"'\n            if r == ')' {\n                    ^~~\n                    \")\"\n/tmp/tmp5jsylyzy.swift:25:45: error: single-quoted string literal found, use '\"'\n                if stack[len(stack) - 1] != '(' {\n                                            ^~~\n                                            \"(\"\n/tmp/tmp5jsylyzy.swift:28:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmp5jsylyzy.swift:16:9: error: type annotation missing in pattern\n    var stack []rune\n        ^\n/tmp/tmp5jsylyzy.swift:16:15: error: empty collection literal requires an explicit type\n    var stack []rune\n              ^~\n/tmp/tmp5jsylyzy.swift:16:15: warning: expression of type '[Any]' is unused\n    var stack []rune\n              ^~\n/tmp/tmp5jsylyzy.swift:16:17: error: cannot find 'rune' in scope\n    var stack []rune\n                ^~~~\n/tmp/tmp5jsylyzy.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp34p6xjl9.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp34p6xjl9.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp7l0c4fuw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp7l0c4fuw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp7l0c4fuw.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp7l0c4fuw.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp7l0c4fuw.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp7l0c4fuw.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp7l0c4fuw.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp7l0c4fuw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp7l0c4fuw.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp6rqf_tel.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp6rqf_tel.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp6rqf_tel.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp6rqf_tel.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6rqf_tel.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6rqf_tel.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp6rqf_tel.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp6rqf_tel.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp6rqf_tel.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpzqid_pih.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpzqid_pih.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpzqid_pih.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpzqid_pih.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpzqid_pih.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpzqid_pih.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmpzqid_pih.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpzqid_pih.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpzqid_pih.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpzqid_pih.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpzqid_pih.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpx0xmatl_.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpx0xmatl_.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpx0xmatl_.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpx0xmatl_.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpx0xmatl_.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpx0xmatl_.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmpx0xmatl_.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpx0xmatl_.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpx0xmatl_.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpx0xmatl_.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpx0xmatl_.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp6rqf_tel.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp6rqf_tel.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp6rqf_tel.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp6rqf_tel.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6rqf_tel.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6rqf_tel.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp6rqf_tel.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp6rqf_tel.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp6rqf_tel.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp419aoy25.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp419aoy25.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp419aoy25.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp419aoy25.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp419aoy25.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmp419aoy25.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    \n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpj80_scpc.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpj80_scpc.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpj80_scpc.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpj80_scpc.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpj80_scpc.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpj80_scpc.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpj80_scpc.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpj80_scpc.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpj80_scpc.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpj80_scpc.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpj80_scpc.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpj80_scpc.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqv9aa4sf.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpqv9aa4sf.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpqv9aa4sf.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpqv9aa4sf.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqv9aa4sf.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqv9aa4sf.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpqv9aa4sf.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpqv9aa4sf.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpqv9aa4sf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpe0y2gygu.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpe0y2gygu.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpe0y2gygu.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpe0y2gygu.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqv9aa4sf.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpqv9aa4sf.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpqv9aa4sf.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpqv9aa4sf.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqv9aa4sf.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqv9aa4sf.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpqv9aa4sf.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpqv9aa4sf.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpqv9aa4sf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_len int\n    var closing_bracket_stack_index_stack_len int\n    var opening_bracket_stack_index_stack_len int\n    var closing_bracket_stack_index_stack_len int\n    var opening_bracket_stack_index_stack_len_max int\n    var closing_bracket_stack_index_stack_len_max int\n    var opening_bracket_stack_index_stack_len_max int\n    var closing_bracket_stack_index_stack_len_max int\n    var opening_bracket_stack_index_stack_len_max_max int\n    var closing_bracket_stack_index_stack_len_max_max int\n    var opening_bracket_stack_index_stack_len_max_max_max int\n    var closing_bracket_stack_index_stack_len_max_max_max int\n    var opening_bracket_stack_index_stack_len_max_max_max_max int\n    var closing_bracket_stack_index_stack_len_max_max_max_max int\n    var opening_bracket_stack_index_stack_len_max_max_max_max_max int\n    var closing_bracket_stack_index_stack_len_max_max_max_max_max int\n    var opening_bracket_stack_index_stack_len_max_max_max_max_max_max int\n    var closing_bracket_stack_index_stack_len_max_max_max_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp24ihdwsk.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp24ihdwsk.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp24ihdwsk.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp24ihdwsk.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp24ihdwsk.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp24ihdwsk.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp24ihdwsk.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp24ihdwsk.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp24ihdwsk.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp24ihdwsk.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp24ihdwsk.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp24ihdwsk.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count++\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp4avc1n8i.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp4avc1n8i.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp4avc1n8i.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp4avc1n8i.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp4avc1n8i.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp4avc1n8i.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp4avc1n8i.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp4avc1n8i.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp4avc1n8i.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp4avc1n8i.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp4avc1n8i.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp4avc1n8i.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_brackets += 1\n        } else if brackets[i] == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp5w27vy4_.swift:15:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp5w27vy4_.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp5w27vy4_.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp5w27vy4_.swift:16:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp5w27vy4_.swift:18:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp4j4_0uxi.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp4j4_0uxi.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp4j4_0uxi.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp4j4_0uxi.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp4j4_0uxi.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp4j4_0uxi.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmp4j4_0uxi.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmp4j4_0uxi.swift:24:29: error: expected ',' separator\n            stack = stack[0 : len(stack) - 1]\n                            ^\n                           ,\n/tmp/tmp4j4_0uxi.swift:24:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack) - 1]\n                            ^\n/tmp/tmp4j4_0uxi.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp4j4_0uxi.swift:27:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp4j4_0uxi.swift:27:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := range brackets {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := len(opening_bracket_index_stack) - 1; i >= 0; i -= 1 {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqeze2y7d.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpqeze2y7d.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpqeze2y7d.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpqeze2y7d.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpqeze2y7d.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpqeze2y7d.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpqeze2y7d.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpqeze2y7d.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpqeze2y7d.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpqeze2y7d.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpqeze2y7d.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpqeze2y7d.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpkvs2hekb.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpkvs2hekb.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpkvs2hekb.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpkvs2hekb.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpkvs2hekb.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpkvs2hekb.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpkvs2hekb.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpkvs2hekb.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpkvs2hekb.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpkvs2hekb.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count++\n        } else if brackets[i] == ')' {\n            closing_bracket_count++\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            if i == 0 || brackets[i-1] != ')' {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpaqnbj43k.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpaqnbj43k.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpaqnbj43k.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpaqnbj43k.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpaqnbj43k.swift:17:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpaqnbj43k.swift:17:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpaqnbj43k.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpaqnbj43k.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpaqnbj43k.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpaqnbj43k.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpaqnbj43k.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpaqnbj43k.swift:28:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpaqnbj43k.swift:28:12: error: expected 'in' after for-each patte",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count++\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    \n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmptccxs371.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmptccxs371.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmptccxs371.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmptccxs371.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmptccxs371.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmptccxs371.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmptccxs371.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmptccxs371.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmptccxs371.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmptccxs371.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmptccxs371.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmptccxs371.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_len int\n    var closing_bracket_index_set_len int\n    var opening_bracket_index_set_len_max int\n    var opening_bracket_index_set_len_min int\n    var opening_bracket_index_set_len_sum int\n    var opening_bracket_index_set_len_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpywi2a_zw.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpywi2a_zw.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpywi2a_zw.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpywi2a_zw.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpywi2a_zw.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpywi2a_zw.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpywi2a_zw.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpywi2a_zw.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpywi2a_zw.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpywi2a_zw.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpywi2a_zw.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpywi2a_zw.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack:=[]int{}\n    for i:=0; i<len(brackets); i++ {\n        if brackets[i] == '(' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            \n            if brackets[i] != ')' {\n                return false\n            }\n            \n            j:=stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            \n            if i-j != 1 {\n                return false\n            }\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpcwxo05up.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{}\n         ^\n         ;\n/tmp/tmpcwxo05up.swift:17:10: error: expected expression\n    stack:=[]int{}\n         ^\n/tmp/tmpcwxo05up.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{}\n          ^\n            \n/tmp/tmpcwxo05up.swift:18:11: error: '=' must have consistent whitespace on both sides\n    for i:=0; i<len(brackets); i++ {\n          ^\n            \n/tmp/tmpcwxo05up.swift:18:11: error: expected type\n    for i:=0; i<len(brackets); i++ {\n          ^\n           <#type#>\n/tmp/tmpcwxo05up.swift:18:11: error: expected 'in' after for-each pattern\n    for i:=0; i<len(brackets); i++ {\n          ^\n/tmp/tmpcwxo05up.swift:18:11: error: expected Sequence expression for for-each loop\n    for i:=0; i<len(brackets); i++ {\n          ^\n/tmp/tmpcwxo05up.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpcwxo05up.swift:26:31: error: single-quoted string literal found, use '\"'\n            if brackets[i] != ')' {\n                              ^~~\n                              \")\"\n/tmp/tmpcwxo05up.swift:30:14: error: consecutive statements on a line must be separated by ';'\n            j:=stack[len(stack)-1]\n             ^\n             ;\n/tmp/tmpcwxo05up.swift:30:14: error: expected expression\n            j:=stack[len(stack)-1]\n             ^\n/tmp/tmpcwxo05up.swift:30:15: error: '=' must have consistent whitespace on both sides\n            j:=stack[len(stack)-1]\n              ^\n                \n/tmp/tmpcwxo05up.swift:17:5: error: cannot find 'stack' in scope\n    stack:=[]int{}\n    ^~~~~\n/tmp/tmpcwxo05up.swift:39:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpcwxo05up.swift:39:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqqtezrhn.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpqqtezrhn.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpqqtezrhn.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpqqtezrhn.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpqqtezrhn.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpqqtezrhn.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmpqqtezrhn.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpqqtezrhn.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpqqtezrhn.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpqqtezrhn.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpqqtezrhn.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpscl9614b.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpscl9614b.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpscl9614b.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpscl9614b.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpscl9614b.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpscl9614b.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpscl9614b.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpscl9614b.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpscl9614b.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpscl9614b.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp419aoy25.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp419aoy25.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp419aoy25.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp419aoy25.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp419aoy25.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp419aoy25.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp419aoy25.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp419aoy25.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmp419aoy25.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_length int\n    var closing_bracket_index_set_length int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp9isoge2i.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp9isoge2i.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp9isoge2i.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp9isoge2i.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp9isoge2i.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp9isoge2i.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp9isoge2i.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp9isoge2i.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp9isoge2i.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp9isoge2i.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp9isoge2i.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp9isoge2i.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n        } else if char == ')' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqdm9kh9j.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpqdm9kh9j.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpqdm9kh9j.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpqdm9kh9j.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_copy []int\n    var opening_bracket_index_set_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpjsj8lnz9.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpjsj8lnz9.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpjsj8lnz9.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpjsj8lnz9.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpjsj8lnz9.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpjsj8lnz9.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpjsj8lnz9.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpjsj8lnz9.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpjsj8lnz9.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpjsj8lnz9.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpjsj8lnz9.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpjsj8lnz9.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '(' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if r == stack[len(stack) - 1] {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) == 0 {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp4h4g1s1v.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp4h4g1s1v.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp4h4g1s1v.swift:17:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmp4h4g1s1v.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmp4h4g1s1v.swift:18:17: error: single-quoted string literal found, use '\"'\n        if r == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp4h4g1s1v.swift:25:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmp4h4g1s1v.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp4h4g1s1v.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) == 0 {\n       ^~~\n/tmp/tmp4h4g1s1v.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) == 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpstqcqd4e.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpstqcqd4e.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpstqcqd4e.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpstqcqd4e.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpstqcqd4e.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpstqcqd4e.swift:20:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpstqcqd4e.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpstqcqd4e.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpstqcqd4e.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    \n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpj80_scpc.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpj80_scpc.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpj80_scpc.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpj80_scpc.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpj80_scpc.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpj80_scpc.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpj80_scpc.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpj80_scpc.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpj80_scpc.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpj80_scpc.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpj80_scpc.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpj80_scpc.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_in_brackets int\n    var closing_bracket_index_in_brackets int\n    var opening_bracket_index_in_brackets_in_string int\n    var closing_bracket_index_in_brackets_in_string int\n    var opening_bracket_index_in_string int\n    var closing_bracket_index_in_string int\n    var opening_bracket_char_in_string string\n    var closing_bracket_char_in_string string\n    var opening_bracket_index_in_string_in_brackets int\n    var closing_bracket_index_in_string_in_brackets int\n    var opening_bracket_index_in_string_in_string int\n    var closing_bracket_index_in_string_in_string int\n    var opening_bracket_char_in_string_in_brackets string\n    var closing_bracket_char_in_string_in_brackets string\n    var opening_bracket_char_in_string_in_string string\n    var closing_bracket_char_in_string_in_string string\n    var opening_bracket_index_in_string_in_string_in_brackets int\n    var closing_bracket_index_in_string_in_string_in_brackets int\n    var opening_bracket_index_in_string_in_string_in_string int\n    var closing_bracket_index_in_string_in_string_in_string int\n    var opening_bracket_char_in_string_in_string_in_brackets_in_string string\n    var closing_bracket_char_in_string_in_string_in_brackets_in_string string\n    var opening_bracket_char_in_string_in_string_in_string_in_brackets string\n    var closing_bracket_char_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpzdv1iky5.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpzdv1iky5.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpzdv1iky5.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpzdv1iky5.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpzdv1iky5.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpzdv1iky5.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpzdv1iky5.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpzdv1iky5.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpzdv1iky5.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpzdv1iky5.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpzdv1iky5.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpzdv1iky5.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpn36ofaou.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpn36ofaou.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpn36ofaou.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpn36ofaou.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpn36ofaou.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpn36ofaou.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpn36ofaou.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpn36ofaou.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpn36ofaou.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmphbmvbx39.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmphbmvbx39.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmphbmvbx39.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmphbmvbx39.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmphbmvbx39.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmphbmvbx39.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmphbmvbx39.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmphbmvbx39.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmphbmvbx39.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmphbmvbx39.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp1swsh32b.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp1swsh32b.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp1swsh32b.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp1swsh32b.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp1swsh32b.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp1swsh32b.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmp1swsh32b.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmp1swsh32b.swift:24:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp1swsh32b.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp1swsh32b.swift:27:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp1swsh32b.swift:27:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpgduxgnpg.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpgduxgnpg.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpgduxgnpg.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpgduxgnpg.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpgduxgnpg.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpgduxgnpg.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmpgduxgnpg.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpgduxgnpg.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpgduxgnpg.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpgduxgnpg.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmplt64m8lj.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmplt64m8lj.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmplt64m8lj.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmplt64m8lj.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmplt64m8lj.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmplt64m8lj.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmplt64m8lj.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmplt64m8lj.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmplt64m8lj.swift:32:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmplt64m8lj.swift:32:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index_stack = append(opening_bracket_index_stack, i)\n        } else if char == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index_stack = append(closing_bracket_index_stack, i)\n        }\n    }\n    opening_bracket_index = len(opening_bracket_index_stack) - 1\n    closing_bracket_index = len(closing_bracket_index_stack) - 1\n    for opening_bracket_index >= 0 {\n        opening_bracket_index_stack[opening_bracket_index] -= 1\n        opening_bracket_index -= 1\n        if opening_bracket_index_stack[opening_bracket_index] < 0 {\n            opening_bracket_count -= 1\n            opening_bracket_index += 1\n        }\n    }\n    for closing_bracket_index >= 0 {\n        closing_bracket_index_stack[closing_bracket_index] -= 1\n        closing_bracket_index -= 1\n        if closing_bracket_index_stack[closing_bracket_index] < 0 {\n            closing_bracket_count -= 1\n            closing_bracket_index += 1\n        }\n    }\n    return opening_bracket_count == 0 && closing_bracket_count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpywaip5hr.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpywaip5hr.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpywaip5hr.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpywaip5hr.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpywaip5hr.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpywaip5hr.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpywaip5hr.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpywaip5hr.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpywaip5hr.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpywaip5hr.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpywaip5hr.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpywaip5hr.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        }\n        if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp85h66kbs.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp85h66kbs.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp85h66kbs.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp85h66kbs.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp85h66kbs.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp85h66kbs.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp85h66kbs.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp85h66kbs.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp85h66kbs.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, char)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp5c8estwd.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp5c8estwd.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp5c8estwd.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp5c8estwd.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp5c8estwd.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp5c8estwd.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmp5c8estwd.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp5c8estwd.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp5c8estwd.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp5c8estwd.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for index, char := range brackets {\n        if char == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = index\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if char == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = index\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    for _, opening_bracket_index := range opening_bracket_index_stack {\n        opening_bracket_count = opening_bracket_stack[opening_bracket_index]\n        for opening_bracket_count > 0 {\n            opening_bracket_count -= 1\n            closing_bracket_index = opening_bracket_index_stack[opening_bracket_index]\n            closing_bracket_count = closing_bracket_stack[closing_bracket_index]\n            if closing_bracket_count > 0 {\n                opening_bracket_index = closing_bracket_index_stack[closing_bracket_index]\n                opening_bracket_count = opening_bracket_stack[opening_bracket_index]\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpqmu5g8_e.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpqmu5g8_e.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpqmu5g8_e.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpqmu5g8_e.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpqmu5g8_e.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpqmu5g8_e.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpqmu5g8_e.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpqmu5g8_e.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpqmu5g8_e.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpqmu5g8_e.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpqmu5g8_e.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpqmu5g8_e.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp2t7gm2k9.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp2t7gm2k9.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp2t7gm2k9.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp2t7gm2k9.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp2t7gm2k9.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp2t7gm2k9.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmp2t7gm2k9.swift:27:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp2t7gm2k9.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp2t7gm2k9.swift:30:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp2t7gm2k9.swift:30:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var open_brackets int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets++\n        } else if brackets[i] == ')' {\n            open_brackets--\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp5v6coqou.swift:16:23: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var open_brackets int\n                      ^\n/tmp/tmp5v6coqou.swift:16:23: note: join the identifiers together\n    var open_brackets int\n        ~~~~~~~~~~~~~~^~~\n        open_bracketsint\n/tmp/tmp5v6coqou.swift:16:23: note: join the identifiers together with camel-case\n    var open_brackets int\n        ~~~~~~~~~~~~~~^~~\n        open_bracketsInt\n/tmp/tmp5v6coqou.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp5v6coqou.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp5v6coqou.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp5v6coqou.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp5v6coqou.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp5v6coqou.swift:16:9: error: type annotation missing in pattern\n    var open_brackets int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := make([]rune, 0)\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, '(')\n        } else if char == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp9b9jhwr6.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := make([]rune, 0)\n         ^\n         ;\n/tmp/tmp9b9jhwr6.swift:16:11: error: expected expression\n    stack := make([]rune, 0)\n          ^\n/tmp/tmp9b9jhwr6.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp9b9jhwr6.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp9b9jhwr6.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp9b9jhwr6.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmp9b9jhwr6.swift:20:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp9b9jhwr6.swift:24:29: error: expected ',' separator\n            stack = stack[0 : len(stack)-1]\n                            ^\n                           ,\n/tmp/tmp9b9jhwr6.swift:24:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack)-1]\n                            ^\n/tmp/tmp9b9jhwr6.swift:16:5: error: cannot find 'stack' in scope\n    stack := make([]rune, 0)\n    ^~~~~\n/tmp/tmp9b9jhwr6.swift:27:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp9b9jhwr6.swift:27:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, char := range brackets {\n        if char == '(' {\n            opening_brackets += 1\n        } else if char == ')' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp34p6xjl9.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp34p6xjl9.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp34p6xjl9.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := range brackets {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := len(opening_bracket_index_stack) - 1; i >= 0; i -= 1 {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpqeze2y7d.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpqeze2y7d.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpqeze2y7d.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpqeze2y7d.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpqeze2y7d.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpqeze2y7d.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpqeze2y7d.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpqeze2y7d.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpqeze2y7d.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpqeze2y7d.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpqeze2y7d.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpqeze2y7d.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3ya3kufi.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3ya3kufi.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3ya3kufi.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp3ya3kufi.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp3ya3kufi.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmp3ya3kufi.swift:20:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmp3ya3kufi.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3ya3kufi.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, char)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmptlj3ukw6.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmptlj3ukw6.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmptlj3ukw6.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmptlj3ukw6.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmptlj3ukw6.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmptlj3ukw6.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmptlj3ukw6.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmptlj3ukw6.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmptlj3ukw6.swift:31:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmptlj3ukw6.swift:31:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    opening_brackets := make([]int, 0)\n    closing_brackets := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            opening_brackets = append(opening_brackets, i)\n        } else if brackets[i] == ')' {\n            closing_brackets = append(closing_brackets, i)\n        }\n    }\n    if len(opening_brackets) != len(closing_brackets) {\n        return false\n    }\n    for i := 0; i < len(opening_brackets); i++ {\n        if opening_brackets[i] > closing_brackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpsgs0pz1u.swift:16:21: error: consecutive statements on a line must be separated by ';'\n    opening_brackets := make([]int, 0)\n                    ^\n                    ;\n/tmp/tmpsgs0pz1u.swift:16:22: error: expected expression\n    opening_brackets := make([]int, 0)\n                     ^\n/tmp/tmpsgs0pz1u.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpsgs0pz1u.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpsgs0pz1u.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpsgs0pz1u.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpsgs0pz1u.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpsgs0pz1u.swift:28:12: error: expected type\n    for i := 0; i < len(opening_brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpsgs0pz1u.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(opening_brackets); i++ {\n           ^\n/tmp/tmpsgs0pz1u.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(opening_brackets); i++ {\n           ^\n/tmp/tmpsgs0pz1u.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpsgs0pz1u.swift:16:5: error: cannot find 'opening_brackets' in scope\n    opening_brackets := make([]int, 0)\n    ^~~~~~~~~~~~~~~~\n/tmp/tmpsgs0pz1u.swift:25:8: error: cannot find 'len' in scope\n    if len(opening_brackets) != len(closing_brackets) {\n       ^~~\n/tmp/tmpsgs0pz1u.swift:25:12: error: cannot find 'opening_brackets' in scope\n    if len(opening_brackets) != len(closing_brackets) {\n           ^~~~~~~~~~~~~~~~\n/tmp/tmpsgs0pz1u.swift:25:33: error: cannot fin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        }\n        if brackets[i] == ')' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmplu9p2ub1.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmplu9p2ub1.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmplu9p2ub1.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmplu9p2ub1.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmplu9p2ub1.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmplu9p2ub1.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmplu9p2ub1.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpecplsbjl.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpecplsbjl.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpecplsbjl.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpecplsbjl.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpecplsbjl.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpecplsbjl.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpecplsbjl.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpecplsbjl.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpecplsbjl.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpecplsbjl.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpecplsbjl.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpecplsbjl.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            open_brackets += 1\n        } else if char == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbf9y_bf0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbf9y_bf0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpbf9y_bf0.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpbf9y_bf0.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpbf9y_bf0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbf9y_bf0.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_set bool\n    var closing_bracket_index_set bool\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_char_stack []string\n    var closing_bracket_char_stack []string\n    var opening_bracket_count_stack []int\n    var closing_bracket_count_stack []int\n    var opening_bracket_index_stack_copy []int\n    var closing_bracket_index_stack_copy []int\n    var opening_bracket_char_stack_copy []string\n    var closing_bracket_char_stack_copy []string\n    var opening_bracket_count_stack_copy []int\n    var closing_bracket_count_stack_copy []int\n    for i := range brackets {\n        if brackets[i] == '(' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_set = true\n            opening_bracket_count_stack = append(opening_bracket_count_stack, opening_bracket_count)\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_char_stack = append(opening_bracket_char_stack, brackets[opening_bracket_index])\n        } else if brackets[i] == ')' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_set = true\n            closing_bracket_count_stack = append(closing_bracket_count_stack, closing_bracket_count)\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_char_stack\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpun25sf2w.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpun25sf2w.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpun25sf2w.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpun25sf2w.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpun25sf2w.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpun25sf2w.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpun25sf2w.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpun25sf2w.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpun25sf2w.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpun25sf2w.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpun25sf2w.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpun25sf2w.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_set []int\n    var closing_bracket_set []int\n    var opening_bracket_index_set_copy []int\n    var closing_bracket_index_set_copy []int\n    var opening_bracket_set_copy []int\n    var closing_bracket_set_copy []int\n    var opening_bracket_index_set_copy_copy []int\n    var closing_bracket_index_set_copy_copy []int\n    var opening_bracket_set_copy_copy []int\n    var closing_bracket_set_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy []int\n    var closing_bracket_index_set_copy_copy_copy []int\n    var opening_bracket_set_copy_copy_copy []int\n    var closing_bracket_set_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy []int\n    var closing_bracket_index_set_copy_copy_copy_copy []int\n    var opening_bracket_set_copy_copy_copy_copy []int\n    var closing_bracket_set_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy []int\n    var closing_bracket_index_set_copy_copy_copy_copy_copy []int\n    var opening_bracket_set_copy_copy_copy_copy_copy []int\n    var closing_bracket_set_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy []int\n    var closing_bracket_index_set_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_set_copy_copy_copy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpzxvmc3nb.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpzxvmc3nb.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpzxvmc3nb.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpzxvmc3nb.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpzxvmc3nb.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpzxvmc3nb.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpzxvmc3nb.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpzxvmc3nb.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpzxvmc3nb.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpzxvmc3nb.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpzxvmc3nb.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpzxvmc3nb.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpzqid_pih.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpzqid_pih.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpzqid_pih.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpzqid_pih.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpzqid_pih.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpzqid_pih.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmpzqid_pih.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpzqid_pih.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpzqid_pih.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpzqid_pih.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpzqid_pih.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_length int\n    var opening_bracket_index_set_length_max int\n    var opening_bracket_index_set_length_min int\n    var opening_bracket_index_set_length_sum int\n    var opening_bracket_index_set_length_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_length_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpuel49fv9.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpuel49fv9.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpuel49fv9.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpuel49fv9.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpuel49fv9.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpuel49fv9.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpuel49fv9.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpuel49fv9.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpuel49fv9.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpuel49fv9.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpuel49fv9.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpuel49fv9.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpoz9yzat9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpoz9yzat9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpoz9yzat9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpoz9yzat9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpoz9yzat9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmpoz9yzat9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpoz9yzat9.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpbzvbvz9a.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbzvbvz9a.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbzvbvz9a.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpbzvbvz9a.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpbzvbvz9a.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpbzvbvz9a.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpbzvbvz9a.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpbzvbvz9a.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbzvbvz9a.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpq4s1_ajg.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpq4s1_ajg.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpq4s1_ajg.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpq4s1_ajg.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpq4s1_ajg.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpq4s1_ajg.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpq4s1_ajg.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpq4s1_ajg.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpq4s1_ajg.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpq4s1_ajg.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '(' {\n            opening_bracket_count++\n        } else if char == ')' {\n            closing_bracket_count++\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmpvgfipjj0.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpvgfipjj0.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpvgfipjj0.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpvgfipjj0.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpvgfipjj0.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpvgfipjj0.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpvgfipjj0.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpvgfipjj0.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpvgfipjj0.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmpvgfipjj0.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == ')' {\n                          ^~~\n                          \")\"\n/tmp/tmpvgfipjj0.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmpvgfipjj0.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '(' {\n            stack = append(stack, char)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '(' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmprri0cx5d.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmprri0cx5d.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmprri0cx5d.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmprri0cx5d.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmprri0cx5d.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '(' {\n                   ^~~\n                   \"(\"\n/tmp/tmprri0cx5d.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '(' {\n                                        ^~~\n                                        \"(\"\n/tmp/tmprri0cx5d.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmprri0cx5d.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmprri0cx5d.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmprri0cx5d.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmps2umr9zw.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmps2umr9zw.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmps2umr9zw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmps2umr9zw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmps2umr9zw.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmps2umr9zw.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, '(')\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp6cz6mmlv.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp6cz6mmlv.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp6cz6mmlv.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp6cz6mmlv.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp6cz6mmlv.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmp6cz6mmlv.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '(')\n                                  ^~~\n                                  \"(\"\n/tmp/tmp6cz6mmlv.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmp6cz6mmlv.swift:24:29: error: expected ',' separator\n            stack = stack[0 : len(stack)-1]\n                            ^\n                           ,\n/tmp/tmp6cz6mmlv.swift:24:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack)-1]\n                            ^\n/tmp/tmp6cz6mmlv.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp6cz6mmlv.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp6cz6mmlv.swift:27:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp6cz6mmlv.swift:27:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack:=make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            stack = append(stack, i)\n        } else if brackets[i] == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292461,
      "stdout": "",
      "stderr": "/tmp/tmp3266ja_1.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack:=make([]int, 0)\n         ^\n         ;\n/tmp/tmp3266ja_1.swift:16:10: error: expected expression\n    stack:=make([]int, 0)\n         ^\n/tmp/tmp3266ja_1.swift:16:11: error: '=' must have consistent whitespace on both sides\n    stack:=make([]int, 0)\n          ^\n            \n/tmp/tmp3266ja_1.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3266ja_1.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3266ja_1.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3266ja_1.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3266ja_1.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3266ja_1.swift:24:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp3266ja_1.swift:16:5: error: cannot find 'stack' in scope\n    stack:=make([]int, 0)\n    ^~~~~\n/tmp/tmp3266ja_1.swift:27:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp3266ja_1.swift:27:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets += 1\n        } else if c == ')' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpc0pvc2oh.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpc0pvc2oh.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc0pvc2oh.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n/tmp/tmpc0pvc2oh.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == ')' {\n                       ^~~\n                       \")\"\n/tmp/tmpc0pvc2oh.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpc0pvc2oh.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            open_brackets += 1\n        } else if brackets[i] == ')' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmp3e69bb8l.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp3e69bb8l.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3e69bb8l.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3e69bb8l.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmp3e69bb8l.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == ')' {\n                                 ^~~\n                                 \")\"\n/tmp/tmp3e69bb8l.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp3e69bb8l.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpaz3ilthm.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpaz3ilthm.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpaz3ilthm.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpaz3ilthm.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpaz3ilthm.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpaz3ilthm.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpaz3ilthm.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpaz3ilthm.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpaz3ilthm.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpaz3ilthm.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpaz3ilthm.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpaz3ilthm.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n/// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets: \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_len int\n    var closing_bracket_index_set_len int\n    var opening_bracket_index_set_len_max int\n    var opening_bracket_index_set_len_min int\n    var opening_bracket_index_set_len_sum int\n    var opening_bracket_index_set_len_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum_square_sum_square_sum_square_sum_square_sum int\n    var opening_bracket_index_set_len_sum_square_sum_square_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
      "timestamp": 1664292460,
      "stdout": "",
      "stderr": "/tmp/tmpywi2a_zw.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpywi2a_zw.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpywi2a_zw.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpywi2a_zw.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpywi2a_zw.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpywi2a_zw.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpywi2a_zw.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpywi2a_zw.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpywi2a_zw.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpywi2a_zw.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpywi2a_zw.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpywi2a_zw.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}