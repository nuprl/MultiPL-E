language: jl
name: HumanEval_58_common
results:
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp_wvqbb9t.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp_wvqbb9t.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp_wvqbb9t.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_wvqbb9t.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_wvqbb9t.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp_wvqbb9t.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp_wvqbb9t.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the number of times each element appears in two\
    \ lists.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprwuu7c_6.jl:22\nin expression starting at\
    \ /tmp/tmprwuu7c_6.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpixbj9oko.jl:20\nin expression starting at\
    \ /tmp/tmpixbj9oko.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkgufnxeb.jl:22\nin expression starting at\
    \ /tmp/tmpkgufnxeb.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n            else\n                common = Set([a] ++ common)\n\
    \        end\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8v2bfgm2.jl:23\nin expression starting at\
    \ /tmp/tmp8v2bfgm2.jl:23\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqkcoymig.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpqkcoymig.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ ++ not "
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \u222A l2\n        push!(common, el)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpz8tl7a52.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpz8tl7a52.jl:23\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpz8tl7a52.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz8tl7a52.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz8tl7a52.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpz8tl7a52.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpz8tl7a52.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp_wvqbb9t.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp_wvqbb9t.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp_wvqbb9t.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_wvqbb9t.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_wvqbb9t.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp_wvqbb9t.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp_wvqbb9t.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        push!(common, i)\n    end\n    \n    for i in l2\n        push!(common,\
    \ i)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpfrfocur6.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpfrfocur6.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpfrfocur6.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfrfocur6.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfrfocur6.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpfrfocur6.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpfrfocur6.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n\
    \    end\n    common = Set()\n    for x in l1 do \n        common.add(x)\n   \
    \ end\n    for x in l2 do \n        common.add(x)\n    end\n    common = Set()\n\
    \    for x in l1 do \n        common.add(x)\n    end\n    for x in l2 do \n  \
    \      common.add(x)\n    end\n    common = Set()\n    for x in l1 do \n     \
    \   common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n    end\n\
    \    common = Set()\n    for x in l1 do \n        common.add(x)\n    end\n   \
    \ for x in l2 do \n        common.add(x)\n    end\n    common = Set()\n    for\
    \ x in l1 do \n        common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n\
    \    end\n    common = Set()\n    for x in l1 do \n        common.add(x)\n   \
    \ end\n    for x in l2 do \n        common.add(x)\n    end\n    common = Set()\n\
    \    for x in l1 do \n        common.add(x)\n    end\n    for x in l2 do \n  \
    \      common.add(x)\n    end\n    common = Set()\n    for x in l1 do \n     \
    \   common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n    end\n\
    \    common = Set()\n    for x in l1 do \n        common.add(x)\n    end\n   \
    \ for x in l2 do \n        common.add(x)\n    end\n    common = Set()\n    for\
    \ x in l1 do \n        common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n\
    \    end\n    common = Set()\n    for x in l1 do \n        common.add(x)\n   \
    \ end\n    for x in l2 do \n        common.add(x)\n    end\n    common = Set()\n\
    \    for x in l1 do \n        common.add(x)\n    end\n    for x in l2 do \n  \
    \      common.add(x)\n    end\n    common = Set()\n    for x in l1 do \n     \
    \   common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n    end\n\
    \    common = Set()\n    for x in l1 do \n        common.add(x)\n    end\n   \
    \ for x in l2 do \n        common.add(x)\n    end\n    common = Set()\n    for\
    \ x in l1 do \n        common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n\
    \nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnh9_45pp.jl:11\nin expression starting at /tmp/tmpnh9_45pp.jl:11\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common.add(x)\n    end\n    for x in l2 do \n        common.add(x)\n\
    \    end\n    common = Set([x for x in common if x != 0])\n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqttiwc6k.jl:11\nin expression starting at /tmp/tmpqttiwc6k.jl:11\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 do \n        if !contains(common, el) \n            common = Set([el])\n\
    \        end\n    end\n    \n    for el in l2 do \n        if !contains(common,\
    \ el) \n            common = Set([el])\n        end\n    end\n    \n    return\
    \ common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkrso2qrs.jl:12\nin expression starting at /tmp/tmpkrso2qrs.jl:12\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxo03vj85.jl:20\nin expression starting at\
    \ /tmp/tmpxo03vj85.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el1 in l1\n        for el2 in l2\n            if el1 == el2\n              \
    \  common = Set([el1])\n            else\n                common = Set([el1])\
    \ \u222A common\n            end\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp5sxackpj.jl:29\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Int64}
    to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmp5sxackpj.jl:22\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5sxackpj.jl:29 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5sxackpj.jl:28\ntest set: Error
    During Test at /tmp/tmp5sxackpj.jl:30\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type
    Set{Int64} to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmp5sxackpj.jl:22\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te'
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in l2\n            common.add(x)\n        end\n    end\n\
    \    \n    return common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpukpe35zp.jl:20\nin expression starting at\
    \ /tmp/tmpukpe35zp.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = Set([x] ++ common)\n    end\n    for x in l2 do \n   \
    \     common = Set([x] ++ common)\n    end\n    common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpadkmpd7x.jl:11\nin expression starting at /tmp/tmpadkmpd7x.jl:11\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6az__a88.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp6az__a88.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp6az__a88.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest s"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for el in\
    \ l1 \u222A l2\n        if !contains(common, el)\n            common = Set([el])\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpcnnvnxbs.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpcnnvnxbs.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching contains(::Set{Any}, ::Int64)\n\
    \  Closest candidates are:\n    contains(!Matched::AbstractString, ::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:100\n\
    \    contains(::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:161\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpcnnvnxbs.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcnnvnxbs.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcnnvnxbs.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpcnnvnxbs.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ contains(::Set{Any}, ::Int64)\n  Closest candidates are:\n    contains(!Matched::AbstractString,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:100\n    contains(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:161\n  Stacktrace:\n\
    \   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpcnnvnxbs.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcnnvnxbs.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcnnvnxbs.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpcnnvnxbs.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching\
    \ contains(::Set{Any}, ::Int64)\n  Closest candidates are:\n    contains(!Matched::AbstractString,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/b"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpplns8ly1.jl:20\nin expression starting at\
    \ /tmp/tmpplns8ly1.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n@time common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\nWrite a function\
    \ that returns the number of common elements in two vectors.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpauyfx457.jl:19\nin expression starting at\
    \ /tmp/tmpauyfx457.jl:19\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 do \n        common = Set([el]) | common\n    end\n    \n    for el\
    \ in l2 do \n        common = Set([el]) | common\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpixcmvfo_.jl:12\nin expression starting at /tmp/tmpixcmvfo_.jl:12\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpixbj9oko.jl:20\nin expression starting at\
    \ /tmp/tmpixbj9oko.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the number of times each element appears in two\
    \ given lists.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptqq2nn4x.jl:20\nin expression starting at\
    \ /tmp/tmptqq2nn4x.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\n\
    Write a function that returns the common elements in two lists.\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbr9n8g8h.jl:20\nin expression starting at\
    \ /tmp/tmpbr9n8g8h.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzse4rn2d.jl:20\nin expression starting at\
    \ /tmp/tmpzse4rn2d.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        push!(common, x)\n    end\n    for x in l2 do \n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in either list. For example,\
    \ `common([1,4,3,34,653,2,5], [5,7,1,5,9,653,121])` returns `[5, 653]` instead\
    \ of `[1, 5, 653]`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I fixed\
    \ the code. Now it works.\n<|/ c |>\n<| a tags=julia,set |>\nI like to use Sets.jl\
    \ for these kinds of problems:\n<code>\njulia> using Sets\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp13nfr9qs.jl:11\nin expression starting at /tmp/tmp13nfr9qs.jl:11\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<text>\nThe function above returns\
    \ a set containing the unique common elements. We can now use the function above\
    \ to find the common elements in two lists.\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfe6tpmgp.jl:22\nin expression starting at\
    \ /tmp/tmpfe6tpmgp.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common = Set([a])\n\
    \                break\n            else\n                common = Set([a]) &\
    \ common\n        end\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaox8kq8i.jl:22\nin expression starting at\
    \ /tmp/tmpaox8kq8i.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo87j7heb.jl:20\nin expression starting at\
    \ /tmp/tmpo87j7heb.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        push!(common, x)\n    end\n    \n    for x in l2 do \n\
    \        push!(common, x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the number of unique elements in a given list.\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpo53cjtgk.jl:12\nin expression starting at /tmp/tmpo53cjtgk.jl:12\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptii_b_rn.jl:20\nin expression starting at\
    \ /tmp/tmptii_b_rn.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6az__a88.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp6az__a88.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp6az__a88.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest s"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp0i68fe.jl:22\nin expression starting at\
    \ /tmp/tmpjp0i68fe.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([x\
    \ for x in l1 if x in l2])\n    common = Set([x for x in l2 if x in l1])\n   \
    \ common = Set([x for x in l1 if x in common])\n    common = Set([x for x in l2\
    \ if x in common])\n    common = Set([x for x in l1 if x in common])\n    common\
    \ = Set([x for x in l2 if x in common])\n    common = Set([x for x in l1 if x\
    \ in common])\n    common = Set([x for x in l2 if x in common])\n    common =\
    \ Set([x for x in l1 if x in common])\n    common = Set([x for x in l2 if x in\
    \ common])\n    common = Set([x for x in l1 if x in common])\n    common = Set([x\
    \ for x in l2 if x in common])\n    common = Set([x for x in l1 if x in common])\n\
    \    common = Set([x for x in l2 if x in common])\n    common = Set([x for x in\
    \ l1 if x in common])\n    common = Set([x for x in l2 if x in common])\n    common\
    \ = Set([x for x in l1 if x in common])\n    common = Set([x for x in l2 if x\
    \ in common])\n    common = Set([x for x in l1 if x in common])\n    common =\
    \ Set([x for x in l2 if x in common])\n    common = Set([x for x in l1 if x in\
    \ common])\n    common = Set([x for x in l2 if x in common])\n    common = Set([x\
    \ for x in l1 if x in common])\n    common = Set([x for x in l2 if x in common])\n\
    \    common = Set([x for x in l1 if x in common])\n    common = Set([x for x in\
    \ l2 if x in common])\n    common = Set([x for x in l1 if x in common])\n    common\
    \ = Set([x for x in l2 if x in common])\n    common = Set([x for x in l1 if x\
    \ in common])\n    common = Set([x for x in l2 if x in common])\n    common =\
    \ Set([x for x in l1 if x in common])\n    common = Set([x for x in l2 if x in\
    \ common])\n    common = Set([x for x in l1 if x in common])\n    common = Set([x\
    \ for x in l2 if x in common])\n    common = Set([x for x in l1 if x in common])\n\
    \    common = Set([x for x in l2 if x in common])\n    common = Set([x for x in\
    \ l1 if x in common])\n    common = Set([x for x in l2 if x in common])\n    common\
    \ = Set([x for x in l1 if x in common])\n    common = Set([x for x in l2 if x\
    \ in common])\n    common = Set\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpq8neskt6.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpq8neskt6.jl:1\n\
    in expression starting at /tmp/tmpq8neskt6.jl:1\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6az__a88.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp6az__a88.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp6az__a88.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest s"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        push!(common, x)\n    end\n    \n    for x in l2 do \n\
    \        push!(common, x)\n    end\n    \n    return common\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpx10ynepr.jl:12\nin expression starting at /tmp/tmpx10ynepr.jl:12\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = common.add(x)\n    end\n    for x in l2 do \n        common\
    \ = common.add(x)\n    end\n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp280j_fe4.jl:11\nin expression starting at /tmp/tmp280j_fe4.jl:11\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp0i68fe.jl:22\nin expression starting at\
    \ /tmp/tmpjp0i68fe.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp0i68fe.jl:22\nin expression starting at\
    \ /tmp/tmpjp0i68fe.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n            else\n                common = Set([a] + common)\n \
    \       end\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd0h10oes.jl:23\nin expression starting at\
    \ /tmp/tmpd0h10oes.jl:23\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \u222A l2\n        push!(common, el)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpz8tl7a52.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpz8tl7a52.jl:23\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpz8tl7a52.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz8tl7a52.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz8tl7a52.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpz8tl7a52.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpz8tl7a52.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp0i68fe.jl:22\nin expression starting at\
    \ /tmp/tmpjp0i68fe.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbqce59b7.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbqce59b7.jl:1\n\
    in expression starting at /tmp/tmpbqce59b7.jl:1\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common = Set([a])\n\
    \                break\n        end\n    end\n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcxc8nmqj.jl:20\nin expression starting at\
    \ /tmp/tmpcxc8nmqj.jl:20\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6az__a88.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp6az__a88.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp6az__a88.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest s"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the common elements for two lists.\nWrite a function\
    \ that returns the common elements for two lists.\nWrite a function that returns\
    \ the common elements for two lists.\nWrite a function that returns the common\
    \ elements for two lists.\nWrite a function that returns the common elements for\
    \ two lists.\nWrite a function that returns the common elements for two lists.\n\
    Write a function that returns the common elements for two lists.\nWrite a function\
    \ that returns the common elements for two lists.\nWrite a function that returns\
    \ the common elements for two lists.\nWrite a function that returns the common\
    \ elements for two lists.\nWrite a function that returns the common elements for\
    \ two lists.\nWrite a function that returns the common elements for two lists.\n\
    Write a function that returns the common elements for two lists.\nWrite a function\
    \ that returns the common elements for two lists.\nWrite a function that returns\
    \ the common elements for two lists.\nWrite a function that returns the common\
    \ elements for two lists.\nWrite a function that returns the common elements for\
    \ two lists.\nWrite a function that returns the common elements for two lists.\n\
    Write a function that returns the common elements for two lists.\nWrite a function\
    \ that returns the common elements for two lists.\nWrite a function that returns\
    \ the common elements for two lists.\nWrite a function that returns the common\
    \ elements for two lists.\nWrite a function that returns the common elements for\
    \ two lists.\nWrite a function that returns the common elements for two lists.\n\
    Write a function that returns the common elements for two lists.\nWrite a function\
    \ that returns the common elements for two lists.\nWrite a function that returns\
    \ the common elements for two lists.\nWrite a function that returns the common\
    \ elements for two lists.\nWrite a function that returns the common elements for\
    \ two lists.\nWrite a function that returns the common elements for two lists.\n\
    Write a function that returns the common elements for two lists.\nWrite a function\
    \ that returns the common elements for two lists.\nWrite a function that returns\
    \ the common elements for two lists.\nWrite a function that returns the common\
    \ elements for two lists.\nWrite a function that returns the common elements for\
    \ two lists.\nWrite a function that returns the common elements for two lists.\n\
    Write a function that returns the common elements for \nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd4ai8r_9.jl:22\nin expression starting at\
    \ /tmp/tmpd4ai8r_9.jl:22\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return Set([x for x in common if x != 0])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp3wrj5ggq.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp3wrj5ggq.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmp3wrj5ggq.jl:12\n   [2] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmp3wrj5ggq.jl:24 [inlined]\n   [4] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3wrj5ggq.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp3wrj5ggq.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmp3wrj5ggq.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3wrj5ggq.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3wrj5ggq.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp3wrj5ggq.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmp3wrj5ggq.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3wrj5ggq.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3wrj5ggq.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp3wrj5ggq.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ ++ not defined\n  Stacktrace:\n   [1] c"
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        else\n            common = Set([el] ++ common)\n        end\n    end\n\
    \    \n    for el in l2\n        if !contains(common, el)\n            common\
    \ = Set([el])\n        else\n            common = Set([el] ++ common)\n      \
    \  end\n    end\n    \n    return common\nend\n</code>\n<|/ a tags=julia,set-theory\
    \ |>\n<| a dscore=2 |>\nI wrote a package called SetOps.jl for this. It has many\
    \ useful set operations, including union, intersection, difference, symmetric\
    \ difference, etc.\n<code>\njulia> using SetOps\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgmy34t1h.jl:30\nin expression starting at\
    \ /tmp/tmpgmy34t1h.jl:30\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp0i68fe.jl:22\nin expression starting at\
    \ /tmp/tmpjp0i68fe.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el] + common)\n    end\n    \n    for el in\
    \ l2\n        common = Set([el] + common)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpvybmbuta.jl:27\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: no method matching +(::Vector{Int64}, ::Set{Any})\n  Closest
    candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array,
    !Matched::Array...) at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array,
    !Matched::SparseArrays.AbstractSparseMatrixCSC) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpvybmbuta.jl:13\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvybmbuta.jl:27 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvybmbuta.jl:26\ntest set: Error
    During Test at /tmp/tmpvybmbuta.jl:28\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching +(::Vector{Int64},
    ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array, !Matched::Array...)
    at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC)
    at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpvybmbuta.jl:13\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvybmbuta.jl:28 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T'
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common.add(a)\n\
    \            end\n        end\n    end\n    \n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprqstpxdj.jl:22\nin expression starting at\
    \ /tmp/tmprqstpxdj.jl:22\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        if !contains(common, x)\n            push!(common, x)\n        end\n\
    \    end\n    for x in l2\n        if !contains(common, x)\n            push!(common,\
    \ x)\n        end\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1ckoyrvz.jl:23\nin expression starting at\
    \ /tmp/tmp1ckoyrvz.jl:23\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpixbj9oko.jl:20\nin expression starting at\
    \ /tmp/tmpixbj9oko.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \n        if !contains(common, el) \n            common = Set([el])\n\
    \        else \n            common = Set([el] ++ common)\n    end\n    \n    for\
    \ el in l2 \n        if !contains(common, el) \n            common = Set([el])\n\
    \        else \n            common = Set([el] ++ common)\n        end\n    end\n\
    \    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8tf4_3w3.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8tf4_3w3.jl:1\n\
    in expression starting at /tmp/tmp8tf4_3w3.jl:1\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = Set([x] + common)\n    end\n    for x in l2 do \n    \
    \    common = Set([x] + common)\n    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the number of times each element appears in\
    \ two given vectors.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7gkjr69w.jl:11\nin expression starting at /tmp/tmp7gkjr69w.jl:11\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpdhbk7jms.jl:27\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any}
    to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpdhbk7jms.jl:20\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdhbk7jms.jl:27 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdhbk7jms.jl:26\ntest set: Error
    During Test at /tmp/tmpdhbk7jms.jl:28\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type
    Set{Any} to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpdhbk7jms.jl:20\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.j'
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([x\
    \ for x in l1 if x in l2])\n    common = Set([x for x in l2 if x in l1])\n   \
    \ common = Set([x for x in l1 if x in l2])\n    common = Set([x for x in l2 if\
    \ x in l1])\n    common = Set([x for x in l1 if x in l2])\n    common = Set([x\
    \ for x in l2 if x in l1])\n    common = Set([x for x in l1 if x in l2])\n   \
    \ common = Set([x for x in l2 if x in l1])\n    common = Set([x for x in l1 if\
    \ x in l2])\n    common = Set([x for x in l2 if x in l1])\n    common = Set([x\
    \ for x in l1 if x in l2])\n    common = Set([x for x in l2 if x in l1])\n   \
    \ common = Set([x for x in l1 if x in l2])\n    common = Set([x for x in l2 if\
    \ x in l1])\n    common = Set([x for x in l1 if x in l2])\n    common = Set([x\
    \ for x in l2 if x in l1])\n    common = Set([x for x in l1 if x in l2])\n   \
    \ common = Set([x for x in l2 if x in l1])\n    common = Set([x for x in l1 if\
    \ x in l2])\n    common = Set([x for x in l2 if x in l1])\n    common = Set([x\
    \ for x in l1 if x in l2])\n    common = Set([x for x in l2 if x in l1])\n   \
    \ common = Set([x for x in l1 if x in l2])\n    common = Set([x for x in l2 if\
    \ x in l1])\n    common = Set([x for x in l1 if x in l2])\n    common = Set([x\
    \ for x in l2 if x in l1])\n    common = Set([x for x in l1 if x in l2])\n   \
    \ common = Set([x for x in l2 if x in l1])\n    common = Set([x for x in l1 if\
    \ x in l2])\n    common = Set([x for x in l2 if x in l1])\n    common = Set([x\
    \ for x in l1 if x in l2])\n    common = Set([x for x in l2 if x in l1])\n   \
    \ common = Set([x for x in l1 if x in l2])\n    common = Set([x for x in l2 if\
    \ x in l1])\n    common = Set([x for x in l1 if x in l2])\n    common = Set([x\
    \ for x in l2 if x in l1])\n    common = Set([x for x in l1 if x in l2])\n   \
    \ common = Set([x for x in l2 if x in l1])\n    common = Set([x for x in l1 if\
    \ x in l2])\n    common = Set([x for x in l2 if x in l1])\n    common = Set\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmfutl77t.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmfutl77t.jl:1\n\
    in expression starting at /tmp/tmpmfutl77t.jl:1\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        if x in l2 \n            common.add(x)\n        end\n \
    \   end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0o49kpn0.jl:12\nin expression starting at /tmp/tmp0o49kpn0.jl:12\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmptrze16oo.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmptrze16oo.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmptrze16oo.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmptrze16oo.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmptrze16oo.jl:26\ntest set:\
    \ Error During Test at /tmp/tmptrze16oo.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmptrze16oo.jl:13\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmptrze16oo.jl:28 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmptrze16oo.jl:26\ntest set:\
    \ Error During Test at /tmp/tmptrze16oo.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmptrze16oo.jl:13\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmptrze16oo.jl:29 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmptrze16oo.jl:26\ntest set:\
    \ Error During Test at /tmp/tmptrze16oo.jl:30\n  Test threw excepti"
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqkcoymig.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpqkcoymig.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ ++ not "
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        if !haskey(common, x)\n            common[x] = true\n \
    \       end\n    end\n    \n    for x in l2 do \n        if !haskey(common, x)\n\
    \            common[x] = true\n        end\n    end\n    \n    return collect(keys(common))\n\
    end\n</cell>\n<code language=julia-1.5>\n@time common([1, 4, 3, 34, 653, 2, 5],\
    \ [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code language=julia-1.5>\n@time common([5,\
    \ 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\nWrite a function that returns\
    \ the number of unique elements in two lists.\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa95t_fye.jl:12\nin expression starting at /tmp/tmpa95t_fye.jl:12\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        common = Set([x] + common)\n    end\n    for x in l2 do\
    \ \n        common = Set([x] + common)\n    end\n    \n    return common\nend\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprqzfa2gf.jl:12\nin expression starting at /tmp/tmprqzfa2gf.jl:12\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = Set([x] ++ common)\n    end\n    for x in l2 do \n   \
    \     common = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwd9n08l2.jl:11\nin expression starting at /tmp/tmpwd9n08l2.jl:11\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqkcoymig.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpqkcoymig.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ ++ not "
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] + common)\n    end\n    for x in l2\n        common\
    \ = Set([x] + common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpt_x182g3.jl:24\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: no method matching +(::Vector{Int64}, ::Set{Any})\n  Closest
    candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array,
    !Matched::Array...) at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array,
    !Matched::SparseArrays.AbstractSparseMatrixCSC) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpt_x182g3.jl:12\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt_x182g3.jl:24 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt_x182g3.jl:23\ntest set: Error
    During Test at /tmp/tmpt_x182g3.jl:25\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching +(::Vector{Int64},
    ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array, !Matched::Array...)
    at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC)
    at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpt_x182g3.jl:12\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt_x182g3.jl:25 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T'
  timestamp: 1659822642
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\n@time common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code language=julia-1.5>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqo8vmhon.jl:19\nin expression starting at\
    \ /tmp/tmpqo8vmhon.jl:19\n"
  stdout: ''
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in common\n            continue\n        else\n      \
    \      common = Set([x])\n        end\n    end\n    \n    for x in l2\n      \
    \  if x in common\n            continue\n        else\n            common = Set([x])\n\
    \        end\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdasyil2a.jl:30\nin expression starting at\
    \ /tmp/tmpdasyil2a.jl:30\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6az__a88.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp6az__a88.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp6az__a88.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest s"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    common\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp51_reyb5.jl:19\nin expression starting at\
    \ /tmp/tmp51_reyb5.jl:19\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmptrze16oo.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmptrze16oo.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmptrze16oo.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmptrze16oo.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmptrze16oo.jl:26\ntest set:\
    \ Error During Test at /tmp/tmptrze16oo.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmptrze16oo.jl:13\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmptrze16oo.jl:28 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmptrze16oo.jl:26\ntest set:\
    \ Error During Test at /tmp/tmptrze16oo.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmptrze16oo.jl:13\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmptrze16oo.jl:29 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmptrze16oo.jl:26\ntest set:\
    \ Error During Test at /tmp/tmptrze16oo.jl:30\n  Test threw excepti"
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = common & Set(l2)\n    end\n    \n    return common\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6xyjhx_c.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmp6xyjhx_c.jl:22\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching &(::Set{Any}, ::Set{Int64})\n\
    \  Closest candidates are:\n    &(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n  Stacktrace:\n\
    \   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmp6xyjhx_c.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6xyjhx_c.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6xyjhx_c.jl:21\ntest set:\
    \ Error During Test at /tmp/tmp6xyjhx_c.jl:23\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ &(::Set{Any}, ::Set{Int64})\n  Closest candidates are:\n    &(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmp6xyjhx_c.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6xyjhx_c.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6xyjhx_c.jl:21\ntest set:\
    \ Error During Test at /tmp/tmp6xyjhx_c.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching\
    \ &(::Set{Any}, ::Set{Int64})\n  Closest candidates are:\n    &(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmp6xyjhx_c.jl:12\n   [2] macro expansion\n     @ ~/.co"
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common.add(x)\n    end\n    for x in l2\n        common.add(x)\n    end\n\
    \    common = Set()\n    for x in common\n        common.add(x)\n    end\n   \
    \ return common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpwky4uqyj.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmpwky4uqyj.jl:28\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpwky4uqyj.jl:12\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpwky4uqyj.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpwky4uqyj.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpwky4uqyj.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpwky4uqyj.jl:12\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmpwky4uqyj.jl:29 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpwky4uqyj.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpwky4uqyj.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpwky4uqyj.jl:12\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmpwky4uqyj.jl:30 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpwky4uqyj.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpwky4uqyj.jl:31\n  Test threw excepti"
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_my4xw8g.jl:19\nin expression starting at\
    \ /tmp/tmp_my4xw8g.jl:19\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in common\n            push!(common, x)\n        else\n\
    \            push!(common, x)\n        end\n    end\n    \n    for x in l2\n \
    \       if x in common\n            push!(common, x)\n        else\n         \
    \   push!(common, x)\n        end\n    end\n    \n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb5xkkd97.jl:30\nin expression starting at\
    \ /tmp/tmpb5xkkd97.jl:30\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk1gpn1zj.jl:22\nin expression starting at\
    \ /tmp/tmpk1gpn1zj.jl:22\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprbimapta.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprbimapta.jl:1\n\
    in expression starting at /tmp/tmprbimapta.jl:1\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaqw4kp57.jl:19\nin expression starting at\
    \ /tmp/tmpaqw4kp57.jl:19\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] + common)\n    end\n    for x in l2\n        common\
    \ = Set([x] + common)\n    end\n    return Set([x for x in common if x != 0])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpyzajvz34.jl:24\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: no method matching +(::Vector{Int64}, ::Set{Any})\n  Closest
    candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array,
    !Matched::Array...) at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array,
    !Matched::SparseArrays.AbstractSparseMatrixCSC) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpyzajvz34.jl:12\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyzajvz34.jl:24 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyzajvz34.jl:23\ntest set: Error
    During Test at /tmp/tmpyzajvz34.jl:25\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching +(::Vector{Int64},
    ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array, !Matched::Array...)
    at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC)
    at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpyzajvz34.jl:12\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyzajvz34.jl:25 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T'
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common.add(a)\n \
    \           end\n        end\n    end\n    return common\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp64z7nopn.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp64z7nopn.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp64z7nopn.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp64z7nopn.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp64z7nopn.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp64z7nopn.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmp64z7nopn.jl:14\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmp64z7nopn.jl:26 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp64z7nopn.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp64z7nopn.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmp64z7nopn.jl:14\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmp64z7nopn.jl:27 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp64z7nopn.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp64z7nopn.jl:28\n  Test threw excepti"
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n                break\n            elseif common == Set()\n    \
    \            common = Set([a])\n            elseif common == Set()\n         \
    \       common = Set([a])\n            elseif common == Set()\n              \
    \  common = Set([a])\n            elseif common == Set()\n                common\
    \ = Set([a])\n            elseif common == Set()\n                common = Set([a])\n\
    \            elseif common == Set()\n                common = Set([a])\n     \
    \       elseif common == Set()\n                common = Set([a])\n          \
    \  elseif common == Set()\n                common = Set([a])\n            elseif\
    \ common == Set()\n                common = Set([a])\n            elseif common\
    \ == Set()\n                common = Set([a])\n            elseif common == Set()\n\
    \                common = Set([a])\n            elseif common == Set()\n     \
    \           common = Set([a])\n            elseif common == Set()\n          \
    \      common = Set([a])\n            elseif common == Set()\n               \
    \ common = Set([a])\n            elseif common == Set()\n                common\
    \ = Set([a])\n            elseif common == Set()\n                common = Set([a])\n\
    \            elseif common == Set()\n                common = Set([a])\n     \
    \       elseif common == Set()\n                common = Set([a])\n          \
    \  elseif common == Set()\n                common = Set([a])\n            elseif\
    \ common == Set()\n                common = Set([a])\n            elseif common\
    \ == Set()\n                common = Set([a])\n            elseif common == Set()\n\
    \                common = Set([a])\n            elseif common == Set()\n     \
    \           common = Set([a])\n            elseif common == Set()\n          \
    \      common = Set([a])\n            elseif common == Set()\n               \
    \ common = Set([a])\n            elseif common == Set()\n                common\
    \ = Set([a])\n            elseif common == Set()\n                common = Set([a])\n\
    \            elseif common == Set()\n                common = Set([a])\n     \
    \       elseif common == Set()\n                common = Set([a])\n          \
    \  elseif common == Set()\n                common = Set([a])\n\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy7nyxghi.jl:1\nin expression starting at /tmp/tmpy7nyxghi.jl:1\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = common & Set([x])\n    end\n    for x in l2\n        common\
    \ = common & Set([x])\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpigk0zz0_.jl:19\nin expression starting at\
    \ /tmp/tmpigk0zz0_.jl:19\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a, b])\n            end\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpgnuh7elp.jl:27\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Int64}
    to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpgnuh7elp.jl:20\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgnuh7elp.jl:27 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgnuh7elp.jl:26\ntest set: Error
    During Test at /tmp/tmpgnuh7elp.jl:28\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an object of type
    Set{Int64} to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpgnuh7elp.jl:20\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te'
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThank you for\
    \ the answer. Could you please explain how this works?\n<|/ c |>\n<| c |>\nI added\
    \ some explanation to the answer.\n<|/ c |>\n<| c |>\nThank you for the explanation.\
    \ Could you please explain how this works?\n<|/ c |>\n<| c |>\nThe `Set` type\
    \ is a mutable set that has `push!` and `pop!` methods. `push!` adds an element\
    \ to the set and `pop!` removes the last element from the set. `Set` has `union`,\
    \ `intersection`, `difference`, `issubset`, `issuperset`, `isdisjoint`, and `isordered`\
    \ methods. `union` returns a new set that is the union of the two sets. `intersection`\
    \ returns a new set that is the intersection of the two sets. `difference` returns\
    \ a new set that is the difference of the two sets. `issubset` returns true if\
    \ the first set is a subset of the second set. `issuperset` returns true if the\
    \ first set is a superset of the second set. `isdisjoint` returns true if the\
    \ two sets are disjoint. `isordered` returns true if the two sets are ordered.\n\
    <|/ c |>\n<| c |>\n`Set` has `union`, `intersection`, `difference`, `issubset`,\
    \ `issuperset`, `isdisjoint`, and `isordered` methods. `union` returns a new set\
    \ that is the union of the two sets. `intersection` returns a new set that is\
    \ the intersection of the two sets. `difference` returns a new set that is the\
    \ difference of the two sets. `issubset` returns true if the first set is a subset\
    \ of the second set. `issuperset` returns true if the first set is a superset\
    \ of the second set. `isdisjoint` returns true if the two sets are disjoint. `isordered`\
    \ returns true if the two sets are ordered.\n<|/ c |>\n<| a dscore=2 |>\nThe answer\
    \ by is very good, but I wanted to add an alternative solution that is more efficient\
    \ and doesn't require the use of a Set:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmla269jh.jl:19\nin expression starting at\
    \ /tmp/tmpmla269jh.jl:19\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps96sww91.jl:22\nin expression starting at\
    \ /tmp/tmps96sww91.jl:22\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n            else\n                common = Set([a] ++ common)\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsmeom1s1.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsmeom1s1.jl:1\n\
    in expression starting at /tmp/tmpsmeom1s1.jl:1\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gh2jdmu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp0gh2jdmu.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0gh2jdmu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0gh2jdmu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp0gh2jdmu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gh2jdmu.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = common & Set([x])\n    end\n    for x in l2 do \n    \
    \    common = common & Set([x])\n    end\n    return common\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqiasozan.jl:11\nin expression starting at /tmp/tmpqiasozan.jl:11\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1 do \n        if x in l2 \n            common.add(x)\n        end\n \
    \   end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0o49kpn0.jl:12\nin expression starting at /tmp/tmp0o49kpn0.jl:12\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp7kwbw263.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmp7kwbw263.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp7kwbw263.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7kwbw263.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7kwbw263.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp7kwbw263.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp7kwbw263.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7kwbw263.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7kwbw263.jl:26\ntest s"
  timestamp: 1659822644
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common.add(i)\n    end\n    \n    for i in l2\n        common.add(i)\n\
    \    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6r15586v.jl:22\nin expression starting at\
    \ /tmp/tmp6r15586v.jl:22\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l1 if\
    \ i in l2])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l1 if i in l2])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprbimapta.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprbimapta.jl:1\n\
    in expression starting at /tmp/tmprbimapta.jl:1\n"
  stdout: ''
  timestamp: 1659822640
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptii_b_rn.jl:20\nin expression starting at\
    \ /tmp/tmptii_b_rn.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        push!(common, el)\n    end\n    \n    for el in l2\n     \
    \   push!(common, el)\n    end\n    \n    return collect(common)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb30e1_c9.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpb30e1_c9.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpb30e1_c9.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpb30e1_c9.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpb30e1_c9.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \n        if !contains(common, el)\n            common = Set([el])\n\
    \        end\n    end\n    \n    for el in l2 \n        if !contains(common, el)\n\
    \            common = Set([el])\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmphkygmxhq.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmphkygmxhq.jl:31\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching contains(::Set{Any}, ::Int64)\n\
    \  Closest candidates are:\n    contains(!Matched::AbstractString, ::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:100\n\
    \    contains(::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:161\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmphkygmxhq.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphkygmxhq.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphkygmxhq.jl:30\ntest set:\
    \ Error During Test at /tmp/tmphkygmxhq.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ contains(::Set{Any}, ::Int64)\n  Closest candidates are:\n    contains(!Matched::AbstractString,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:100\n    contains(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:161\n  Stacktrace:\n\
    \   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmphkygmxhq.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphkygmxhq.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphkygmxhq.jl:30\ntest set:\
    \ Error During Test at /tmp/tmphkygmxhq.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching\
    \ contains(::Set{Any}, ::Int64)\n  Closest candidates are:\n    contains(!Matched::AbstractString,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/b"
  timestamp: 1659822644
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ elt in l1 do \n        if elt in l2 \n            common = common + [elt]\n\
    \        end\n    end\n    \n    return common\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa72lt7_4.jl:12\nin expression starting at /tmp/tmpa72lt7_4.jl:12\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el] + common)\n    end\n    \n    for el in\
    \ l2\n        common = Set([el] + common)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpvybmbuta.jl:27\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: no method matching +(::Vector{Int64}, ::Set{Any})\n  Closest
    candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array,
    !Matched::Array...) at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array,
    !Matched::SparseArrays.AbstractSparseMatrixCSC) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpvybmbuta.jl:13\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvybmbuta.jl:27 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvybmbuta.jl:26\ntest set: Error
    During Test at /tmp/tmpvybmbuta.jl:28\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching +(::Vector{Int64},
    ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array, !Matched::Array...)
    at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC)
    at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpvybmbuta.jl:13\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvybmbuta.jl:28 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T'
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp0i68fe.jl:22\nin expression starting at\
    \ /tmp/tmpjp0i68fe.jl:22\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common.add(a)\n\
    \            end\n        end\n    end\n    \n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprqstpxdj.jl:22\nin expression starting at\
    \ /tmp/tmprqstpxdj.jl:22\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common = Set([a])\n\
    \                break\n            else\n                common = Set([a] ++\
    \ common)\n        end\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi18ln3nk.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi18ln3nk.jl:1\n\
    in expression starting at /tmp/tmpi18ln3nk.jl:1\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the unique elements of a list that do not appear\
    \ in another list.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpswp1xct5.jl:22\nin expression starting at\
    \ /tmp/tmpswp1xct5.jl:22\n"
  stdout: ''
  timestamp: 1659822642
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise:\
    \ Write a function that returns the unique elements of a given vector. \nHint:\
    \ Use Set()\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp38fwrcle.jl:22\nin expression starting at\
    \ /tmp/tmp38fwrcle.jl:22\n"
  stdout: ''
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ do \n        common = Set([x] ++ common)\n    end\n    for x in l2 do \n   \
    \     common = Set([x] ++ common)\n    end\n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr_ac7i9j.jl:11\nin expression starting at /tmp/tmpr_ac7i9j.jl:11\n"
  stdout: ''
  timestamp: 1659822642
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        end\n    end\n    \n    for el in l2\n        if !contains(common, el)\n\
    \            common = Set([el])\n        end\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl1n6kcd6.jl:26\nin expression starting at\
    \ /tmp/tmpl1n6kcd6.jl:26\n"
  stdout: ''
  timestamp: 1659822642
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for a in l1\n\
    \        for b in l2\n            if a == b\n                common = Set([a])\n\
    \                break\n        end\n    end\n    return common\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpywt9l9q5.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpywt9l9q5.jl:1\n\
    in expression starting at /tmp/tmpywt9l9q5.jl:1\n"
  stdout: ''
  timestamp: 1659822642
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 do \n        if !contains(common, el) \n            common = Set([el])\n\
    \        else \n            common = Set([el]) & common\n        end\n    end\n\
    \    \n    for el in l2 do \n        if !contains(common, el) \n            common\
    \ = Set([el])\n        else \n            common = Set([el]) & common\n      \
    \  end\n    end\n    \n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp3mmgfkfv.jl:12\nin expression starting at /tmp/tmp3mmgfkfv.jl:12\n"
  stdout: ''
  timestamp: 1659822642
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\n\
    Write a function that returns the number of common elements for two lists.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbgkovu6c.jl:22\nin expression starting at\
    \ /tmp/tmpbgkovu6c.jl:22\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqkcoymig.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpqkcoymig.jl:24\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: ++ not defined\n  Stacktrace:\n   [1] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: ++ not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqkcoymig.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkcoymig.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkcoymig.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpqkcoymig.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ ++ not "
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    common\nend\n</cell>\n<code language=julia-1.3>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<text>\n\
    Exercise: Write a function that returns the number of unique elements in a given\
    \ list.\nHint: Use a Set\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9lmzd_f9.jl:19\nin expression starting at\
    \ /tmp/tmp9lmzd_f9.jl:19\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the\
    \ answer! I tested it and it works perfectly! I still don't understand why my\
    \ code doesn't work, though.\n<|/ c |>\n<| c |>\nI added some explanation to the\
    \ answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for the explanation! I still\
    \ don't understand why my code doesn't work, though.\n<|/ c |>\n<| c |>\nI added\
    \ some explanation to the answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for\
    \ the explanation! I still don't understand why my code doesn't work, though.\n\
    <|/ c |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw9eicsg9.jl:19\nin expression starting at\
    \ /tmp/tmpw9eicsg9.jl:19\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\n@time common([5,\
    \ 3, 2, 8], [3, 2])\n</cell>\n<text>\nThe @time macro will give you the runtime\
    \ in seconds. You can divide this by the number of elements to get the average\
    \ runtime.\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptm8frwdo.jl:20\nin expression starting at\
    \ /tmp/tmptm8frwdo.jl:20\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    common = Set([i\
    \ for i in l1 if i in l2])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l1 if i in l2])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l1 if i in l2])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n    common = Set([i for i in l2 if i in l1])\n    common = Set([i\
    \ for i in l2 if i in l1])\n    common = Set([i for i in l2 if i in l1])\n   \
    \ common = Set([i for i in l2 if i in l1])\n    common = Set([i for i in l2 if\
    \ i in l1])\n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbqce59b7.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbqce59b7.jl:1\n\
    in expression starting at /tmp/tmpbqce59b7.jl:1\n"
  stdout: ''
  timestamp: 1659822638
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptii_b_rn.jl:20\nin expression starting at\
    \ /tmp/tmptii_b_rn.jl:20\n"
  stdout: ''
  timestamp: 1659822636
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ i in l1\n        common = Set([i | common])\n    end\n    \n    for i in l2\n\
    \        common = Set([i | common])\n    end\n    \n    return common\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp83mv5y6a.jl:22\nin expression starting at\
    \ /tmp/tmp83mv5y6a.jl:22\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphwmbpf5y.jl:22\nin expression starting at\
    \ /tmp/tmphwmbpf5y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        end\n    end\n    \n    for el in l2\n        if !contains(common, el)\n\
    \            common = Set([el])\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpbk0686fj.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpbk0686fj.jl:31\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching contains(::Set{Any}, ::Int64)\n\
    \  Closest candidates are:\n    contains(!Matched::AbstractString, ::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:100\n\
    \    contains(::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:161\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmpbk0686fj.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbk0686fj.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbk0686fj.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpbk0686fj.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ contains(::Set{Any}, ::Int64)\n  Closest candidates are:\n    contains(!Matched::AbstractString,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:100\n    contains(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:161\n  Stacktrace:\n\
    \   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpbk0686fj.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbk0686fj.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbk0686fj.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpbk0686fj.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  MethodError: no method matching\
    \ contains(::Set{Any}, ::Int64)\n  Closest candidates are:\n    contains(!Matched::AbstractString,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/b"
  timestamp: 1659822646
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\
    \ \n        common = Set([x] ++ common)\n    end\n    for x in l2\n        common\
    \ = Set([x] ++ common)\n    end\n    return common\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy_bdygok.jl:19\nin expression starting at\
    \ /tmp/tmpy_bdygok.jl:19\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.5>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<text>\nExercise\n\
    Write a function that returns the number of unique elements in a given vector.\n\
    using Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4,\
    \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprv1p4e9z.jl:22\nin expression starting at\
    \ /tmp/tmprv1p4e9z.jl:22\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return sort(common)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6az__a88.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp6az__a88.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Any})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp6az__a88.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Any})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp6az__a88.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6az__a88.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6az__a88.jl:24\ntest s"
  timestamp: 1659822639
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        push!(common, el)\n    end\n    \n    for el in l2\n     \
    \   push!(common, el)\n    end\n    \n    return collect(common)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb30e1_c9.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpb30e1_c9.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpb30e1_c9.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpb30e1_c9.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpb30e1_c9.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb30e1_c9.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb30e1_c9.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  timestamp: 1659822643
- exit_code: -1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el] + common)\n    end\n    \n    for el in\
    \ l2\n        common = Set([el] + common)\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpvybmbuta.jl:27\n  Test threw
    exception\n  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,
    121]) == [1, 5, 653]\n  MethodError: no method matching +(::Vector{Int64}, ::Set{Any})\n  Closest
    candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array,
    !Matched::Array...) at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array,
    !Matched::SparseArrays.AbstractSparseMatrixCSC) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpvybmbuta.jl:13\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvybmbuta.jl:27 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvybmbuta.jl:26\ntest set: Error
    During Test at /tmp/tmpvybmbuta.jl:28\n  Test threw exception\n  Expression: candidate([5,
    3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching +(::Vector{Int64},
    ::Set{Any})\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    +(::Array, !Matched::Array...)
    at ~/.conda/envs/polyglot/share/julia/base/arraymath.jl:43\n    +(::Array, !Matched::SparseArrays.AbstractSparseMatrixCSC)
    at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/SparseArrays/src/sparsematrix.jl:1775\n    ...\n  Stacktrace:\n   [1]
    common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmpvybmbuta.jl:13\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvybmbuta.jl:28 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T'
  timestamp: 1659822641
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        if !contains(common, el)\n            common = Set([el])\n\
    \        end\n    end\n    \n    for el in l2\n        if !contains(common, el)\n\
    \            common = Set([el])\n        end\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe_ypnwbv.jl:26\nin expression starting at\
    \ /tmp/tmpe_ypnwbv.jl:26\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        if x in l2\n            common.add(x)\n        end\n    end\n\
    \    \n    return common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0gx_k4kw.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp0gx_k4kw.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp0gx_k4kw.jl:14\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0gx_k4kw.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0gx_k4kw.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp0gx_k4kw.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmp0gx_k4kw.jl:14\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmp0gx_k4kw.jl:26 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0gx_k4kw.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp0gx_k4kw.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  type Set has no field add\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmp0gx_k4kw.jl:14\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmp0gx_k4kw.jl:27 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0gx_k4kw.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp0gx_k4kw.jl:28\n  Test threw excepti"
  timestamp: 1659822646
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ a in l1\n        for b in l2\n            if a == b\n                common\
    \ = Set([a])\n                break\n        end\n    end\n    \n    return common\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvzholpmh.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvzholpmh.jl:1\n\
    in expression starting at /tmp/tmpvzholpmh.jl:1\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmprul_76.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpmprul_76.jl:25\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:26\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:27\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpmprul_76.jl:28\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmprul_76.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmprul_76.jl:24\nTest Summary:\
    \ | Fail  Total\ntest"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \u222A l2\n        common \u222A= Set(el)\n    end\n    \n    return\
    \ common\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"=\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjo1g_ec3.jl:13\nin expression starting at /tmp/tmpjo1g_ec3.jl:13\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        if x in l2\n            common = common + Set([x])\n        end\n   \
    \ end\n    return common\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv0t9hua0.jl:18\nin expression starting at\
    \ /tmp/tmpv0t9hua0.jl:18\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7adecil.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7adecil.jl:1\n\
    in expression starting at /tmp/tmp_7adecil.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    for x in l1\n\
    \        push!(common, x)\n    end\n    for x in l2\n        push!(common, x)\n\
    \    end\n    common\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8jks5d7.jl:19\nin expression starting at\
    \ /tmp/tmpo8jks5d7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    common\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnd5vlzxe.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpnd5vlzxe.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: Cannot `convert` an object of type Set{Any} to\
    \ an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnd5vlzxe.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnd5vlzxe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpnd5vlzxe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: Cannot `convert` an\
    \ object of type Set{Any} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpnd5vlzxe.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1 \n        push!(common, el)\n    end\n    \n    for el in l2\n    \
    \    push!(common, el)\n    end\n    \n    return collect(common)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy16i4dvj.jl:22\nin expression starting at\
    \ /tmp/tmpy16i4dvj.jl:22\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ el in l1\n        common = Set([el]) & common\n    end\n    \n    for el in\
    \ l2\n        common = Set([el]) & common\n    end\n    \n    return common\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8cg7lsps.jl:22\nin expression starting at\
    \ /tmp/tmp8cg7lsps.jl:22\n"
  stdout: ''
  timestamp: 1659822643
- exit_code: 1
  program: "\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \n    common = Set()\n    \n    for\
    \ x in l1\n        push!(common, x)\n    end\n    \n    for x in l2\n        push!(common,\
    \ x)\n    end\n    \n    return collect(common)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilaw0xeh.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpilaw0xeh.jl:27\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [34, 4, 5, 7, 2, 9, 121, 653, 3, 1] == [1, 5, 653]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:28\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [5, 2, 8, 3] == [2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:29\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 2, 8, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpilaw0xeh.jl:30\n  Expression: candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [4, 2, 8, 3] == Int64[]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilaw0xeh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilaw0xeh.jl:26\nTest Summary:\
    \ | Fail  Total\ntest"
