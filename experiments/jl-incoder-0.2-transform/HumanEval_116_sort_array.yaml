name: HumanEval_116_sort_array
language: jl
prompt: "\"\"\"\n    In this Kata, you have to sort an array of non-negative integers\
  \ according to\n    number of ones in their binary representation in ascending order.\n\
  \    For similar number of ones, sort based on decimal value.\n\n    It must be\
  \ implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4])\n    [1, 2, 3, 4,\
  \ 5]\n    >>> sort_array([-2, -3, -4, -5, -6])\n    [-6, -5, -4, -3, -2]\n    >>>\
  \ sort_array([1, 0, 2, 3, 4])\n    [0, 1, 2, 3, 4]\n    \"\"\"\nfunction sort_array(arr::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate([1,\
  \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\t@test(candidate([-2, -3, -4, -5, -6]) == [-4,\
  \ -2, -6, -5, -3])\n\t@test(candidate([1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
  \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\t@test(candidate([3, 6, 44, 12, 32, 5])\
  \ == [32, 3, 5, 6, 12, 44])\n\t@test(candidate([2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
  \ 32])\n\t@test(candidate([2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nend\n"
completions: ["    \n    arr = arr .+ 1\n    \n    ones = zeros(Int64, length(arr))\n\
    \    \n    for i = 1:length(arr)\n        ones[i] = sum(arr .== i)\n    end\n\
    \    \n    ones = ones .+ 1\n    \n    ones = ones ./ sum(ones)\n    \n    ones\
    \ = ones .* 100\n    \n    ones = ones .- 100\n    \n    ones = ones ./ sum(ones)\n\
    \    \n    ones = ones .* 100\n    \n    ones = ones .- 100\n    \n    ones =\
    \ ones ./ sum(ones)\n    \n    ones = ones .* 100\n    \n    ones = ones .- 100\n\
    \    \n    ones = ones ./ sum(ones)\n    \n    ones = ones .* 100\n    \n    ones\
    \ = ones .- 100\n    \n    ones = ones ./ sum(ones)\n    \n    ones = ones .*\
    \ 100\n    \n    ones = ones .- 100\n    \n    ones = ones ./ sum(ones)\n    \n\
    \    ones = ones .* 100\n    \n    ones = ones .- 100\n    \n    ones = ones ./\
    \ sum(ones)\n    \n    ones = ones .* 100\n    \n    ones = ones .- 100\n    \n\
    \    ones = ones ./ sum(ones)\n    \n    ones = ones .* 100\n    \n    ones =\
    \ ones .- 100\n    \n    ones = ones ./ sum(ones)\n    \n    ones = ones .* 100\n\
    \    \n    ones = ones .- 100\n    \n    ones = ones ./ sum(ones)\n    \n    ones\
    \ = ones .* 100\n    \n    ones = ones .- 100\n    \n    ones = ones ./ sum(ones)\n\
    \    \n    ones = ones .* 100\n    \n    ones = ones .- 100\n    \n    ones =\
    \ ones ./ sum(ones)\n    \n    ones = ones .* 100\n    \n    ones = ones .- 100\n\
    \    \n    ones = ones ./ sum(ones)\n    \n    ones = ones .* 100\n    \n    ones\
    \ = ones .- 100\n    \n    ones = ones ./ sum(ones)\n    \n    ones = ones .*\
    \ 100\n    \n    ones = ones .- 100\n    \n    ones = ones ./ sum(ones)\n    \n\
    \    one", "    \n    ones = zeros(Int64, length(arr))\n    ones[arr .== 1] =\
    \ 1\n    \n    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n \
    \   \n    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n\
    \    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones\
    \ = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones\
    \ .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n\
    \    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n    \n\
    \    ones = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n    \n    ones\
    \ = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n\
    \    \n    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n\
    \    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones\
    \ = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones\
    \ .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n\
    \    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n    \n\
    \    ones = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n    \n    ones\
    \ = ones[order(ones)]\n    \n    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n\
    \    \n    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n\
    \    ones = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones\
    \ = ones[ones .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones = ones[ones\
    \ .!= 0]\n    \n    ones = ones[order(ones)]\n    \n    ones = ones[one", "  \
    \  \n    ones = zeros(Int, length(arr))\n    ones[arr .== 1] = 1\n    \n    sorted_arr\
    \ = zeros(Int, length(arr))\n    \n    ones_count = zeros(Int, length(arr))\n\
    \    \n    for i in 1:length(arr)\n        ones_count[i] = sum(ones[arr .== i])\n\
    \    end\n    \n    for i in 1:length(arr)\n        sorted_arr[i] = arr[ones_count\
    \ .== i][1]\n    end\n    \n    return sorted_arr\nend\n</cell>\n<code language=julia-1.5>\n\
    @test sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n</cell>\n<text>\nPart III: Binary Search\nIn this Kata, you have\
    \ to implement binary search algorithm to find if given number exists in given\
    \ array.", "    \n    ones = zeros(Int64, length(arr))\n    ones[arr .!= 0] =\
    \ 1\n    \n    ones = ones .> ones\n    \n    ones = ones .== ones\n    \n   \
    \ ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones\
    \ .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n \
    \   \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n\
    \    \n    ones = ones .== ones\n    \n    ones = ones .== ones\n    \n    ones\
    \ = ones .", "    \n    ones = zeros(Int64, length(arr))\n    \n    for i in 1:length(arr)\n\
    \        ones[i] = sum(arr[i] == 1)\n    end\n    \n    ones = sort(ones)\n  \
    \  \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n\
    \    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones =\
    \ ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n  \
    \  \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n\
    \    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones =\
    \ ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n  \
    \  \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n\
    \    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones =\
    \ ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n  \
    \  \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n\
    \    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones =\
    \ ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n  \
    \  \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n\
    \    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones =\
    \ ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n  \
    \  \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n\
    \    \n    ones = ones[2:end]\n    \n    ones = ones[2:end]\n    \n    ones =\
    \ ones[2:end]\n    \n    ones = ones[2:end]\n    \n    one", "    \n    ones =\
    \ zeros(Int64, length(arr))\n    ones[arr .== 1] = 1\n    \n    sorted = zeros(Int64,\
    \ length(arr))\n    \n    for i = 1:length(arr)\n        sorted[i] = sum(ones[arr\
    \ .== i])\n    end\n    \n    return sorted\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=sorting,julia,arrays |>\nThe answer by is correct, but I thought I'd\
    \ add some explanation as to why it works.\nThe reason why it works is because\
    \ Julia's sort function sorts in-place. So, if you have an array arr = [1, 2,\
    \ 3, 4, 5] and you call sort(arr), arr will now be sorted as [1, 2, 3, 4, 5].\n\
    However, if you have an array arr = [1, 2, 3, 4, 5] and you call sort(arr) again,\
    \ arr will still be sorted as [1, 2, 3, 4, 5]. However, the sort function will\
    \ now be called on the sorted array [1, 2, 3, 4, 5] instead of the original array\
    \ [1, 2, 3, 4, 5]. Thus, if you call sort(arr) again, arr will now be sorted as\
    \ [5, 4, 3, 2, 1].\n<|/ a dscore=2 |>\n<| a tags=sorting,julia,arrays |>\nThe\
    \ answer by is correct, but I thought I'd add some explanation as to why it works.\n\
    The reason why it works is because Julia's sort function sorts in-place. So, if\
    \ you have an array arr = [1, 2, 3, 4, 5] and you call sort(arr), arr will now\
    \ be sorted as [1, 2, 3, 4, 5].\nHowever, if you have an array arr = [1, 2, 3,\
    \ 4, 5] and you call sort(arr) again, arr will still be sorted as [1, 2, 3, 4,\
    \ 5]. However, the sort function will now be called on the sorted array [1, 2,\
    \ 3, 4, 5] instead of the original array [1, 2, 3, 4, 5]. Thus, if you call sort(arr)\
    \ again, arr will now be sorted as [5, 4, 3, 2, 1].\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nI wanted to add an additional answer that uses Julia's built-in sort function\
    \ and does not require a for loop:\n<code>\njulia> a = [1, 2, 3, 4, 5]\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    ones = zeros(Int64, length(arr))\n    \n    for\
    \ i in 1:length(arr)\n        ones[i] = sum(arr[i] == 1)\n    end\n    \n    ones\
    \ = sort(ones)\n    \n    arr = zeros(Int64, length(arr))\n    for i in 1:length(arr)\n\
    \        arr[i] = arr[ones[i]]\n    end\n    \n    return arr\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    \n    ones = zeros(Int64, length(arr))\n    ones[arr .== 1] = 1\n\
    \    \n    sorted_arr = zeros(Int64, length(arr))\n    \n    sorted_arr .= ones\n\
    \    \n    sorted_arr .= sort(ones)\n    \n    return sorted_arr\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    \n    ones = zeros(Int64,\
    \ length(arr))\n    ones[arr .== 1] = 1\n    \n    ones_sorted = sort(ones)\n\
    \    \n    sorted_arr = zeros(Int64, length(arr))\n    \n    for i = 1:length(arr)\n\
    \        sorted_arr[i] = arr[ones_sorted .== i]\n    end\n    \n    return sorted_arr\n\
    end\n</cell>\n<code language=julia-1.5>\nsort_array([1, 5, 2, 3, 4])\n</cell>\n\
    <code language=julia-1.5>\nsort_array([-2, -3, -4, -5, -6])\n</cell>\n<code language=julia-1.5>\n\
    sort_array([1, 0, 2, 3, 4])\n</cell>\n<text>\nProblem 3\nImplement a function\
    \ that counts how many times each unique number appears in an array.", "    \n\
    \    ones = zeros(Int, length(arr))\n    \n    for i in eachindex(arr)\n     \
    \   ones[i] = sum(arr[i] == 1)\n    end\n    \n    sort(ones)\n    \n    return\
    \ arr\nend\n</cell>\n<code language=julia-1.5>\nsort_array([1, 5, 2, 3, 4])\n\
    </cell>\n<code language=julia-1.5>\nsort_array([-2, -3, -4, -5, -6])\n</cell>\n\
    <code language=julia-1.5>\nsort_array([1, 0, 2, 3, 4])\n</cell>\n<text>\nPart\
    \ III: Binary Search Algorithm\nIn this Kata, you have to implement binary search\
    \ algorithm to find if an element is present in a sorted array.", "    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    \n    ones = zeros(Int64, length(arr))\n\
    \    ones[arr .== 1] = 1\n    \n    sorted = zeros(Int64, length(arr))\n    \n\
    \    sorted[ones .== 1] = arr[ones .== 1]\n    \n    sorted[ones .!= 1] = arr[ones\
    \ .!= 1]\n    \n    sorted\nend\n</cell>\n<code language=julia-1.5>\n@assert sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@assert sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n@assert sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n\
    </cell>\n<text>\nPart II: Binary Search\nNow that you have implemented the binary\
    \ search algorithm, you can test it against the previous one. Remember that binary\
    \ search is really just a special case of binary search, where you only have to\
    \ search for the middle element of the array. Thus, you can use the binary search\
    \ algorithm to find the first and last elements of the array, and then use linear\
    \ search to find the middle element.", "    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    ones = zeros(Int64, length(arr))\n    ones[arr\
    \ .== 1] = 1\n    \n    sorted = sort(ones)\n    \n    sorted[sorted .== 0] =\
    \ -99\n    \n    return sorted\nend\n</cell>\n<code language=julia-1.0>\n@test\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3, -4,\
    \ -5, -6]) == [-6, -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 3, 4]\n</cell>\n<text>\nProblem 4\nImplement a function that returns the\
    \ number of ones in an integer.", "    \n    ones = zeros(Int, length(arr))\n\
    \    ones[arr .== 1] = 1\n    \n    sorted_arr = zeros(Int, length(arr))\n   \
    \ \n    for i = 1:length(arr)\n        sorted_arr[i] = arr[ones[i]]\n    end\n\
    \    \n    return sorted_arr\nend\n</cell>\n<code language=julia-1.5>\n@test sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3, -4, -5, -6]) == [-6,\
    \ -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the number of ones in the binary\
    \ representation of an integer.", "    \n    ones = zeros(Int64, length(arr))\n\
    \    ones[arr .!= 0] = 1\n    \n    sorted_arr = zeros(Int64, length(arr))\n \
    \   \n    sorted_arr .= arr\n    \n    ones_idx = findall(ones .== 1)\n    \n\
    \    sorted_arr[ones_idx] .= sort(arr[ones_idx])\n    \n    sorted_arr[ones_idx]\
    \ .= ones[ones_idx]\n    \n    return sorted_arr\nend\n</cell>\n<code language=julia-1.5>\n\
    @test sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n</cell>\n<text>\nPart II: Binary Search Algorithm\nIn this Kata,\
    \ you have to implement binary search algorithm for searching in\nsorted array\
    \ of non-negative integers. Binary search algorithm is very useful for\nsearching\
    \ sorted arrays of non-negative integers because it is very efficient.", "   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    ones = zeros(Int64,\
    \ length(arr))\n    ones[arr .== 1] = 1\n    \n    sorted_arr = zeros(Int64, length(arr))\n\
    \    \n    for i = 1:length(arr)\n        sorted_arr[i] = maximum(ones[arr .==\
    \ i])\n    end\n    \n    return sorted_arr\nend\n</cell>\n<text>\nSolution\n\
    Let's test your function with the test cases:"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
