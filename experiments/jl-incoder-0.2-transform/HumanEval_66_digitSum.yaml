name: HumanEval_66_digitSum
language: jl
prompt: "\"\"\"Task\n    Write a function that takes a string as input and returns\
  \ the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n   \
  \ >>> digitSum(\"\")\n    0\n    >>> digitSum(\"abAB\")\n    131\n    >>> digitSum(\"\
  abcCd\")\n    67\n    >>> digitSum(\"helloE\")\n    69\n    >>> digitSum(\"woArBld\"\
  )\n    131\n    >>> digitSum(\"aAaaaXa\")\n    153\n    \"\"\"\nfunction digitSum(s::String)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = digitSum;\n\t@test(candidate(\"\
  \") == 0)\n\t@test(candidate(\"abAB\") == 131)\n\t@test(candidate(\"abcCd\") ==\
  \ 67)\n\t@test(candidate(\"helloE\") == 69)\n\t@test(candidate(\"woArBld\") == 131)\n\
  \t@test(candidate(\"aAaaaXa\") == 153)\n\t@test(candidate(\" How are yOu?\") ==\
  \ 151)\n\t@test(candidate(\"You arE Very Smart\") == 327)\nend\n"
completions: ["    sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n    \
    \        sum += c.codePointAt(0)\n    return sum\n</code>\n<|/ a tags=string,haskell,ascii\
    \ |>\n<| c |>\nThanks for the answer! I didn't know about `codePointAt`, but this\
    \ looks very useful. I'm going to try this out and see how it works.\n<|/ c |>\n\
    <| c |>\n`codePointAt` was introduced in `Data.Char`, which is part of the base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base\
    \ libraries.  It was introduced in `base-4.9.0.0`, which is part of the GHC base ",
  "    sum::Int64 = 0\n    for c in s\n        if c >= '0' and c <= '9'\n        \
    \    sum += c - '0'\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"\
    abAB\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abcCd\")\n</cell>\n<code\
    \ language=julia-1.5>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string as input\
    \ and returns the sum of the digits in that string.", "    sum::Int64 = 0\n  \
    \  for c in s:\n        if c.isUpper():\n            sum += c.codePointAt(0)\n\
    \    return sum\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\ndef digitSum(s):\n\
    \    sum = 0\n    for c in s:\n        if c.isupper():\n            sum += ord(c.lower())\
    \ - ord('A')\n    return sum\n</code>\n<|/ a tags=string,haskell,functional-programming\
    \ |>\n<| c |>\nThis doesn't work. `ord` takes an argument of type `Char`, not\
    \ `String`.\n<|/ c |>\n<| c |>\nThis doesn't work either. `ord` takes an argument\
    \ of type `Char`, not `String`.\n<|/ c |>\n<| c |>\nIt does work, if you change\
    \ `ord` to `ord` as I did.\n<|/ c |>\n<| c |>\nIt does work, if you change `ord`\
    \ to `ord` as I did.\n<|/ c |>\n<| c |>\nIt does work, if you change `ord` to\
    \ `ord` as I did.\n<|/ c |>\n<| a |>\n<code>\ndigitSum :: String -> Int\ndigitSum\
    \ s = sum (map ord $ filter (\\c -> isUpper c) s)\n</code>\n<|/ a tags=string,haskell,functional-programming\
    \ dscore=0 |>\n<| c |>\nThis doesn't work. `ord` takes an argument of type `Char`,\
    \ not `String`.\n<|/ c |>\n<| c |>\nThis doesn't work either. `ord` takes an argument\
    \ of type `Char`, not `String`.\n<|/ c |>\n<| c |>\nThis doesn't work either.\
    \ `ord` takes an argument of type `Char`, not `String`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work either. `ord` takes an argument of type `Char`, not `String`.\n\
    <|/ c |>\n<| a tags=string,haskell,functional-programming |>\n<code>\nimport Data.Char",
  "    sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n            sum +=\
    \ c.codePointAt(0)\n    return sum\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,haskell,functional-programming\
    \ |>\n<code>\nimport Data.Char", "    sum::Int64 = 0\n    for c in s\n       \
    \ if ('A' <= c && c <= 'Z')\n            sum += c - 'A' + 1\n        else if ('a'\
    \ <= c && c <= 'z')\n            sum += c - 'a' + 1\n        else if ('0' <= c\
    \ && c <= '9')\n            sum += c - '0'\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.3>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.3>\ndigitSum(\"\
    abAB\")\n</cell>\n<code language=julia-1.3>\ndigitSum(\"abcCd\")\n</cell>\n<code\
    \ language=julia-1.3>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.3>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.3>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise\nWrite a function that takes a string as input and\
    \ returns the sum of the upper characters only'\nASCII codes.", "    if s == \"\
    \"\n        0\n    else\n        sum = 0\n        for c in s\n            if isUpper\
    \ c\n                sum += toUpper c\n            else\n                sum +=\
    \ toLower c\n        sum\nend\n</cell>\n<code language=julia-1.0>\ndigitSum(\"\
    \")\n</cell>\n<code language=julia-1.0>\ndigitSum(\"abAB\")\n</cell>\n<code language=julia-1.0>\n\
    digitSum(\"abcCd\")\n</cell>\n<code language=julia-1.0>\ndigitSum(\"helloE\")\n\
    </cell>\n<code language=julia-1.0>\ndigitSum(\"woArBld\")\n</cell>\n<code language=julia-1.0>\n\
    digitSum(\"aAaaaXa\")\n</cell>\n<text>\nExercise: Write a function that takes\
    \ a string as input and returns the sum of the numbers in the string.", "    sum::Int64\
    \ = 0\n    for c in s:\n        if c.isUpper():\n            sum += c.codePointAt(0)\n\
    \    return sum\n</code>\n<|/ a tags=string,haskell,ascii |>\n<| c |>\nThis doesn't\
    \ work. `digitSum(\"aAaaaXa\")` returns `153` instead of `131`.\n<|/ c |>\n<|\
    \ c |>\n: I missed that requirement. Fixed now.\n<|/ c |>\n<| c |>\nThis still\
    \ doesn't work. `digitSum(\"aAaaaXa\")` returns `153` instead of `131`.\n<|/ c\
    \ |>\n<| c |>\n: I missed that requirement. Fixed now.\n<|/ c |>\n<| c |>\nThis\
    \ still doesn't work. `digitSum(\"aAaaaXa\")` returns `153` instead of `131`.\n\
    <|/ c |>\n<| a dscore=3 |>\nThe other answers here are all great, but I thought\
    \ I'd add my own solution, which is based on a combination of Data.Char from the\
    \ standard library, and Data.Text from the text library. \n<code>\nimport Data.Char\n\
    import Data.Text", "    sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n\
    \            sum += c.codePointAt(0)\n    return sum\n</code>\n<|/ a tags=string,haskell\
    \ |>\n<| c |>\nThis doesn't work for `digitSum(\"aAaaaXa\")` which should return\
    \ 153\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll edit my answer.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution that doesn't require\
    \ any imports.\n<|/ c |>\n<| a tags=string,haskell |>\nHere's a solution without\
    \ imports:\n<code>\nimport Data.Char", "    sum::Int64 = 0\n    for c in s:\n\
    \        if c.isUpper():\n            sum += c.codePointAt(0)\n    return sum\n\
    </code>\n<|/ a tags=string,haskell,functional-programming |>\n<| c |>\nThis doesn't\
    \ answer the question, which is about how to do this in Haskell, not how to do\
    \ it in a different language.\n<|/ c |>\n<| c |>\nI agree with you. My answer\
    \ was more about how to do this in Haskell and I thought it would be useful to\
    \ share the code with others. I edited my answer to make it more clear.\n<|/ c\
    \ |>\n<| a tags=string,haskell,functional-programming |>\n<code>\nimport Data.Char",
  "    sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n            sum +=\
    \ c.codePointAt(0)\n    return sum\n</code>\n<|/ a tags=string,haskell,ascii |>\n\
    <| c |>\n`digitSum = sum . filter (\\c -> isUpper c)`\n<|/ c |>\n<| c |>\n`digitSum\
    \ = sum . filter (\\c -> isUpper c)` - this one looks very nice.\n<|/ c |>\n<|\
    \ a dscore=4 |>\nThe other answers here are great, but I wanted to add that you\
    \ can also use Data.Char's toUpper to convert a character to a character code.\
    \ \n<code>\ndigitSum :: String -> Int\ndigitSum s = sum $ map toUpper s\n</code>\n\
    <|/ a tags=string,haskell,ascii |>\n<| a dscore=4 |>\n<code>\ndigitSum :: String\
    \ -> Int\ndigitSum s = sum $ map toUpper s\n</code>\n<|/ a tags=string,haskell,ascii\
    \ |>\n<| a dscore=3 |>\n<code>\ndigitSum :: String -> Int\ndigitSum s = sum $\
    \ map toUpper s\n</code>\n<|/ a tags=string,haskell,ascii |>\n<| a |>\n<code>\n\
    digitSum :: String -> Int\ndigitSum s = sum $ map toUpper s\n</code>\n<|/ a tags=string,haskell,ascii\
    \ dscore=3 |>\n<| a tags=string,haskell,ascii |>\n<code>\ndigitSum :: String ->\
    \ Int\ndigitSum s = sum $ map toUpper s\n</code>\n<|/ a dscore=3 |>\n<| a tags=string,haskell,ascii\
    \ |>\n<code>\ndigitSum :: String -> Int\ndigitSum s = sum $ map toUpper s\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=string,haskell,ascii |>\n<code>\ndigitSum :: String\
    \ -> Int\ndigitSum s = sum $ map toUpper s\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3\
    \ |>\n<code>\ndigitSum :: String -> Int\ndigitSum s = sum $ map toUpper s\n</code>\n\
    <|/ a tags=string,haskell,ascii |>\n<| a |>\n<code>\ndigitSum :: String -> Int\n\
    digitSum s = ", "    sum = 0\n    for c in s:\n        if c.isUpper():\n     \
    \       sum += c.codePointAt(0)\n    return sum\n</code>\n<|/ a tags=string,haskell,ascii\
    \ |>\n<| c |>\nThe `sum` function can be replaced by `foldl (+) 0`.\n<|/ c |>\n\
    <| c |>\n: Yes, but `foldl` has some nice properties that `sum` doesn't, like\
    \ being strict in its arguments and being strict in its return type.\n<|/ c |>\n\
    <| c |>\n: I agree with you, but I find `foldl` easier to read and understand.\n\
    <|/ c |>\n<| c |>\n: I agree with you, but I find `foldl` easier to read and understand.\n\
    <|/ c |>\n<| c |>\n: I agree with you, but I find `foldl` easier to read and understand.\n\
    <|/ c |>\n<| a tags=string,haskell,ascii |>\nHere's a solution that doesn't use\
    \ any libraries:\n<code>\nimport Data.Char", "    sum::Int64 = 0\n    for c in\
    \ s do\n        if c >= 'A' and c <= 'Z' then \n            sum += c - 'A' + 10\n\
    \        else \n            sum += c\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-1.5>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string as input\
    \ and returns the number of characters in the string that are uppercase letters.",
  "    if s == \"\"\n        0\n    else\n        sum = 0\n        for c in s\n  \
    \          if c >= '0' and c <= '9'\n                sum += c - '0'\n        \
    \    else\n                sum\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abAB\")\n</cell>\n\
    <code language=julia-1.5>\ndigitSum(\"abcCd\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"woArBld\"\
    )\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string as input and returns the number\
    \ of characters in the string.", "    sum::Int64 = 0\n    for c in s:\n      \
    \  if c.isUpper():\n            sum += c.codePointAt(0)\n    return sum\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\ndef digitSum(s:String)::Int64\n \
    \   sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n            sum\
    \ += c.codePointAt(0)\n    return sum\n</code>\n<|/ a tags=haskell,string,ascii\
    \ |>\n<| a tags=haskell,string,ascii |>\n<code>\nimport Data.Char", "    digitSum\
    \ = 0\n    for c in s\n        if c.isUpper\n            digitSum += c.codePointAt(0)\n\
    \    return digitSum\n</code>\n<|/ a tags=string,haskell |>\n<| c |>\nI like this\
    \ solution, although it might be worth pointing out that `digitSum` can be implemented\
    \ as `sum . filter (\\c -> isUpper c)`.\n<|/ c |>\n<| c |>\nYes, that's a good\
    \ point. I was trying to keep it close to the original code as much as possible.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nimport Data.Char\nimport Data.List", "   \
    \ if s == \"\"\n        0\n    else\n        sum = 0\n        for c in s\n   \
    \         if c >= '0' && c <= '9'\n                sum += c - '0'\n          \
    \  else\n                sum += c - 'A' + 10\n        end\n        sum\nend\n\
    </cell>\n<code language=julia-1.3>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.3>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-1.3>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-1.3>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.3>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.3>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise\nWrite a function that takes a string as input and\
    \ returns the sum of the upper characters only'\nASCII codes.", "    sum::Int64\
    \ = 0\n    for c in s:\n        if c.isUpper():\n            sum += c.codePointAt(0)\n\
    \    return sum\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `digitSum(\"\
    aAaaaXa\")` returns `153` instead of `131`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've updated the answer to include a more robust solution.\n<|/ c |>\n\
    <| c |>\nThis doesn't work. `digitSum(\"aAaaaXa\")` returns `153` instead of `131`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've updated the answer to include a more\
    \ robust solution.\n<|/ c |>\n<| a tags=string,haskell,functional-programming\
    \ |>\n<code>\ndigitSum :: String -> Int\ndigitSum s = sum $ map (ord '0') s\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `digitSum(\"aAaaaXa\"\
    )` returns `153` instead of `131`.\n<|/ c |>\n<| c |>\nI see what you mean. I've\
    \ updated the answer to include a more robust solution.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nimport Data.Char", "    sum::Int64 = 0\n    for c in s:\n      \
    \  if c.isUpper():\n            sum += c.codePointAt(0)\n    return sum\nend",
  "    sum::Int64 = 0\n    for c in s\n        if ('A' <= c && c <= 'Z')\n       \
    \     sum += c - 'A' + 1\n        else\n            sum += c\n    return sum\n\
    end", "    if s == \"\"\n        0\n    else\n        sum(map(ord, filter(c =>\
    \ c >= 'a' && c <= 'z', s)))\nend\n</cell>\n<code language=julia-1.0>\ndigitSum(\"\
    \")\n</cell>\n<code language=julia-1.0>\ndigitSum(\"abAB\")\n</cell>\n<code language=julia-1.0>\n\
    digitSum(\"abcCd\")\n</cell>\n<code language=julia-1.0>\ndigitSum(\"helloE\")\n\
    </cell>\n<code language=julia-1.0>\ndigitSum(\"woArBld\")\n</cell>\n<code language=julia-1.0>\n\
    digitSum(\"aAaaaXa\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a string as input and returns the sum of the digits in that string."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
