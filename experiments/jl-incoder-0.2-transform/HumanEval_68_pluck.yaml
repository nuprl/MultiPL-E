name: HumanEval_68_pluck
language: jl
prompt: "\"\"\"\n    \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given array is empty, return\
  \ [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n    [2, 1]\n    Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n\
  \    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n  \
  \  []\n    \n    Example 4:\n    >>> pluck([5, 0, 3, 0, 4, 2])\n    [0, 1]\n   \
  \ Explanation: 0 is the smallest value, but  there are two zeros,\n            \
  \     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\
  \        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction\
  \ pluck(arr::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
  \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1,\
  \ 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t\
  @test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
  end\n"
completions: ["    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64\
    \ = 1\n    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n  \
    \          if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = smallest_index + 1\n            end\n      \
    \  end\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 7\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values.", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    \n    if smallest_index == 0 \n        smallest_value\n    else\n       \
    \ smallest_value\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value\
    \ = min(even_values)\n    smallest_index = index(even_values, smallest_value)\n\
    \    \n    if smallest_index == -1\n        return [] \n    end\n    \n    smallest_value\
    \ = arr[smallest_index]\n    \n    if smallest_value % 2 == 0\n        return\
    \ smallest_value, smallest_index\n    else\n        smallest_index -= 1\n    \
    \    smallest_value = arr[smallest_index]\n        \n        if smallest_value\
    \ % 2 == 0\n            return smallest_value, smallest_index\n        else\n\
    \            smallest_index -= 1\n            smallest_value = arr[smallest_index]\n\
    \            \n            if smallest_value % 2 == 0\n                return\
    \ smallest_value, smallest_index\n            else\n                smallest_index\
    \ -= 1\n                smallest_value = arr[smallest_index]\n               \
    \ \n                if smallest_value % 2 == 0\n                    return smallest_value,\
    \ smallest_index\n                else\n                    smallest_index -=\
    \ 1\n                    smallest_value = arr[smallest_index]\n              \
    \      \n                    if smallest_value % 2 == 0\n                    \
    \    return smallest_value, smallest_index\n                    else\n       \
    \                 smallest_index -= 1\n                        smallest_value\
    \ = arr[smallest_index]\n                        \n                        if\
    \ smallest_value % 2 == 0\n                            return smallest_value,\
    \ smallest_index\n                        else\n                            smallest_index\
    \ -= 1\n                            smallest_value = arr[smallest_index]\n   \
    \                         \n                            if smallest_value % 2\
    \ == 0\n                                return smallest_value, smallest_index\n\
    \                            else\n                                smallest_index\
    \ -= 1\n                                smallest_value = arr[smallest_index]\n\
    \                                \n                                if smallest_value\
    \ % 2 == 0\n                                    return smallest_value, smallest_index\n\
    \                                else\n                                    smallest_index\
    \ -= 1\n                                    smallest_value = arr[smallest_index]\n\
    \                                    \n                                    if\
    \ smallest_value % 2 == 0\n                                        return smallest_value,\
    \ smallest_index\n                                    else\n                 \
    \                       smallest_index -= 1\n                                \
    \        smallest_value = arr[smallest_index]\n                              \
    \          \n                                        if smallest_value % 2 ==\
    \ 0\n                                            return smallest_value, smallest_index\n\
    \                                        else\n                              \
    \              smallest_index -= 1\n                                         \
    \   smallest_value = arr[smallest_index]\n                                   \
    \         \n                                            if smallest_value % 2\
    \ == 0\n                                                return smallest_value,\
    \ smallest_index\n                                            else\n         \
    \                                       smallest_index -= 1\n                \
    \                                smallest_value = arr[smallest_index]\n      \
    \                                          \n                                \
    \                if smallest_value % 2 == 0\n                                \
    \                    return smallest_value, smallest_index\n                 \
    \                               else\n                                       \
    \             smallest_index -= 1\n                                          \
    \          smallest_value = arr[smallest_index]\n                            \
    \                        \n                                                  \
    \  if smallest_value % 2 == 0\n                                              \
    \          return ", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value\
    \ = min(even_values)\n    smallest_index = findfirst(x -> x == smallest_value,\
    \ even_values)\n    if smallest_index == nothing\n        return Vector{Int64}()\n\
    \    else\n        return Vector{Int64}([smallest_value, smallest_index])\n  \
    \  end\nend\n</cell>\n<text>\nProblem 7\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (ie, from left to right, level by level).",
  "    \n    smalest_value = 0\n    smallest_index = 0\n    \n    for node in arr\n\
    \        if node.value % 2 == 0\n            if node.value < smalest_value\n \
    \               smalest_value = node.value\n                smallest_index = node\n\
    \            end\n        end\n    end\n    \n    if smalest_value == 0\n    \
    \    return []\n    end\n    \n    return [smalest_value, smallest_index]\nend\n\
    </cell>\n<text>\nProblem 3\nGiven an array representing a binary tree, return\
    \ the levels of the tree in order from top to bottom.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(x -> x == smallest_value, even_values)\n    \n    if smallest_index ==\
    \ -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 4\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    \n    \n    return Vector{Int64}([smallest_value, smallest_index])\nend",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = find(even_values == smallest_even_value)[1]\n    \n\
    \    if smallest_even_index == 0 \n        smallest_even_index == length(arr)\n\
    \    end\n    \n    smallest_value = arr[smallest_even_index]\n    \n    return\
    \ [smallest_value, smallest_even_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    Practice 3\nPractice 3 is more challenging than practice 2, but still interesting.\n\
    The goal is to find the smallest even value in a given array.\nThe array is represented\
    \ as a vector with non-negative integer values.\nThe function should return a\
    \ list of two elements: the smallest even value and the index of the smallest\
    \ even value.", "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    \n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = findfirst(x -> x == smallest_even_value, even_values)\n\
    \    \n    if smallest_even_index == -1\n        return Vector{Int64}()\n    \n\
    \    smallest_value = arr[smallest_even_index]\n    \n    smallest_value_and_index\
    \ = Vector{Int64}([smallest_value, smallest_even_index])\n    \n    return smallest_value_and_index\n\
    end", "    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [] \n    end\n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    return smallest_value, smallest_index\n\
    end", "    \n    smalest_value::Int64 = arr[1]\n    smalest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node % 2 == 0\n            if\
    \ node < smalest_value\n                smalest_value = node\n               \
    \ smalest_index = smalest_index + 1\n            else\n                if smalest_index\
    \ > 1\n                    return [smalest_value, smalest_index]\n           \
    \     end\n            end\n        end\n    end\n    \n    return []\nend", " \
    \   even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values) ||\
    \ length(even_values) == 0\n        return []\n    else\n        smallest_value\
    \ = min(even_values)\n        smallest_index = find(even_values == smallest_value)[1]\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Practice 3\nWrite a function that returns the number of nodes in a binary search\
    \ tree\nGiven a binary search tree with non-negative integer nodes,\nyour task\
    \ is to return the number of nodes in the tree.", "    even_values = filter(x->mod(x,2)==0,\
    \ arr)\n    if length(even_values) == 0\n        return [] \n    else\n      \
    \  smallest_even_value = min(even_values)\n        smallest_index = find(even_values==smallest_even_value,1)[1]\n\
    \        return [smallest_even_value,smallest_index]\n    end\nend\n</cell>\n\
    <text>\nProblem 7\nWrite a function that returns the number of nodes in a binary\
    \ search tree with root node root.", "    \n    even_values = filter(x -> x %\
    \ 2 == 0, arr)\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    \n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    end\n    \n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing\
    \ a branch of a tree that has non-negative integer nodes\nyour task is to pluck\
    \ one of the nodes and return it.\nThe plucked node should be the node with the\
    \ smallest odd value.\nIf multiple nodes with the same smallest odd value are\
    \ found return the node that has smallest index.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}[]\n\
    \    else\n        smallest_value = minimum(even_values)\n        smallest_index\
    \ = findfirst(x -> x == smallest_value, even_values)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree\
    \ and a number x, find the node in the tree that has value x.", "    \n    smallest_value::Int64\
    \ = arr[1]\n    smallest_index::Int64 = 1\n    \n    for node in arr[2 : end]\n\
    \        if node.value % 2 == 0\n            if smallest_value < node.value\n\
    \                smallest_value = node.value\n                smallest_index =\
    \ node.index\n            end\n        end\n    end\n    \n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<text>\nProblem 7\nWrite a function that returns\
    \ the number of nodes in a binary search tree with root node root.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n     \
    \   smallest_index = index(even_values, smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 7\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).", "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).", "    even_values = filter(x -> x % 2\
    \ == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    if smallest_index == nothing\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <text>\nProblem 8\nGiven a binary tree and a number x, return the number of nodes\
    \ in the subtree rooted at that node. If there is no such subtree, then return\
    \ 0.", "    \n    even_values = findall(x -> x % 2 == 0, arr)\n    \n    if isempty(even_values)\n\
    \        return [];\n    else\n        smallest_value = min(even_values)\n   \
    \     smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 7\n\
    Given a binary tree, return the level order traversal of its nodes' values.",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end", "    even_values = filter(x->mod(x,2)==0,\
    \ arr)\n    even_values = sort(even_values)\n    smalest_value = even_values[1]\n\
    \    smalest_index = find(even_values==smalest_value)[1]\n    return smalest_value,\
    \ smalest_index\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing\
    \ a branch of a tree that has non-negative integer nodes\nyour task is to pluck\
    \ one of the nodes and return it.\nThe plucked node should be the node with the\
    \ smallest odd value.\nIf multiple nodes with the same smallest odd value are\
    \ found return the node that has smallest index.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(x -> x == smallest_value, even_values)\n    \n    if smallest_index ==\
    \ -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 7\nGiven a binary tree and a number x, find and return the node in the\
    \ tree that has value x.", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    \n    if length(even_values) == 0\n        return [] \n    end", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = index(even_values, smallest_value)\n    return smallest_value, smallest_index\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values.", "    even_values = filter(x -> x % 2 == 0, arr)\n  \
    \  if length(even_values) == 0\n        return Vector{Int64}()\n    elseif length(even_values)\
    \ == 1\n        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @test pluck([4, 2, 3]) == [2, 1]\n@test pluck([1, 2, 3]) == [2, 1]\n@test pluck([])\
    \ == []\n@test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\nProblem 4\n\
    Given a binary tree and a node value, swap the node value with the node in the\
    \ tree with the same value.", "    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    if length(even_values) == 0\n        return [] \n    \n    smallest_value\
    \ = minimum(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    \n    plucked_value = arr[smallest_index]\n    return [ smallest_value, smallest_index\
    \ ]\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2,\
    \ 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\nProblem 3\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values.", "    \n    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values) == 0\n    \
    \    return Vector{Int64}()\n    end", "    \n    smalest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            if node\
    \ < smalest_value\n                smalest_value = node\n                smallest_index\
    \ = smallest_index\n            else\n                if node < smallest_index\n\
    \                    smallest_index = node\n                end\n            end\n\
    \        end\n    end\n    \n    if smallest_index == 0\n        return []\n \
    \   end\n    \n    return [smalest_value, smallest_index]\nend\n</cell>\n<text>\n\
    Problem 4\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values.", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if\
    \ length(even_values) == 0\n        return Vector{Int64}()\n    end\n    \n  \
    \  smallest_even_value = min(even_values)\n    smallest_index = find(x -> x ==\
    \ smallest_even_value, even_values)\n    \n    return Vector{Int64}([smallest_even_value,\
    \ smallest_index])\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n  \
    \  if length(even_values) == 0\n        return Vector{Int64}[]\n    elseif length(even_values)\
    \ == 1\n        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Practice 3\nLet's practice some more with some more examples. Let's try some more\
    \ examples with different input arrays.", "    even_values = filter(x -> x % 2\
    \ == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index = index(even_values,\
    \ smallest_value)\n    \n    if smallest_index == -1 || length(even_values) ==\
    \ 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 4\nGiven a binary tree\
    \ and a number x, find x with path compression.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)\n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n\
    @assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.3 Plucking all nodes with the\
    \ smallest even value", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    \n    if length(even_values) == 0\n        return []\n    end\n    \n   \
    \ smallest_value = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 4\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    \n    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    end", "    \n    even_values = filter(x -> x % 2 == 0,\
    \ arr)\n    \n    if length(even_values) == 0\n        return []\n    end\n  \
    \  \n    smallest_even_value = min(even_values)\n    smallest_even_index = findfirst(x\
    \ -> x == smallest_even_value, even_values)\n    \n    if smallest_even_index\
    \ == nothing\n        return []\n    end\n    \n    return [smallest_even_value,\
    \ smallest_even_index]\nend\n</cell>\n<text>\nProblem 3\nGiven an array of integers\
    \ representing a binary tree, return the sum of all nodes values.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_even_value, even_values)\n \
    \       return [smallest_even_value, smallest_index]\n    end\nend\n</cell>\n\
    <text>\nSolution\nLet's see how we solve this problem by implementing our own\
    \ version of pluck.", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    if length(even_values) == 0\n        return Vector{Int64}()\n    end\n  \
    \  \n    smallest_even_value = minimum(even_values)\n    smallest_even_index =\
    \ findfirst(x -> x == smallest_even_value, even_values)\n    \n    smallest_value\
    \ = arr[smallest_even_index]\n    \n    return smallest_value, smallest_even_index\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n\
    @assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.3 Plucking all even values\nGiven\
    \ an array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck all of the nodes and return them in a list.\nThe plucked\
    \ nodes should be the nodes with the smallest even value.\nIf multiple nodes with\
    \ the same smallest even value are found return the node that has smallest index.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values) ||\
    \ length(even_values) == 0\n        return Vector{Int64}()\n    else\n       \
    \ smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing a branch of\
    \ a tree that has non-negative integer nodes\nyour task is to pluck one of the\
    \ nodes and return it.\nThe plucked node should be the node with the smallest\
    \ odd value.\nIf multiple nodes with the same smallest odd value are found return\
    \ the node that has smallest index.", "    even_values = filter(x -> x % 2 ==\
    \ 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n \
    \   else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(even_values == smallest_value)[1]\n        return [ smallest_value, smallest_index\
    \ ]\n    end\nend\n</cell>\n<text>\nProblem 8\nGiven an array representing a binary\
    \ tree, return the sum of the values of the nodes in that tree.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_index == 0 \n\
    \        smallest_value = arr[smallest_index]\n        smallest_index = 1\n  \
    \  end\n    \n    return smallest_value, smallest_index\nend\n</cell>\n<text>\n\
    Problem 3\nGiven an array representing a branch of a tree that has non-negative\
    \ integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked\
    \ node should be the node with the smallest odd value.\nIf multiple nodes with\
    \ the same smallest odd value are found return the node that has smallest index.",
  "    largest = minimum(arr)\n    smallest = maximum(arr)\n    even = filter(x ->\
    \ x % 2 == 0, arr)\n    \n    if length(even) == 0 || length(even) == length(arr)\n\
    \        return largest, smallest\n    end", "    even_values = filter(x -> x\
    \ % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    elseif length(even_values) == 1\n        return even_values\n    else\n \
    \       smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return smallest_value, smallest_index\n    end\n\
    end\n</cell>\n<text>\nProblem 7\nGiven a binary tree and a number x, return the\
    \ path from the root to the node with value x.", "    largest = arr[1]\n    smallest\
    \ = arr[1]\n    smallest_index = 2\n    largest_index = 1\n    \n    for index\
    \ in 2:length(arr)\n        if arr[index] >= largest\n            largest = arr[index]\n\
    \            largest_index = index\n        elseif arr[index] < smallest\n   \
    \         smallest = arr[index]\n            smallest_index = index\n        end\n\
    \    end\n    \n    if smallest == largest\n        return smallest_index\n  \
    \  else\n        return [smallest, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_index == 0 \n\
    \        smallest_index = 1\n    end\n    \n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a node value, swap the\
    \ node value with the node that results from traveling down the tree starting\
    \ from the given node. Return the new tree.", "    even_values = filter(x -> x\
    \ % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}[]\n\
    \    else\n        smallest_even_value = min(even_values)\n        smallest_index\
    \ = find(even_values == smallest_even_value) + 1\n        return [smallest_even_value,\
    \ smallest_index]\n    end\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    \n    if smallest_index == length(arr)\n        return\
    \ Vector{Int64}()\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if\
    \ length(even_values) == 0\n        return Vector{Int64}()\n    end\n    \n  \
    \  smallest_even_value = min(even_values)\n    smallest_even_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    even_values = filter(x -> x\
    \ % 2 == 0, arr)\n    \n    if isempty(even_values)\n        return []\n    else\n\
    \        smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (ie, from left to right, level by level).",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n\
    \        return Vector{Int64}()\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_even_value) + 1\n     \
    \   return [ smallest_even_value, smallest_index ]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree and a node value, swap the node value with the\
    \ node that results from traversing the tree to that node. Return the new tree.",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end", "    even_values = filter(x -> x % 2 ==\
    \ 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}[]\n \
    \   else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    return smallest_value, smallest_index\nend", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n       \
    \ return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    4.3 Plucking from a dictionary\nGiven a dictionary representing a tree, your task\
    \ is to pluck one of the nodes and return it.\nThe plucked node should be the\
    \ node with the smallest even value.\nIf multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.", "    if arr.length==0\n\
    \        return Vector{Int64}()\n    \n    even_values = filter(x -> x % 2 ==\
    \ 0, arr)\n    \n    if even_values.length==0\n        return Vector{Int64}()\n\
    \    \n    smallest_even_value = min(even_values)\n    smallest_even_index = find(x\
    \ -> x == smallest_even_value, even_values)\n    \n    if smallest_even_index==0\n\
    \        return Vector{Int64}()\n    \n    smallest_value = arr[smallest_even_index]\n\
    \    \n    smallest_value_index = find(x -> x == smallest_value, arr)\n    \n\
    \    if smallest_value_index==0\n        return Vector{Int64}()\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smallest_value_index\
    \ - 1\n    \n    smallest_value_index = smallest_value_index - 1\n    \n    smallest_value_index\
    \ = smallest_value_index - 1\n    \n    smallest_value_index = smalle", "    \n\
    \    smallest_value = minimum(arr)\n    smallest_index = find(arr == smallest_value)\n\
    \    \n    if smallest_index == -1 || smallest_value == 0\n        return [] \n\
    \    end\n    \n    smallest_value % 2 == 0 ? smallest_index : smallest_index\
    \ - 1\nend\n</cell>\n<text>\nProblem 7\nGiven an array representing a binary tree,\
    \ return the number of nodes in the tree.", "    even_values = filter(x -> x %\
    \ 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}[]\n\
    \    else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (ie, from left to right, level by level).",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x -> x == smallest_even_value,\
    \ even_values)\n    \n    if smallest_index == nothing\n        return Vector{Int64}()\n\
    \    end\n    \n    return [smallest_even_value, smallest_index]\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1,\
    \ 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n</cell>\n<text>\nProblem 7: Plucking from the Array\nWrite a function\
    \ pluck_array that takes in an array of non-negative integers and returns the\
    \ smallest even number and the index of the smallest even number.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_index == 0 \n\
    \        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values.", "    even_values = filter(x -> x % 2 == 0, arr)\n  \
    \  smallest_value = min(even_values)\n    smallest_index = find(x -> x == smallest_value,\
    \ even_values)\n    if smallest_index == -1 || length(even_values) == 0\n    \
    \    return Vector{Int64}()\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing a binary\
    \ tree, return the height of the tree.", "    even_values = filter(x -> x % 2\
    \ == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}[]\n\
    \    elseif length(even_values) == 1\n        return even_values\n    else\n \
    \       smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nProblem 7\nGiven an array representing a binary tree,\
    \ return the levels of the tree in sorted order.", "    if arr.length == 0 \n\
    \        return [] \n    \n    even_values = filter(x -> x % 2 == 0, arr) \n \
    \   \n    if even_values.length == 0 \n        return [] \n    \n    smallest_value\
    \ = min(even_values) \n    smallest_index = even_values.index(smallest_value)\
    \ \n    \n    return [smallest_value, smallest_index] \nend\n</cell>\n<text>\n\
    Problem 4\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (i.e., the in-order traversal of its nodes' values.)", "    \n    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\nSolution\n\
    Let's see how we could solve this problem by implementing our own version of pluck.",
  "    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    \n\
    \    for node in arr[2:end]\n        if node.value % 2 == 0\n            smallest_value\
    \ = node.value\n            smallest_index = node.index\n        end\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\nSolution\n\
    Let's see how we could solve this problem by hand.", "    \n    even_values =\
    \ filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ [] \n    end\n    \n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    \n    return [ smallest_value,\
    \ smallest_index ]\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a\
    \ number x, your task is to find the node in the tree that has value x. \nIf the\
    \ node doesn't exist, return nil.", "    evens = filter(x -> x % 2 == 0, arr)\n\
    \    evens = sort(evens)\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[", "  \
    \  even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n\
    \        return Vector{Int64}()\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_even_index = find(even_values == smallest_even_value)\n    \
    \    return [smallest_even_value,smallest_even_index]\n    end\nend\n</cell>\n\
    <text>\nProblem 7\nGiven an array of integers, find the node with the smallest\
    \ value.", "    evens = arr.filter(x -> x % 2 == 0)\n    if length(evens) == 0\n\
    \        return [] \n    smallest_even = minimum(evens)\n    smallest_index =\
    \ index(evens, smallest_even)\n    smallest_value = arr[smallest_index]\n    return\
    \ smallest_value, smallest_index\nend", "    even_values = filter(x -> x % 2 ==\
    \ 0, arr)\n    smallest_value = min(even_values)\n    smallest_index = find(x\
    \ -> x == smallest_value, even_values)\n    \n    if smallest_index == -1 || length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 4\nGiven a binary tree\
    \ and a number x, your task is to find the node in the tree that has value x.\
    \ \nIf the node does not exist, return nil.", "    even_values = filter(x -> x\
    \ % 2 == 0, arr)\n    if length(even_values) == 0\n        return [] \n    \n\
    \    smallest_value = min(even_values)\n    smallest_index = index(even_values,\
    \ smallest_value)\n    \n    return smallest_value, smallest_index\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x->mod(x,2) == 0, arr)\n    smallest_value = min(even_values)\n   \
    \ smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return [] \n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 7\nGiven a binary tree and a number k,\
    \ find the kth smallest element in the tree.", "    even_values = filter(x ->\
    \ x % 2 == 0, arr)\n    if length(even_values) == 0\n        return [] \n    end\n\
    \    smallest_even_value = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n    if smallest_index == nothing\n        return [] \n    end\n\
    \    return [ smallest_even_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    4.4 Plucking all nodes with the smallest even value", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return [] \n    end\n\
    \    smallest_value = min(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    return [smallest_value, smallest_index]\nend", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n     \
    \   smallest_index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).", "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n    \n    if smallest_index == nothing\n        return Vector{Int64}()\n\
    \    end\n    \n    return [smallest_even_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 3\nGiven an array representing a branch of a tree that has non-negative\
    \ integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked\
    \ node should be the node with the smallest odd value.\nIf multiple nodes with\
    \ the same smallest odd value are found return the node that has smallest index.",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return []\n    else\n        smallest_value = min(even_values)\n    \
    \    smallest_index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree\
    \ and a number x, find the node in the tree with the value closest to x.", " \
    \   even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) ==\
    \ 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).", "    \n    smallest_value::Int64 = Inf\
    \ \n    smallest_index::Int64 = Inf \n    \n    for i in arr \n        if smallest_value\
    \ < i \n            smallest_value = i \n            smallest_index = i \n   \
    \     else \n            if smallest_value == i \n                smallest_index\
    \ += 1\n            end \n        end \n    end \n    \n    if smallest_value\
    \ == Inf \n        return [] \n    end \n    \n    return [smallest_value, smallest_index]\
    \ \nend \n</cell>\n<code language=julia-1.5>\n# Test your function above\narr\
    \ = [4, 2, 3]\n@assert pluck(arr) == [2, 1]\narr = [1, 2, 3]\n@assert pluck(arr)\
    \ == [2, 1]\narr = []\n@assert pluck(arr) == []\narr = [5, 0, 3, 0, 4, 2]\n@assert\
    \ pluck(arr) == [0, 1]\n</cell>\n<text>\n4.4 Plucking Elements from an Array\n\
    Given an array arr of positive integers, return the elements of the array in sorted\
    \ order.", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    return smallest_value, smallest_index\nend", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return []\n  \
    \  smallest_value = min(even_values)\n    smallest_index = find(even_values ==\
    \ smallest_value)[1]\n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(x -> x == smallest_value, even_values)\n    if smallest_index == -1 ||\
    \ length(even_values) == 0\n        return Vector{Int64}()\n    else\n       \
    \ return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem\
    \ 3\nGiven an array representing a branch of a tree that has non-negative integer\
    \ nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node\
    \ should be the node with the smallest odd value.\nIf multiple nodes with the\
    \ same smallest odd value are found return the node that has smallest index.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n \
    \       return [] \n    end\n    smallest_even_value = min(even_values)\n    smallest_index\
    \ = find(x -> x == smallest_even_value, even_values)\n    return [smallest_even_value,\
    \ smallest_index]\nend", "    evens = filter(x -> x % 2 == 0, arr)\n    evens\
    \ = sort(evens)\n    evens = evens[2:end]\n    evens = evens[findall(x -> x ==\
    \ 0, evens)]\n    if isempty(evens)\n        return []\n    else\n        return\
    \ evens\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a number\
    \ x, your task is to find the node in the tree with value closest to x.", "  \
    \  even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven an array representing a binary tree, return the levels of the\
    \ tree in order from top to bottom.", "    evens = filter(x -> x % 2 == 0, arr)\n\
    \    evens = sort(evens)\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[", "  \
    \  even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(arr) == 0\n        return Vector{Int64}()\n    end\n    \n \
    \   return smallest_value, smallest_index\nend\n</cell>\n<text>\nSolution\nLet's\
    \ see how we solve this problem. First we define our helper functions:", "   \
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \    \n    if smallest_even_index == 0 \n        return [] \n    else\n      \
    \  return smallest_even_value,smallest_even_index\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree and a number x, find the path from the root to\
    \ the node with value x.", "    even_values = filter(x -> x % 2 == 0, arr)\n \
    \   smallest_value = min(even_values)\n    smallest_index = find(x -> x == smallest_value,\
    \ even_values)\n    smallest_value = arr[smallest_index]\n    return smallest_value,\
    \ smallest_index\nend", "    even_values = filter(x->mod(x,2)==0, arr)\n    if\
    \ length(even_values) == 0\n        return Vector{Int64}[]\n    else\n       \
    \ smallest_even_value = min(even_values)\n        smallest_even_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n        return [smallest_even_value, smallest_even_index]\n  \
    \  end\nend\n</cell>\n<text>\nProblem 7\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (ie, from left to right, level by level).",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree and a number x, your task is to find the node in the tree\
    \ that has value x.", "    even_values = filter(x -> x % 2 == 0, arr)\n    if\
    \ length(even_values) == 0\n        return Vector{Int64}[]\n    else\n       \
    \ smallest_value = min(even_values)\n        smallest_index = find(x -> x == smallest_value,\
    \ even_values)\n        return [smallest_value, smallest_index]\n    end\nend\n\
    </cell>\n<text>\nProblem 3\nGiven a binary tree and a number k, you need to find\
    \ the kth smallest element in the tree.", "    even_values = filter(x -> x % 2\
    \ == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(even_values == smallest_value)[1]\n        return Vector{Int64}([smallest_value,\
    \ smallest_index])\n    end\nend\n</cell>\n<text>\nProblem 7\nGiven a binary tree\
    \ and a node value, swap the node value with the node in the tree that has the\n\
    smallest value in its left subtree and return that node. Do this without changing\
    \ the tree structure\nor changing the values of any nodes in any way!", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = index(even_values, smallest_value)\n    \n    if length(even_values) == 0\
    \ || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value\
    \ = smallest_value % 2\n    smallest_index = smallest_index + 1\n    \n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<text>\nProblem\
    \ 7\nGiven a binary tree, return the level order traversal of its nodes' values.\
    \ (ie, from left to right, level by level).", "    \n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    \n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([4,\
    \ 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n\
    @assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\nPractice 3\nGiven\
    \ a binary tree and a node value, return the path to the node value.", "    evens\
    \ = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[", "    even_values = filter(x -> x % 2 == 0, arr)\n    if\
    \ length(even_values) == 0\n        return [] \n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    return [smallest_value,\
    \ smallest_index]\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n   \
    \ if length(even_values) == 0\n        return Vector{Int64}()\n    else\n    \
    \    smallest_value = min(even_values)\n        smallest_index = find(x -> x ==\
    \ smallest_value, even_values)\n        return Vector{Int64}([smallest_value,\
    \ smallest_index])\n    end\nend\n</cell>\n<text>\nProblem 4\nGiven a binary tree\
    \ and a node value, swap the node value with the node in the tree that has the\n\
    smallest key greater than the given node value. If there are multiple nodes with\
    \ the\nsame smallest key value, pick the smallest key index. Return the swapped\
    \ node value in a list.", "    even_values = filter(x -> x % 2 == 0, arr)\n  \
    \  if length(even_values) == 0\n        return [] \n    else\n        smallest_value\
    \ = min(even_values)\n        smallest_index = find(even_values == smallest_value)[1]\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2,\
    \ 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\n</cell>\n<text>\nPluck all nodes with the smallest even value", "  \
    \  \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\n</cell>\n<text>\nProblem 3\nGiven\
    \ a binary tree and a node value, swap the node value with the node that results\
    \ from traveling up the tree to the node's position in the tree.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 3\nGiven an array representing a branch of a tree\
    \ that has non-negative integer nodes\nyour task is to pluck one of the nodes\
    \ and return it.\nThe plucked node should be the node with the smallest odd value.\n\
    If multiple nodes with the same smallest odd value are found return the node that\
    \ has smallest index.", "    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64\
    \ = 1\n    \n    for node in arr[2:end]\n        if node.value % 2 == 0\n    \
    \        smallest_value = node.value\n            smallest_index = node.index\n\
    \        end\n    end\n    \n    return smallest_value, smallest_index\nend\n\
    </cell>\n<text>\nProblem 3\nGiven an array representing a binary tree, return\
    \ the levels of the tree in order from top to bottom.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return [] \n \
    \   end\n    smallest_value = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\n\
    Problem 3\nGiven an array representing a binary tree where each node has at most\
    \ two children,\npluck one of the nodes and return its value.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return []\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nSolution\nLet's see how we would\
    \ solve this problem manually.", "    \n    even_values = filter(x -> x % 2 ==\
    \ 0, arr)\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    \n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    end\n    \n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n@test pluck([4, 2,\
    \ 3]) == [2, 1]\n@test pluck([1, 2, 3]) == [2, 1]\n@test pluck([]) == []\n@test\
    \ pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\nProblem 3\nGiven an array\
    \ representing a binary tree, return the levels of the tree in order of\nlevels,\
    \ where each level is an array of integers representing the number of nodes at\
    \ that level\nin the tree. \nThe array returned should be of the form [level1,\
    \ level2, ..., leveln]\nwhere level1 is the total number of nodes at level 1,\
    \ level2 is the total number of nodes at level 2, etc.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return []\n  \
    \  smalest_value = min(even_values)\n    smallest_index = index(even_values, smalest_value)\n\
    \    return [smalest_value, smallest_index]\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree and a number x, your task is to find the node in the tree\
    \ that has value x.", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value\
    \ = min(even_values)\n    smallest_index = findfirst(x->x==smallest_value, even_values)\n\
    \    if smallest_index == nothing\n        return []\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_index == 0 \n\
    \        smallest_value = arr[smallest_index]\n        smallest_index = smallest_index\n\
    \    end", "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem\
    \ 3\nGiven a binary tree, return the level order traversal of its nodes' values.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nSolution\nLet's see how we could solve this problem\
    \ by hand. Let's start with a simple case:", "    \n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return []\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend", "    if arr.length == 0 || arr.length == 1\n\
    \        return arr\n    end\n    smalest_value = arr[end]\n    smallest_index\
    \ = 0\n    smallest_even_value = smalest_value % 2 == 0\n    smallest_even_index\
    \ = findfirst(smallest_even_value)\n    if smallest_even_index == -1\n       \
    \ return arr\n    end\n    \n    for index in 1:length(arr)\n        if arr[index]\
    \ == smalest_value\n            if smallest_even_index == -1\n               \
    \ smallest_even_index = index\n            else\n                if smallest_even_index\
    \ == index\n                    smallest_even_index = index\n                else\n\
    \                    if smallest_even_index < index\n                        smallest_even_index\
    \ = index\n                    end\n                end\n            end\n   \
    \     end\n    end\n    \n    arr[smallest_even_index] = arr[end]\n    arr[end]\
    \ = smalest_value\n    return arr\nend\n</cell>\n<text>\nProblem 4\nGiven a binary\
    \ tree, return the level order traversal of its nodes' values. (ie, from left\
    \ to right, level by level).", "    evens = filter(x -> x % 2 == 0, arr)\n   \
    \ evens = sort(evens)\n    evens = evens[2:end]\n    evens = evens[2:end]\n  \
    \  evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n\
    \    evens = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[", "  \
    \  even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return smallest_value, smallest_index\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1,\
    \ 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a node value,\
    \ swap the node with that value.", "    even_values = filter(x -> x % 2 == 0,\
    \ arr)\n    if length(even_values) == 0\n        return [] \n    smalest_value\
    \ = minimum(even_values)\n    smalest_index = findfirst(x -> x == smalest_value,\
    \ even_values)\n    return [smalest_value, smalest_index]\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2,\
    \ 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\n</cell>\n<text>\n4.3 Plucking from a dictionary\nGiven a dictionary\
    \ representing a tree with non-negative integer nodes,\nyour task is to pluck\
    \ one of the nodes and return it.\nThe plucked node should be the node with the\
    \ smallest even value.\nIf multiple nodes with the same smallest even value are\
    \ found return the node that has smallest index.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return []\n  \
    \  smallest_value = min(even_values)\n    smallest_index = find(even_values ==\
    \ smallest_value)[1]\n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree and a number x, find if there exists a\
    \ path from x to any node in the tree that sums to x.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(x -> x == smallest_value, even_values)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree\
    \ and a node value, swap the node value with the node in the tree that has the\n\
    smallest key greater than or equal to the node value.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = index(even_values, smallest_value)\n    return [smallest_value, smallest_index]\n\
    end", "    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for index in 2:length(arr)\n        if arr[index] % 2 == 0\n      \
    \      if smallest_value < arr[index]\n                smallest_value = arr[index]\n\
    \                smallest_index = index\n            end\n        end\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_value == 0\n\
    \        return Vector{Int64}[]\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 4\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values.", "    \n    even_values = filter(x ->\
    \ x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        smallest_value = minimum(even_values)\n        smallest_index\
    \ = find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 8\nGiven a binary tree and a node value,\
    \ swap the node value with the node that results from traveling up the tree starting\
    \ from the given node. Return the new tree.", "    even_values = filter(x -> x\
    \ % 2 == 0, arr)\n    smallest_even_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_even_value) + 1\n    \n    if smallest_index\
    \ == length(arr)\n        smallest_index = []\n    end\n    \n    return smallest_even_value,smallest_index\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values.", "    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64\
    \ = 1\n    \n    for node in arr[2:end]\n        if node % 2 == 0\n          \
    \  if smallest_value % 2 == 0\n                smallest_value = node\n       \
    \         smallest_index = smallest_index + 1\n            else\n            \
    \    if smallest_index > 1\n                    smallest_value = node\n      \
    \              smallest_index = smallest_index + 1\n                else\n   \
    \                 smallest_value = node\n                    smallest_index =\
    \ smallest_index + 1\n                end\n            end\n        else\n   \
    \         if smallest_value % 2 == 0\n                smallest_value = node\n\
    \                smallest_index = smallest_index + 1\n            else\n     \
    \           if smallest_index > 1\n                    smallest_value = node\n\
    \                    smallest_index = smallest_index + 1\n                else\n\
    \                    smallest_value = node\n                    smallest_index\
    \ = smallest_index + 1\n                end\n            end\n        end\n  \
    \  end\n    \n    if smallest_index > 1\n        return [smallest_value, smallest_index]\n\
    \    else\n        return []\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven\
    \ a binary tree, return the level order traversal of its nodes' values. (ie, from\
    \ left to right, level by level).", "    even_values = filter(x -> x % 2 == 0,\
    \ arr)\n    if length(even_values) == 0\n        return [] \n    else\n      \
    \  smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a number x, find\
    \ all nodes in the tree that are less than or equal to x.", "    even_values =\
    \ filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    smalest_value = min(even_values)\n    smalest_index = find(even_values\
    \ == smalest_value)[1]\n    return [smalest_value, smalest_index]\nend", "   \
    \ even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Solution\nLet's see how we would solve this problem manually.", "    \n    smalest_value::Int64\
    \ = Inf \n    smallest_index::Int64 = Inf \n    \n    for node in arr \n     \
    \   if node.even? \n            if node.value < smalest_value \n             \
    \   smalest_value = node.value \n                smallest_index = node \n    \
    \        end \n        end \n    end \n    \n    if smalest_value == Inf \n  \
    \      return [] \n    end \n    \n    return [smalest_value, smallest_index]\
    \ \nend \n</cell>\n<code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2,\
    \ 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.3 Pluck all nodes with even values",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree and a number x, find all nodes in the tree that\
    \ are less than or equal to x.", "    \n    smallest_value::Int64 = arr[1]\n \
    \   smallest_index::Int64 = 1\n    \n    for node in arr[2:end]\n        if node.value\
    \ % 2 == 0\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = smallest_index + 1\n        \
    \    end\n        end\n    end\n    \n    return smallest_value::Vector{Int64},\
    \ [smallest_index, smallest_value] \nend\n</cell>\n<text>\nProblem 4\nGiven an\
    \ array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck one of the nodes and return it.\nThe plucked node should\
    \ be the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    elseif length(even_values) == 1\n        return even_values\n\
    \    else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(x -> x == smallest_value, even_values)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).", "    \n    smalest_value = Int64(0)\n    smallest_index =\
    \ Int64(0)\n    \n    for node in arr\n        if node.value % 2 == 0\n      \
    \      if node.value < smalest_value\n                smalest_value = node.value\n\
    \                smallest_index = node\n            end\n        end\n    end\n\
    \    \n    if smalest_value == 0\n        return []\n    end\n    \n    return\
    \ [smalest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>", " \
    \   evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens =\
    \ evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[", "    even_values = filter(x -> x % 2 ==\
    \ 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n \
    \   else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 8\nGiven a binary tree and a number x,\
    \ find all nodes in the tree that are less than or equal to x.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ []\n    else\n        smallest_value = min(even_values)\n        smallest_index\
    \ = find(x -> x == smallest_value, even_values)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n \
    \   if length(even_values) == 0\n        return [] \n    end\n    \n    smallest_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    \n    if smallest_index == nothing\n        return [] \n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).", "    \n    even_values =\
    \ filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ [] \n    end\n    \n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    \n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([4, 2,\
    \ 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n\
    @assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.3 Plucking all\
    \ nodes with even values", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    \n    if length(even_values) == 0\n        return Vector{Int64}()\n    end",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n\
    \        return [] \n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_even_value) \n        return\
    \ [smallest_even_value,smallest_index]\n    end\nend\n</cell>\n<text>\nProblem\
    \ 4\nGiven a binary tree and a number x, find all nodes in the tree that are less\
    \ than or equal to x.", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    \n    if length(even_values) == 0\n        return Vector{Int64}()\n    end",
  "    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    \n\
    \    for node in arr[2:end]\n        if node < smallest_value\n            smallest_value\
    \ = node\n            smallest_index = smallest_index + 1\n        end\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend", "    \n    smallest_value::Int64\
    \ = arr[1]\n    smallest_index::Int64 = 1\n    \n    for node in arr[2:end]\n\
    \        if node.value % 2 == 0\n            if node.value < smallest_value\n\
    \                smallest_value = node.value\n                smallest_index =\
    \ smallest_index + 1\n            else\n                if smallest_value == node.value\n\
    \                    smallest_index = smallest_index + 1\n                end\n\
    \            end\n        end\n    end\n    \n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 4\nGiven an array representing a binary tree, return\
    \ the levels of the tree in order from top to bottom. \nThe level of a node is\
    \ the number of nodes at that level. \nFor example, given the following tree:",
  "    \n    smallest_value = arr[1]\n    smallest_index = 1\n    \n    for node in\
    \ arr[2:end]\n        if node < smallest_value\n            smallest_value = node\n\
    \            smallest_index = index\n        end\n    end\n    \n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a\
    \ node value, swap the node with that value.", "    even_values = filter(x ->\
    \ x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    elseif length(even_values) == 1\n        return even_values\n    else\n \
    \       smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return Vector{Int64}([smallest_value, smallest_index])\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (i.e., the in-order traversal of its nodes'\
    \ values.)", "    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [];\n    else\n        smallest_value = min(even_values)\n   \
    \     smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nPractice 3\n\
    Let's practice your pluck function on some more test cases. Write some test cases\
    \ for pluck function and make sure your function passes them.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ []\n    smallest_value = min(even_values)\n    smallest_index = find(x -> x\
    \ == smallest_value, even_values)\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return []\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree\
    \ and a number x, find all nodes in the tree that are less than or equal to x.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ smallest_value, smallest_index\nend\n</cell>\n<text>\nProblem 3\nGiven a binary\
    \ tree, return the level order traversal of its nodes' values. (ie, from left\
    \ to right, level by level).", "    \n    even_values = filter(x -> x % 2 == 0,\
    \ arr)\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end", "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [\
    \ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    4.3 Plucking from a dictionary\nGiven a dictionary representing a tree with non-negative\
    \ integer nodes,\nyour task is to pluck one of the nodes and return it.\nThe plucked\
    \ node should be the node with the smallest even value.\nIf multiple nodes with\
    \ the same smallest even value are found return the node that has smallest index.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing\
    \ a branch of a tree that has non-negative integer nodes\nyour task is to pluck\
    \ one of the nodes and return it.\nThe plucked node should be the node with the\
    \ smallest odd value.\nIf multiple nodes with the same smallest odd value are\
    \ found return the node that has smallest index.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n       \
    \ return [smallest_value, smallest_index]\n    end\nend", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(x -> x == smallest_value, even_values)\n        return Vector{Int64}([smallest_value,\
    \ smallest_index])\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n \
    \   \n    if length(even_values) == 0\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    \n    return Vector{Int64}([smallest_value, smallest_index])\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values.", "    even_values = filter(x -> x % 2 == 0, arr)\n  \
    \  smallest_value = min(even_values)\n    smallest_index = find(even_values ==\
    \ smallest_value)[1]\n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    elseif length(even_values) == 1\n        return even_values\n\
    \    else\n        smallest_value = minimum(even_values)\n        smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([4,\
    \ 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n\
    @assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\nPractice 3\nGiven\
    \ an array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck one of the nodes and return it.\nThe plucked node should\
    \ be the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = index(even_values, smallest_value)\n    \n    if smallest_index == -1 || length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree\
    \ and a number x, your task is to find the node in the tree that has value x.",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ index]\n    end\nend\n</cell>\n<text>\nProblem 7\nWrite a function that returns\
    \ the number of nodes in a binary search tree with root node root.", "    \n \
    \   even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values) ==\
    \ 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n   \
    \     return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return Vector{Int64}([smallest_value, smallest_index])\n    end\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_even_value) + 1\n     \
    \   return [smallest_even_value,smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).", "    \n    even_values =\
    \ filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values) == 0\n      \
    \  return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend", "    if arr.length == 0 \n  \
    \      return [] \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n\
    \    if even_values.length == 0 \n        return [] \n    \n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(x -> x == smallest_value, even_values)\n\
    \    \n    return [smallest_value, smallest_index]\nend", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.0>\n@assert pluck([4, 2, 3]) == [2, 1]\n\
    @assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.3 Plucking all nodes with even\
    \ values\nGiven an array representing a branch of a tree that has non-negative\
    \ integer nodes\nyour task is to pluck all of the nodes and return them.\nThe\
    \ plucked nodes should be returned in a list, [ smalest_value, its index ],\n\
    If there are no even values or the given array is empty, return [].", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = even_values.index(smallest_even_value)\n    smallest_value\
    \ = arr[smallest_even_index]\n    \n    if smallest_even_index == 0 \n       \
    \ smallest_value = arr[smallest_even_index + 1]\n    end\n    \n    return smallest_value,\
    \ smallest_even_index\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return\
    \ the level order traversal of its nodes' values. (ie, from left to right, level\
    \ by level).", "    largest = arr[1]\n    largest_index = 1\n    smallest = arr[1]\n\
    \    smallest_index = 1\n    for node in arr[2:end]\n        if node < smallest\
    \ \n            smallest = node\n            smallest_index = largest_index\n\
    \        elseif node > largest\n            largest = node\n            largest_index\
    \ = smallest_index\n        elseif smallest_index == largest_index\n         \
    \   smallest_index += 1\n        elseif smallest_index > largest_index\n     \
    \       largest_index = smallest_index\n            smallest_index = largest_index\n\
    \        end\n    end\n    return [smallest, smallest_index]\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2,\
    \ 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\n</cell>\n<text>\nProblem 4\nWrite a function that returns the number\
    \ of nodes in the given tree.", "    \n    smallest_value::Int64 = Inf \n    smallest_index::Int64\
    \ = Inf \n    \n    for node in arr \n        if node.value % 2 == 0 \n      \
    \      if node.value < smallest_value \n                smallest_value = node.value\
    \ \n                smallest_index = node \n            end \n        end \n \
    \   end \n    \n    if smallest_value == Inf \n        return [] \n    end \n\
    \    \n    return [smallest_value, smallest_index] \nend \n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    Problem 7: Plucking from a BST\nGiven a binary search tree and a value x, your\
    \ task is to pluck one of the nodes and return it.\nThe plucked node should be\
    \ the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ [] \n    end\n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x -> x == smallest_value, even_values)\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return\
    \ the level order traversal of its nodes' values. (ie, from left to right, level\
    \ by level).", "    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_even_index = index(even_values, smallest_even_value)\n     \
    \   return smallest_even_value::Vector{Int64}([smallest_even_index])\n    end\n\
    end\n</cell>\n<text>\nProblem 7\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return\
    \ Vector{Int64}[]\n    else\n        smallest_value = minimum(even_values)\n \
    \       smallest_index = findfirst(x -> x == smallest_value, even_values)\n  \
    \      return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).", "    \n    if length(arr)\
    \ == 0 \n        return [] \n    \n    smalest_value = arr[1] \n    smalest_index\
    \ = 1\n    \n    for node in arr[2:end] \n        if node % 2 == 0 \n        \
    \    if node < smalest_value \n                smalest_value = node \n       \
    \         smalest_index = 1 \n            else \n                smalest_index\
    \ += 1\n        end \n    end \n    \n    return [smalest_value, smalest_index]\
    \ \nend \n</cell>\n<code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2,\
    \ 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n4.3 Pluck all nodes with the smallest\
    \ even value", "    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64\
    \ = 1\n    \n    for node in arr[2:end]\n        if node.value % 2 == 0\n    \
    \        if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = smallest_index + 1\n            end\n      \
    \  end\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 4\nGiven a binary tree and a node value, swap the node value with\
    \ the node in the tree that has smallest key greater than the given node value.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    \n    if length(even_values) == 0 || smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nSolution\nLet's see how we could\
    \ solve this problem using Julia's built-in high-level functionality.", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n  \
    \  \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (i.e., the in-order traversal).", "    \n    smallest_value::Int64 =\
    \ arr[1]\n    smallest_index::Int64 = 1\n    \n    for node in arr[2:end]\n  \
    \      if node.value % 2 == 0\n            if smallest_value < node.value\n  \
    \              smallest_value = node.value\n                smallest_index = smallest_index\
    \ + 1\n            else\n                smallest_value = node.value\n       \
    \         smallest_index = smallest_index\n            end\n        end\n    end\n\
    \    \n    if smallest_value == 0\n        return Vector{Int64}[]\n    end\n \
    \   \n    return Vector{Int64}[smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if length(even_values) ==\
    \ 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n       \
    \ return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nPractice\
    \ 3\nLet's practice our new skills by solving some more interesting problems.",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend", "    \n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        smallest_value = min(even_values)\n        smallest_index =\
    \ find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nSolution\nLet's see how we would solve this problem.\
    \ First let's see how we would solve it using recursion.", "    even_values =\
    \ filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.5>", "    even_values = filter(x -> x % 2\
    \ == 0, arr)\n    if length(even_values) == 0\n        return [] \n    \n    smallest_even_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_even_value)\
    \ \n    \n    return [smallest_even_value,smallest_index]\nend\n</cell>\n<text>\n\
    Solution\nLet's see how we would solve this problem with Julia.", "    \n    even_values\
    \ = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return\
    \ [];\n    else\n        smallest_value = min(even_values)\n        smallest_index\
    \ = find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a node value,\
    \ swap the node value with the node in the tree that has the\nsmallest key greater\
    \ than the given node value.", "    \n    smallest_value::Int64 = arr[1]\n   \
    \ smallest_index::Int64 = 1\n    \n    for node in arr[2 : end]\n        if node.value\
    \ % 2 == 0\n            if smallest_value < node.value\n                smallest_value\
    \ = node.value\n                smallest_index = node.index\n            end\n\
    \        end\n    end\n    \n    return [smallest_value, smallest_index]\nend\n\
    </cell>\n<text>\nProblem 7\nGiven a binary tree and a number x, find the node\
    \ in the tree with the value closest to x. If there are multiple nodes with the\
    \ value closest to x, return the node that has the smallest index.", "    \n \
    \   even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    \n    smallest_even_value = min(even_values)\n\
    \    \n    smallest_even_index = findfirst(x->x==smallest_even_value, even_values)\n\
    \    \n    return [smallest_even_value, smallest_even_index]\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree and a node value, swap the node value with the\
    \ node in the tree that has the\nsmallest key greater than or equal to the node\
    \ value.", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n        return [smallest_even_value, smallest_even_index]\n  \
    \  end\nend\n</cell>\n<text>\nPractice 3\nWrite a function that takes a vector\
    \ of integers and returns the sum of the even values.", "    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n    smallest_index\
    \ = index(even_values, smallest_value)\n    \n    if length(even_values) == 0\
    \ || smallest_value == 0\n        return Vector{Int64}()\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree and a number x, your task is to find the node in the tree\
    \ that has value x.", "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value\
    \ = min(even_values)\n    smallest_even_index = find(x -> x == smallest_even_value,\
    \ even_values)\n    if smallest_even_index == length(even_values)\n        return\
    \ Vector{Int64}[]\n    else\n        return [smallest_even_value, smallest_even_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values.", "    \n    even_values = filter(x ->\
    \ x % 2 == 0, arr)\n    if length(even_values) == 0\n        return [] \n    end\n\
    \    \n    smallest_value = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_value,\
    \ even_values)\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).", "    \n    even_values\
    \ = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values) == 0\n    \
    \    return []\n    else\n        smallest_value = min(even_values)\n        smallest_index\
    \ = index(even_values, smallest_value)\n        return [smallest_value, smallest_index]\n\
    \    end\nend", "    evens = filter(x -> x % 2 == 0, arr)\n    if length(evens)\
    \ == 0\n        return [] \n    end\n    evens = sort(evens)\n    smalest_value\
    \ = evens[1]\n    smalest_index = find(x -> x == smalest_value, evens)[1]\n  \
    \  return [ smalest_value, smalest_index ]\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).", "    \n    even_values = findall(x ->\
    \ x % 2 == 0, arr)\n    \n    if isempty(even_values)\n        return []\n   \
    \ else\n        smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nProblem 8\nWrite a function that returns the number\
    \ of nodes in a binary search tree with root node root.\nThe tree is represented\
    \ as an array of nodes where each node stores an integer value and a pointer to\
    \ the left and right child nodes. \nThe function should return the number of nodes\
    \ in the tree.", "    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [] \n    end\n    smallest_even_value = min(even_values)\n   \
    \ smallest_even_index = findfirst(x -> x == smallest_even_value, even_values)\n\
    \    smallest_even_value \n    smallest_even_index\nend\n</cell>\n<text>\nProblem\
    \ 3\nGiven an array representing a branch of a tree that has non-negative integer\
    \ nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node\
    \ should be the node with the smallest odd value.\nIf multiple nodes with the\
    \ same smallest odd value are found return the node that has smallest index.",
  "    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend", "    \n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    \n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a\
    \ number x, find and return the node in the tree with the value closest to x.\
    \ If there are two nodes with this value, return the node that comes before the\
    \ other. If there are multiple nodes with this value, return the node that comes\
    \ before the other. If there is no node in the tree with value closest to x, return\
    \ nil.", "    \n    if length(arr) == 0 \n        return [] \n    \n    even_values\
    \ = filter(x -> x % 2 == 0, arr) \n    \n    if length(even_values) == 0 \n  \
    \      return [] \n    \n    smallest_even_value = min(even_values) \n    \n \
    \   smallest_even_index = index(even_values, smallest_even_value) \n    \n   \
    \ return [smallest_even_value, smallest_even_index] \nend\n</cell>\n<text>\nProblem\
    \ 3\nGiven a binary tree, return the level order traversal of its nodes' values.",
  "    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n   \
    \ if length(even_values) == 0\n        return []\n    smallest_even_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_even_value) + 1\n    smallest_value\
    \ = arr[smallest_index]\n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1,\
    \ 2, 3]) == [2, 1]\n@assert pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n</cell>\n<text>\nProblem 3\nGiven a binary tree and a node value,\
    \ swap the node value with the node in the tree that has the\nsmallest key greater\
    \ than or equal to the node value.", "    even_values = filter(x -> x % 2 == 0,\
    \ arr)\n    if length(even_values) == 0\n        return [] \n    else\n      \
    \  smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nPractice 3\nLet's practice our new function pluck_even_values!\
    \ Let's see how it works.", "    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    smallest_value = min(even_values)\n    smallest_index = findfirst(x -> x\
    \ == smallest_value, even_values)\n    if smallest_index == nothing\n        smallest_index\
    \ = []\n    end\n    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\n\
    Problem 3\nGiven an array representing a binary tree, return the level order traversal\
    \ of its nodes' values.", "    \n    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    if length(even_values) == 0\n        return Vector{Int64}()\n    else\n \
    \       smallest_value = minimum(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n        return [smallest_value, smallest_index]\n   \
    \ end\nend\n</cell>\n<text>\nSolution\nLet's see how this solution works:"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
