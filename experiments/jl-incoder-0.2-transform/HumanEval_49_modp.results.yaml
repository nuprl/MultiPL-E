language: jl
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(abs(n), abs(p))\n    else if p > 1 \n  \
    \      then return modp(n, p - 1)\n    else if n < 0 \n        then return modp(-n,\
    \ p)\n    else if n > p \n        then return modp(n, p - 1)\n    else \n    \
    \    then return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcorval13.jl:15\nin expression starting at /tmp/tmpcorval13.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return 1\n    else \n        modp(n / p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return n modulo p (be aware of numerics).\n    >>>\
    \ modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n  \
    \  1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphiry_733.jl:15\nin expression starting at /tmp/tmphiry_733.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp((n - p) / 2, p) \nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=math,algorithm,modular-arithmetic |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpj3xde1bl.jl:15\nin expression starting at /tmp/tmpj3xde1bl.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < n \n        then return modp(n - p,\
    \ p)\n    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr_wcpr3g.jl:15\nin expression starting at /tmp/tmpr_wcpr3g.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    if n==1 then return p \n\
    \    if n==p then return 1 \n    if n<p then return modp(modp(n,p)+p, p) \n  \
    \  else return modp(n%p, p) \nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\
    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>>\
    \ modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n \
    \   8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp03jfjwjx.jl:14\nin expression starting at /tmp/tmp03jfjwjx.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+1)/2\n    if\
    \ p==5 then return n*(n+1)/2\n    if p==6 then return n*(n+1)/2\n    if p==7 then\
    \ return n*(n+1)/2\n    if p==8 then return n*(n+1)/2\n    if p==9 then return\
    \ n*(n+1)/2\n    if p==10 then return n*(n+1)/2\n    if p==11 then return n*(n+1)/2\n\
    \    if p==12 then return n*(n+1)/2\n    if p==13 then return n*(n+1)/2\n    if\
    \ p==14 then return n*(n+1)/2\n    if p==15 then return n*(n+1)/2\n    if p==16\
    \ then return n*(n+1)/2\n    if p==17 then return n*(n+1)/2\n    if p==18 then\
    \ return n*(n+1)/2\n    if p==19 then return n*(n+1)/2\n    if p==20 then return\
    \ n*(n+1)/2\n    if p==21 then return n*(n+1)/2\n    if p==22 then return n*(n+1)/2\n\
    \    if p==23 then return n*(n+1)/2\n    if p==24 then return n*(n+1)/2\n    if\
    \ p==25 then return n*(n+1)/2\n    if p==26 then return n*(n+1)/2\n    if p==27\
    \ then return n*(n+1)/2\n    if p==28 then return n*(n+1)/2\n    if p==29 then\
    \ return n*(n+1)/2\n    if p==30 then return n*(n+1)/2\n    if p==31 then return\
    \ n*(n+1)/2\n    if p==32 then return n*(n+1)/2\n    if p==33 then return n*(n+1)/2\n\
    \    if p==34 then return n*(n+1)/2\n    if p==35 then return n*(n+1)/2\n    if\
    \ p==36 then return n*(n+1)/2\n    if p==37 then return n*(n+1)/2\n    if p==38\
    \ then return n*(n+1)/2\n    if p==39 then return n*(n+1)/2\n    if p==40 then\
    \ return n*(n+1)/2\n    if p==41 then return n*(n+1)/2\n    if p==42 then return\
    \ n*(n+1)/2\n    if p==43 then return n*(n+1)/2\n    if p==44 then return n*(n+1)/2\n\
    \    if p==45 \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfcaavd1k.jl:14\nin expression starting at /tmp/tmpfcaavd1k.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        return 1 \n    else if p == 0 \n\
    \        return 0 \n    else if n <= p \n        return modp(n - 1, p) \n    else\
    \ \n        return modp(n / p, p) \nend \n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp815blp93.jl:16\nin expression starting at\
    \ /tmp/tmp815blp93.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p \n        then return n \n        else return\
    \ modp(n - p, p) \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpb28m5jex.jl:15\nin expression starting at /tmp/tmpb28m5jex.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 || p==0 \n        then return 0\n    else if\
    \ n==1\n        then return p\n    else if p==1\n        then return n\n    else\
    \ if p==2\n        then return modp(n-1, 2)\n    else if p==3\n        then return\
    \ modp(n-1, 3)\n    else if p==4\n        then return modp(n-1, 4)\n    else if\
    \ p==5\n        then return modp(n-1, 5)\n    else if p==6\n        then return\
    \ modp(n-1, 6)\n    else if p==7\n        then return modp(n-1, 7)\n    else if\
    \ p==8\n        then return modp(n-1, 8)\n    else if p==9\n        then return\
    \ modp(n-1, 9)\n    else if p==10\n        then return modp(n-1, 10)\n    else\
    \ if p==11\n        then return modp(n-1, 11)\n    else if p==12\n        then\
    \ return modp(n-1, 12)\n    else if p==13\n        then return modp(n-1, 13)\n\
    \    else if p==14\n        then return modp(n-1, 14)\n    else if p==15\n   \
    \     then return modp(n-1, 15)\n    else if p==16\n        then return modp(n-1,\
    \ 16)\n    else if p==17\n        then return modp(n-1, 17)\n    else if p==18\n\
    \        then return modp(n-1, 18)\n    else if p==19\n        then return modp(n-1,\
    \ 19)\n    else if p==20\n        then return modp(n-1, 20)\n    else if p==21\n\
    \        then return modp(n-1, 21)\n    else if p==22\n        then return modp(n-1,\
    \ 22)\n    else if p==23\n        then return modp(n-1, 23)\n    else if p==24\n\
    \        then return modp(n-1, 24)\n    else if p==25\n        then return modp(n-1,\
    \ 25)\n    else if p==26\n        then return modp(n-1, 26)\n    else if p==27\n\
    \        then return modp(n-1, 27)\n    else if p==28\n        then return modp(n-1,\
    \ 28)\n    else if p==29\n        then return modp(n-1, 29)\n    else if p==30\n\
    \        then return modp(n-1, 30)\n    else if p==\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp51hfrshl.jl:15\nin expression starting at /tmp/tmp51hfrshl.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-abs(n), abs(p))\n   \
    \ else if n < p \n        then return modp(abs(n), p)\n    else if n == p \n \
    \       then return n\n    else if n % p == 0\n        then return modp(n / p,\
    \ p)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4oa7ow77.jl:15\nin expression starting at /tmp/tmp4oa7ow77.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p < 2 then return modp(n\
    \ >> 1, p)\n    if p < 4 then return modp(n >> 2, p)\n    if p < 8 then return\
    \ modp(n >> 3, p)\n    if p < 16 then return modp(n >> 4, p)\n    if p < 32 then\
    \ return modp(n >> 5, p)\n    if p < 64 then return modp(n >> 6, p)\n    if p\
    \ < 128 then return modp(n >> 7, p)\n    if p < 256 then return modp(n >> 8, p)\n\
    \    if p < 512 then return modp(n >> 9, p)\n    if p < 1024 then return modp(n\
    \ >> 10, p)\n    if p < 2048 then return modp(n >> 11, p)\n    if p < 4096 then\
    \ return modp(n >> 12, p)\n    if p < 8192 then return modp(n >> 13, p)\n    if\
    \ p < 16384 then return modp(n >> 14, p)\n    if p < 32768 then return modp(n\
    \ >> 15, p)\n    if p < 65536 then return modp(n >> 16, p)\n    if p < 131072\
    \ then return modp(n >> 17, p)\n    if p < 262144 then return modp(n >> 18, p)\n\
    \    if p < 524288 then return modp(n >> 19, p)\n    if p < 1048576 then return\
    \ modp(n >> 20, p)\n    if p < 2097152 then return modp(n >> 21, p)\n    if p\
    \ < 4194304 then return modp(n >> 22, p)\n    if p < 8388608 then return modp(n\
    \ >> 23, p)\n    if p < 16777216 then return modp(n >> 24, p)\n    if p < 33554432\
    \ then return modp(n >> 25, p)\n    if p < 67108864 then return modp(n >> 26,\
    \ p)\n    if p < 134217728 then return modp(n >> 27, p)\n    if p < 268435456\
    \ then return modp(n >> 28, p)\n    if p < 536870912 then return modp(n >> 29,\
    \ p)\n    if p < 1073741824 then return modp(n >> 30, p)\n    if p < 2147483648\
    \ then return modp(n >> 31, p)\n    if p < 4294967296 then return modp(n >> 32,\
    \ p)\n    if p < 8589934592 then \nusing Test\n\n@testset begin\n\ncandidate =\
    \ modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t\
    @test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp78ygjfsu.jl:14\nin expression starting at /tmp/tmp78ygjfsu.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return p\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if p < n \n   \
    \     then return modp(n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else \n        then return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjz8el2i9.jl:15\nin expression starting at /tmp/tmpjz8el2i9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"n must be positive\")\n  \
    \  else if p <= 0\n        error(\"p must be positive\")\n    else if p < n\n\
    \        error(\"p must be larger than n\")\n    else if p == 1\n        error(\"\
    p is prime\")\n    else if p == n\n        error(\"p is composite\")\n    else\
    \ if n % p == 0\n        error(\"p is not a prime number\")\n    else\n      \
    \  return modp(n - 1, p) * (p - 1) % p\nend\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoz7byr7o.jl:16\nin expression starting at\
    \ /tmp/tmpoz7byr7o.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p < n \n        then\
    \ return modp(n, p)\n    else return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp0k_wyz5.jl:15\nin expression starting at /tmp/tmpp0k_wyz5.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-abs(n), abs(p))\n   \
    \ else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n  \
    \      then return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(-abs(n), p)\n    else if n\
    \ < p \n        then return modp(abs(n), p)\n    else if n < p \n        then\
    \ return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(-abs(n), p)\n    else if n\
    \ < p \n        then return modp(abs(n), p)\n    else if n < p \n        then\
    \ return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(-abs(n), p)\n    else if n\
    \ < p \n        then return modp(abs(n), p)\n    else if n < p \n        then\
    \ return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(-abs(n), p)\n    else if n\
    \ < p \n        then return modp(abs(n), p)\n    else if n < p \n        then\
    \ return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(-abs(n), p)\n    else if n\
    \ < p \n        then return modp(abs(n), p)\n    else if n < p \n        then\
    \ return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return modp(-abs(n), p)\n    else if n\
    \ < p \n        then return modp(abs(n), p)\n    else if n < p \n        then\
    \ return modp(-abs(n), p)\n    else if n < p \n        then return modp(abs(n),\
    \ p)\n    else if n < p \n        then return mod\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppahn7r8z.jl:15\nin expression starting at /tmp/tmppahn7r8z.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else if n == p \n      \
    \  then return 1\n    else \n        then return modp(n - p, p)\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. `modp(3, -5)`\
    \ returns `3` instead of `2`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. The function works with negative numbers. I tested it on Julia 1.5.1\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 too. `modp(3, -5)` returns `3` instead\
    \ of `2`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. The\
    \ function works with negative numbers. I tested it on Julia 1.5.1\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.1 too. `modp(3, -5)` returns `3` instead of\
    \ `2`.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution that uses only integer arithmetic:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphut8z1vw.jl:15\nin expression starting at /tmp/tmphut8z1vw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n    else \n     \
    \   modp(n / p, p) \nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,modular-arithmetic\
    \ |>\nThe algorithm is simple and straightforward:\n<code>\ndef modpow(a, n):\n\
    \    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    if n\
    \ % 2 == 0:\n        return modpow(a * a, n // 2)\n    else:\n        return modpow(a\
    \ * a, (n - 1) // 2)\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,modular-arithmetic\
    \ |>\n<code>\ndef modpow(x, n):\n    if n == 0:\n        return 1\n    if n ==\
    \ 1:\n        return x\n    if n % 2 == 0:\n        return modpow(x * x, n //\
    \ 2)\n    else:\n        return modpow(x * x, (n - 1) // 2)\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\ndef modpow(x, n):\n    if n == 0:\n        return\
    \ 1\n    if n == 1:\n        return x\n    if n % 2 == 0:\n        return modpow(x\
    \ * x, n // 2)\n    else:\n        return modpow(x * x, (n - 1) // 2)\n</code>\n\
    <|/ a tags=math,algorithm,modular-arithmetic |>\n<| a dscore=1 |>\n<code>\ndef\
    \ modpow(x, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ x\n    if n % 2 == 0:\n        return modpow(x * x, n // 2)\n    else:\n   \
    \     return modpow(x * x, (n - 1) // 2)\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| a dscore=1 |>\n<code>\ndef modpow(x, n):\n    if n == 0:\n        return\
    \ 1\n    if n == 1:\n        return x\n    if n % 2 == 0:\n        return modpow(x\
    \ * x, n // 2)\n    else:\n        return modpow(x * x, (n - 1) // 2)\n</code>\n\
    <|/ a tags=math,algorithm,modular-arithmetic |>\n<| a dscore=1 |>\n<code>\ndef\
    \ modpow(x, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ x\n    if n % 2 == 0:\n        return modpow(x * x, n // 2)\n    else:\n   \
    \     return modpow(x * x, (n - 1) // 2)\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| a tags=math,algorithm,modular-arithmetic |>\n<code>\ndef modpow(x, n):\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe05u2r7b.jl:15\nin expression starting at /tmp/tmpe05u2r7b.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(n-1, 2)\n    if p==4 then return modp(n-1, 3)\n\
    \    if p==5 then return modp(n-1, 4)\n    if p==6 then return modp(n-1, 5)\n\
    \    if p==7 then return modp(n-1, 6)\n    if p==8 then return modp(n-1, 7)\n\
    \    if p==9 then return modp(n-1, 8)\n    if p==10 then return modp(n-1, 9)\n\
    \    if p==11 then return modp(n-1, 10)\n    if p==12 then return modp(n-1, 11)\n\
    \    if p==13 then return modp(n-1, 12)\n    if p==14 then return modp(n-1, 13)\n\
    \    if p==15 then return modp(n-1, 14)\n    if p==16 then return modp(n-1, 15)\n\
    \    if p==17 then return modp(n-1, 16)\n    if p==18 then return modp(n-1, 17)\n\
    \    if p==19 then return modp(n-1, 18)\n    if p==20 then return modp(n-1, 19)\n\
    \    if p==21 then return modp(n-1, 20)\n    if p==22 then return modp(n-1, 21)\n\
    \    if p==23 then return modp(n-1, 22)\n    if p==24 then return modp(n-1, 23)\n\
    \    if p==25 then return modp(n-1, 24)\n    if p==26 then return modp(n-1, 25)\n\
    \    if p==27 then return modp(n-1, 26)\n    if p==28 then return modp(n-1, 27)\n\
    \    if p==29 then return modp(n-1, 28)\n    if p==30 then return modp(n-1, 29)\n\
    \    if p==31 then return modp(n-1, 30)\n    if p==32 then return modp(n-1, 31)\n\
    \    if p==33 then return modp(n-1, 32)\n    if p==34 then return modp(n-1, 33)\n\
    \    if p==35 then return modp(n-1, 34)\n    if p==36 then return modp(n-1, 35)\n\
    \    if p==37 then return modp(n-1, 36)\n    if p==38 then return modp(n-1, 37)\n\
    \    if p==39 then return modp(n-1, 38)\n    if p==40 then return modp(n-1, 39)\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfvwuzyy2.jl:14\nin expression starting at /tmp/tmpfvwuzyy2.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(n-1, 2)\n    if p==4 then return modp(n-1, 3)\n\
    \    if p==5 then return modp(n-1, 4)\n    if p==6 then return modp(n-1, 5)\n\
    \    if p==7 then return modp(n-1, 6)\n    if p==8 then return modp(n-1, 7)\n\
    \    if p==9 then return modp(n-1, 8)\n    if p==10 then return modp(n-1, 9)\n\
    \    if p==11 then return modp(n-1, 10)\n    if p==12 then return modp(n-1, 11)\n\
    \    if p==13 then return modp(n-1, 12)\n    if p==14 then return modp(n-1, 13)\n\
    \    if p==15 then return modp(n-1, 14)\n    if p==16 then return modp(n-1, 15)\n\
    \    if p==17 then return modp(n-1, 16)\n    if p==18 then return modp(n-1, 17)\n\
    \    if p==19 then return modp(n-1, 18)\n    if p==20 then return modp(n-1, 19)\n\
    \    if p==21 then return modp(n-1, 20)\n    if p==22 then return modp(n-1, 21)\n\
    \    if p==23 then return modp(n-1, 22)\n    if p==24 then return modp(n-1, 23)\n\
    \    if p==25 then return modp(n-1, 24)\n    if p==26 then return modp(n-1, 25)\n\
    \    if p==27 then return modp(n-1, 26)\n    if p==28 then return modp(n-1, 27)\n\
    \    if p==29 then return modp(n-1, 28)\n    if p==30 then return modp(n-1, 29)\n\
    \    if p==31 then return modp(n-1, 30)\n    if p==32 then return modp(n-1, 31)\n\
    \    if p==33 then return modp(n-1, 32)\n    if p==34 then return modp(n-1, 33)\n\
    \    if p==35 then return modp(n-1, 34)\n    if p==36 then return modp(n-1, 35)\n\
    \    if p==37 then return modp(n-1, 36)\n    if p==38 then return modp(n-1, 37)\n\
    \    if p==39 then return modp(n-1, 38)\n    if p==40 then return modp(n-1, 39)\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfvwuzyy2.jl:14\nin expression starting at /tmp/tmpfvwuzyy2.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if p < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 0 \n        error(\"modp requires non-zero integers\")\n \
    \   else if p == 1 \n        return n\n    else \n        return modp(n - 1, p)\
    \ \nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7xyguwon.jl:16\nin expression starting at\
    \ /tmp/tmp7xyguwon.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(n, p)\n    if n == p then return 1\n    if\
    \ n <= p then return modp(n, p)\n    if n >= p then return modp(n, abs(p))\n \
    \   return modp(n, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n\
    \ modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvbzw8yv3.jl:14\nin expression starting at /tmp/tmpvbzw8yv3.jl:14\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp: n must be positive\"\
    )\n    else if p <= 0\n        error(\"modp: p must be positive\")\n    else if\
    \ p > n\n        error(\"modp: p must be <= n\")\n    else if p < 2\n        error(\"\
    modp: p must be >= 2\")\n    else if p == 2\n        return n\n    else if p ==\
    \ 3\n        return n\n    else if p == 4\n        return n + 1\n    else if p\
    \ == 5\n        return n - 1\n    else if p == 6\n        return n + (n+1)/2\n\
    \    else if p == 7\n        return n - (n+1)/2\n    else if p == 8\n        return\
    \ n + (n-1)/2\n    else if p == 9\n        return n - (n-1)/2\n    else if p ==\
    \ 10\n        return n + (n-1)/2\n    else if p == 11\n        return n - (n-1)/2\n\
    \    else if p == 12\n        return n + (n-1)/2\n    else if p == 13\n      \
    \  return n - (n-1)/2\n    else if p == 14\n        return n + (n-1)/2\n    else\
    \ if p == 15\n        return n - (n-1)/2\n    else if p == 16\n        return\
    \ n + (n-1)/2\n    else if p == 17\n        return n - (n-1)/2\n    else if p\
    \ == 18\n        return n + (n-1)/2\n    else if p == 19\n        return n - (n-1)/2\n\
    \    else if p == 20\n        return n + (n-1)/2\n    else if p == 21\n      \
    \  return n - (n-1)/2\n    else if p == 22\n        return n + (n-1)/2\n    else\
    \ if p == 23\n        return n - (n-1)/2\n    else if p == 24\n        return\
    \ n + (n-1)/2\n    else if p == 25\n        return n - (n-1)/2\n    else if p\
    \ == 26\n        return n + (n-1)/2\n    else if p == 27\n        return n - (n-1)/2\n\
    \    else if p == 28\n        return n + (n-1)/2\n    else if p == 29\n      \
    \  return n - (n-1)/2\n    else if p == 30\n        return n + (n-1)/2\n    else\
    \ if p == 31\n        return n - (n-1)/2\n    else if p == 32\n        return\
    \ n + (n-1)/2\n    else if p == 33\n        return n - (n-1)/2\n    else if p\
    \ == 34\n        return n + (n-1)/2\n    else if p == 35\n        return n - (n-1)/2\n\
    \    else \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcv71nrtw.jl:16\nin expression starting at\
    \ /tmp/tmpcv71nrtw.jl:16\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n >= p \n        then return modp(n - p,\
    \ p)\n    else \n        then return modp(n - p, p) + p\nend\n</cell>\n<code language=julia-1.0>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpow9eh_je.jl:15\nin expression starting at /tmp/tmpow9eh_je.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else return modp(n + p - 1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp1_xi0tux.jl:15\nin expression starting at /tmp/tmp1_xi0tux.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp: n must be positive\"\
    )\n    else if p <= 0\n        error(\"modp: p must be positive\")\n    else if\
    \ p > n\n        error(\"modp: p must be <= n\")\n    else if p < 2\n        error(\"\
    modp: p must be >= 2\")\n    else if p == 2\n        return n\n    else if p ==\
    \ 3\n        return n\n    else if p % 2 == 0\n        return modp(n / 2, p)\n\
    \    else\n        return modp((n - 1) / 2, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6gqcctyn.jl:16\nin expression starting at\
    \ /tmp/tmp6gqcctyn.jl:16\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp((n - p) % p, p) \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return n^k modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe01ux6m6.jl:15\nin expression starting at /tmp/tmpe01ux6m6.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp: negative argument\"\
    )\n    if p < 0 \n        error(\"modp: negative argument\")\n    if p > n \n\
    \        error(\"modp: negative argument\")\n    if n == 0 \n        error(\"\
    modp: division by zero\")\n    if p == 0 \n        error(\"modp: division by zero\"\
    )\n    if p == 1 \n        return n\n    if n == 1 \n        return p\n    if\
    \ p == 0 \n        return n\n    if n == 0 \n        return p\n    if n == 1 \n\
    \        return p\n    if p == 0 \n        return n\n    if n == 1 \n        return\
    \ p\n    if p == 1 \n        return n\n    if n == 0 \n        return p\n    if\
    \ n == 1 \n        return p\n    if p == 0 \n        return n\n    if n == 1 \n\
    \        return p\n    if p == 1 \n        return n\n    if n == 0 \n        return\
    \ p\n    if n == 1 \n        return p\n    if p == 1 \n        return n\n    if\
    \ n == 0 \n        return p\n    if n == 1 \n        return p\n    if p == 1 \n\
    \        return n\n    if n == 0 \n        return p\n    if n == 1 \n        return\
    \ p\n    if p == 1 \n        return n\n    if n == 0 \n        return p\n    if\
    \ n == 1 \n        return p\n    if p == 1 \n        return n\n    if n == 0 \n\
    \        return p\n    if n == 1 \n        return p\n    if p == 1 \n        return\
    \ n\n    if n == 0 \n        return p\n    if n == 1 \n        return p\n    if\
    \ p == 1 \n        return n\n    if n == 0 \n        return p\n    if n == 1 \n\
    \        return p\n    if p == 1 \n        return n\n    if n == 0 \n        return\
    \ p\n    if n == 1 \n        return p\n    if p == 1 \n        return n\n    if\
    \ n == 0 \n        return p\n    if n == 1 \n        return p\n    if p == 1 \n\
    \        return n\n    if n == 0 \n        return p\n    if n == 1 \n        return\
    \ p\n    if p == 1 \n        return n\n    if n == 0 \n        return p\n    if\
    \ n == 1 \n        return p\n    if p == 1 \n        return n\n    if n == 0 \n\
    \        return p\n    if n == 1 \n        return p\n    if p == 1 \n        return\
    \ n\n    if n == 0 \n        return p\n    if n == 1 \n        return p\n    if\
    \ p == 1 \n        return n\n    if n == 0 \n        return p\n    if n == 1 \n\
    \        return p\n    if p == 1 \n        return n\n    if n == 0 \n        return\
    \ p\n    if n == 1 \n        return p\n    if p == 1 \n        return n\n    if\
    \ n == 0 \n        return p\n    if n == 1 \n        return p\n    if p == 1 \n\
    \        return n\n    if n == 0 \n        return p\n    if n == 1 \n        return\
    \ p\n    if p == 1 \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5of7emht.jl:1\nin expression starting at /tmp/tmp5of7emht.jl:1\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return 1\n    else \n        return modp(n - p, p)\nend \n\"\"\
    \"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppqup_qqe.jl:15\nin expression starting at /tmp/tmppqup_qqe.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n <= p \n        then return modp(abs(n), abs(p))\n    else if n >= p \n\
    \        then return modp(abs(n), abs(p))\n    else if n >= p && n <= 2*p \n \
    \       then return modp(n - p, p)\n    else if n >= 2*p && n <= 3*p \n      \
    \  then return modp(n - 2*p, p)\n    else if n >= 3*p && n <= 4*p \n        then\
    \ return modp(n - 3*p, p)\n    else if n >= 4*p && n <= 5*p \n        then return\
    \ modp(n - 4*p, p)\n    else if n >= 5*p && n <= 6*p \n        then return modp(n\
    \ - 5*p, p)\n    else if n >= 6*p && n <= 7*p \n        then return modp(n - 6*p,\
    \ p)\n    else if n >= 7*p && n <= 8*p \n        then return modp(n - 7*p, p)\n\
    \    else if n >= 8*p && n <= 9*p \n        then return modp(n - 8*p, p)\n   \
    \ else if n >= 9*p && n <= 10*p \n        then return modp(n - 9*p, p)\n    else\
    \ if n >= 10*p && n <= 11*p \n        then return modp(n - 10*p, p)\n    else\
    \ if n >= 11*p && n <= 12*p \n        then return modp(n - 11*p, p)\n    else\
    \ if n >= 12*p && n <= 13*p \n        then return modp(n - 12*p, p)\n    else\
    \ if n >= 13*p && n <= 14*p \n        then return modp(n - 13*p, p)\n    else\
    \ if n >= 14*p && n <= 15*p \n        then return modp(n - 14*p, p)\n    else\
    \ if n >= 15*p && n <= 16*p \n        then return modp(n - 15*p, p)\n    else\
    \ if n >= 16*p && n <= 17*p \n        then return modp(n - 16*p, p)\n    else\
    \ if n >= 17*p && n <= 18*p \n        then return modp(n - 17*\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn5yif7yu.jl:15\nin expression starting at /tmp/tmpn5yif7yu.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), p)\n    if p > p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), p)\n    if p < p then return modp(abs(n),\
    \ p)\n    if p < p \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptyjuomfa.jl:14\nin expression starting at /tmp/tmptyjuomfa.jl:14\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n < p \n        then return modp(n, p)\n    else return modp(n + p - 1, p)\n\
    end\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu_1cqopw.jl:15\nin expression starting at /tmp/tmpu_1cqopw.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n+1\n    if p==4 then return n+2\n    if p==5 then return\
    \ n+3\n    if p==6 then return n+4\n    if p==7 then return n+5\n    if p==8 then\
    \ return n+6\n    if p==9 then return n+7\n    if p==10 then return n+8\n    if\
    \ p==11 then return n+9\n    if p==12 then return n+10\n    if p==13 then return\
    \ n+11\n    if p==14 then return n+12\n    if p==15 then return n+13\n    if p==16\
    \ then return n+14\n    if p==17 then return n+15\n    if p==18 then return n+16\n\
    \    if p==19 then return n+17\n    if p==20 then return n+18\n    if p==21 then\
    \ return n+19\n    if p==22 then return n+20\n    if p==23 then return n+21\n\
    \    if p==24 then return n+22\n    if p==25 then return n+23\n    if p==26 then\
    \ return n+24\n    if p==27 then return n+25\n    if p==28 then return n+26\n\
    \    if p==29 then return n+27\n    if p==30 then return n+28\n    if p==31 then\
    \ return n+29\n    if p==32 then return n+30\n    if p==33 then return n+31\n\
    \    if p==34 then return n+32\n    if p==35 then return n+33\n    if p==36 then\
    \ return n+34\n    if p==37 then return n+35\n    if p==38 then return n+36\n\
    \    if p==39 then return n+37\n    if p==40 then return n+38\n    if p==41 then\
    \ return n+39\n    if p==42 then return n+40\n    if p==43 then return n+41\n\
    \    if p==44 then return n+42\n    if p==45 then return n+43\n    if p==46 then\
    \ return n+44\n    if p==47 then return n+45\n    if p==48 then return n+46\n\
    \    if p==49\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzbht63ok.jl:14\nin expression starting at /tmp/tmpzbht63ok.jl:14\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p)\n    else return modp(n, p - n)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6aavmfub.jl:15\nin expression starting at /tmp/tmp6aavmfub.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return 1\n    if p < n then return modp(n - p, p)\n    else\
    \ return modp(n - p, p) + modp(n, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp3bhbd19t.jl:14\nin expression starting at /tmp/tmp3bhbd19t.jl:14\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p)\n    else return modp(n + p - 1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return n modulo p (be aware of numerics).\n \
    \   >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppkb00wo7.jl:15\nin expression starting at /tmp/tmppkb00wo7.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp((n - 1) % p, p) \nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdi4rvkk9.jl:15\nin expression starting at /tmp/tmpdi4rvkk9.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp(n,p)\")\n    elseif p\
    \ <= 0\n        error(\"modp(n,p)\")\n    elseif p > n\n        error(\"modp(n,p)\"\
    )\n    else\n        modp(n - 1, p) + modp(n, p - 1)\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzrplig3e.jl:24\nin expression starting at\
    \ /tmp/tmpzrplig3e.jl:24\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n < p \n        then return modp(n-1, p)\n    else if n == p \n        then\
    \ return 1\n    else \n        then return modp(n-1, p) + modp(n-1, p-1)\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like your answer, but I think it would\
    \ be better to add some explanation as to why you think this works.\n<|/ c |>\n\
    <| c |>\nI added some explanation.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzwo5epkw.jl:15\nin expression starting at /tmp/tmpzwo5epkw.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if n < 0\
    \ \n        then return modp(abs(n), p)\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), p)\n    else if p <\
    \ n \n        then return modp(n - abs(n), p)\n    else \n        then return\
    \ modp(n - abs(n), p) + modp(abs(n), p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpth68ozmh.jl:15\nin expression starting at /tmp/tmpth68ozmh.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, -p)\n    else return modp(n, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz_vhz2i7.jl:15\nin expression starting at /tmp/tmpz_vhz2i7.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    if p < 0 \n        error(\"modp requires p >= 0\")\n    if n == 0 \n    \
    \    error(\"modp requires n > 0\") \n    if p == 0 \n        error(\"modp requires\
    \ p > 0\") \n    if n == p \n        error(\"modp requires n and p are equal\"\
    )\n    \n    if n == 1 \n        return p\n    \n    if n == p \n        return\
    \ n\n    \n    if n % p == 0 \n        return modp(n / p, p)\n    \n    if n %\
    \ p == 1 \n        return modp((n - p) / p, p)\n    \n    if n % p == 2 \n   \
    \     return modp((n - p) / p, p) + p\n    \n    if n % p == 3 \n        return\
    \ modp((n - p) / p, p) + p + p\n    \n    if n % p == 4 \n        return modp((n\
    \ - p) / p, p) + p + p + p\n    \n    if n % p == 5 \n        return modp((n -\
    \ p) / p, p) + p + p + p + p\n    \n    if n % p == 6 \n        return modp((n\
    \ - p) / p, p) + p + p + p + p + p\n    \n    if n % p == 7 \n        return modp((n\
    \ - p) / p, p) + p + p + p + p + p + p\n    \n    if n % p == 8 \n        return\
    \ modp((n - p) / p, p) + p + p + p + p + p + p + p\n    \n    if n % p == 9 \n\
    \        return modp((n - p) / p, p) + p + p + p + p + p + p + p + p\n    \n \
    \   if n % p == 10 \n        return modp((n - p) / p, p) + p + p + p + p + p +\
    \ p + p + p + p\n    \n    if n % p == 11 \n        return modp((n - p) / p, p)\
    \ + p + p + p + p + p + p + p + p + p + p + p\n    \n    if n % p == 12 \n   \
    \     return modp((n - p) / p, p) + p + p + p + p + p + p + p + p + p + p + p\
    \ + p\n    \n    if n % p == 13 \n        return modp((n - p) / p, p) + p + p\
    \ + p + p + p + p + p + p + p + p + p + p + p\n    \n    if n % p == 14 \n   \
    \     return modp((n - p) / p, p) + p + p\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuu72lk3s.jl:1\nin expression starting at /tmp/tmpuu72lk3s.jl:1\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n    then return 0\n    else if n == 1\n  \
    \  then return p\n    else return modp(n - 1, p) + p\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwza6u9zt.jl:15\nin expression starting at /tmp/tmpwza6u9zt.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else if n < p \n       \
    \ then return modp(abs(n), p)\n    else \n        then return modp(abs(n), p)\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4z5yamxg.jl:15\nin expression starting at /tmp/tmp4z5yamxg.jl:15\n"
  stdout: ''
  timestamp: 1659823059
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p < 0\
    \ \n        then return modp(-n, p)\n    else if n < 0 \n        then return modp(-n,\
    \ p)\n    else if n < p \n        then return modp(n, p)\n    else \n        then\
    \ return modp(n, p - n)\nend\n</code>\n<|/ a tags=math,julia |>\n<| c |>\nI believe\
    \ this should be `modp(n, p - n)` instead of `modp(n, p)`.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing that out! I fixed it.\n<|/ c |>\n<| a dscore=3 |>\nThe Julia\
    \ standard library has this functionality built-in:\n<code>\njulia> mod(3, 5)\n\
    1\n</code>\n<|/ a tags=math,julia |>\n<| c |>\nI believe this should be `mod(3,\
    \ 5)` instead of `mod(3, 5)`.\n<|/ c |>\n<| c |>\nThanks for pointing that out!\
    \ I fixed it.\n<|/ c |>\n<| a tags=math,julia |>\nI believe that Julia has this\
    \ functionality built in:\n<code>\njulia> mod(3, 5)\n1\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=math,julia |>\nThe modulus operator is defined in the Base package:\n\
    <code>\njulia> mod(3, 5)\n1\n</code>\n<|/ a dscore=3 |>\n<| a tags=math,julia\
    \ |>\nThe modulus operator is defined in the Base package:\n<code>\njulia> mod(3,\
    \ 5)\n1\n</code>\n<|/ a dscore=3 |>\n<| a tags=math,julia |>\nThe modulus operator\
    \ is defined in the Base package:\n<code>\njulia> mod(3, 5)\n1\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a |>\nThe modulus operator is defined in the Base package:\n\
    <code>\njulia> mod(3, 5)\n1\n</code>\n<|/ a dscore=3 tags=math,julia |>\n<| a\
    \ tags=math,julia |>\nThe modulus operator is defined in the Base package:\n<code>\n\
    julia> mod(3, 5)\n1\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nThe modulus\
    \ operator is defined in the Base package:\n<code>\njulia> mod(3, 5)\n1\n</code>\n\
    <|/ a tags=math,julia |>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpklg5et7j.jl:15\nin expression starting at /tmp/tmpklg5et7j.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n == p then return 1\n    if n < p then return modp(n, p)\n    if n < 0\
    \ then return modp(-n, p)\n    return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0bkvk9l1.jl:14\nin expression starting at /tmp/tmp0bkvk9l1.jl:14\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if p == 0 then return\
    \ 0\n    else if p > n then return modp(n - p, p)\n    else return modp(n, p -\
    \ 1)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsgwfn_zt.jl:14\nin expression starting at /tmp/tmpsgwfn_zt.jl:14\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n < p \n        then return modp(n, p)\n    else return modp((n-p), p)\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8i7a944a.jl:15\nin expression starting at /tmp/tmp8i7a944a.jl:15\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if n==p then return 1\n    if n>p then return modp(mod(n, p), p)\n    return\
    \ modp(mod(n, p), p) * modp(p, n)\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"Return nth root of p (be aware of numerics).\n    >>> rootp(3, 5)\n    1.73205080756888\n\
    \    >>> rootp(1101, 101)\n    1.1102230246251565\n    >>> rootp(0, 101)\n   \
    \ 1.0\n    >>> rootp(3, 11)\n    1.73205080756888\n    >>> rootp(100, 101)\n \
    \   1.0\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6u01ndjv.jl:14\nin expression starting at /tmp/tmp6u01ndjv.jl:14\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n >= p\n        then return modp(n - p,\
    \ p)\n    else return modp(n - p, p) + p\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5pa1aotw.jl:15\nin expression starting at /tmp/tmp5pa1aotw.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n    else \n     \
    \   return modp(n - p, p) \nend \n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm8irn2fw.jl:15\nin expression starting at /tmp/tmpm8irn2fw.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 1\n    else if n==1\n \
    \       then return p\n    else if p==0\n        then return 1\n    else if p==1\n\
    \        then return n\n    else if p==2\n        then return n*modp(n-1, 2)\n\
    \    else if p==3\n        then return n*modp(n-1, 3)\n    else if p==4\n    \
    \    then return n*modp(n-1, 4)\n    else if p==5\n        then return n*modp(n-1,\
    \ 5)\n    else if p==6\n        then return n*modp(n-1, 6)\n    else if p==7\n\
    \        then return n*modp(n-1, 7)\n    else if p==8\n        then return n*modp(n-1,\
    \ 8)\n    else if p==9\n        then return n*modp(n-1, 9)\n    else if p==10\n\
    \        then return n*modp(n-1, 10)\n    else if p==11\n        then return n*modp(n-1,\
    \ 11)\n    else if p==12\n        then return n*modp(n-1, 12)\n    else if p==13\n\
    \        then return n*modp(n-1, 13)\n    else if p==14\n        then return n*modp(n-1,\
    \ 14)\n    else if p==15\n        then return n*modp(n-1, 15)\n    else if p==16\n\
    \        then return n*modp(n-1, 16)\n    else if p==17\n        then return n*modp(n-1,\
    \ 17)\n    else if p==18\n        then return n*modp(n-1, 18)\n    else if p==19\n\
    \        then return n*modp(n-1, 19)\n    else if p==20\n        then return n*modp(n-1,\
    \ 20)\n    else if p==21\n        then return n*modp(n-1, 21)\n    else if p==22\n\
    \        then return n*modp(n-1, 22)\n    else if p==23\n        then return n*modp(n-1,\
    \ 23)\n    else if p==24\n        then return n*modp(n-1, 24)\n    else if p==25\n\
    \        then return n*modp(n-1, 25)\n    else if p==26\n        then return n*modp(n-1,\
    \ 26)\n    else if p==27\n        then return n*modp(n-1, 27)\n    else if p==28\n\
    \        then return n*modp(n-1, 28)\n    else \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc9gkbxyp.jl:15\nin expression starting at /tmp/tmpc9gkbxyp.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - abs(n), p)\n    else if n < p \n   \
    \     then return modp(n - abs(n), p)\n    else \n        then return modp(n -\
    \ abs(n), p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkotgb7kc.jl:15\nin expression starting at /tmp/tmpkotgb7kc.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 1\n    else if n <= p\
    \ \n        then return modp(n-1, p) \n        else return modp(n-1, p) + modp(n-1,\
    \ p-1)\nend\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwjg_eym0.jl:15\nin expression starting at /tmp/tmpwjg_eym0.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    if p==1 return\
    \ n\n    if p==0 return 0\n    if p==-1 return -1\n    if p==-2 return -2\n  \
    \  if p==-3 return -3\n    if p==-4 return -4\n    if p==-5 return -5\n    if\
    \ p==-6 return -6\n    if p==-7 return -7\n    if p==-8 return -8\n    if p==-9\
    \ return -9\n    if p==-10 return -10\n    if p==-11 return -11\n    if p==-12\
    \ return -12\n    if p==-13 return -13\n    if p==-14 return -14\n    if p==-15\
    \ return -15\n    if p==-16 return -16\n    if p==-17 return -17\n    if p==-18\
    \ return -18\n    if p==-19 return -19\n    if p==-20 return -20\n    if p==-21\
    \ return -21\n    if p==-22 return -22\n    if p==-23 return -23\n    if p==-24\
    \ return -24\n    if p==-25 return -25\n    if p==-26 return -26\n    if p==-27\
    \ return -27\n    if p==-28 return -28\n    if p==-29 return -29\n    if p==-30\
    \ return -30\n    if p==-31 return -31\n    if p==-32 return -32\n    if p==-33\
    \ return -33\n    if p==-34 return -34\n    if p==-35 return -35\n    if p==-36\
    \ return -36\n    if p==-37 return -37\n    if p==-38 return -38\n    if p==-39\
    \ return -39\n    if p==-40 return -40\n    if p==-41 return -41\n    if p==-42\
    \ return -42\n    if p==-43 return -43\n    if p==-44 return -44\n    if p==-45\
    \ return -45\n    if p==-46 return -46\n    if p==-47 return -47\n    if p==-48\
    \ return -48\n    if p==-49 return -49\n    if p==-50 return -50\n    if p==-51\
    \ return -51\n    if p==-52 return -52\n    if p==-53 return -53\n    if p==-54\
    \ return -54\n    if p==-55 return -55\n    if p==-56 return -56\n    if p==-57\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1_5j3qnt.jl:1\nin expression starting at /tmp/tmp1_5j3qnt.jl:1\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n >= p\n        then return modp(n - p,\
    \ p)\n    else return modp(n - p, p) + modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpaeanog38.jl:15\nin expression starting at /tmp/tmpaeanog38.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    else if n==1 then return\
    \ p \n    else if p==0 then return 0 \n    else if p==1 then return 1 \n    else\
    \ if p==2 then return modp(n / 2, p) \n    else return modp(n / 2, modp(n % p,\
    \ p)) \nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc0qua325.jl:14\nin expression starting at /tmp/tmpc0qua325.jl:14\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+1)/2\n    if\
    \ p==5 then return n*(n+1)/2\n    if p==6 then return n*(n+1)/2\n    if p==7 then\
    \ return n*(n+1)/2\n    if p==8 then return n*(n+1)/2\n    if p==9 then return\
    \ n*(n+1)/2\n    if p==10 then return n*(n+1)/2\n    if p==11 then return n*(n+1)/2\n\
    \    if p==12 then return n*(n+1)/2\n    if p==13 then return n*(n+1)/2\n    if\
    \ p==14 then return n*(n+1)/2\n    if p==15 then return n*(n+1)/2\n    if p==16\
    \ then return n*(n+1)/2\n    if p==17 then return n*(n+1)/2\n    if p==18 then\
    \ return n*(n+1)/2\n    if p==19 then return n*(n+1)/2\n    if p==20 then return\
    \ n*(n+1)/2\n    if p==21 then return n*(n+1)/2\n    if p==22 then return n*(n+1)/2\n\
    \    if p==23 then return n*(n+1)/2\n    if p==24 then return n*(n+1)/2\n    if\
    \ p==25 then return n*(n+1)/2\n    if p==26 then return n*(n+1)/2\n    if p==27\
    \ then return n*(n+1)/2\n    if p==28 then return n*(n+1)/2\n    if p==29 then\
    \ return n*(n+1)/2\n    if p==30 then return n*(n+1)/2\n    if p==31 then return\
    \ n*(n+1)/2\n    if p==32 then return n*(n+1)/2\n    if p==33 then return n*(n+1)/2\n\
    \    if p==34 then return n*(n+1)/2\n    if p==35 then return n*(n+1)/2\n    if\
    \ p==36 then return n*(n+1)/2\n    if p==37 then return n*(n+1)/2\n    if p==38\
    \ then return n*(n+1)/2\n    if p==39 then return n*(n+1)/2\n    if p==40 then\
    \ return n*(n+1)/2\n    if p==41 then return n*(n+1)/2\n    if p==42 then return\
    \ n*(n+1)/2\n    if p==43 then return n*(n+1)/2\n    if p==44 then return n*(n+1)/2\n\
    \    if p==45 \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfcaavd1k.jl:14\nin expression starting at /tmp/tmpfcaavd1k.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if p == 0 then return\
    \ 0\n    else if p < n then return modp(n - 1, p) \n    else return modp(n, p\
    \ - 1)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptoixuafv.jl:14\nin expression starting at /tmp/tmptoixuafv.jl:14\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p == -1 \n        then return -n\n    else if p < 0 \n        then return\
    \ modp(-n, p)\n    else if p > 0 \n        then return modp(n, p)\n    else if\
    \ p < n \n        then return modp(-n, p)\n    else if p > n \n        then return\
    \ modp(n, p)\n    else if p < n \n        then return modp(-n, p)\n    else if\
    \ p > n \n        then return modp(n, p)\n    else if p < n \n        then return\
    \ modp(-n, p)\n    else if p > n \n        then return modp(n, p)\n    else if\
    \ p < n \n        then return modp(-n, p)\n    else if p > n \n        then return\
    \ modp(n, p)\n    else if p < n \n        then return modp(-n, p)\n    else if\
    \ p > n \n        then return modp(n, p)\n    else if p < n \n        then return\
    \ modp(-n, p)\n    else if p > n \n        then return modp(n, p)\n    else if\
    \ p < n \n        then return modp(-n, p)\n    else if p > n \n        then return\
    \ modp(n, p)\n    else if p < n \n        then return modp(-n, p)\n    else if\
    \ p > n \n        then return modp(n, p)\n    else if p < n \n        then return\
    \ modp(-n, p)\n    else if p > n \n        then return modp(n, p)\n    else if\
    \ p < n \n        then return modp(-n, p)\n    else if p > n \n        then return\
    \ modp(n, p)\n    else if p < n \n        then return modp(-n, p)\n    else if\
    \ p > n \n        then return modp(n, p)\n    else if p < n \n        then return\
    \ modp(-n, p)\n    else if p > n \n        then return modp(n, p)\n    else if\
    \ p < n \n        then return modp(-n, p)\n    else if p > n \n        then return\
    \ modp(n, p)\n    else if p < n \n        then return modp(-n, p)\n    else if\
    \ p > n \n        then return modp(n, p)\n    else \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg4vyxbo2.jl:15\nin expression starting at /tmp/tmpg4vyxbo2.jl:15\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp((n - 1) % p, p) \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return nth root of p (be aware of numerics).\n    >>> nthroot(3, 5)\n  \
    \  1.73205080756888\n    >>> nthroot(1101, 101)\n    2.23606797749979\n    >>>\
    \ nthroot(0, 101)\n    1.0\n    >>> nthroot(3, 11)\n    1.73205080756888\n   \
    \ >>> nthroot(100, 101)\n    1.0\n    \"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnbxsd15_.jl:15\nin expression starting at /tmp/tmpnbxsd15_.jl:15\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p < n \n        then\
    \ return modp(n, p)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg2j94ls0.jl:15\nin expression starting at /tmp/tmpg2j94ls0.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    if p==0 return\
    \ 0\n    if p==1 return 1\n    if n==p return n\n    if p==2 return n\n    if\
    \ p==3 return n\n    if p==4 return n\n    if p==5 return n\n    if p==6 return\
    \ n\n    if p==7 return n\n    if p==8 return n\n    if p==9 return n\n    if\
    \ p==10 return n\n    if p==11 return n\n    if p==12 return n\n    if p==13 return\
    \ n\n    if p==14 return n\n    if p==15 return n\n    if p==16 return n\n   \
    \ if p==17 return n\n    if p==18 return n\n    if p==19 return n\n    if p==20\
    \ return n\n    if p==21 return n\n    if p==22 return n\n    if p==23 return\
    \ n\n    if p==24 return n\n    if p==25 return n\n    if p==26 return n\n   \
    \ if p==27 return n\n    if p==28 return n\n    if p==29 return n\n    if p==30\
    \ return n\n    if p==31 return n\n    if p==32 return n\n    if p==33 return\
    \ n\n    if p==34 return n\n    if p==35 return n\n    if p==36 return n\n   \
    \ if p==37 return n\n    if p==38 return n\n    if p==39 return n\n    if p==40\
    \ return n\n    if p==41 return n\n    if p==42 return n\n    if p==43 return\
    \ n\n    if p==44 return n\n    if p==45 return n\n    if p==46 return n\n   \
    \ if p==47 return n\n    if p==48 return n\n    if p==49 return n\n    if p==50\
    \ return n\n    if p==51 return n\n    if p==52 return n\n    if p==53 return\
    \ n\n    if p==54 return n\n    if p==55 return n\n    if p==56 return n\n   \
    \ if p==57 return n\n    if p==58 return n\n    if p==59 return n\n    if p==60\
    \ return n\n    if p==61 return n\n    if p==62 return n\n    if p==63 return\
    \ n\n    if p==64 return n\n    if p==65 return n\n    if p==66 return n\n   \
    \ if p==67 return n\n    if p==68 return n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpktqc9d5_.jl:1\nin expression starting at /tmp/tmpktqc9d5_.jl:1\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if p == 0 then return\
    \ 0\n    else if p == 1 then return n\n    else return modp(n - 1, p) \nend \n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm9oaxy_s.jl:14\nin expression starting at /tmp/tmpm9oaxy_s.jl:14\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    else if n==1 then return\
    \ p \n    else return modp(mod(n, p), p) \nend \n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpv0i_y_44.jl:14\nin expression starting at /tmp/tmpv0i_y_44.jl:14\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 0\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return n\n    else if p==2 \n        then return n*(n-1)\n\
    \    else if p==3 \n        then return n*(n-1)*(n-2)\n    else if p==4 \n   \
    \     then return n*(n-1)*(n-2)*(n-3)\n    else if p==5 \n        then return\
    \ n*(n-1)*(n-2)*(n-3)*(n-4)\n    else if p==6 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)\n\
    \    else if p==7 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)\n\
    \    else if p==8 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)\n\
    \    else if p==9 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)\n\
    \    else if p==10 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)\n\
    \    else if p==11 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)*(n-10)\n\
    \    else if p==12 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)*(n-10)*(n-11)\n\
    \    else if p==13 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)*(n-10)*(n-11)*(n-12)\n\
    \    else if p==14 \n        then return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)*(n-10)*(n-11)*(n-12)*(n-13)\n\
    \    else if p==15 \n        then return n*(n-1)*\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmhey3b4j.jl:15\nin expression starting at /tmp/tmpmhey3b4j.jl:15\n"
  stdout: ''
  timestamp: 1659823060
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p > p then return modp(n, p)\n \
    \   if p % 2 == 1 then return modp(n-1, p-1)\n    if p % 2 == 0 then return modp(n-1,\
    \ p)\n    return modp(n-1, p-1)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprqtg_ehi.jl:14\nin expression starting at /tmp/tmprqtg_ehi.jl:14\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ abs(p))\n    if p < p then return modp(abs(n), p)\n    if p > n then return\
    \ modp(abs(n), p)\n    return modp(abs(n), abs(p))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpy91470xe.jl:14\nin expression starting at /tmp/tmpy91470xe.jl:14\n"
  stdout: ''
  timestamp: 1659823061
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\
    \ \n        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(n + p, p)\n    else return modp((n - p) * (n - p), p)\nend\n</cell>\n<code\
    \ language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplfn7zkkr.jl:15\nin expression starting at /tmp/tmplfn7zkkr.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return 1\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else if n > p \n        then\
    \ return modp(n, p - abs(n))\n    else return modp(n, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphc4jo456.jl:15\nin expression starting at /tmp/tmphc4jo456.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp: n must be positive\"\
    )\n    else if p <= 0\n        error(\"modp: p must be positive\")\n    else if\
    \ p > n\n        error(\"modp: p must be <= n\")\n    else if p == 1\n       \
    \ error(\"modp: p is 1\")\n    else if p == n\n        error(\"modp: p == n\"\
    )\n    else if p == -1\n        error(\"modp: p == -1\")\n    else if p == -2\n\
    \        error(\"modp: p == -2\")\n    else if p == -3\n        error(\"modp:\
    \ p == -3\")\n    else if p == -4\n        error(\"modp: p == -4\")\n    else\
    \ if p == -5\n        error(\"modp: p == -5\")\n    else if p == -6\n        error(\"\
    modp: p == -6\")\n    else if p == -7\n        error(\"modp: p == -7\")\n    else\
    \ if p == -8\n        error(\"modp: p == -8\")\n    else if p == 9\n        error(\"\
    modp: p == 9\")\n    else if p == 10\n        error(\"modp: p == 10\")\n    else\
    \ if p == 11\n        error(\"modp: p == 11\")\n    else if p == 12\n        error(\"\
    modp: p == 12\")\n    else if p == 13\n        error(\"modp: p == 13\")\n    else\
    \ if p == 14\n        error(\"modp: p == 14\")\n    else if p == 15\n        error(\"\
    modp: p == 15\")\n    else if p == 16\n        error(\"modp: p == 16\")\n    else\
    \ if p == 17\n        error(\"modp: p == 17\")\n    else if p == 18\n        error(\"\
    modp: p == 18\")\n    else if p == 19\n        error(\"modp: p == 19\")\n    else\
    \ if p == 20\n        error(\"modp: p == 20\")\n    else if p == 21\n        error(\"\
    modp: p == 21\")\n    else if p == 22\n        error(\"modp: p == 22\")\n    else\
    \ if p == 23\n        error(\"modp: p == 23\")\n    else if p == 24\n        error(\"\
    modp: p == 24\")\n    else if p == 25\n        error(\"modp: p == 25\")\n    else\
    \ if p == 26\n        error(\"modp: p == 26\")\n    else if p == 27\n        error(\"\
    modp: p == 27\")\n    else if p == 28\n        error(\"modp: \nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpawr6z8fz.jl:16\nin expression starting at\
    \ /tmp/tmpawr6z8fz.jl:16\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp((n - 1) % p, p) \nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return nth root of p (be aware of numerics).\n    >>> nroot(3, 5)\n    3\n\
    \    >>> nroot(1101, 101)\n    2\n    >>> nroot(0, 101)\n    1\n    >>> nroot(3,\
    \ 11)\n    8\n    >>> nroot(100, 101)\n    1\n\"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu2tyluou.jl:15\nin expression starting at /tmp/tmpu2tyluou.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return p\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n, p - 1)\n    else if n == p\n        then\
    \ return n\n    else return modp(n, p - 1)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8qebtxf2.jl:15\nin expression starting at /tmp/tmp8qebtxf2.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 2 then return 1\n    if p < n then return modp(n - 1, p)\n    else\
    \ return modp(n - 2, p) + modp((n - 1) * (n - 2), p)\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprmtq7xxx.jl:14\nin expression starting at /tmp/tmprmtq7xxx.jl:14\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n    then return 0\n    else if n <= p\n  \
    \  then return 1\n    else return modp(n - 1, p) \nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpq5djwww9.jl:15\nin expression starting at /tmp/tmpq5djwww9.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if p < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 0 \n        error(\"modp requires non-zero integers\")\n \
    \   else if p == 1 \n        return n\n    else if n == 1 \n        return 1\n\
    \    else if n == p \n        return p\n    else if n % p == 0 \n        return\
    \ modp(n / p, p)\n    else \n        error(\"modp requires non-zero integers\"\
    )\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgj6cb056.jl:16\nin expression starting at\
    \ /tmp/tmpgj6cb056.jl:16\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else \n        return\
    \ modp(n-1, p) + modp(n-1, p-1)\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe50flzay.jl:15\nin expression starting at /tmp/tmpe50flzay.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp: n must be positive\"\
    )\n    else if p < 0 \n        error(\"modp: p must be positive\")\n    else if\
    \ n < p \n        error(\"modp: n must be >= p\")\n    else \n        return n\
    \ & (p-1)\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp91ojlb11.jl:16\nin expression starting at\
    \ /tmp/tmp91ojlb11.jl:16\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\n\
    \        then return modp(abs(n), p)\n    else if p == 0\n        then return\
    \ 1\n    else if p < 0\n        then return modp(abs(n), abs(p))\n    else if\
    \ p < n\n        then return modp(n - p, p)\n    else if p > n\n        then return\
    \ modp(n, p - n)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp4gflczk.jl:15\nin expression starting at /tmp/tmpp4gflczk.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if n <= p then return modp(n - 1, p) + 1\n \
    \   return modp(n - 1, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return\
    \ n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjf8bdzfj.jl:14\nin expression starting at /tmp/tmpjf8bdzfj.jl:14\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else return modp(n, p - n)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpax71d8ev.jl:15\nin expression starting at /tmp/tmpax71d8ev.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    if p < 0 \n        error(\"modp requires p >= 0\")\n    if p == 0 \n    \
    \    error(\"modp requires p != 0\")\n    if n == 0 \n        error(\"modp requires\
    \ n != 0\")\n    if n == 1 \n        return p\n    if p == 1 \n        return\
    \ n\n    if p == 0 \n        return n\n    if n == p \n        return n\n    if\
    \ n % p == 0 \n        return n\n    if n % p == 1 \n        return p\n    if\
    \ n % p == 2 \n        return p + 1\n    if n % p == 3 \n        return p + 2\n\
    \    if n % p == 4 \n        return p + 3\n    if n % p == 5 \n        return\
    \ p + 4\n    if n % p == 6 \n        return p + 5\n    if n % p == 7 \n      \
    \  return p + 6\n    if n % p == 8 \n        return p + 7\n    if n % p == 9 \n\
    \        return p + 8\n    if n % p == 10 \n        return p + 9\n    if n % p\
    \ == 11 \n        return p + 10\n    if n % p == 12 \n        return p + 11\n\
    \    if n % p == 13 \n        return p + 12\n    if n % p == 14 \n        return\
    \ p + 13\n    if n % p == 15 \n        return p + 14\n    if n % p == 16 \n  \
    \      return p + 15\n    if n % p == 17 \n        return p + 16\n    if n % p\
    \ == 18 \n        return p + 17\n    if n % p == 19 \n        return p + 18\n\
    \    if n % p == 20 \n        return p + 19\n    if n % p == 21 \n        return\
    \ p + 20\n    if n % p == 22 \n        return p + 21\n    if n % p == 23 \n  \
    \      return p + 22\n    if n % p == 24 \n        return p + 23\n    if n % p\
    \ == 25 \n        return p + 24\n    if n % p == 26 \n        return p + 25\n\
    \    if n % p == 27 \n        return p + 26\n    if n % p == 28 \n        return\
    \ p + 27\n    if n % p == 29 \n        return p + 28\n    if n % p == 30 \n  \
    \      return p + 29\n    if n % p == 31 \n        return p + 30\n    if n % p\
    \ == 32 \n        return p + 31\n    if n % p == 33 \n        return p + 32\n\
    \    if n % p == 34 \n        return p + 33\n    if n % p == 35 \n        return\
    \ p + 34\n    if n % p == 36 \n        return p + 35\n    if n % p == 37 \n  \
    \      return p + 36\n    if n % p == 38 \n        return p + 37\n    if n % p\
    \ == 39 \n        return p + 38\n    if \nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing condition in \"if\" at /tmp/tmpzbm_scqn.jl:110\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzbm_scqn.jl:111\nin expression\
    \ starting at /tmp/tmpzbm_scqn.jl:111\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ \n        return modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8zqbqhdl.jl:15\nin expression starting at /tmp/tmp8zqbqhdl.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        return 1 \n    else \n        return\
    \ ((n%p)+modp(n/p, p))\n\"\"\"\n    \n\"\"\"\n    modpow(n::Int64, p::Int64)::Int64\n\
    \    \n    Raise a number to a power, modulo p (be aware of numerics).\n    >>>\
    \ modpow(5, 3, 2)\n    8\n    >>> modpow(5, 3, 3)\n    27\n    >>> modpow(5, 3,\
    \ 4)\n    64\n    >>> modpow(5, 3, 5)\n    125\n    >>> modpow(5, 3, 6)\n    121\n\
    \    >>> modpow(5, 3, 7)\n    121\n    >>> modpow(5, 3, 8)\n    121\n    >>> modpow(5,\
    \ 3, 9)\n    121\n    >>> modpow(5, 3, 10)\n    121\n    >>> modpow(5, 3, 11)\n\
    \    121\n    >>> modpow(5, 3, 12)\n    121\n    >>> modpow(5, 3, 13)\n    121\n\
    \    >>> modpow(5, 3, 14)\n    121\n    >>> modpow(5, 3, 15)\n    121\n    >>>\
    \ modpow(5, 3, 16)\n    121\n    >>> modpow(5, 3, 17)\n    121\n    >>> modpow(5,\
    \ 3, 18)\n    121\n    >>> modpow(5, 3, 19)\n    121\n    >>> modpow(5, 3, 20)\n\
    \    121\n    >>> modpow(5, 3, 21)\n    121\n    >>> modpow(5, 3, 22)\n    121\n\
    \    >>> modpow(5, 3, 23)\n    121\n    >>> modpow(5, 3, 24)\n    121\n    >>>\
    \ modpow(5, 3, 25)\n    121\n    >>> modpow(5, 3, 26)\n    121\n    >>> modpow(5,\
    \ 3, 27)\n    121\n    >>> modpow(5, 3, 28)\n    121\n    >>> modpow(5, 3, 29)\n\
    \    121\n    >>> modpow(5, 3, 30)\n    121\n    >>> modpow(5, 3, 31)\n    121\n\
    \    >>> modpow(5, 3, 32)\n    121\n    >>> modpow(5, 3, 33)\n    121\n    >>>\
    \ modpow(5, 3, 34)\n    121\n    >>> modpow(5, 3, 35)\n    121\n    >>> modpow(5,\
    \ 3, 36)\n    121\n    >>> modpow(5, 3, 37)\n    121\n    >>> modpow(5, 3, 38)\n\
    \    121\n    >>> modpow(5, 3, 39)\n    121\n    >>> modpow(5, 3, 40)\n    121\n\
    \    >>> modpow(5, 3, 41)\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpiuucs31j.jl:14 expected \"\
    end\", got \"a\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpiuucs31j.jl:23\n\
    in expression starting at /tmp/tmpiuucs31j.jl:23\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if n==p then return n\n\
    \    return modp(n - 1, p) * (p % n) + modp(n, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0of4pzh9.jl:14\nin expression starting at /tmp/tmp0of4pzh9.jl:14\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if n==p then return 1\n    if n>p then return modp(mod(n,p),p)\n    else return\
    \ modp(mod(n,p),p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return nth\
    \ root of p (be aware of numerics).\n    >>> rootp(3, 5)\n    1.73205080756888\n\
    \    >>> rootp(1101, 101)\n    1.73205080756888\n    >>> rootp(0, 101)\n    1.0\n\
    \    >>> rootp(3, 11)\n    1.73205080756888\n    >>> rootp(100, 101)\n    1.0\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprowcfy4a.jl:14\nin expression starting at /tmp/tmprowcfy4a.jl:14\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n <= p \n        then return modp(n-1, p)\n    else \n        then\
    \ return modp(n-1, p) + modp(n-1, p-1)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps5wbw1w6.jl:15\nin expression starting at /tmp/tmps5wbw1w6.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n <= p \n        then return modp(n - p, p)\n    else return modp(n - p,\
    \ modp(n, p))\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxx4wwf7k.jl:15\nin expression starting at /tmp/tmpxx4wwf7k.jl:15\n"
  stdout: ''
  timestamp: 1659823063
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else \n        return modp(n-1, p) + modp(n-1,\
    \ p-1)\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps3ii0o4r.jl:15\nin expression starting at /tmp/tmps3ii0o4r.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 1\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return 1\n    else if p==2 \n        then return n\n   \
    \ else if p==3 \n        then return modp(2*n, p)\n    else if p==4 \n       \
    \ then return modp(3*n, p)\n    else if p==5 \n        then return modp(4*n, p)\n\
    \    else if p==6 \n        then return modp(5*n, p)\n    else if p==7 \n    \
    \    then return modp(6*n, p)\n    else if p==8 \n        then return modp(7*n,\
    \ p)\n    else if p==9 \n        then return modp(8*n, p)\n    else if p==10 \n\
    \        then return modp(9*n, p)\n    else if p==11 \n        then return modp(10*n,\
    \ p)\n    else if p==12 \n        then return modp(11*n, p)\n    else if p==13\
    \ \n        then return modp(12*n, p)\n    else if p==14 \n        then return\
    \ modp(13*n, p)\n    else if p==15 \n        then return modp(14*n, p)\n    else\
    \ if p==16 \n        then return modp(15*n, p)\n    else if p==17 \n        then\
    \ return modp(16*n, p)\n    else if p==18 \n        then return modp(17*n, p)\n\
    \    else if p==19 \n        then return modp(18*n, p)\n    else if p==20 \n \
    \       then return modp(19*n, p)\n    else if p==21 \n        then return modp(20*n,\
    \ p)\n    else if p==22 \n        then return modp(21*n, p)\n    else if p==23\
    \ \n        then return modp(22*n, p)\n    else if p==24 \n        then return\
    \ modp(23*n, p)\n    else if p==25 \n        then return modp(24*n, p)\n    else\
    \ if p==26 \n        then return modp(25*n, p)\n    else if p==27 \n        then\
    \ return modp(26*n, p)\n    else if p==28 \n        then return modp(27*n, p)\n\
    \    else if p==29 \n        then return modp(28*n, p)\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpv3l7wn1z.jl:15\nin expression starting at /tmp/tmpv3l7wn1z.jl:15\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n, p)\n    if p==4 then return modp(3*n, p)\n\
    \    if p==5 then return modp(4*n, p)\n    if p==6 then return modp(5*n, p)\n\
    \    if p==7 then return modp(6*n, p)\n    if p==8 then return modp(7*n, p)\n\
    \    if p==9 then return modp(8*n, p)\n    if p==10 then return modp(9*n, p)\n\
    \    if p==11 then return modp(10*n, p)\n    if p==12 then return modp(11*n, p)\n\
    \    if p==13 then return modp(12*n, p)\n    if p==14 then return modp(13*n, p)\n\
    \    if p==15 then return modp(14*n, p)\n    if p==16 then return modp(15*n, p)\n\
    \    if p==17 then return modp(16*n, p)\n    if p==18 then return modp(17*n, p)\n\
    \    if p==19 then return modp(18*n, p)\n    if p==20 then return modp(19*n, p)\n\
    \    if p==21 then return modp(20*n, p)\n    if p==22 then return modp(21*n, p)\n\
    \    if p==23 then return modp(22*n, p)\n    if p==24 then return modp(23*n, p)\n\
    \    if p==25 then return modp(24*n, p)\n    if p==26 then return modp(25*n, p)\n\
    \    if p==27 then return modp(26*n, p)\n    if p==28 then return modp(27*n, p)\n\
    \    if p==29 then return modp(28*n, p)\n    if p==30 then return modp(29*n, p)\n\
    \    if p==31 then return modp(30*n, p)\n    if p==32 then return modp(31*n, p)\n\
    \    if p==33 then return modp(32*n, p)\n    if p==34 then return modp(33*n, p)\n\
    \    if p==35 then return modp(34*n, p)\n    if p==36 then return modp(35*n, p)\n\
    \    if p==37 then return modp(36*n, p)\n    if p==38 then return modp(37*n, p)\n\
    \    if p==39 then return \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5x932lgr.jl:14\nin expression starting at /tmp/tmp5x932lgr.jl:14\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else return modp(abs(n),\
    \ p) \nend\n</code>\n<|/ a tags=julia,modular-arithmetic |>\n<| a dscore=2 |>\n\
    The accepted answer does not work for negative numbers. Here is a version that\
    \ does:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpynhplsxc.jl:15\nin expression starting at /tmp/tmpynhplsxc.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p == 2 \n        then return n*(n+1)\n    else if p == 3 \n        then return\
    \ n*(n+1)/2\n    else if p == 4 \n        then return n*(n+1)/2\n    else if p\
    \ == 5 \n        then return n*(n+1)*(2*n+1)\n    else if p == 6 \n        then\
    \ return n*(n+1)*(2*n+1)/2\n    else if p == 7 \n        then return n*(n+1)*(2*n+1)/2\n\
    \    else if p == 8 \n        then return n*(n+1)*(2*n+1)*(3*n+1)\n    else if\
    \ p == 9 \n        then return n*(n+1)*(2*n+1)*(3*n+1)/2\n    else if p == 10\
    \ \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)\n    else if p == 11 \n\
    \        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)/2\n    else if p == 12 \n\
    \        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)\n    else if p ==\
    \ 13 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)/2\n    else\
    \ if p == 14 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(9*n+1)\n\
    \    else if p == 15 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(9*n+1)/2\n\
    \    else if p == 16 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(9*n+1)*(11*n+1)\n\
    \    else if p == 17 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(9*n+1)*(11*n+1)/2\n\
    \    else if p == 18 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(9*n+1)*(11*n+1)*(13*n+1)\n\
    \    else if p == 19 \n        then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(9*n+1)*(11*n+1)*(13*n\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7yit_1v1.jl:15\nin expression starting at /tmp/tmp7yit_1v1.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if n < 0 then return\
    \ modp(-n, p)\n    else if p == 0 then return 0\n    else if p < 0 then return\
    \ modp(-n, p)\n    else if n < p then return modp(n, p)\n    else return modp(n\
    \ + p - 1, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpuo5tmx_2.jl:14\nin expression starting at /tmp/tmpuo5tmx_2.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n == p then return 1\n    if n < p then return modp(n, p)\n    if n < p\
    \ then return modp(n, p)\n    if n < p then return modp(n, p)\n    return modp(n,\
    \ p)\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9_tyidw7.jl:14\nin expression starting at /tmp/tmp9_tyidw7.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), -p) \n    return modp(n-1, p)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfd_61gsw.jl:14\nin expression starting at /tmp/tmpfd_61gsw.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p)\n    else \n        then return modp(n + p - 1,\
    \ p)\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe answer by is correct,\
    \ but I thought I'd add my own answer since I didn't see it posted yet.\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpo37b5i7m.jl:15\nin expression starting at /tmp/tmpo37b5i7m.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp50q239u2.jl:15\nin expression starting at /tmp/tmp50q239u2.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    else if n < p \n        error(\"modp requires n >= p\")\n    else if n ==\
    \ 0 \n        error(\"modp requires n != 0\")\n    else if p == 0 \n        error(\"\
    modp requires p != 0\")\n    else if p == 1 \n        error(\"modp requires p\
    \ != 1\")\n    else if p == -1 \n        error(\"modp requires p != -1\")\n  \
    \  else if n == 1 \n        error(\"modp requires n != 1\")\n    else if n ==\
    \ -1 \n        error(\"modp requires n != -1\")\n    else if p == 2 \n       \
    \ error(\"modp requires p != 2\")\n    else if p == 3 \n        error(\"modp requires\
    \ p != 3\")\n    else if p == 4 \n        error(\"modp requires p != 4\")\n  \
    \  else if p == 5 \n        error(\"modp requires p != 5\")\n    else if p ==\
    \ 6 \n        error(\"modp requires p != 6\")\n    else if p == 7 \n        error(\"\
    modp requires p != 7\")\n    else if p == 8 \n        error(\"modp requires p\
    \ != 8\")\n    else if p == 9 \n        error(\"modp requires p != 9\")\n    else\
    \ if p == 10 \n        error(\"modp requires p != 10\")\n    else if p == 11 \n\
    \        error(\"modp requires p != 11\")\n    else if p == 12 \n        error(\"\
    modp requires p != 12\")\n    else if p == 13 \n        error(\"modp requires\
    \ p != 13\")\n    else if p == 14 \n        error(\"modp requires p != 14\")\n\
    \    else if p == 15 \n        error(\"modp requires p != 15\")\n    else if p\
    \ == 16 \n        error(\"modp requires p != 16\")\n    else if p == 17 \n   \
    \     error(\"modp requires p != 17\")\n    else if p == 18 \n        error(\"\
    modp requires p != 18\")\n    else if p == 19 \n        error(\"modp requires\
    \ p != 19\")\n    else if p == 20 \n        error(\"modp requires p != 20\")\n\
    \    else if p == 21 \n        error(\"modp requires p != 21\")\n    else if p\
    \ == 22 \n        error(\"modp requires p != 22\")\n    else if p == 23 \n   \
    \     error(\"modp requires p != 23\")\n    else if p == 24 \n        error(\"\
    modp requires p != 24\")\n    else if p == 25 \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9a4965zi.jl:16\nin expression starting at\
    \ /tmp/tmp9a4965zi.jl:16\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n-1, p-1)\n    if p==4 then return modp(2*n-1,\
    \ p)\n    if p==5 then return modp(2*n-1, p+1)\n    if p==6 then return modp(2*n-1,\
    \ p+2)\n    if p==7 then return modp(2*n-1, p+3)\n    if p==8 then return modp(2*n-1,\
    \ p+4)\n    if p==9 then return modp(2*n-1, p+5)\n    if p==10 then return modp(2*n-1,\
    \ p+6)\n    if p==11 then return modp(2*n-1, p+7)\n    if p==12 then return modp(2*n-1,\
    \ p+8)\n    if p==13 then return modp(2*n-1, p+9)\n    if p==14 then return modp(2*n-1,\
    \ p+10)\n    if p==15 then return modp(2*n-1, p+11)\n    if p==16 then return\
    \ modp(2*n-1, p+12)\n    if p==17 then return modp(2*n-1, p+13)\n    if p==18\
    \ then return modp(2*n-1, p+14)\n    if p==19 then return modp(2*n-1, p+15)\n\
    \    if p==20 then return modp(2*n-1, p+16)\n    if p==21 then return modp(2*n-1,\
    \ p+17)\n    if p==22 then return modp(2*n-1, p+18)\n    if p==23 then return\
    \ modp(2*n-1, p+19)\n    if p==24 then return modp(2*n-1, p+20)\n    if p==25\
    \ then return modp(2*n-1, p+21)\n    if p==26 then return modp(2*n-1, p+22)\n\
    \    if p==27 then return modp(2*n-1, p+23)\n    if p==28 then return modp(2*n-1,\
    \ p+24)\n    if p==29 then return modp(2*n-1, p+25)\n    if p==30 then return\
    \ modp(2*n-1, p+26)\n    if p==31 then return modp(2*n-1, p+27)\n    if p==32\
    \ then return modp(2*n-1, p+28)\n    if p==33 then return modp(2*n-1, p+29)\n\
    \    if p==34 \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfmwk72b3.jl:14\nin expression starting at /tmp/tmpfmwk72b3.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(n, -p)\n    if p > n then return modp(n, p - n)\n\
    \    \n    let mut n1 = n\n    let mut n2 = n\n    let mut n3 = n\n    let mut\
    \ n4 = n\n    let mut n5 = n\n    let mut n6 = n\n    let mut n7 = n\n    let\
    \ mut n8 = n\n    let mut n9 = n\n    let mut n10 = n\n    let mut n11 = n\n \
    \   let mut n12 = n\n    let mut n13 = n\n    let mut n14 = n\n    let mut n15\
    \ = n\n    let mut n16 = n\n    let mut n17 = n\n    let mut n18 = n\n    let\
    \ mut n19 = n\n    let mut n20 = n\n    let mut n21 = n\n    let mut n22 = n\n\
    \    let mut n23 = n\n    let mut n24 = n\n    let mut n25 = n\n    let mut n26\
    \ = n\n    let mut n27 = n\n    let mut n28 = n\n    let mut n29 = n\n    let\
    \ mut n30 = n\n    let mut n31 = n\n    let mut n32 = n\n    let mut n33 = n\n\
    \    let mut n34 = n\n    let mut n35 = n\n    let mut n36 = n\n    let mut n37\
    \ = n\n    let mut n38 = n\n    let mut n39 = n\n    let mut n40 = n\n    let\
    \ mut n41 = n\n    let mut n42 = n\n    let mut n43 = n\n    let mut n44 = n\n\
    \    let mut n45 = n\n    let mut n46 = n\n    let mut n47 = n\n    let mut n48\
    \ = n\n    let mut n49 = n\n    let mut n50 = n\n    let mut n51 = n\n    let\
    \ mut n52 = n\n    let mut n53 = n\n    let mut n54 = n\n    let mut n55 = n\n\
    \    let mut n56 = n\n    let mut n57 = n\n    let mut n58 = n\n    let mut n59\
    \ = n\n    let mut n60 = n\n    let mut n61 = n\n    let mut n62 = n\n    let\
    \ mut n63 = n\n    let mut n64 = n\n    let mut n65 = n\n    let mut n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdz5j3ysd.jl:14\nin expression starting at /tmp/tmpdz5j3ysd.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if p == 1\
    \ \n        then return n\n    else if n <= p \n        then return modp(n - p,\
    \ p)\n    else return modp(n - p, p + p - 1)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwv1dxphk.jl:15\nin expression starting at /tmp/tmpwv1dxphk.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(n, -p)\n    if p > n then return modp(n, p - n)\n\
    \    if n <= p then return modp(n, n)\n    return modp(n, p - n)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgvudl6gp.jl:14\nin expression starting at /tmp/tmpgvudl6gp.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else if n < p \n        then\
    \ return modp(n, p)\n    else \n        then return modp(n - p, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxtt1ikar.jl:15\nin expression starting at /tmp/tmpxtt1ikar.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n        else return\
    \ modp(n - p, p)\n    end\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2rcim88k.jl:15\nin expression starting at /tmp/tmp2rcim88k.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n+1\n    if p==4 then return n*2\n    if p==5 then return\
    \ n*3\n    if p==6 then return n*4\n    if p==7 then return n*5\n    if p==8 then\
    \ return n*6\n    if p==9 then return n*7\n    if p==10 then return n*8\n    if\
    \ p==11 then return n*9\n    if p==12 then return n*10\n    if p==13 then return\
    \ n*11\n    if p==14 then return n*12\n    if p==15 then return n*13\n    if p==16\
    \ then return n*14\n    if p==17 then return n*15\n    if p==18 then return n*16\n\
    \    if p==19 then return n*17\n    if p==20 then return n*18\n    if p==21 then\
    \ return n*19\n    if p==22 then return n*20\n    if p==23 then return n*21\n\
    \    if p==24 then return n*22\n    if p==25 then return n*23\n    if p==26 then\
    \ return n*24\n    if p==27 then return n*25\n    if p==28 then return n*26\n\
    \    if p==29 then return n*27\n    if p==30 then return n*28\n    if p==31 then\
    \ return n*29\n    if p==32 then return n*30\n    if p==33 then return n*31\n\
    \    if p==34 then return n*32\n    if p==35 then return n*33\n    if p==36 then\
    \ return n*34\n    if p==37 then return n*35\n    if p==38 then return n*36\n\
    \    if p==39 then return n*37\n    if p==40 then return n*38\n    if p==41 then\
    \ return n*39\n    if p==42 then return n*40\n    if p==43 then return n*41\n\
    \    if p==44 then return n*42\n    if p==45 then return n*43\n    if p==46 then\
    \ return n*44\n    if p==47 then return n*45\n    if p==48 then return n*46\n\
    \    if p==49 then return n*47\n    if p==50 then return n*48\n    if p==51 then\
    \ return n*49\n    if p==52 then return n*50\n    if p==53 then return n*51\n\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfpc8rkam.jl:14\nin expression starting at /tmp/tmpfpc8rkam.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-abs(n), abs(p))\n   \
    \ else if n == p \n        then return 0\n    else if n < p \n        then return\
    \ modp(n - p, p)\n    else return modp(n - p, modp(n - n, p))\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7ibz8vr3.jl:15\nin expression starting at /tmp/tmp7ibz8vr3.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, -p)\n    else return modp(n, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp322nmh1q.jl:15\nin expression starting at /tmp/tmp322nmh1q.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n, p)\n    if p==4 then return modp(3*n, p)\n\
    \    if p==5 then return modp(4*n, p)\n    if p==6 then return modp(5*n, p)\n\
    \    if p==7 then return modp(6*n, p)\n    if p==8 then return modp(7*n, p)\n\
    \    if p==9 then return modp(8*n, p)\n    if p==10 then return modp(9*n, p)\n\
    \    if p==11 then return modp(10*n, p)\n    if p==12 then return modp(11*n, p)\n\
    \    if p==13 then return modp(12*n, p)\n    if p==14 then return modp(13*n, p)\n\
    \    if p==15 then return modp(14*n, p)\n    if p==16 then return modp(15*n, p)\n\
    \    if p==17 then return modp(16*n, p)\n    if p==18 then return modp(17*n, p)\n\
    \    if p==19 then return modp(18*n, p)\n    if p==20 then return modp(19*n, p)\n\
    \    if p==21 then return modp(20*n, p)\n    if p==22 then return modp(21*n, p)\n\
    \    if p==23 then return modp(22*n, p)\n    if p==24 then return modp(23*n, p)\n\
    \    if p==25 then return modp(24*n, p)\n    if p==26 then return modp(25*n, p)\n\
    \    if p==27 then return modp(26*n, p)\n    if p==28 then return modp(27*n, p)\n\
    \    if p==29 then return modp(28*n, p)\n    if p==30 then return modp(29*n, p)\n\
    \    if p==31 then return modp(30*n, p)\n    if p==32 then return modp(31*n, p)\n\
    \    if p==33 then return modp(32*n, p)\n    if p==34 then return modp(33*n, p)\n\
    \    if p==35 then return modp(34*n, p)\n    if p==36 then return modp(35*n, p)\n\
    \    if p==37 then return modp(36*n, p)\n    if p==38 then return modp(37*n, p)\n\
    \    if p==39 then return \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5x932lgr.jl:14\nin expression starting at /tmp/tmp5x932lgr.jl:14\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(n - 1, modp(n, p - 1)) + p\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqei5pnr8.jl:15\nin expression starting at /tmp/tmpqei5pnr8.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n, p - 1)\n    else return modp(n, p)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm7babgwh.jl:15\nin expression starting at /tmp/tmpm7babgwh.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return 1\n        else return modp(n - 1, p) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpza1e7l03.jl:15\nin expression starting at /tmp/tmpza1e7l03.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 1\n    else if n == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if n < p \n   \
    \     then return modp(n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\
    \"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbf9ajjn6.jl:15\nin expression starting at /tmp/tmpbf9ajjn6.jl:15\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return n\n    if n==p then return 1\n\
    \    if n>p then return modp(modp(n,p)-1,p)\n    if n<p then return modp(n,modp(p,n))\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6oe3f6uu.jl:14\nin expression starting at /tmp/tmp6oe3f6uu.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    else if n==1 then return\
    \ p \n    else if p==0 then return 0 \n    else if p==1 then return 1 \n    else\
    \ if p==2 then return modp(n / 2, p) \n    else return modp(n / 2, modp(n, p -\
    \ 1)) * modp(n, p)\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgda_25xa.jl:14\nin expression starting at /tmp/tmpgda_25xa.jl:14\n"
  stdout: ''
  timestamp: 1659823064
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 1\n    else if n==1\n \
    \       then return p\n    else if p==1\n        then return 1\n    else if p==0\n\
    \        then return 0\n    else if p==2\n        then return n\n    else if p==3\n\
    \        then return modp(2*n-1, p)\n    else if p==5\n        then return modp(3*n-1,\
    \ p)\n    else if p==7\n        then return modp(4*n-1, p)\n    else if p==11\n\
    \        then return modp(5*n-1, p)\n    else if p==13\n        then return modp(6*n-1,\
    \ p)\n    else if p==17\n        then return modp(7*n-1, p)\n    else if p==19\n\
    \        then return modp(8*n-1, p)\n    else if p==23\n        then return modp(9*n-1,\
    \ p)\n    else if p==29\n        then return modp(10*n-1, p)\n    else if p==31\n\
    \        then return modp(11*n-1, p)\n    else if p==37\n        then return modp(12*n-1,\
    \ p)\n    else if p==41\n        then return modp(13*n-1, p)\n    else if p==43\n\
    \        then return modp(14*n-1, p)\n    else if p==47\n        then return modp(15*n-1,\
    \ p)\n    else if p==53\n        then return modp(16*n-1, p)\n    else if p==59\n\
    \        then return modp(17*n-1, p)\n    else if p==61\n        then return modp(18*n-1,\
    \ p)\n    else if p==67\n        then return modp(19*n-1, p)\n    else if p==71\n\
    \        then return modp(20*n-1, p)\n    else if p==73\n        then return modp(21*n-1,\
    \ p)\n    else if p==79\n        then return modp(22*n-1, p)\n    else if p==83\n\
    \        then return modp(23*n-1, p)\n    else if p==89\n        then return modp(24*n-1,\
    \ p)\n    else if p==97\n        then return modp(25*n-1, p)\n    else if p==101\n\
    \        then return modp(26*n-1, p)\n    else if p==103\n        then return\
    \ modp(27*n-1, p)\n    else if p==107\n        then return modp(\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsxc1re7m.jl:15\nin expression starting at /tmp/tmpsxc1re7m.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return p\n    else if n==1 \n\
    \        then return p\n    else \n        return modp(n-1, p) + p\nend\n</cell>\n\
    <code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjknhbyyl.jl:15\nin expression starting at /tmp/tmpjknhbyyl.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    if p==0 return\
    \ 0\n    if p==1 return 1\n    if p==2 return n\n    if p==3 return n*(n+1)/2\n\
    \    if p==4 return n*(n+1)*(2*n+1)/6\n    if p==5 return n*(n+1)*(2*n+1)*(3*n+1)/24\n\
    \    if p==6 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)/120\n    if p==7 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)/720\n\
    \    if p==8 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)/5040\n  \
    \  if p==9 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)/40320\n\
    \    if p==10 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)/36288\n\
    \    if p==11 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)/67108864\n\
    \    if p==12 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)/134217728\n\
    \    if p==13 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)/268435456\n\
    \    if p==14 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)/39321648\n\
    \    if p==15 return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)*(37*n+1)/67108864\n\
    \    if p==16 return \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy81jf0sw.jl:1\nin expression starting at /tmp/tmpy81jf0sw.jl:1\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else if n < p \n        then\
    \ return modp(n - p, p)\n    else \n        then return modp(n - p, p)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmarb5qeu.jl:15\nin expression starting at /tmp/tmpmarb5qeu.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 || p==0 \n        then return 0\n    else if\
    \ n==1\n        then return p\n    else if p==1\n        then return n\n    else\
    \ \n        modp(n - 1, p) \n        + modp(n, p mod n)\nend\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| c |>\nThis answer does not seem to answer the question. `modp(3, 5)`\
    \ returns `3` but `modp(1101, 101)` returns `2`.\n<|/ c |>\n<| c |>\nIt does answer\
    \ the question. modp(1101, 101) returns 2 because 1101 mod 101 = 2. modp(3, 5)\
    \ returns 3 because 3 mod 5 = 0.\n<|/ c |>\n<| c |>\nThis answer does not seem\
    \ to answer the question. `modp(3, 5)` returns `3` but `modp(1101, 101)` returns\
    \ `2`.\n<|/ c |>\n<| c |>\nThis answer does not seem to answer the question. `modp(3,\
    \ 5)` returns `3` but `modp(1101, 101)` returns `2`.\n<|/ c |>\n<| a dscore=5\
    \ |>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod m is given by \n<code>\n(a*m)%m\n\
    </code>\nThe modular inverse of a number a mod \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpw_ucqheh.jl:15\nin expression starting at /tmp/tmpw_ucqheh.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return 1\n    if n >= p then return 0\n    if n % p == 0 then\
    \ return modp(n / p, p)\n    return modp(n / p, p) * modp(p, n)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9s14mwbz.jl:14\nin expression starting at /tmp/tmp9s14mwbz.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp: n must be positive\"\
    )\n    if p <= 0\n        error(\"modp: p must be positive\")\n    if p < n\n\
    \        error(\"modp: p must be >= n\")\n    if p == 0 \n        error(\"modp:\
    \ p == 0\")\n    if p == 1 \n        error(\"modp: p == 1\")\n    if p == 2 \n\
    \        error(\"modp: p == 2\")\n    if p == 3 \n        error(\"modp: p == 3\"\
    )\n    if p == 4 \n        error(\"modp: p == 4\")\n    if p == 5 \n        error(\"\
    modp: p == 5\")\n    if p == 6 \n        error(\"modp: p == 6\")\n    if p ==\
    \ 7 \n        error(\"modp: p == 7\")\n    if p == 8 \n        error(\"modp: p\
    \ == 8\")\n    if p == 9 \n        error(\"modp: p == 9\")\n    if p == 10 \n\
    \        error(\"modp: p == 10\")\n    if p == 11 \n        error(\"modp: p ==\
    \ 11\")\n    if p == 12 \n        error(\"modp: p == 12\")\n    if p == 13 \n\
    \        error(\"modp: p == 13\")\n    if p == 14 \n        error(\"modp: p ==\
    \ 14\")\n    if p == 15 \n        error(\"modp: p == 15\")\n    if p == 16 \n\
    \        error(\"modp: p == 16\")\n    if p == 17 \n        error(\"modp: p ==\
    \ 17\")\n    if p == 18 \n        error(\"modp: p == 18\")\n    if p == 19 \n\
    \        error(\"modp: p == 19\")\n    if p == 20 \n        error(\"modp: p ==\
    \ 20\")\n    if p == 21 \n        error(\"modp: p == 21\")\n    if p == 22 \n\
    \        error(\"modp: p == 22\")\n    if p == 23 \n        error(\"modp: p ==\
    \ 23\")\n    if p == 24 \n        error(\"modp: p == 24\")\n    if p == 25 \n\
    \        error(\"modp: p == 25\")\n    if p == 26 \n        error(\"modp: p ==\
    \ 26\")\n    if p == 27 \n        error(\"modp: p == 27\")\n    if p == 28 \n\
    \        error(\"modp: p == 28\")\n    if p == 29 \n        error(\"modp: p ==\
    \ 29\")\n    if p == 30 \n        error(\"modp: p == 30\")\n    if p == 31 \n\
    \        error(\"modp: p == 31\")\n    if p == 32 \n        error(\"modp: p ==\
    \ 32\")\n    if p == 33 \n        error(\"modp: p == 33\")\n    if p == 34 \n\
    \        error(\"modp: p == 34\")\n    if p\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqzznsgx2.jl:1\nin expression starting at /tmp/tmpqzznsgx2.jl:1\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    else if n==1 then return\
    \ p \n    else if p==0 then return 1 \n    else if p==1 then return n \n    else\
    \ return modp(n mod p, p) \nend \n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The algorithm is quite simple:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4vacl55v.jl:14\nin expression starting at /tmp/tmp4vacl55v.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else \n        return modp(abs(n),\
    \ abs(p))\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p\
    \ (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe1zhypy9.jl:15\nin expression starting at /tmp/tmpe1zhypy9.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p == 0 then return 0\n    if p == 1 then return n\n    if p < n then return\
    \ modp(n - p, p)\n    if p > n then return modp(n, p - n)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"Return n modulo p (be aware of numerics).\n    >>>\
    \ modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n  \
    \  1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6q17_cuo.jl:14\nin expression starting at /tmp/tmp6q17_cuo.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n-1, p)\n    else if n > p \n        then\
    \ return modp(n, p-n)\n    else return modp(n-1, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps357_zyf.jl:15\nin expression starting at /tmp/tmps357_zyf.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    else if p < 0 \n        error(\"modp requires p >= 0\")\n    else if n ==\
    \ 0 \n        error(\"modp requires n > 0\") \n    else if p == 0 \n        error(\"\
    modp requires p > 0\") \n    else if p == 1 \n        error(\"modp requires p\
    \ != 1\")\n    else if p == 2 \n        return n\n    else if p == 3 \n      \
    \  return n\n    else if p == 4 \n        return n\n    else if p == 5 \n    \
    \    return n\n    else if p == 6 \n        return n\n    else if p == 7 \n  \
    \      return n\n    else if p == 8 \n        return n\n    else if p == 9 \n\
    \        return n\n    else if p == 10 \n        return n\n    else if p == 11\
    \ \n        return n\n    else if p == 12 \n        return n\n    else if p ==\
    \ 13 \n        return n\n    else if p == 14 \n        return n\n    else if p\
    \ == 15 \n        return n\n    else if p == 16 \n        return n\n    else if\
    \ p == 17 \n        return n\n    else if p == 18 \n        return n\n    else\
    \ if p == 19 \n        return n\n    else if p == 20 \n        return n\n    else\
    \ if p == 21 \n        return n\n    else if p == 22 \n        return n\n    else\
    \ if p == 23 \n        return n\n    else if p == 24 \n        return n\n    else\
    \ if p == 25 \n        return n\n    else if p == 26 \n        return n\n    else\
    \ if p == 27 \n        return n\n    else if p == 28 \n        return n\n    else\
    \ if p == 29 \n        return n\n    else if p == 30 \n        return n\n    else\
    \ if p == 31 \n        return n\n    else if p == 32 \n        return n\n    else\
    \ if p == 33 \n        return n\n    else if p == 34 \n        return n\n    else\
    \ if p == 35 \n        return n\n    else if p == 36 \n        return n\n    else\
    \ if p == 37 \n        return n\n    else if p == 38 \n        return n\n    else\
    \ if p == 39 \n        return n\n    else if p == 40 \n        return n\n    else\
    \ if p == 41 \n        return n\n    else if p == 42 \n        return n\n    else\
    \ if p == 43 \n        return n\n    else if p == 44 \n        return n\n    else\
    \ if p == 45 \n        return n\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjoep4dw4.jl:16\nin expression starting at\
    \ /tmp/tmpjoep4dw4.jl:16\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    if p < 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    if p < 1 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    if n == 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    if n == 1 \n        return n\n    if n == p \n        return\
    \ 1\n    if n % p == 0 \n        return p\n    if n % p == 1 \n        return\
    \ p + 1\n    if n % p == 2 \n        return p + 2\n    if n % p == 3 \n      \
    \  return p + 3\n    if n % p == 4 \n        return p + 4\n    if n % p == 5 \n\
    \        return p + 5\n    if n % p == 6 \n        return p + 6\n    if n % p\
    \ == 7 \n        return p + 7\n    if n % p == 8 \n        return p + 8\n    if\
    \ n % p == 9\n        return p + 9\n    if n % p == 10\n        return p + 10\n\
    \    if n % p == 11\n        return p + 11\n    if n % p == 12\n        return\
    \ p + 12\n    if n % p == 13\n        return p + 13\n    if n % p == 14\n    \
    \    return p + 14\n    if n % p == 15\n        return p + 15\n    if n % p ==\
    \ 16\n        return p + 16\n    if n % p == 17\n        return p + 17\n    if\
    \ n % p == 18\n        return p + 18\n    if n % p == 19\n        return p + 19\n\
    \    if n % p == 20\n        return p + 20\n    if n % p == 21\n        return\
    \ p + 21\n    if n % p == 22\n        return p + 22\n    if n % p == 23\n    \
    \    return p + 23\n    if n % p == 24\n        return p + 24\n    if n % p ==\
    \ 25\n        return p + 25\n    if n % p == 26\n        return p + 26\n    if\
    \ n % p == 27\n        return p + 27\n    if n % p == 28\n        return p + 28\n\
    \    if n % p == 29\n        return p + 29\n    if n % p == 30\n        return\
    \ p + 30\n    if n % p == 31\n        return p + 31\n    if n % p == 32\n    \
    \    return p + 32\n    if n % p == 33\n        return p + 33\n    if n % p ==\
    \ 34\n        return p + 34\n    if n % p == 35\n        return p + 35\n    if\
    \ n % p == 36\n        return p + 36\n    if n % p == 37\n        return p + 37\n\
    \    if n % p == 38\n        return p + 38\n    if n % p == 39\n        return\
    \ p + 39\n    if n % p == 40\n        return p + 40\n    if n % \nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpisc98b6z.jl:1\nin expression starting at /tmp/tmpisc98b6z.jl:1\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\
    \ \n        then return modp(-n, p)\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n\
    \        then return modp(n mod p, p)\n    else return modp(n mod p, p)\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphjc4fmny.jl:15\nin expression starting at /tmp/tmphjc4fmny.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    if p < 0 \n        error(\"modp requires p >= 0\")\n    if p > n \n     \
    \   error(\"modp requires p <= n\")\n    if n == 0 \n        error(\"modp requires\
    \ n != 0\")\n    if p == 0 \n        error(\"modp requires p != 0\")\n    if p\
    \ == 1 \n        return n\n    if p == 2 \n        return n // 2 + 1\n    if p\
    \ == 3 \n        return n // 3 + 1\n    if p == 4 \n        return n // 4 + 1\n\
    \    if p == 5 \n        return n // 5 + 1\n    if p == 6 \n        return n //\
    \ 6 + 1\n    if p == 7 \n        return n // 7 + 1\n    if p == 8 \n        return\
    \ n // 8 + 1\n    if p == 9 \n        return n // 9 + 1\n    if p == 10 \n   \
    \     return n // 10 + 1\n    if p == 11 \n        return n // 11 + 1\n    if\
    \ p == 12 \n        return n // 12 + 1\n    if p == 13 \n        return n // 13\
    \ + 1\n    if p == 14 \n        return n // 14 + 1\n    if p == 15 \n        return\
    \ n // 15 + 1\n    if p == 16 \n        return n // 16 + 1\n    if p == 17 \n\
    \        return n // 17 + 1\n    if p == 18 \n        return n // 18 + 1\n   \
    \ if p == 19 \n        return n // 19 + 1\n    if p == 20 \n        return n //\
    \ 20 + 1\n    if p == 21 \n        return n // 21 + 1\n    if p == 22 \n     \
    \   return n // 22 + 1\n    if p == 23 \n        return n // 23 + 1\n    if p\
    \ == 24 \n        return n // 24 + 1\n    if p == 25 \n        return n // 25\
    \ + 1\n    if p == 26 \n        return n // 26 + 1\n    if p == 27 \n        return\
    \ n // 27 + 1\n    if p == 28 \n        return n // 28 + 1\n    if p == 29 \n\
    \        return n // 29 + 1\n    if p == 30 \n        return n // 30 + 1\n   \
    \ if p == 31 \n        return n // 31 + 1\n    if p == 32 \n        return n //\
    \ 32 + 1\n    if p == 33 \n        return n // 33 + 1\n    if p == 34 \n     \
    \   return n // 34 + 1\n    if p == 35 \n        return n // 35 + 1\n    if p\
    \ == 36 \n        return n // 36 + 1\n    if p == 37 \n        return n // 37\
    \ + 1\n    if p == 38 \n        return n // 38 + 1\n    if p == 39 \n        return\
    \ n // 39 + 1\n    if p == 40 \n        return n // 40 + 1\n    if p == 41 \n\
    \        return n // 41 + \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkywwzfbn.jl:1\nin expression starting at /tmp/tmpkywwzfbn.jl:1\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p \n        then return n \n    else \n      \
    \  modp(n - p, p) \nend \n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsciyxovs.jl:15\nin expression starting at /tmp/tmpsciyxovs.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p > p then return modp(n, p)\n \
    \   if p % 2 == 0 then return modp(n / 2, p)\n    return modp(n / 2, p) + modp(n\
    \ / 2, p - 1)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvnk4bid1.jl:14\nin expression starting at /tmp/tmpvnk4bid1.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n, p mod n)\n    if p < n then return modp(n, p\
    \ mod n)\n    if p == n then return 1\n    if p == 1 then return 0\n    if p ==\
    \ 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then return 1\n    if p == 1 then\
    \ return 0\n    if p == 0 then return 1\n    if p == 1 then return 0\n    if p\
    \ == 0 then return 1\n    if p == 1 then return 0\n    if p == 0 then return 1\n\
    \    if p == 1 then return 0\n    if p == 0 then \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphovrqduq.jl:14\nin expression starting at /tmp/tmphovrqduq.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if p > 0 \n        then return modp(n, p)\n    else if n <= 0 \n\
    \        then return 0\n    else if n == 1 \n        then return p\n    else if\
    \ n == 2 \n        then return p\n    else if n % 2 == 0 \n        then return\
    \ modp(n / 2, p)\n    else return modp((n - 1) / 2, p) + p\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpw3dgocfq.jl:15\nin expression starting at /tmp/tmpw3dgocfq.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < n \n        then return modp(n - 1,\
    \ p) \n        else return modp(n, p - 1)\nend\n</code>\n<|/ a tags=math,julia,algorithm\
    \ |>\n<| c |>\nThis doesn't work. `modp(3, 5)` returns `3` instead of `2`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I tested it before posting it. I will edit the\
    \ post to make it clearer.\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I must have made a mistake when I first tried it. Thanks for pointing it out.\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I must have made a mistake\
    \ when I first tried it. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I must have made a mistake when I first tried it. Thanks\
    \ for pointing it out.\n<|/ c |>\n<| a dscore=3 |>\nThe answer by is correct,\
    \ but I thought I'd add some explanation as to why it works.\nThe modular inverse\
    \ of a number N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ inverse of N is defined as the number x such that x^-1 mod N == 1.\nThe modular\
    \ \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbwwiwqjq.jl:15\nin expression starting at /tmp/tmpbwwiwqjq.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n    else \n     \
    \   then return modp(n - p, p) \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_m154zwx.jl:15\nin expression starting at /tmp/tmp_m154zwx.jl:15\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 2 then return 0\n    if p < n then return modp(n - 1, p) \n    else\
    \ return modp(n-1, p) % p\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5apamh7m.jl:14\nin expression starting at /tmp/tmp5apamh7m.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if p == 0 then return\
    \ 0\n    else if p < 0 then return modp(abs(n), abs(p))\n    else return modp(n\
    \ / p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return n^k modulo p\
    \ (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpuwmrfoj0.jl:14\nin expression starting at /tmp/tmpuwmrfoj0.jl:14\n"
  stdout: ''
  timestamp: 1659823066
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(abs(n), abs(p))\n    else if p > 1 \n  \
    \      then return modp(n, p mod 2)\n    else if p < 2 \n        then return modp(n,\
    \ p mod 3)\n    else if p < 3 \n        then return modp(n, p mod 5)\n    else\
    \ if p < 5 \n        then return modp(n, p mod 7)\n    else if p < 7 \n      \
    \  then return modp(n, p mod 11)\n    else if p < 11 \n        then return modp(n,\
    \ p mod 13)\n    else if p < 13 \n        then return modp(n, p mod 17)\n    else\
    \ if p < 17 \n        then return modp(n, p mod 19)\n    else if p < 19 \n   \
    \     then return modp(n, p mod 23)\n    else if p < 23 \n        then return\
    \ modp(n, p mod 29)\n    else if p < 29 \n        then return modp(n, p mod 31)\n\
    \    else if p < 31 \n        then return modp(n, p mod 37)\n    else if p < 37\
    \ \n        then return modp(n, p mod 43)\n    else if p < 43 \n        then return\
    \ modp(n, p mod 51)\n    else if p < 51 \n        then return modp(n, p mod 59)\n\
    \    else if p < 59 \n        then return modp(n, p mod 61)\n    else if p < 61\
    \ \n        then return modp(n, p mod 67)\n    else if p < 67 \n        then return\
    \ modp(n, p mod 73)\n    else if p < 73 \n        then return modp(n, p mod 79)\n\
    \    else if p < 79 \n        then return modp(n, p mod 83)\n    else if p < 83\
    \ \n        then return modp(n, p mod 89)\n    else if p < 89 \n        then return\
    \ modp(n, p mod 97)\n    else if p < 97 \n        then return modp(n, p mod 103)\n\
    \    else if p < 103 \n        then return modp(n, p mod 109)\n    else if p <\
    \ 109 \n        then return modp(n, p mod 115)\n    else if p < 115 \nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprgko5kgb.jl:15\nin expression starting at /tmp/tmprgko5kgb.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return 1\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if p < n \n   \
    \     then return modp(n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else \n        then return modp(n+p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpybq0l6kv.jl:15\nin expression starting at /tmp/tmpybq0l6kv.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+1)*(2*n+1)/6\n\
    \    if p==5 then return n*(n+1)*(2*n+1)*(3*n+1)/5\n    if p==6 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)/4\n\
    \    if p==7 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)/25\n    if p==8\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)/125\n    if p==9\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)/625\n  \
    \  if p==10 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)/1680\n\
    \    if p==11 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)/4096\n\
    \    if p==12 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)/131072\n\
    \    if p==13 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)/262144\n\
    \    if p==14 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)*(12*n+1)/524288\n\
    \    if p==15 then return n*(n+1)*(2*n+1)*(3*n+1)*(4*n+1)*(5*n+1)*(6*n+1)*(7*n+1)*(8*n+1)*(9*n+1)*(10*n+1)*(11*n+1)*(12*n\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5i8pi8hm.jl:14\nin expression starting at /tmp/tmp5i8pi8hm.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return 0\n    if p < n then return 0\n    if p < 2 then return\
    \ 1\n    if p < 3 then return 1\n    if p < 4 then return 2\n    if p < 5 then\
    \ return 2\n    if p < 6 then return 4\n    if p < 7 then return 4\n    if p <\
    \ 8 then return 8\n    if p < 9 then return 8\n    if p < 10 then return 16\n\
    \    if p < 11 then return 16\n    if p < 12 then return 32\n    if p < 13 then\
    \ return 32\n    if p < 14 then return 64\n    if p < 15 then return 64\n    if\
    \ p < 16 then return 128\n    if p < 17 then return 128\n    if p < 18 then return\
    \ 256\n    if p < 19 then return 256\n    if p < 20 then return 512\n    if p\
    \ < 21 then return 512\n    if p < 22 then return 1024\n    if p < 23 then return\
    \ 1024\n    if p < 24 then return 2048\n    if p < 25 then return 2048\n    if\
    \ p < 26 then return 4096\n    if p < 27 then return 4096\n    if p < 28 then\
    \ return 8192\n    if p < 29 then return 8192\n    if p < 30 then return 16384\n\
    \    if p < 31 then return 16384\n    if p < 32 then return 32768\n    if p <\
    \ 33 then return 32768\n    if p < 34 then return 65536\n    if p < 35 then return\
    \ 65536\n    if p < 36 then return 131072\n    if p < 37 then return 131072\n\
    \    if p < 38 then return 262144\n    if p < 39 then return 262144\n    if p\
    \ < 40 then return 524288\n    if p < 41 then return 524288\n    if p < 42 then\
    \ return 1048576\n    if p < 43 then return 1048576\n    if p < 44 then return\
    \ 2097152\n    if p < 45 then return 2097152\n    if p < 46 then return 4194304\n\
    \    if p < 47 then return 4194304\n    if p < 48 then return 8388608\n    if\
    \ p < 49 then return 8388608\n    if p < 50 then return 16777216\n    if p < 51\
    \ then return 16777216\n    if p < 52 then return 33554432\n    if p < 53 then\
    \ return 33554432\n    if p < 54 then return 67\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn5c6ikkh.jl:14\nin expression starting at /tmp/tmpn5c6ikkh.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n <= p\
    \ \n        then return n\n    else \n        modp(n / p, p) + n % p\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. Try it with\
    \ `modp(2, -2)`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting\
    \ it. I will add an example to my answer.\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it does work. Try it with `modp(2, -2)`.\n<|/ c |>\n<| c |>\nI tested it\
    \ again and it does work. Try it with `modp(2, -2)`.\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it does work. Try it with `modp(2, -2)`.\n<|/ c |>\n<| a |>\nThe\
    \ solution I came up with is this:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbstmfx1n.jl:15\nin expression starting at /tmp/tmpbstmfx1n.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p < 0 then return modp(-n, p)\n    if p >\
    \ 1 then return modp(n, p)\n    if p < n then return modp(n, p - n)\n    return\
    \ modp(n, p - n)\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp85ugr82p.jl:14\nin expression starting at /tmp/tmp85ugr82p.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+2)/2\n    if\
    \ p==5 then return n*(n+3)/2\n    if p==6 then return n*(n+4)/2\n    if p==7 then\
    \ return n*(n+5)/2\n    if p==8 then return n*(n+6)/2\n    if p==9 then return\
    \ n*(n+7)/2\n    if p==10 then return n*(n+8)/2\n    if p==11 then return n*(n+9)/2\n\
    \    if p==12 then return n*(n+10)/2\n    if p==13 then return n*(n+11)/2\n  \
    \  if p==14 then return n*(n+12)/2\n    if p==15 then return n*(n+13)/2\n    if\
    \ p==16 then return n*(n+14)/2\n    if p==17 then return n*(n+15)/2\n    if p==18\
    \ then return n*(n+16)/2\n    if p==19 then return n*(n+17)/2\n    if p==20 then\
    \ return n*(n+18)/2\n    if p==21 then return n*(n+19)/2\n    if p==22 then return\
    \ n*(n+20)/2\n    if p==23 then return n*(n+21)/2\n    if p==24 then return n*(n+22)/2\n\
    \    if p==25 then return n*(n+23)/2\n    if p==26 then return n*(n+24)/2\n  \
    \  if p==27 then return n*(n+25)/2\n    if p==28 then return n*(n+26)/2\n    if\
    \ p==29 then return n*(n+27)/2\n    if p==30 then return n*(n+28)/2\n    if p==31\
    \ then return n*(n+29)/2\n    if p==32 then return n*(n+30)/2\n    if p==33 then\
    \ return n*(n+31)/2\n    if p==34 then return n*(n+32)/2\n    if p==35 then return\
    \ n*(n+33)/2\n    if p==36 then return n*(n+34)/2\n    if p==37 then return n*(n+35)/2\n\
    \    if p==38 then return n*(n+36)/2\n    if p==39 then return n*(n\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpec_sdebj.jl:14\nin expression starting at /tmp/tmpec_sdebj.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    return modp(mod(n,\
    \ p), p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpog12jeb5.jl:18\nin expression starting at\
    \ /tmp/tmpog12jeb5.jl:18\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return n - p\n    else return modp(n - p, p)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr07b1b4f.jl:14\nin expression starting at /tmp/tmpr07b1b4f.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\
    \ \n        then return modp(abs(n), p)\n    else if n < p \n        then return\
    \ modp(n + p, p)\n    else return modp((n - p) * (n - p), p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppkqy8umx.jl:15\nin expression starting at /tmp/tmppkqy8umx.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if p > 0 \n        then return modp(n / p, p)\n    else return\
    \ 0\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpistbil30.jl:15\nin expression starting at /tmp/tmpistbil30.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n == p then return n\n    if n % p == 0 then return modp(n / p, p)\n  \
    \  return modp((n - p) / p, p)\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpf0m37cxb.jl:14\nin expression starting at /tmp/tmpf0m37cxb.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), -p)\n    if p > p then return modp(n, p\
    \ - p)\n    if p % 2 == 1 then return modp(n + p, p)\n    else return modp(n +\
    \ p / 2, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpj1lgxf19.jl:14\nin expression starting at /tmp/tmpj1lgxf19.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n == 1\n\
    \        then return p\n    else if p <= 0\n        then return 0\n    else if\
    \ p == 1\n        then return n\n    else if p == 2 \n        then return modp(n\
    \ / 2, p)\n    else if p == 3\n        then return modp(n / 3, p)\n    else if\
    \ p == 4\n        then return modp(n / 4, p)\n    else if p == 5\n        then\
    \ return modp(n / 5, p)\n    else if p == 6\n        then return modp(n / 6, p)\n\
    \    else if p == 7\n        then return modp(n / 7, p)\n    else if p == 8\n\
    \        then return modp(n / 8, p)\n    else if p == 9\n        then return modp(n\
    \ / 9, p)\n    else if p == 10\n        then return modp(n / 10, p)\n    else\
    \ if p == 11\n        then return modp(n / 11, p)\n    else if p == 12\n     \
    \   then return modp(n / 12, p)\n    else if p == 13\n        then return modp(n\
    \ / 13, p)\n    else if p == 14\n        then return modp(n / 14, p)\n    else\
    \ if p == 15\n        then return modp(n / 15, p)\n    else if p == 16\n     \
    \   then return modp(n / 16, p)\n    else if p == 17\n        then return modp(n\
    \ / 17, p)\n    else if p == 18\n        then return modp(n / 18, p)\n    else\
    \ if p == 19\n        then return modp(n / 19, p)\n    else if p == 20\n     \
    \   then return modp(n / 20, p)\n    else if p == 21\n        then return modp(n\
    \ / 21, p)\n    else if p == 22\n        then return modp(n / 22, p)\n    else\
    \ if p == 23\n        then return modp(n / 23, p)\n    else if p == 24\n     \
    \   then return modp(n / 24, p)\n    else if p == 25\n        then return modp(n\
    \ / 25, p)\n    else if p == 26\n        then return modp(n / 26, p)\n    else\
    \ if p == 27\n        then return modp(n / 27, p)\n    else if p == 28\n     \
    \   then return modp(n / 28, p)\n    else if p == 29\n        then return modp(n\
    \ / 29, p)\n    else \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa923x3fz.jl:15\nin expression starting at /tmp/tmpa923x3fz.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if n==2 then return p+1\n    if n<0 then return modp(-n, p)\n    if p<0 then\
    \ return modp(-n, p)\n    if p==0 then return 1\n    if p==1 then return n\n \
    \   if p==2 then return n*(n+1)/2\n    if p==3 then return n*(n+1)*(2*n+1)/6\n\
    \    if p==4 then return n*(n+1)*(2*n+1)*(3*n+1)/24\n    if p==5 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)/120\n\
    \    if p==6 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)/720\n    if p==7\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)/5040\n    if p==8\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)/40320\n\
    \    if p==9 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)/36288\n\
    \    if p==10 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)/870480\n\
    \    if p==11 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)/507168\n\
    \    if p==12 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)/262144\n\
    \    if p==13 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)/1048576\n\
    \    if p==14 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxii_p1ov.jl:14\nin expression starting at /tmp/tmpxii_p1ov.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n-1, p)\n    else \n        return modp(n-1,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkad91xm3.jl:15\nin expression starting at /tmp/tmpkad91xm3.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p)\n    else return modp(n-1, p) + modp(n-1, p-1)\n\
    end\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic |>\n<| a dscore=2 |>\n\
    The algorithm is quite simple:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu728mln2.jl:15\nin expression starting at /tmp/tmpu728mln2.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n == 1\n\
    \        then return p\n    else \n        return modp(n - 1, p) * (p % n) + p\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptvu7j3wq.jl:15\nin expression starting at /tmp/tmptvu7j3wq.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp() only accepts non-negative\
    \ numbers\")\n    end\n    if p == 0 \n        error(\"modp() only accepts non-zero\
    \ divisors\")\n    end\n    if n == 0 \n        return p\n    end\n    if p ==\
    \ 1 \n        return n\n    end\n    if n % p == 0 \n        return modp(n / p,\
    \ p)\n    end\n    return modp(n / p, p) * p\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyi1ewzfe.jl:31\nin expression starting at\
    \ /tmp/tmpyi1ewzfe.jl:31\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if n < 0 then return modp(-n,\
    \ abs(p))\n    if n == p then return 0\n    if n < p then return modp(n - p, p)\n\
    \    return modp(n - p, p) + modp(n, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5639vefo.jl:14\nin expression starting at /tmp/tmp5639vefo.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if n==p then return 1\n\
    \    if n>p then return modp(n-p,p)\n    return modp(n,p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprr31bfng.jl:14\nin expression starting at /tmp/tmprr31bfng.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n == 1\n\
    \        then return p\n    else if p < 0\n        then return modp(n - 1, p +\
    \ 1)\n    else if p == 1\n        then return 1\n    else if p == 2\n        then\
    \ return n\n    else if p == 3\n        then return n mod 2\n    else if p ==\
    \ 4\n        then return n mod 3\n    else if p == 5\n        then return n mod\
    \ 5\n    else if p == 6\n        then return n mod 7\n    else if p == 7\n   \
    \     then return n mod 11\n    else if p == 8\n        then return n mod 13\n\
    \    else if p == 9\n        then return n mod 17\n    else if p == 10\n     \
    \   then return n mod 23\n    else if p == 11\n        then return n mod 29\n\
    \    else if p == 12\n        then return n mod 31\n    else if p == 13\n    \
    \    then return n mod 37\n    else if p == 14\n        then return n mod 43\n\
    \    else if p == 15\n        then return n mod 59\n    else if p == 16\n    \
    \    then return n mod 61\n    else if p == 17\n        then return n mod 67\n\
    \    else if p == 18\n        then return n mod 73\n    else if p == 19\n    \
    \    then return n mod 79\n    else if p == 20\n        then return n mod 83\n\
    \    else if p == 21\n        then return n mod 89\n    else if p == 22\n    \
    \    then return n mod 97\n    else if p == 23\n        then return n mod 103\n\
    \    else if p == 24\n        then return n mod 109\n    else if p == 25\n   \
    \     then return n mod 115\n    else if p == 26\n        then return n mod 121\n\
    \    else if p == 27\n        then return n mod 127\n    else if p == 28\n   \
    \     then return n mod 133\n    else if p == 29\n        then return n mod 139\n\
    \    else if p == 30\n        then return n mod 141\n    else if p == 31\n   \
    \     then return n mod 147\n    else if p == 32\n        then return n mod 153\n\
    \    else if p == 33\n        then return n mod 159\n    else if p == 34\n   \
    \     then return n mod 165\n    else if p == 35\n        then return n mod 171\n\
    \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp3wop24s.jl:15\nin expression starting at /tmp/tmpp3wop24s.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if n == 1 \n  \
    \      then return p\n    else if p == 1 \n        then return 0\n    else if\
    \ p < 1 \n        then return modp(-n, p)\n    else if n < 1 \n        then return\
    \ modp(-n, p)\n    else if n % p == 0 \n        then return modp(n / p, p)\n \
    \   else return modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprqzhnxgs.jl:15\nin expression starting at /tmp/tmprqzhnxgs.jl:15\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n <= p \n        then return modp(n - p, p)\n    else return modp(n - p,\
    \ modp(n, p))\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplmakizko.jl:15\nin expression starting at /tmp/tmplmakizko.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 || p==0 \n        then return 1\n    else if\
    \ n==1\n        then return p\n    else if p==1\n        then return n\n    else\
    \ if p==2\n        then return modp(modp(n-1, p), p)\n    else if p==3\n     \
    \   then return modp(modp(n-1, p), modp(n-1, p))\n    else if p==4\n        then\
    \ return modp(modp(n-1, modp(n-1, p)), p)\n    else if p==5\n        then return\
    \ modp(modp(n-1, modp(n-1, p)), modp(n-1, p))\n    else if p==6\n        then\
    \ return modp(modp(n-1, modp(n-1, modp(n-1, p))), p)\n    else if p==7\n     \
    \   then return modp(modp(n-1, modp(n-1, modp(n-1, p))), modp(n-1, p))\n    else\
    \ if p==8\n        then return modp(modp(n-1, modp(n-1, modp(n-1, modp(n-1, p)))),\
    \ p)\n    else if p==9\n        then return modp(modp(n-1, modp(n-1, modp(n-1,\
    \ modp(n-1, modp(n-1, p))))), p)\n    else if p==10\n        then return modp(modp(n-1,\
    \ modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1, p)))))) , p)\n    else if\
    \ p==11\n        then return modp(modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1,\
    \ modp(n-1, modp(n-1, p)))))) , modp(n-1, p))\n    else if p==12\n        then\
    \ return modp(modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1,\
    \ modp(n-1, p)))))) , modp(n-1, modp(n-1, p)))) , p)\n    else if p==13\n    \
    \    then return modp(modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1, modp(n-1,\
    \ modp(n-1, modp(n-1, p)))))) , modp(n-1, modp(n-1, modp(n-1, p)))) , modp(n-1,\
    \ p))) , p)\n    else if p==14\n        then return modp(modp(n-1, modp(n-1, modp(n-1,\
    \ \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpy7lhv9x1.jl:15\nin expression starting at /tmp/tmpy7lhv9x1.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < n \n        then return modp(n - p,\
    \ p)\n    else \n        modp(n - p, p)\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nI believe this should be the accepted answer. `modp` is very simple and\
    \ straightforward, and it doesn't require any complex mathematical operations.\n\
    <|/ c |>\n<| a dscore=2 |>\nI believe this can be done in O(log(n)) time using\
    \ binary search and O(1) space:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdust5da8.jl:15\nin expression starting at /tmp/tmpdust5da8.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), p)\n    if p > p then return modp(n, p\
    \ - p)\n    if p % 2 == 1 then return modp(n + p, p)\n    else return modp(n +\
    \ p / 2, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7e_2pa9p.jl:14\nin expression starting at /tmp/tmp7e_2pa9p.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if n <= p then return modp(n - p, p)\n\
    \    else return modp((n - p + 1), p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6ddqkuzq.jl:14\nin expression starting at /tmp/tmp6ddqkuzq.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p > 1 \n        then return modp(n / p, p)\n    else \n        then return\
    \ modp((n - 1) / p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprl4tlmob.jl:15\nin expression starting at /tmp/tmprl4tlmob.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n == p \n        then return 0\n    else if n < p \n        then return modp(n\
    \ - p, p)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpom87engy.jl:15\nin expression starting at /tmp/tmpom87engy.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n    else \n     \
    \   then return modp(n - p, p)\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| c |>\nThis doesn't work. modp(3, 5) returns 3, not 2.\n<|/ c |>\n<| c\
    \ |>\nIt does work. modp(3, 5) returns 3. modp(3, 11) returns 8. modp(100, 101)\
    \ returns 1. modp(2, 5) returns 2. modp(2, 11) returns 8. modp(2, 100) returns\
    \ 1. modp(2, 101) returns 1. modp(2, 110) returns 1. modp(2, 111) returns 1. modp(2,\
    \ 1000) returns 1. modp(2, 1001) returns 1. modp(2, 1002) returns 1. modp(2, 1003)\
    \ returns 1. modp(2, 1004) returns 1. modp(2, 1005) returns 1. modp(2, 1006) returns\
    \ 1. modp(2, 1007) returns 1. modp(2, 1008) returns 1. modp(2, 1009) returns 1.\
    \ modp(2, 1010) returns 1. modp(2, 1011) returns 1. modp(2, 1012) returns 1. modp(2,\
    \ 1013) returns 1. modp(2, 1014) returns 1. modp(2, 1015) returns 1. modp(2, 1016)\
    \ returns 1. modp(2, 1017) returns 1. modp(2, 1018) returns 1. modp(2, 1019) returns\
    \ 1. modp(2, 1020) returns 1. modp(2, 1021).\n<|/ c |>\n<| c |>\nmodp(2, 1022)\
    \ returns 1. modp(2, 1023) returns 1. modp(2, 1024) returns 1. modp(2, 1025) returns\
    \ 1. modp(2, 1026) returns 1. modp(2, 1027) returns 1. modp(2, 1028) returns 1.\
    \ modp(2, 1029) returns 1. modp(2, 1030) returns 1. modp(2, 1031) returns 1. modp(2,\
    \ 1032) returns 1. modp(2, 1033) returns 1. modp(2, 1034) returns 1. modp(2, 1035)\
    \ returns 1. modp(2, 1036) returns 1. modp(2, 1037) returns 1. modp(2, 1038) returns\
    \ 1. modp(2, 1039) returns 1. modp(2, 1040) returns 1. modp(2, 1041) returns 1.\
    \ modp(2, 1042) returns 1. modp(2, 1043) returns 1. modp(2, 1044) returns 1. modp(2,\
    \ 1045) returns 1. modp(2, 1046) returns 1. modp(2, 1047) returns 1. mod\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgpeeds_6.jl:15\nin expression starting at /tmp/tmpgpeeds_6.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 | p <= 0 | n >= p \n        then return 0\n\
    \    else if n == 0 \n        then return p\n    else if p == 0 \n        then\
    \ return n\n    else if p < n \n        then return modp(n - p, p)\n    else return\
    \ modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz5e1vuwt.jl:15\nin expression starting at /tmp/tmpz5e1vuwt.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n == 1\
    \ \n        then return p\n    else \n        return modp(n / p, p) * p\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxih32zpr.jl:15\nin expression starting at /tmp/tmpxih32zpr.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if n < p then return\
    \ modp(n - 1, p) \n    else return modp((n - p) % p + p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6njygacg.jl:14\nin expression starting at /tmp/tmp6njygacg.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    else if n < p \n        error(\"modp requires n >= p\")\n    else if n ==\
    \ 0 \n        error(\"modp requires n != 0\")\n    else \n        return n\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work for negative numbers. `modp(3, -5)` returns\
    \ `3` instead of `-2`.\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers,\
    \ but it does work for positive numbers. `modp(3, -5)` returns `3` instead of\
    \ `-2`.\n<|/ c |>\n<| c |>\nIt works for negative numbers. `modp(3, -5)` returns\
    \ `3` instead of `-2`.\n<|/ c |>\n<| c |>\nIt works for negative numbers. `modp(3,\
    \ -5)` returns `3` instead of `-2`.\n<|/ c |>\n<| c |>\nIt works for negative\
    \ numbers. `modp(3, -5)` returns `3` instead of `-2`.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3x71pxyb.jl:16\nin expression starting at\
    \ /tmp/tmp3x71pxyb.jl:16\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - 1, p)\n    if p < n then return modp(n, p -\
    \ 1)\n    return modp(n - 1, p)\nend\n</cell>\n<code language=julia-1.4>\n\"\"\
    \"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptew9pl08.jl:14\nin expression starting at /tmp/tmptew9pl08.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if p < n \n        then return modp(n, p)\n    else \n        return\
    \ modp(n-1, p) + modp(n-1, p-1)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0wp_1yy4.jl:15\nin expression starting at /tmp/tmp0wp_1yy4.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(n, -p)\n    if n < p then return modp(n, p - 1)\n\
    \    \n    if n % p == 0 then return modp(n / p, p)\n    \n    return modp(n +\
    \ p - 1, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpl9aoxfo4.jl:14\nin expression starting at /tmp/tmpl9aoxfo4.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(n,\
    \ p - p)\n    if p % 2 == 1 then return modp(n, (p - 1)/2)\n    else return modp(n,\
    \ (p - 1)*2)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxwp_n7l1.jl:14\nin expression starting at /tmp/tmpxwp_n7l1.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return n\n    if p==2 then return n+1\n\
    \    if p==3 then return n*2\n    if p==4 then return n*3\n    if p==5 then return\
    \ n*4\n    if p==6 then return n*5\n    if p==7 then return n*6\n    if p==8 then\
    \ return n*7\n    if p==9 then return n*8\n    if p==10 then return n*9\n    if\
    \ p==11 then return n*10\n    if p==12 then return n*11\n    if p==13 then return\
    \ n*12\n    if p==14 then return n*13\n    if p==15 then return n*14\n    if p==16\
    \ then return n*15\n    if p==17 then return n*16\n    if p==18 then return n*17\n\
    \    if p==19 then return n*18\n    if p==20 then return n*19\n    if p==21 then\
    \ return n*20\n    if p==22 then return n*21\n    if p==23 then return n*22\n\
    \    if p==24 then return n*23\n    if p==25 then return n*24\n    if p==26 then\
    \ return n*25\n    if p==27 then return n*26\n    if p==28 then return n*27\n\
    \    if p==29 then return n*28\n    if p==30 then return n*29\n    if p==31 then\
    \ return n*30\n    if p==32 then return n*31\n    if p==33 then return n*32\n\
    \    if p==34 then return n*33\n    if p==35 then return n*34\n    if p==36 then\
    \ return n*35\n    if p==37 then return n*36\n    if p==38 then return n*37\n\
    \    if p==39 then return n*38\n    if p==40 then return n*39\n    if p==41 then\
    \ return n*40\n    if p==42 then return n*41\n    if p==43 then return n*42\n\
    \    if p==44 then return n*43\n    if p==45 then return n*44\n    if p==46 then\
    \ return n*45\n    if p==47 then return n*46\n    if p==48 then return n*47\n\
    \    if p==49 then return n*48\n    if p==50 then return n*49\n    if p==51 then\
    \ return n*50\n    if p==52 then return n*51\n    if p==53 then return n*52\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpx665qgq_.jl:14\nin expression starting at /tmp/tmpx665qgq_.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n-1, p)\n    if p==4 then return modp(2*n-1, p-1)\n\
    \    if p==5 then return modp(2*n-1, p-2)\n    if p==6 then return modp(2*n-1,\
    \ p-3)\n    if p==7 then return modp(2*n-1, p-4)\n    if p==8 then return modp(2*n-1,\
    \ p-5)\n    if p==9 then return modp(2*n-1, p-6)\n    if p==10 then return modp(2*n-1,\
    \ p-7)\n    if p==11 then return modp(2*n-1, p-8)\n    if p==12 then return modp(2*n-1,\
    \ p-9)\n    if p==13 then return modp(2*n-1, p-10)\n    if p==14 then return modp(2*n-1,\
    \ p-11)\n    if p==15 then return modp(2*n-1, p-12)\n    if p==16 then return\
    \ modp(2*n-1, p-13)\n    if p==17 then return modp(2*n-1, p-14)\n    if p==18\
    \ then return modp(2*n-1, p-15)\n    if p==19 then return modp(2*n-1, p-16)\n\
    \    if p==20 then return modp(2*n-1, p-17)\n    if p==21 then return modp(2*n-1,\
    \ p-18)\n    if p==22 then return modp(2*n-1, p-19)\n    if p==23 then return\
    \ modp(2*n-1, p-20)\n    if p==24 then return modp(2*n-1, p-21)\n    if p==25\
    \ then return modp(2*n-1, p-22)\n    if p==26 then return modp(2*n-1, p-23)\n\
    \    if p==27 then return modp(2*n-1, p-24)\n    if p==28 then return modp(2*n-1,\
    \ p-25)\n    if p==29 then return modp(2*n-1, p-26)\n    if p==30 then return\
    \ modp(2*n-1, p-27)\n    if p==31 then return modp(2*n-1, p-28)\n    if p==32\
    \ then return modp(2*n-1, p-29)\n    if p==33 then return modp(2*n-1, p-30)\n\
    \    if p==34 then return modp(2*n-1, p-31)\n    if p==35 then return modp(2*n-1,\
    \ p-32)\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwf6rzugh.jl:14\nin expression starting at /tmp/tmpwf6rzugh.jl:14\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n < p\
    \ \n        then return n\n    else \n        modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5vh5ls58.jl:15\nin expression starting at /tmp/tmp5vh5ls58.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n == 1\n\
    \        then return p\n    else if p == 0 \n        then return 0\n    else if\
    \ p < 0 \n        then return modp(abs(n), abs(p))\n    else if p > 0 \n     \
    \   then return modp(n - 1, p)\n    else return modp(n - 1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2qaejyea.jl:15\nin expression starting at /tmp/tmp2qaejyea.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    else if p < 0 \n        error(\"modp requires p >= 0\")\n    else if n <\
    \ p \n        error(\"modp requires n >= p\")\n    else if n == 0 \n        error(\"\
    modp requires n > 0\") \n    else if p == 0 \n        error(\"modp requires p\
    \ > 0\") \n    else if p == 1 \n        error(\"modp requires p != 1\")\n    else\
    \ if n == 1 \n        error(\"modp requires n != 1\")\n    else if p == 0 \n \
    \       error(\"modp requires p != 1\")\n    else if n == 0 \n        error(\"\
    modp requires n != 0\")\n    else if n == 1 \n        error(\"modp requires n\
    \ != 1\")\n    else if n == p \n        error(\"modp requires n != p\")\n    else\
    \ if n == p \n        error(\"modp requires n != p\")\n    else if n == p \n \
    \       error(\"modp requires n != p\")\n    else if n == p \n        error(\"\
    modp requires n != p\")\n    else if n == p \n        error(\"modp requires n\
    \ != p\")\n    else if n == p \n        error(\"modp requires n != p\")\n    else\
    \ if n == p \n        error(\"modp requires n != p\")\n    else if n == p \n \
    \       error(\"modp requires n != p\")\n    else if n == p \n        error(\"\
    modp requires n != p\")\n    else if n == p \n        error(\"modp requires n\
    \ != p\")\n    else if n == p \n        error(\"modp requires n != p\")\n    else\
    \ if n == p \n        error(\"modp requires n != p\")\n    else if n == p \n \
    \       error(\"modp requires n != p\")\n    else if n == p \n        error(\"\
    modp requires n != p\")\n    else if n == p \n        error(\"modp requires n\
    \ != p\")\n    else if n == p \n        error(\"modp requires n != p\")\n    else\
    \ if n == p \n        error(\"modp requires n != p\")\n    else if n == p \n \
    \       error(\"modp requires n != p\")\n    else if n == p \n        error(\"\
    modp requires n != p\")\n    else if n == p \n        error(\"modp requires n\
    \ != p\")\n    else if n == p \n        error(\"modp requires n != p\")\n    else\
    \ if n == p \n        error(\"modp requires n != p\")\n    else if n == p \n \
    \       error(\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1mgds410.jl:16\nin expression starting at\
    \ /tmp/tmp1mgds410.jl:16\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0pcslhgj.jl:15\nin expression starting at /tmp/tmp0pcslhgj.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n        then\
    \ return modp(n, p-1)\n    else \n        error(\"modp: p must be positive\")\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxv__7fii.jl:15\nin expression starting at /tmp/tmpxv__7fii.jl:15\n"
  stdout: ''
  timestamp: 1659823070
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n == 1\
    \ \n        then return p\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if p > 0 \n        then return modp(n, p - 1)\n    else \n\
    \        error(\"modp: p must be non-negative\")\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your answer but I don't think it works. modp(3, 5) returns\
    \ 3 instead of 8. modp(1101, 101) returns 2 instead of 1. modp(0, 101) returns\
    \ 1 instead of 0. modp(3, 11) returns 8 instead of 3. modp(100, 101) returns 1\
    \ instead of 0.\n<|/ c |>\n<| c |>\nI fixed the bugs. Thanks for pointing them\
    \ out. :)\n<|/ c |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8r0a8d0z.jl:15\nin expression starting at /tmp/tmp8r0a8d0z.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    if p < 0 \n        error(\"modp requires p >= 0\")\n    if n == 0 \n    \
    \    error(\"modp requires n != 0\")\n    if p == 0 \n        error(\"modp requires\
    \ p != 0\")\n    if n == p \n        error(\"modp requires n != p\")\n    if p\
    \ == 0 \n        error(\"modp requires p != 0\")\n    if n == 0 \n        error(\"\
    modp requires n != 0\")\n    if p == 0 \n        error(\"modp requires p != 0\"\
    )\n    if n == 1 \n        return n\n    if n == p \n        return p\n    if\
    \ p == 1 \n        return n\n    if p == 0 \n        return p\n    if n == p \n\
    \        return p\n    if n == 0 \n        return 0\n    if p == 1 \n        return\
    \ p\n    if n == 1 \n        return n\n    if p == 0 \n        return p\n    if\
    \ n == p \n        return p\n    if n == 0 \n        return n\n    if p == 1 \n\
    \        return p\n    if n == 1 \n        return n\n    if p == 0 \n        return\
    \ p\n    if n == p \n        return p\n    if n == 0 \n        return n\n    if\
    \ p == 1 \n        return p\n    if n == 1 \n        return n\n    if p == 0 \n\
    \        return p\n    if n == p \n        return p\n    if n == 0 \n        return\
    \ n\n    if p == 1 \n        return p\n    if n == 1 \n        return n\n    if\
    \ p == 0 \n        return p\n    if n == p \n        return p\n    if n == 0 \n\
    \        return n\n    if p == 1 \n        return p\n    if n == 1 \n        return\
    \ n\n    if p == 0 \n        return p\n    if n == p \n        return p\n    if\
    \ n == 0 \n        return n\n    if p == 1 \n        return p\n    if n == 1 \n\
    \        return n\n    if p == 0 \n        return p\n    if n == p \n        return\
    \ p\n    if n == 0 \n        return n\n    if p == 1 \n        return p\n    if\
    \ n == 1 \n        return n\n    if p == 0 \n        return p\n    if n == p \n\
    \        return p\n    if n == 0 \n        return n\n    if p == 1 \n        return\
    \ p\n    if n == 1 \n        return n\n    if p == 0 \n        return p\n    if\
    \ n == p \n        return p\n    if n == 0 \n        return n\n    if p == 1 \n\
    \        return p\n    if n == 1 \n        return n\n    if p == 0 \n        return\
    \ p\n    if n == p \n        return p\n    if n == 0 \n        return n\n    if\
    \ p == 1 \n        return p\n    if n == 1 \n        return n\n    if p == 0 \n\
    \        return p\n    if n == p \n        return p\n    if n == 0 \n        return\
    \ n\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps5a8tnjn.jl:1\nin expression starting at /tmp/tmps5a8tnjn.jl:1\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return p\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return 1\n    else \n        return modp(n div p, p) * modp(n\
    \ mod p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_y0031f5.jl:15\nin expression starting at /tmp/tmp_y0031f5.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < n \n        then return modp(n - p,\
    \ p)\n    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0pjshfya.jl:15\nin expression starting at /tmp/tmp0pjshfya.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return 1\n        else return modp(n - p, p)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphy8u9t3a.jl:15\nin expression starting at /tmp/tmphy8u9t3a.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if n < 0 then return modp(abs(n),\
    \ abs(p))\n    if n == p then return 0\n    if n <= p then return modp(n - p,\
    \ p)\n    return modp((n - p + 1) * (n - p + 2), p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpf737enjy.jl:14\nin expression starting at /tmp/tmpf737enjy.jl:14\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n <= p \n        then return modp(n, p)\n    else return modp(n + p, p)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfm2l2z7m.jl:15\nin expression starting at /tmp/tmpfm2l2z7m.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ abs(p))\n    if p < p then return modp(abs(n), p)\n    if p > n then return\
    \ modp(n, abs(p))\n    if p < n then return modp(n, p)\n    if n < 0 then return\
    \ modp(abs(n), abs(p))\n    if n < n then return modp(abs(n), p)\n    if n < p\
    \ then return modp(n, p)\n    if n < p then return modp(n, p)\n    return modp(n,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp3725_ajj.jl:14\nin expression starting at /tmp/tmp3725_ajj.jl:14\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p < n then return modp(n - p, p)\n\
    \    if p > n then return modp(n, p - n)\n    return modp(n - p, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr9ktf_s1.jl:14\nin expression starting at /tmp/tmpr9ktf_s1.jl:14\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n        else return\
    \ modp(n - p, p)\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5swfppf4.jl:15\nin expression starting at /tmp/tmp5swfppf4.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p < n then return modp(n, p - 1)\n    return\
    \ modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n\
    \    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpyoe9p68b.jl:14\nin expression starting at /tmp/tmpyoe9p68b.jl:14\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p > p then return 0\n    if p %\
    \ 2 == 1 then return modp(n-1, p)\n    else return modp(n-1, p//2)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2mssnp3p.jl:14\nin expression starting at /tmp/tmp2mssnp3p.jl:14\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+2)/2\n    if\
    \ p==5 then return n*(n+3)/2\n    if p==6 then return n*(n+4)/2\n    if p==7 then\
    \ return n*(n+5)/2\n    if p==8 then return n*(n+6)/2\n    if p==9 then return\
    \ n*(n+7)/2\n    if p==10 then return n*(n+8)/2\n    if p==11 then return n*(n+9)/2\n\
    \    if p==12 then return n*(n+10)/2\n    if p==13 then return n*(n+11)/2\n  \
    \  if p==14 then return n*(n+12)/2\n    if p==15 then return n*(n+13)/2\n    if\
    \ p==16 then return n*(n+14)/2\n    if p==17 then return n*(n+15)/2\n    if p==18\
    \ then return n*(n+16)/2\n    if p==19 then return n*(n+17)/2\n    if p==20 then\
    \ return n*(n+18)/2\n    if p==21 then return n*(n+19)/2\n    if p==22 then return\
    \ n*(n+20)/2\n    if p==23 then return n*(n+21)/2\n    if p==24 then return n*(n+22)/2\n\
    \    if p==25 then return n*(n+23)/2\n    if p==26 then return n*(n+24)/2\n  \
    \  if p==27 then return n*(n+25)/2\n    if p==28 then return n*(n+26)/2\n    if\
    \ p==29 then return n*(n+27)/2\n    if p==30 then return n*(n+28)/2\n    if p==31\
    \ then return n*(n+29)/2\n    if p==32 then return n*(n+30)/2\n    if p==33 then\
    \ return n*(n+31)/2\n    if p==34 then return n*(n+32)/2\n    if p==35 then return\
    \ n*(n+33)/2\n    if p==36 then return n*(n+34)/2\n    if p==37 then return n*(n+35)/2\n\
    \    if p==38 then return n*(n+36)/2\n    if p==39 then return n*(n\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpec_sdebj.jl:14\nin expression starting at /tmp/tmpec_sdebj.jl:14\n"
  stdout: ''
  timestamp: 1659823068
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else return modp(n, p - n)\nend\n</cell>\n\
    <code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfk2e43jr.jl:15\nin expression starting at /tmp/tmpfk2e43jr.jl:15\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if p % 2 == 1 then return modp(n + p, p)\n    else return modp(n + p / 2,\
    \ p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjwqzqf8m.jl:14\nin expression starting at /tmp/tmpjwqzqf8m.jl:14\n"
  stdout: ''
  timestamp: 1659823071
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp555n29cz.jl:15\nin expression starting at /tmp/tmp555n29cz.jl:15\n"
  stdout: ''
  timestamp: 1659823072
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n+1\n    if p==4 then return n+2\n    if p==5 then return\
    \ n+3\n    if p==6 then return n+4\n    if p==7 then return n+5\n    if p==8 then\
    \ return n+6\n    if p==9 then return n+7\n    if p==10 then return n+8\n    if\
    \ p==11 then return n+9\n    if p==12 then return n+10\n    if p==13 then return\
    \ n+11\n    if p==14 then return n+12\n    if p==15 then return n+13\n    if p==16\
    \ then return n+14\n    if p==17 then return n+15\n    if p==18 then return n+16\n\
    \    if p==19 then return n+17\n    if p==20 then return n+18\n    if p==21 then\
    \ return n+19\n    if p==22 then return n+20\n    if p==23 then return n+21\n\
    \    if p==24 then return n+22\n    if p==25 then return n+23\n    if p==26 then\
    \ return n+24\n    if p==27 then return n+25\n    if p==28 then return n+26\n\
    \    if p==29 then return n+27\n    if p==30 then return n+28\n    if p==31 then\
    \ return n+29\n    if p==32 then return n+30\n    if p==33 then return n+31\n\
    \    if p==34 then return n+32\n    if p==35 then return n+33\n    if p==36 then\
    \ return n+34\n    if p==37 then return n+35\n    if p==38 then return n+36\n\
    \    if p==39 then return n+37\n    if p==40 then return n+38\n    if p==41 then\
    \ return n+39\n    if p==42 then return n+40\n    if p==43 then return n+41\n\
    \    if p==44 then return n+42\n    if p==45 then return n+43\n    if p==46 then\
    \ return n+44\n    if p==47 then return n+45\n    if p==48 then return n+46\n\
    \    if p==49\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzbht63ok.jl:14\nin expression starting at /tmp/tmpzbht63ok.jl:14\n"
  stdout: ''
  timestamp: 1659823059
