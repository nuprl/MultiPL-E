name: HumanEval_128_prod_signs
language: jl
prompt: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
  \    sum of magnitudes of integers multiplied by product of all signs\n    of each\
  \ number in the array, represented by 1, -1 or 0.\n    Note: return None for empty\
  \ arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n    >>> prod_signs([0,\
  \ 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64,\
  \ Nothing} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
  \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
  \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
  \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
  \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
completions: ["    if length(arr) == 0 \n        return nothing\n    \n    prod =\
    \ 1\n    for x in arr\n        prod *= sign(x)\n    end\n    \n    return prod\
    \ * sum(abs(x) for x in arr)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum\
    \ of squares of integers multiplied by product of all signs of numbers in the\
    \ array, represented by 1, -1 or 0.", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = zeros(Int64, length(arr))\n        signs[1]\
    \ = 1\n        signs[end] = -1\n        product = 1\n        for i in 2:length(arr)\
    \ \n            product *= signs[i]\n            signs[i] = product\n        end\n\
    \        return product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\
    \"\n    You are given an array arr of integers and you need to return\n    sum\
    \ of magnitudes of integers multiplied by product of all signs\n    of each number\
    \ in the array, represented by 1, -1 or 0.\n    Note: return 0 for empty arr.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        product = prod(signs) \n        magnitudes = map(abs, arr) \n\
    \        return sum(magnitudes * product) \n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .< 0] = 1\n        signs[arr .> 0] = -1\n  \
    \      signs = signs.*prod(signs)\n        return sum(signs)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an array of integers and returns its sum of the absolute\
    \ values.", "    if length(arr) == 0 \n        return nothing\n    \n    signs\
    \ = zeros(Int, length(arr))\n    signs[arr .== 0] = -1\n    signs[arr .== 1] =\
    \ 1\n    \n    prod = 1\n    for i in 1:length(arr) \n        prod *= signs[i]\n\
    \    end\n    \n    return prod\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nTask 2.2: Sum of magnitudes of integers multiplied\
    \ by product of all signs\nWrite a function that returns sum of magnitudes of\
    \ integers multiplied by product of all signs\nof each number in the array, represented\
    \ by 1, -1 or 0.\nNote: return 0 for empty arr.", "    if length(arr) == 0 \n\
    \        return nothing\n    \n    signs = zeros(Int, length(arr))\n    for (i,x)\
    \ in enumerate(arr)\n        signs[i] = sign(x) * sign(i)\n    end\n    \n   \
    \ prod = prod(signs)\n    \n    return prod * sum(abs(arr))\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is odd, False otherwise.", "    if\
    \ length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        product = prod(signs)\n        sum_of_mags = sum(map(abs, arr))\n\
    \        return product * sum_of_mags\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd and False otherwise.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    \n    signs = zeros(Int64, length(arr))\n  \
    \  signs[arr .== 1] = 1\n    signs[arr .== -1] = -1\n    signs[arr .== 0] = 0\n\
    \    \n    prod = signs .* prod(signs)\n    \n    return sum(abs.(prod)) + nothing\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns True if a number is odd and\
    \ False otherwise.", "    if length(arr)==0 \n        return nothing\n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[arr .< 0] = -1\n  \
    \      signs[arr .> 0] = 1\n        product = signs .* prod(signs)\n        return\
    \ sum(abs(product))\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,arrays\
    \ |>\n<code>", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = map(sign, arr)\n        product = prod(signs)\n        sum_of_magnitudes\
    \ = sum(map(abs, arr))\n        return product * sum_of_magnitudes\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    \n    sum = 0\n    prod = 1\n    for x in\
    \ arr\n        sum += abs(x)\n        prod *= sign(x)\n    end\n    return sum\
    \ * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns True if a number is\
    \ odd and False otherwise.", "    if length(arr) == 0 \n        return nothing\n\
    \    \n    prod = 1\n    sign = 1\n    for x in arr\n        sign *= sign(x)\n\
    \        prod *= sign\n    end\n    return prod * prod(arr)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of positive numbers in a given array.", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .==\
    \ -1] = -1\n        signs[arr .== 0] = 0\n        product = signs .* prod(signs)\n\
    \        return sum(abs(product))\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nA simple solution using Julia Base is to use Base.prod function\
    \ which computes the product of all the elements in a vector:\n<code>\njulia>\
    \ Base.prod([1,2,3])\n6\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nI came\
    \ up with a solution that is very similar to some of the other answers, but I\
    \ wanted to show that you can also use broadcasting instead of looping through\
    \ each element in the array. \n<code>", "    if length(arr)==0 return nothing\n\
    \    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] = -1\n\
    \    prod = 1\n    for x in arr\n        prod *= signs[x]\n    end\n    return\
    \ prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nTask 3", "    if length(arr) == 0 \n        return nothing\n\
    \    \n    prod = 1\n    for x in arr\n        prod *= sign(x)\n    end\n    \n\
    \    mag = sqrt(prod(map(x -> abs2, arr)))\n    \n    return mag * prod\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Prod of Signs", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n\
    \        signs = filter(x -> x == 0, signs)\n        signs = filter(x -> x ==\
    \ 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs = sum(signs)\n\
    \        return signs * prod(arr)\n    end\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThanks for your answer! I didn't know that Julia had a product function.\
    \ I was trying to use reduce but couldn't get it to work. Your solution is much\
    \ more elegant than mine.\n<|/ c |>\n<| c |>\nI didn't know about `product` either,\
    \ but `reduce(*, arr)` works just fine.\n<|/ c |>\n<| c |>\nI didn't know about\
    \ `product` either, but `reduce(*, arr)` works just fine.\n<|/ c |>\n<| a |>\n\
    Here's a solution using reduce:\n<code>", "    if length(arr) == 0 \n        return\
    \ nothing\n    \n    prod = 1\n    for x in arr\n        prod *= sign(x)\n   \
    \ end\n    \n    mags = map(abs, arr)\n    mags = filter(x -> x != 0, mags)\n\
    \    mags = map(prod, mags)\n    \n    return sum(mags)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the product of all numbers in the given array arr except the given number\
    \ num.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = zeros(Int, length(arr))\n        signs[arr .< 0] = -1\n        signs[arr\
    \ .> 0] = 1\n        signs = signs.prod(1)\n        return signs * prod(signs)\n\
    \    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns the\
    \ number of positive numbers in an array.", "    if length(arr) == 0 \n      \
    \  return nothing\n    else \n        signs = map(sign, arr)\n        signs_product\
    \ = prod(signs)\n        sum_of_magnitudes = sum(map(abs, arr))\n        return\
    \ signs_product * sum_of_magnitudes\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is even, False otherwise. You may use bitwise operators.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        for i = 1:length(arr)\n            signs[i] = sign(arr[i])\n\
    \        end\n        product = prod(signs)\n        return product * sum(signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing\n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        sum_of_mags = sum(abs.(arr .* signs))\n        return sum_of_mags\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array\
    \ of integers and returns its sum.", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = map(sign, arr)\n        signs = filter(x\
    \ -> x != 0, signs)\n        signs = filter(x -> x == 0, signs)\n        signs\
    \ = filter(x -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n\
    \        signs = filter(x -> x == 0, signs)\n        signs = filter(x -> x ==\
    \ 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs = filter(x\
    \ -> x == 0, signs)\n        signs = filter(x -> x == 1, signs)\n        signs\
    \ = filter(x -> x == -1, signs)\n        signs = filter(x -> x == 0, signs)\n\
    \        signs = filter(x -> x == 1, signs)\n        signs = filter(x -> x ==\
    \ -1, signs)\n        signs = filter(x -> x == 0, signs)\n        signs = filter(x\
    \ -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs\
    \ = filter(x -> x == 0, signs)\n        signs = filter(x -> x == 1, signs)\n \
    \       signs = filter(x -> x == -1, signs)\n        signs = filter(x -> x ==\
    \ 0, signs)\n        signs = filter(x -> x == 1, signs)\n        signs = filter(x\
    \ -> x == -1, signs)\n        signs = filter(x -> x == 0, signs)\n        signs\
    \ = filter(x -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n\
    \        signs = filter(x -> x == 0, signs)\n        signs = filter(x -> x ==\
    \ 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs = filter(x\
    \ -> x == 0, signs)\n        signs = filter(x -> x == 1, signs)\n        signs\
    \ = filter(x -> x == -1, signs)\n        signs = filter(x -> x == 0, signs)\n\
    \        signs = filter(x -> x == 1, signs)\n        signs = filter(x -> x ==\
    \ -1, signs)\n        signs = filter(x -> x == 0, signs)\n        signs = filter(x\
    \ -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs\
    \ = filter(x -> x == 0, signs)\n        signs = filter(x -> x == 1, signs)\n \
    \       signs = filter(x -> x == -1, signs)\n        signs = filter(x -> x ==\
    \ 0, signs)\n        signs = filter(x -> x == 1, signs)\n        signs = filter(x\
    \ -> x == -1, signs)\n        signs = filter(x -> x == 0, signs)\n        signs\
    \ = filter(x -> x == ", "    if length(arr)==0 \n        return nothing\n    else\
    \ \n        signs = map(sign, arr)\n        signs = filter(x -> x==1, signs)\n\
    \        signs = filter(x -> x==-1, signs)\n        signs = filter(x -> x==0,\
    \ signs)\n        signs = prod(signs)\n        return signs * prod(arr)\n    end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = map(sign, arr)\n \
    \       product = prod(signs)\n        return product * sum(signs)\n    end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\nI wrote\
    \ a function that does this for you:\n<code>", "    if length(arr) == 0 \n   \
    \     return nothing\n    end\n    signs = map(sign, arr)\n    prod = prod(signs)\n\
    \    mags = map(abs, arr)\n    return sum(mags .* signs)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is odd, False otherwise.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = signs(arr)\
    \ \n        product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return product * sum_of_mags \n    end\nend\n</code>\n<|/ a tags=julia,arrays,function\
    \ |>\n<| a tags=julia,arrays,function |>\n<code>", "    if length(arr) == 0 \n\
    \        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs\
    \ * prod(signs)\n        return signs\n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't seem to work. `prod_signs([1, 2, 2, -4])` returns `9` instead\
    \ of `-9`.\n<|/ c |>\n<| c |>\nIt works. I tested it before posting. What do you\
    \ mean by \"doesn't work\"? It returns `-9` as expected. `prod(signs)` returns\
    \ `-9` as well.\n<|/ c |>\n<| c |>\nI mean it returns `-9` instead of `9`. `signs`\
    \ should be `-9` but `prod(signs)` returns `9`.\n<|/ c |>\n<| c |>\nI see. `signs`\
    \ is `-9` but `prod(signs)` returns `9`. What is your expected output?\n<|/ c\
    \ |>\n<| c |>\n`prod(signs)` returns `-9` because `signs` is `-9`. `signs` is\
    \ `-9` because `arr .< 0` returns `[false, true, false, true]`.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "    if length(arr) == 0 \n        return nothing\n\
    \    end\n    signs = map(sign, arr)\n    signs_product = prod(signs)\n    sum_of_magnitudes\
    \ = sum(map(abs, arr))\n    return signs_product * sum_of_magnitudes\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is odd, False otherwise. \nThe function\
    \ should work for negative and positive numbers.", "    if length(arr) == 0 \n\
    \        return nothing\n    end\n    sum_of_mags = sum(map(abs, arr))\n    signs\
    \ = map(sign, arr)\n    prod = prod(signs)\n    return sum_of_mags * prod\nend",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        signs = filter(x -> x == 1, signs)\n        signs = filter(x ->\
    \ x == -1, signs)\n        signs = filter(x -> x == 0, signs)\n        signs =\
    \ sum(signs)\n        return signs * prod(signs)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates the sum of squares of integers in arr\nand returns\
    \ the sum of the squares.", "    if length(arr) == 0 \n        return nothing\n\
    \    elseif length(arr) == 1 \n        return arr[0] * signs(arr[1])\n    else\n\
    \        signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n   \
    \     signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        sum_signs\
    \ = sum(signs)\n        prod_signs = signs .* arr .* signs\n        return sum_signs\
    \ * prod(prod_signs)\n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a\
    \ dscore=1 |>\nI wrote a function that does this in Julia. \n<code>", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        product\
    \ = 1\n        for i in 1:length(arr) \n            product *= signs[i]\n    \
    \        signs[i] = 0\n        end\n        return product * sum(abs.(arr))\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    <code>", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = map(sign, arr) \n        signs_prod = prod(signs) \n        sum_of_mags\
    \ = sum(map(abs, arr)) \n        return sum_of_mags * signs_prod \n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "    if length(arr) == 0 return\
    \ nothing\n    \n    signs = zeros(Int, length(arr))\n    signs[arr .== 0] = -1\n\
    \    signs[arr .== 1] = 1\n    \n    prod = 1\n    for x in arr\n        prod\
    \ *= signs[x]\n    end\n    \n    return prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the sum of absolute values of numbers in an array.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        signs = signs .* prod(signs)\n        return sum(signs)\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "  \
    \  if length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs_product = prod(signs) \n        sum_of_mags = sum(map(abs,\
    \ arr)) \n        return sum_of_mags * signs_product \n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    if length(arr) == 0 \n    \
    \    return nothing\n    else \n        signs = map(sign, arr)\n        signs\
    \ = filter(x -> x != 0, signs)\n        signs = prod(signs)\n        mags = map(abs,\
    \ arr)\n        mags = filter(x -> x != 0, mags)\n        mags = prod(mags)\n\
    \        return signs * mags\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to avoid the use of filter and\
    \ map. I guess it would be possible to use reduce or foldl but I am not sure how\
    \ to do it.\n<|/ c |>\n<| c |>\nI added a solution that uses foldl and reduce.\n\
    <|/ c |>\n<| c |>\nI added a solution that uses foldl and reduce.\n<|/ c |>\n\
    <| a tags=julia,functional-programming |>\nI came up with this solution:\n<code>",
  "    if length(arr) == 0 \n        return nothing\n    end\n    signs = zeros(Int64,\
    \ length(arr))\n    for idx in 1:length(arr)\n        signs[idx] = signs[idx]\
    \ + arr[idx]\n    end\n    signs = signs./sum(signs)\n    return prod(signs)\n\
    end\n</cell>\n<code language=julia-1.5>", "    if length(arr) == 0 return nothing\n\
    \    sum = 0\n    for i in arr\n        sum += sign(i) * i\n    end\n    return\
    \ sum\nend", "    if length(arr) == 0 return nothing\n    \n    sum = 0\n    for\
    \ i in arr\n        sum += i\n    end\n    \n    prod = 1\n    for i in arr\n\
    \        prod *= sign(i)\n    end\n    \n    sum * prod\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is odd and False otherwise.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        product\
    \ = 1\n        for n in arr\n            product *= signs[n]\n        end\n  \
    \      return product\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the sum of all elements in the given array arr\nthat are greater\
    \ than or equal to 0.", "    if length(arr) == 0 \n        return nothing\n  \
    \  \n    signs = zeros(Int, length(arr))\n    for k in 1:length(arr)\n       \
    \ signs[k] = signs[k] + (arr[k] >= 0 ? 1 : -1)\n    end\n    \n    prod = 1\n\
    \    for k in 1:length(arr)\n        prod *= signs[k]\n    end\n    \n    return\
    \ prod\nend\n</cell>\n<code language=julia-1.5>", "    if length(arr) == 0 \n\
    \        return nothing\n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        return sum(signs .* prod)\n    end\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that calculates sum of squares of integers in arr\
    \ \nand returns sum of squares of integers multiplied by product of all signs\n\
    of each number in the array, represented by 1, -1 or 0.\nNote: return None for\
    \ empty arr.", "    if length(arr) == 0 \n        return nothing\n    elseif length(arr)\
    \ == 1 \n        return arr[0] * signs(arr[1])\n    elseif length(arr) == 2 \n\
    \        return arr[0] * signs(arr[1]) * signs(arr[2])\n    elseif length(arr)\
    \ == 3 \n        return arr[0] * signs(arr[1]) * signs(arr[2]) * signs(arr[3])\n\
    \    elseif length(arr) == 4 \n        return arr[0] * signs(arr[1]) * signs(arr[2])\
    \ * signs(arr[3]) * signs(arr[4])\n    elseif length(arr) == 5 \n        return\
    \ arr[0] * signs(arr[1]) * signs(arr[2]) * signs(arr[3]) * signs(arr[4]) * signs(arr[5])\n\
    \    elseif length(arr) == 6 \n        return arr[0] * signs(arr[1]) * signs(arr[2])\
    \ * signs(arr[3]) * signs(arr[4]) * signs(arr[5]) * signs(arr[6])\n    elseif\
    \ length(arr) == 7 \n        return arr[0] * signs(arr[1]) * signs(arr[2]) * signs(arr[3])\
    \ * signs(arr[4]) * signs(arr[5]) * signs(arr[6]) * signs(arr[7])\n    elseif\
    \ length(arr) == 8 \n        return arr[0] * signs(arr[1]) * signs(arr[2]) * signs(arr[3])\
    \ * signs(arr[4]) * signs(arr[5]) * signs(arr[6]) * signs(arr[7]) * signs(arr[8])\n\
    \    elseif length(arr) == 9 \n        return arr[0] * signs(arr[1]) * signs(arr[2])\
    \ * signs(arr[3]) * signs(arr[4]) * signs(arr[5]) * signs(arr[6]) * signs(arr[7])\
    \ * signs(arr[8]) * signs(arr[9])\n    elseif length(arr) == 10 \n        return\
    \ arr[0] * signs(arr[1]) * signs(arr[2]) * signs(arr[3]) * signs(arr[4]) * signs(arr[5])\
    \ * signs(arr[6]) * signs(arr[7]) * signs(arr[8]) * signs(arr[9]) * signs(arr[10])\n\
    \    elseif length(arr) == 11 \n        return arr[0] * signs(arr[1]) * signs(arr[2])\
    \ * signs(arr[3]) * signs(arr[4]) * signs(arr[5]) * signs(arr[6]) * signs(arr[7])\
    \ * signs(arr[8]) * signs(arr[9]) * signs(arr[10]) * signs(arr[11])\n    elseif\
    \ length(arr) == 12 \n        return arr[0] * signs(arr[1]) * signs(arr[2]) *\
    \ signs(arr[3]) * signs(arr[4]) * signs(arr[5]) * signs(arr[6]", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        product\
    \ = signs .* prod(signs)\n        return sum(abs.(product))\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThanks for your answer! I appreciate it. I was wondering\
    \ if there is a way to do this without using any packages.\n<|/ c |>\n<| c |>\n\
    I added a solution without packages.\n<|/ c |>\n<| a dscore=1 |>\nI wrote a solution\
    \ without packages. \n<code>", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\
    \ \n            signs[i] = sign(arr[i])\n        end\n        signs = signs *\
    \ prod(signs)\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ calculates the sum of squares of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        \n        sum = 0\n        for i in 1:length(signs)\n  \
    \          sum += signs[i] * prod(signs)\n        end\n        return sum\n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the product of absolute\
    \ values of all numbers in an array.", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = map(sign, arr)\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        sum_magnitudes = sum(magnitudes)\n\
    \        return sum_magnitudes * product\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = signs(arr)\n\
    \        sign = signs[1]\n        product = prod(signs)\n        magnitude = sum(abs.(arr))\n\
    \        return magnitude * product\n    end\nend\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a vector arr and returns its mean value.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        signs = signs .* prod(signs)\n        return\
    \ sum(abs.(signs))\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        sum_of_mags = sum(abs.(signs))\n      \
    \  prod_of_mags = prod(signs)\n        return sum_of_mags * prod_of_mags\n   \
    \ end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    \n    signs = zeros(Int, length(arr))\n \
    \   signs[1] = 1\n    signs[2] = -1\n    \n    prod = 1\n    for i in 1:length(arr)\n\
    \        prod *= signs[i]\n    end\n    \n    return prod * sum(abs(arr))\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes an array of integers\
    \ and returns its product of absolute values.", "    if length(arr) == 0 return\
    \ nothing\n    signs = zeros(Int64, length(arr))\n    signs[arr .== 0] = -1\n\
    \    signs[arr .== 1] = 1\n    signs[arr .== -1] = 0\n    prod = prod(signs)\n\
    \    return prod * sum(signs)\nend", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = map(sign, arr) \n        signs = filter(x\
    \ -> x != 0, signs) \n        signs = prod(signs) \n        mags = map(abs, arr)\
    \ \n        mags = filter(x -> x != 0, mags) \n        mags = prod(mags) \n  \
    \      return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is even, False otherwise.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    \n    sum_of_signs = 0 \n    for x in arr \n\
    \        sum_of_signs += sign(x) \n    \n    product = 1 \n    for x in arr \n\
    \        product *= sign(x) \n    \n    return sum_of_signs * product \nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that checks if a number is odd or even.", "    if\
    \ length(arr) == 0 \n        return nothing\n    \n    signs = zeros(Int, length(arr))\n\
    \    signs[1] = 1\n    signs[end] = -1\n    \n    product = 1\n    for i in 1:length(arr)\n\
    \        product *= signs[i]\n    end\n    \n    return product * sum(abs(arr))\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\n4.5 Product of absolute values", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = map(sign, arr) \n        signs = filter(x\
    \ -> x != 0, signs) \n        signs = prod(signs) \n        mags = map(abs, arr)\
    \ \n        mags = filter(x -> x != 0, mags) \n        mags = prod(mags) \n  \
    \      return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is odd and False otherwise. \nThe function should work\
    \ for any type of number.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = map(sign, arr) \n        signs = filter(x -> x\
    \ != 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = prod(signs) \n        magnitudes = map(abs, arr) \n        magnitudes\
    \ = filter(x -> x != 0, magnitudes) \n        magnitudes = filter(x -> x == 0,\
    \ magnitudes) \n        magnitudes = filter(x -> x == 1, magnitudes) \n      \
    \  magnitudes = filter(x -> x == -1, magnitudes) \n        magnitudes = prod(magnitudes)\
    \ \n        return signs * magnitudes \n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nA simple solution that does not require any packages:\n\
    <code>", "    if length(arr) == 0 \n        return nothing\n    else \n      \
    \  signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes =\
    \ map(abs, arr)\n        return sum(magnitudes * product)\n    end\nend\n</code>\n\
    <|/ a tags=julia,function,arrays |>\n<| c |>\nThanks for your answer. Can you\
    \ please explain the function `prod_signs(arr::Vector{Int64})::Union{Int64, Nothing}`?\
    \ What does it do? What does it return?\n<|/ c |>\n<| c |>\nIt returns a union\
    \ of Int64 and Nothing. Nothing is a special type that indicates that a value\
    \ is not available. Here is a link to Julia docs: https://docs.julialang.org/en/v1/manual/types/#Union-types-1\n\
    <|/ c |>\n<| c |>\nThanks. I understand now. Can you please explain what `signs\
    \ = map(sign, arr)` does? What does it do? What does it return?\n<|/ c |>\n<|\
    \ c |>\n`signs` is a vector of signs of the elements of `arr`. For example `signs([-2,\
    \ -1, 0, 1, 2])` returns `[1, 1, -1, 0, 1]`. `sign` returns sign of a number.\
    \ `sign` returns `-1` for negative numbers and `1` for positive numbers. `sign`\
    \ returns `nothing` for zero. `sign` returns `nothing` for non-numbers. `signs`\
    \ returns `nothing` for empty array. `signs` returns `nothing` for non-vectors.\n\
    <|/ c |>\n<| c |>\nThanks. I understand now. Can you please explain what `signs\
    \ = map(sign, arr)` does? What does it do? What does it return?\n<|/ c |>\n<|\
    \ a tags=julia,function,arrays |>\nHere is a solution using broadcasting -\n<code>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        for (i, x) in enumerate(arr) \n            signs[i] =\
    \ sign(x) * sign(i)\n        end\n        return sum(abs2, signs)\n    end\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the sum of all numbers\
    \ in arr multiplied by product of all signs of numbers in arr, represented by\
    \ 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    \n   \
    \ signs = zeros(Int64, length(arr))\n    for x in arr \n        signs[x] = signs[x]\
    \ + 1 \n    end\n    \n    mags = map(x -> abs(x), arr)\n    \n    prod = prod(signs)\n\
    \    \n    return prod * prod(mags)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite a function that returns\
    \ sum of absolute values of all numbers in an array.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n  \
    \      product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return product * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the product of absolute values of all numbers in an array. \nThe function\
    \ should work for both arrays of integers and arrays of floating point numbers.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        \n        sum_of_mags = sum(signs .* arr)\n\
    \        \n        prod_signs = prod(signs)\n        \n        return sum_of_mags\
    \ * prod_signs\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that calculates the sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the array, represented by 1, -1 or 0.", "    if length(arr) == 0 \n        return\
    \ nothing\n    elseif length(arr) == 1 \n        return arr[0] * signs(arr[1])\n\
    \    else\n        signs = signs(arr)\n        mags = map(abs, arr)\n        mags\
    \ = map(prod, mags)\n        mags = map(signs, mags)\n        return sum(mags)\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "  \
    \  if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n\
    \        signs = signs * prod(signs)\n        return signs\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd and False otherwise. Test it\
    \ on all numbers from 0 to 20.", "    if length(arr) == 0 \n        return nothing\n\
    \    elseif length(arr) == 1 \n        return arr[1]\n    else\n        signs\
    \ = zeros(Int64, length(arr))\n        for i = 1:length(arr)\n            signs[i]\
    \ = sign(arr[i])\n        end\n        product = prod(signs)\n        return product\
    \ * sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that returns True if\
    \ a number is odd and False otherwise.", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = signs(arr) \n        product = prod(signs)\
    \ \n        sum = 0\n        for a in arr \n            sum += sign(a) * a * product\n\
    \        return sum \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns the sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the array, represented by 1, -1 or 0.", "    if length(arr) == 0 \n        return\
    \ nothing\n    \n    sum = 0\n    sign = 1\n    for x in arr\n        sum += sign\
    \ * x\n        sign *= sign\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs of\
    \ each number in the array, represented by 1, -1 or 0.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    \n    signs = zeros(Int, length(arr))\n    signs[arr\
    \ .< 0] = -1\n    signs[arr .> 0] = 1\n    \n    prod = 1\n    for i in 1:length(arr)\
    \ \n        prod *= signs[i]\n    end\n    \n    return prod\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of each number in the array, represented by 1, -1 or 0.", "   \
    \ if length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = prod(signs)\
    \ \n        mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n\
    \        mags = prod(mags) \n        return signs * mags \n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=2 |>\n<code>", "    if length(arr) == 0 \n  \
    \      return nothing\n    else \n        signs = map(sign, arr)\n        signs\
    \ = filter(x -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n\
    \        signs = filter(x -> x == 0, signs)\n        signs = prod(signs)\n   \
    \     return signs * prod(arr)\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=julia,arrays |>\nHere's a solution using broadcasting and the function\
    \ prod from the StatsBase package:\n<code>\nusing StatsBase", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ n in arr \n            product *= signs[n]\n        end\n        return product\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>", "    if length(arr)==0\n \
    \       return nothing\n    elseif length(arr)==1\n        return arr[1]\n   \
    \ else\n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n      \
    \  signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\n    \
    \        product *= signs[i]\n        end\n        return product*sum(abs(arr))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if length(arr) == 0 \n\
    \        return nothing\n    else \n        signs = map(sign, arr)\n        mags\
    \ = map(abs, arr)\n        product = reduce(mul, signs)\n        return product\
    \ * reduce(mul, mags)\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/29544544)\n\
    <|/ c |>\n<| c |>\nI believe it does answer the question. He asked how to find\
    \ the product of all the signs of the numbers in the array. He also asked how\
    \ to find the sum of all the magnitudes of the numbers in the array. He also asked\
    \ how to find the product of all the signs and magnitudes of the numbers in the\
    \ array. He also asked how to find the product of all the signs and magnitudes\
    \ of the numbers in the array. He also asked how to find the product of all the\
    \ signs and magnitudes of the numbers in the array. He also asked how to find\
    \ the product of all the signs and magnitudes of the numbers in the array. He\
    \ also asked how to find the product of all the signs and magnitudes of the numbers\
    \ in the array. He also asked how to find the product of all the signs and magnitudes\
    \ of the numbers in the array. He also asked how to find the product of all the\
    \ signs and magnitudes of the numbers in the array. He also asked how to find\
    \ the product of all the signs and magnitudes of the numbers in the array. He\
    \ also asked how to find the product of all the signs and magnitudes of the numbers\
    \ in the array. He also asked how to find the product of all the signs and magnitudes\
    \ of the numbers in the array. He also asked how to find the product of all the\
    \ signs and magnitudes of the numbers in the array. He also asked how to find\
    \ the product of all the signs and magnitudes of the numbers in the array. He\
    \ also asked how to find the product of all the signs and magnitudes of the numbers\
    \ in the array. He also asked how to find the product of all the signs and magnitudes\
    \ of the numbers in the array. He also asked how to find the product of all the\
    \ signs and magnitudes of the numbers in the array. He also asked how to find\
    \ the product of all the signs and magnitudes of the numbers in the array. He\
    \ also asked how to find the product of all the signs and magnitudes of the numbers\
    \ in the array. He also asked how to find the product of all the signs and magnitudes\
    \ of the numbers in the array. He also asked how to find the product of all the\
    \ signs and magnitudes of the numbers in the array. He also asked how to find\
    \ the product of all the ", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        sum_of_mags = 0 \n        for el in arr \n            sum_of_mags\
    \ += el * signbit(el) \n        \n        return sum_of_mags \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an array of integers and returns the sum\
    \ of all integers multiplied by product of all signs of each number in the array,\
    \ represented by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing\n\
    \    end\n    signs = map(sign, arr)\n    prod = prod(signs)\n    mags = map(abs,\
    \ arr)\n    return sum(mags .* signs)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd, False otherwise. \nThe function should work\
    \ for any type of number.", "    if length(arr) == 0 return nothing\n    \n  \
    \  signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] = -1\n  \
    \  \n    prod = 1\n    for i in 1:length(arr)\n        prod = prod * signs[i]\n\
    \    end\n    \n    return prod\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nTask 9. Write a function that returns number of\
    \ unique elements in an array.", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        product = prod(signs)\n  \
    \      magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is even, False otherwise.", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = map(sign, arr)\n        product = prod(signs)\n\
    \        return product * sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is odd and False otherwise. \nWrite a function that\
    \ returns True if a number is even and False otherwise. \nWrite a function that\
    \ returns True if a number is prime and False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by 3 and False otherwise. \nWrite a function\
    \ that returns True if a number is divisible by 5 and False otherwise. \nWrite\
    \ a function that returns True if a number is divisible by 7 and False otherwise.\
    \ \nWrite a function that returns True if a number is divisible by 11 and False\
    \ otherwise. \nWrite a function that returns True if a number is divisible by\
    \ 13 and False otherwise. \nWrite a function that returns True if a number is\
    \ divisible by 17 and False otherwise. \nWrite a function that returns True if\
    \ a number is divisible by 19 and False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by 23 and False otherwise. \nWrite a function\
    \ that returns True if a number is divisible by 29 and False otherwise. \nWrite\
    \ a function that returns True if a number is divisible by 31 and False otherwise.\
    \ \nWrite a function that returns True if a number is divisible by 37 and False\
    \ otherwise. \nWrite a function that returns True if a number is divisible by\
    \ 41 and False otherwise. \nWrite a function that returns True if a number is\
    \ divisible by 43 and False otherwise. \nWrite a function that returns True if\
    \ a number is divisible by 47 and False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by 53 and False otherwise. \nWrite a function\
    \ that returns True if a number is divisible by 59 and False otherwise. \nWrite\
    \ a function that returns True if a number is divisible by 61 and False otherwise.\
    \ \nWrite a function that returns True if a number is divisible by 67 and False\
    \ otherwise. \nWrite a function that returns True if a number is divisible by\
    \ 71 and False otherwise. \nWrite a function that returns True if a number is\
    \ divisible by 73 and False otherwise. \nWrite a function that returns True if\
    \ a number is divisible by 79 and False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by 83 and False otherwise. \nWrite a function\
    \ that returns True if a number is divisible by 89 and False otherwise. \nWrite\
    \ a function that returns True if a number is divisible by 97 and False otherwise.\
    \ \nWrite a function that ", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .<\
    \ 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs.prod(1)\n      \
    \  return signs * prod(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd, False otherwise. Test it on several examples:",
  "    if length(arr) == 0 \n        return nothing\n    elseif length(arr) == 1 \n\
    \        return arr[1]\n    elseif length(arr) == 2 \n        return arr[1]*arr[2]\n\
    \    elseif length(arr) > 2 \n        signs = zeros(Int, length(arr))\n      \
    \  signs[1] = 1\n        signs[2] = -1\n        signs[end] = -1\n        signs[end-1]\
    \ = 1\n        signs[end-2] = 1\n        signs[end-3] = 1\n        signs[end-4]\
    \ = 1\n        signs[end-5] = 1\n        signs[end-6] = 1\n        signs[end-7]\
    \ = 1\n        signs[end-8] = 1\n        signs[end-9] = 1\n        signs[end-10]\
    \ = 1\n        signs[end-11] = 1\n        signs[end-12] = 1\n        signs[end-13]\
    \ = 1\n        signs[end-14] = 1\n        signs[end-15] = 1\n        signs[end-16]\
    \ = 1\n        signs[end-17] = 1\n        signs[end-18] = 1\n        signs[end-19]\
    \ = 1\n        signs[end-20] = 1\n        signs[end-21] = 1\n        signs[end-22]\
    \ = 1\n        signs[end-23] = 1\n        signs[end-24] = 1\n        signs[end-25]\
    \ = 1\n        signs[end-26] = 1\n        signs[end-27] = 1\n        signs[end-28]\
    \ = 1\n        signs[end-29] = 1\n        signs[end-30] = 1\n        signs[end-31]\
    \ = 1\n        signs[end-32] = 1\n        signs[end-33] = 1\n        signs[end-34]\
    \ = 1\n        signs[end-35] = 1\n        signs[end-36] = 1\n        signs[end-37]\
    \ = 1\n        signs[end-38] = 1\n        signs[end-39] = 1\n        signs[end-40]\
    \ = 1\n        signs[end-41] = 1\n        signs[end-42] = 1\n        signs[end-43]\
    \ = 1\n        signs[end-44] = 1\n        signs[end-45] = 1\n        signs[end-46]\
    \ = 1\n        signs[end-47] = 1\n        signs[end-48] = 1\n        signs[end-49]\
    \ = 1\n        signs[end-50] = 1\n        signs[end-51] = 1\n        signs[end-52]\
    \ = 1\n        signs[end-53] = 1\n        signs[end-54] = 1\n        signs[end-55]\
    \ = 1\n        signs[end-56] = 1\n        signs[end-57] = 1\n        signs[end-58]\
    \ = 1", "    if length(arr) == 0 \n        return nothing \n    else \n      \
    \  signs = map(sign, arr) \n        product = prod(signs) \n        magnitudes\
    \ = map(abs, arr) \n        return sum(magnitudes * product) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that calculates the sum of squares of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0.", "    if length(arr) == 0 \n        return nothing\n    else \n        signs\
    \ = map(sign, arr)\n        signs_product = prod(signs)\n        sum_of_mags =\
    \ sum(map(abs, arr))\n        return sum_of_mags * signs_product\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the product of the absolute values of\
    \ all numbers in the given array.", "    if length(arr)==0 return nothing\n  \
    \  prod = 1\n    sign = 1\n    for x in arr\n        prod *= sign\n        sign\
    \ *= x\n    end\n    return prod\nend", "    if length(arr) == 0 \n        return\
    \ nothing\n    \n    sum_signs = sum(signs(arr))\n    \n    if sum_signs == 0\
    \ \n        return nothing\n    \n    prod = 1\n    for x in arr \n        prod\
    \ *= sign(x)\n    end\n    \n    return sum_signs * prod\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an array arr of integers and returns its sum.", "    if\
    \ length(arr) == 0 \n        return nothing\n    else \n        sum_of_magnitudes\
    \ = sum(abs(arr))\n        signs = prod(signs(arr))\n        return sum_of_magnitudes\
    \ * signs\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ an array arr of integers and returns its sum of the absolute values of all its\
    \ elements. \nWrite a second function that takes an array arr of integers and\
    \ returns its sum of the absolute values of all its elements. \nWrite a third\
    \ function that takes an array arr of integers and returns its sum of the absolute\
    \ values of all its elements. \nWrite a fourth function that takes an array arr\
    \ of integers and returns its sum of the absolute values of all its elements.\
    \ \nWrite a fifth function that takes an array arr of integers and returns its\
    \ sum of the absolute values of all its elements. \nWrite a sixth function that\
    \ takes an array arr of integers and returns its sum of the absolute values of\
    \ all its elements. \nWrite a seventh function that takes an array arr of integers\
    \ and returns its sum of the absolute values of all its elements. \nWrite a eighth\
    \ function that takes an array arr of integers and returns its sum of the absolute\
    \ values of all its elements. \nWrite a ninth function that takes an array arr\
    \ of integers and returns its sum of the absolute values of all its elements.\
    \ \nWrite a tenth function that takes an array arr of integers and returns its\
    \ sum of the absolute values of all its elements. \nWrite a eleventh function\
    \ that takes an array arr of integers and returns its sum of the absolute values\
    \ of all its elements. \nWrite a twelfth function that takes an array arr of integers\
    \ and returns its sum of the absolute values of all its elements. \nWrite a thirteenth\
    \ function that takes an array arr of integers and returns its sum of the absolute\
    \ values of all its elements. \nWrite a fourteenth function that takes an array\
    \ arr of integers and returns its sum of the absolute values of all its elements.\
    \ \nWrite a fifteenth function that takes an array arr of integers and returns\
    \ its sum of the absolute values of all its elements. \nWrite a sixteenth function\
    \ that takes an array arr of integers and returns its sum of the absolute values\
    \ of all its elements. \nWrite a seventeenth function that takes an array arr\
    \ of integers and returns its sum of the absolute values of all its elements.\
    \ \nWrite a eighteenth function that takes an array arr of integers and returns\
    \ its sum of the absolute values of all its elements. \nWrite a nineteenth function\
    \ that takes an array arr of integers and returns its sum of the absolute values\
    \ of all its elements. \nWrite a twentieth function that takes an array ", " \
    \   if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        product = prod(signs)\n        return product * sum(signs)\n \
    \   end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns True\
    \ if a number is even, False otherwise. Test it on all numbers from 0 to 20.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n\
    \        signs[arr .== -1] = 0\n        signs = signs .* prod(signs)\n       \
    \ return sum(signs)\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that calculates the absolute value of an integer.", "    if length(arr) == 0\
    \ \n        return nothing\n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(abs.(signs))\n        prod_of_signs =\
    \ prod(signs)\n        return sum_of_mags * prod_of_signs\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is even, False otherwise. Test it on\
    \ all numbers from 0 to 20.", "    if length(arr)==0 return nothing\n    sum =\
    \ 0\n    sign = 1\n    for i in arr\n        sum += sign * i\n        sign *=\
    \ sign\n    end\n    return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia\
    \ |>\n<code>", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes\
    \ = map(abs, arr)\n        return sum(magnitudes * product)\n    end\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| a |>\n<code>", "    if length(arr) == 0 \n    \
    \    return nothing\n    else\n        signs = map(sign, arr)\n        signs =\
    \ filter(x -> x != 0, signs)\n        signs = prod(signs)\n        mags = map(abs,\
    \ arr)\n        mags = filter(x -> x != 0, mags)\n        mags = prod(mags)\n\
    \        return signs * mags\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = map(sign, arr)\n        mags = map(abs, arr)\n        product\
    \ = prod(signs)\n        return product * prod(mags)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates the sum of squares of integers in arr\nand returns\
    \ the result as a Float64 number. \nThe function should work for empty arr as\
    \ well. \nThe function should work for any type of arr including Float64, Int64,\n\
    and BigInt. \nThe function should work for any type of arr including Float64,\
    \ Int64,\nand BigInt.", "    if length(arr) == 0 \n        return nothing\n  \
    \  \n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n    end\n \
    \   return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns True if\
    \ a number is divisible by 3 and False otherwise. Test it on several examples:",
  "    if length(arr) == 0 return nothing\n    sum = 0\n    sign = 1\n    for x in\
    \ arr\n        sum += sign * x\n        sign *= sign\n    end\n    return sum\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    if length(arr)==0\
    \ \n        return nothing\n    else \n        signs = map(sign, arr)\n      \
    \  product = prod(signs)\n        magnitudes = map(abs, arr)\n        return sum(magnitudes\
    \ * product)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array arr\
    \ of integers and returns its sum.", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = zeros(Int, length(arr))\n        signs[1]\
    \ = 1\n        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\n\
    \            product *= signs[i]\n        end\n        return product * sum(abs(arr))\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array\
    \ of integers and returns its sum\nof squares.", "    if length(arr) == 0 \n \
    \       return nothing\n    else \n        signs = zeros(Int, length(arr))\n \
    \       signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr)\n            product *= signs[i]\n            signs[i] =\
    \ 0\n        end\n        return product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of magnitudes of integers multiplied by product of all signs\n\
    of each number in the array, represented by 1, -1 or 0.\nNote: return 0 for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing\n    else \n      \
    \  signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n      \
    \  signs = map(x -> x * prod(signs), arr)\n        return sum(signs)\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    elseif length(arr) == 1 \n        return\
    \ arr[0] * prod(signs(arr))\n    else\n        signs = signs(arr)\n        signs_prod\
    \ = prod(signs)\n        sum_of_mags = sum(map(abs, arr))\n        sum_of_mags_prod\
    \ = sum_of_mags * signs_prod\n        return sum_of_mags_prod\n    end\nend\n\
    </cell>\n<code language=julia-1.5>", "    if length(arr) == 0 \n        return\
    \ nothing\n    elseif length(arr) == 1 \n        return arr[1]\n    else\n   \
    \     signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n   \
    \     signs = filter(x -> x == 1, signs)\n        signs = filter(x -> x == -1,\
    \ signs)\n        signs = prod(signs)\n        mags = map(abs, arr)\n        mags\
    \ = filter(x -> x != 0, mags)\n        mags = filter(x -> x == 1, mags)\n    \
    \    mags = filter(x -> x == -1, mags)\n        mags = prod(mags)\n        return\
    \ signs * mags\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for\
    \ your answer! I see that your solution works but I'm still wondering if there\
    \ is a way to do this without using any loops. I guess it would be a good exercise\
    \ to try to solve this problem without using loops.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that doesn't use loops. I hope it helps.\n<|/ c |>\n<| c |>\nThanks\
    \ again! I really appreciate your help!\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't use loops. I hope it helps.\n<|/ c |>\n<| a dscore=1 |>\nI believe\
    \ that your solution is fine, but I wanted to point out that you can avoid the\
    \ loops by using broadcasting and the fact that your function returns Int64:\n\
    <code>\njulia> function prod_signs(arr::Vector{Int64})::Int64\n           signs\
    \ = map(sign, arr)\n           signs = filter(x -> x != 0, signs)\n          \
    \ signs = filter(x -> x == 1, signs)\n           signs = filter(x -> x == -1,\
    \ signs)\n           signs = prod(signs)\n           mags = map(abs, arr)\n  \
    \         mags = filter(x -> x != 0, mags)\n           mags = filter(x -> x ==\
    \ 1, mags)\n           mags = filter(x -> x == -1, mags)\n           mags = prod(mags)\n\
    \           return signs * mags\n       end\nprod_signs (generic function with\
    \ 1 method)", "    if length(arr) == 0 \n        return nothing\n    \n    sum_of_mags\
    \ = sum(map(abs, arr))\n    signs = map(sign, arr)\n    prod = prod(signs)\n \
    \   return sum_of_mags * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is odd and False otherwise.", "    if length(arr) == 0 \n      \
    \  return nothing\n    elseif length(arr) == 1 \n        return arr[1]\n    elseif\
    \ length(arr) == 2 \n        return arr[1]*arr[2]\n    elseif length(arr) > 2\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n        signs[2]\
    \ = -1\n        signs[end] = -1\n        product = 1\n        for i = 2:length(arr)\
    \ \n            product *= signs[i]\n        end\n        return product * prod(signs)\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns number\
    \ of digits in an integer. \nExample: \n>>> digits(123)\n3\n>>> digits(1234)\n\
    4\n>>> digits(12345)\n5\n>>> digits(123456)\n6\n>>> digits(123456789)\n9\n>>>\
    \ digits(1234567890)\n10\n>>> digits(12345678901)\n10\n>>> digits(123456789012)\n\
    10\n>>> digits(1234567890123)\n10\n>>> digits(12345678901234)\n10\n>>> digits(123456789012345)\n\
    10\n>>> digits(1234567890123456)\n10\n>>> digits(1234567890123456789)\n10\n>>>\
    \ digits(12345678901234567890)\n10\n>>> digits(123456789012345678901)\n10\n>>>\
    \ digits(1234567890123456789012)\n10\n>>> digits(12345678901234567890123)\n10\n\
    >>> digits(123456789012345678901234)\n10\n>>> digits(1234567890123456789012345)\n\
    10\n>>> digits(12345678901234567890123456)\n10\n>>> digits(12345678901234567890123456789)\n\
    10\n>>> digits(123456789012345678901234567890)\n10\n>>> digits(1234567890123456789012345678901)\n\
    10\n>>> digits(12345678901234567890123456789012)\n10\n>>> digits(123456789012345678901234567890123)\n\
    10\n>>> digits(1234567890123456789012345678901234)\n10\n>>> digits(12345678901234567890123456789012345)\n\
    10\n>>> digits(123456789012345678901234567890123456)\n10\n>>> digits(123456789012345678901234567890123456789)\n\
    10\n>>> digits(1234567890123456789012345678901234567890)\n10\n>>> digits(12345678901234567890123456789012345678901)\n\
    10\n>>> digits(123456789012345678901234567890123456789012)\n10\n>>> digits(1234567890123456789012345678901234567890123)\n\
    10\n>>> digits(12345678901234567890123456789012345678901234)\n10\n>>> digits(123456789012345678901234567890123456789012345)\n\
    10\n>>> digits(1234567890123456789012345678901234567890123456)\n10\n>>> digits(1234567890123456789012345678901234567890123456789)\n\
    10\n>>> digit", "    if length(arr) == 0 \n        return nothing\n    end\n \
    \   \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] =\
    \ -1\n    \n    product = prod(signs)\n    \n    sum = 0\n    for x in arr\n \
    \       sum += sign(x) * x\n    end\n    \n    return sum * product\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n4.3 Sum of absolute\
    \ differences", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        sum_signs = sum(signs)\n        product = 1\n        for i in\
    \ 1:length(arr) \n            product *= signs[i]\n            product *= arr[i]\n\
    \        end\n        return sum_signs * product\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns number of positive numbers in an array.", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = map(sign, arr)\n \
    \       product = prod(signs)\n        sum = 0\n        for n in arr\n       \
    \     sum += sign(n) * product\n        end\n        return sum\n    end\nend\n\
    </cell>\n<code language=julia-1.5>", "    if length(arr)==0 return nothing\n \
    \   signs = zeros(Int, length(arr))\n    signs[arr .< 0] = -1\n    signs[arr .>\
    \ 0] = 1\n    prod = prod(signs)\n    mags = map(abs, arr)\n    mags = map(prod,\
    \ mags)\n    return sum(mags)\nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to avoid the explicit loop. Maybe some sort of\
    \ vectorized operation?\n<|/ c |>\n<| c |>\nI guess you could use something like\
    \ `@view map(prod, map(abs, arr))`, but that would probably be less efficient.\n\
    <|/ c |>\n<| c |>\nI added a solution without explicit loops.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's a solution without explicit loops:\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        signs = signs.prod(1)\n        return signs * prod(signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes an array of integers\
    \ and returns its product of absolute values.", "    if length(arr) == 0 \n  \
    \      return nothing\n    end\n    \n    sum = 0\n    product = 1\n    for i\
    \ in arr\n        sign = sign(i)\n        sum += sign * i\n        product *=\
    \ sign\n    end\n    return sum, product\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns the sum of squares of integers multiplied by product of all signs of\
    \ each number in the array, represented by 1, -1 or 0.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    end\n    signs = zeros(Int64, length(arr))\n\
    \    for (i,x) in enumerate(arr)\n        signs[i] = sign(x) * sign(i)\n    end\n\
    \    return sum(signs)\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        product = reduce(mul, signs)\n        return product * prod(signs)\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe most efficient\
    \ way is to use broadcasting and the built-in function sum:\n<code>", "    if\
    \ length(arr) == 0 return nothing\n    sum = 0\n    for i in arr\n        sum\
    \ += sign(i) * i\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = signs(arr)\
    \ \n        signs_prod = prod(signs) \n        sum_of_mags = sum(abs.(arr .- signs_prod))\
    \ \n        return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd and False otherwise.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    \n    prod = 1\n    for x in arr \n        prod\
    \ *= sign(x)\n    end\n    return prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ calculates the sum of squares of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns True if a number is\
    \ even, False otherwise. Test it on all numbers from 0 to 20.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product =\
    \ signs .* prod(signs)\n        return sum(abs(product))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of absolute deviations of elements in a vector.",
  "    if length(arr) == 0 \n        return nothing\n    end\n    signs = zeros(Int64,\
    \ length(arr))\n    signs[arr .== 1] = 1\n    signs[arr .== -1] = -1\n    signs[arr\
    \ .== 0] = 0\n    prod = prod(signs)\n    return prod * sum(signs)\nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = zeros(Int, length(arr))\n        for (i, x) in enumerate(arr)\n\
    \            signs[i] = sign(x) * sign(i)\n        end\n        \n        sum_signs\
    \ = sum(signs)\n        \n        product = 1\n        for (i, x) in enumerate(arr)\n\
    \            product *= signs[i]\n        end\n        \n        return sum_signs\
    \ * product\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes an array arr of integers and returns its product of absolute values.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        product = prod(signs)\n        magnitudes = map(abs, arr)\n  \
    \      return sum(magnitudes) * product\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia,arrays |>\nI wrote a function that does this in one line:\n\
    <code>", "    if length(arr) == 0 \n        return nothing\n    end\n    \n  \
    \  signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] = -1\n  \
    \  \n    prod = 1\n    for x in arr\n        prod *= signs[x]\n    end\n    \n\
    \    return prod\nend\n</cell>\n<code language=julia-1.5>", "    if length(arr)\
    \ == 0 return nothing\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>", "    if length(arr) == 0 \n        return nothing\n    else \n      \
    \  signs = signs(arr)\n        product = prod(signs)\n        sum_of_mags = sum(map(abs,\
    \ arr))\n        return product * sum_of_mags\n    end\nend\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that takes a vector of integers and returns the sum\
    \ of the absolute values of the integers in the vector.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product\
    \ = signs .* prod(signs)\n        return sum(abs.(product))\n    end\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThe answer by is correct, but I wanted to add some explanation\
    \ as to why it works.\nThe function prod_signs returns a single value, which can\
    \ be assigned to a variable of type Int64 or Nothing. \nThe function prod_signs\
    \ has two branches: one branch returns nothing (Nothing) if the length of the\
    \ array is zero. The other branch returns a single value which is the sum of the\
    \ absolute values of the product of the signs of the elements of the array.\n\
    The function prod_signs also has two branches: one branch returns nothing (Nothing)\
    \ if the length of the array is zero. The other branch returns a single value\
    \ which is the sum of the absolute values of the product of the signs of the elements\
    \ of the array.\nThe function prod_signs has two branches: one branch returns\
    \ nothing (Nothing) if the length of the array is zero. The other branch returns\
    \ a single value which is the sum of the absolute values of the product of the\
    \ signs of the elements of the array.\nThe function prod_signs has two branches:\
    \ one branch returns nothing (Nothing) if the length of the array is zero. The\
    \ other branch returns a single value which is the sum of the absolute values\
    \ of the product of the signs of the elements of the array.\nThe function prod_signs\
    \ has two branches: one branch returns nothing (Nothing) if the length of the\
    \ array is zero. The other branch returns a single value which is the sum of the\
    \ absolute values of the product of the signs of the elements of the array.\n\
    The function prod_signs has two branches: one branch returns nothing (Nothing)\
    \ if the length of the array is zero. The other branch returns a single value\
    \ which is the sum of the absolute values of the product of the signs of the elements\
    \ of the array.\nThe function prod_signs has two branches: one branch returns\
    \ nothing (Nothing) if the length of the array is zero. The other branch returns\
    \ a single value which is the sum of the absolute values of the product of the\
    \ signs of the elements of the array.\nThe function prod_signs has two branches:\
    \ one branch returns nothing (Nothing) if the length of the array is zero. The\
    \ other branch returns a single value which is the sum of the absolute values\
    \ of the product of the signs of the elements of the array.\nThe function prod_signs\
    \ has two branches: one branch returns nothing (Nothing) if the length of the\
    \ array is zero. The other branch returns a single value which is the sum of the\
    \ absolute values of the product of the signs of the elements of the array.\n\
    The function prod_signs has two branches: one branch returns nothing (Nothing)\
    \ if the length of the array is zero. The other branch returns a single value\
    \ which is the sum", "    if length(arr)==0\n        return nothing\n    sum =\
    \ 0\n    for x in arr\n        sum += sign(x)*abs(x)\n    end\n    return sum\n\
    end", "    if length(arr)==0\n        return nothing\n    else\n        signs\
    \ = zeros(Int64, length(arr))\n        for (i,x) in enumerate(arr)\n         \
    \   signs[i] = sign(x) * sign(i)\n        end\n        return sum(abs2, signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers in arr using prod_signs function.", "    if length(arr) == 0 \n   \
    \     return nothing\n    \n    sum = 0\n    for i in arr\n        sum += sign(i)\
    \ * i\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the array, represented by 1, -1 or 0.", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = zeros(Int, length(arr))\n        for (i,\
    \ x) in enumerate(arr)\n            signs[i] = sign(x) * sign(i)\n        end\n\
    \        sum(signs)\n    end\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays |>\n\
    I came up with a solution that is similar to what was suggested in the comments,\
    \ but I wanted to share it here in case it helps someone:\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = map(sign, arr)\n \
    \       mags = map(abs, arr)\n        product = reduce(mul, signs)\n        return\
    \ product * sum(mags)\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays\
    \ |>\n<code>", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n\
    \        signs = filter(x -> x == 0, signs)\n        signs = filter(x -> x ==\
    \ 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs = map(x\
    \ -> x * prod(signs), arr)\n        return sum(signs)\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    if length(arr) == 0 \n  \
    \      return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    The answer by is good, but I wanted to add that you can also use broadcasting\
    \ instead of looping through the array:\n<code>", "    if length(arr) == 0 return\
    \ nothing\n    \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end]\
    \ = -1\n    \n    prod = 1\n    for i in 1:length(arr)\n        prod *= signs[i]\n\
    \    end\n    \n    return prod\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nProblem 7\nWrite a function that returns True if\
    \ a number is prime and False otherwise.", "    if length(arr) == 0 \n       \
    \ return nothing\n    elseif length(arr) == 1 \n        return arr[1]\n    elseif\
    \ length(arr) == 2 \n        return arr[1] * arr[1]\n    elseif length(arr) ==\
    \ 3 \n        return arr[1] * arr[1] * arr[1]\n    elseif length(arr) == 4 \n\
    \        return arr[1] * arr[1] * arr[1] * arr[1]\n    elseif length(arr) == 5\
    \ \n        return arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\n    elseif length(arr)\
    \ == 6 \n        return arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\n\
    \    elseif length(arr) == 7 \n        return arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1]\n    elseif length(arr) == 8 \n        return arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\n    elseif length(arr)\
    \ == 9 \n        return arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] *\
    \ arr[1] * arr[1] * arr[1]\n    elseif length(arr) == 10 \n        return arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1]\n    elseif length(arr) == 11 \n        return arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\n\
    \    elseif length(arr) == 12 \n        return arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1]\n    elseif length(arr) == 13 \n        return arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1]\n    elseif length(arr) == 14 \n        return arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\n    elseif length(arr)\
    \ == 15 \n        return arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] *\
    \ arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\n    elseif length(arr) == 16 \n\
    \        return arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] *\
    \ arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1] * arr[1]\
    \ * arr[1] * arr[1] * arr[1] * ", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr)) \n        signs[arr .==\
    \ 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n     \
    \   signs = signs .* prod(signs)\n        return sum(signs)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the sum of squares of integers multiplied by product\
    \ of all signs of each number in the array, represented by 1, -1 or 0.", "   \
    \ if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        mags = map(abs, arr)\n        product = prod(signs)\n        return\
    \ product * prod(mags)\n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<|\
    \ a dscore=1 |>\nI came up with a solution which uses no loops and is very fast:\n\
    <code>", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = map(sign, arr) \n        signs_product = prod(signs) \n        sum_of_mags\
    \ = sum(map(abs, arr)) \n        return sum_of_mags * signs_product \n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        product = prod(signs) \n        return product * sum(signs) \n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    if length(arr) == 0 return nothing\n\
    \    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n    end\n    return\
    \ sum\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>", " \
    \   if length(arr) == 0 \n        return nothing\n    end\n    signs = zeros(Int,\
    \ length(arr))\n    signs[1] = 1\n    signs[end] = -1\n    prod = 1\n    for x\
    \ in arr\n        prod *= signs[x]\n    end\n    return prod\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite\
    \ a function that checks if a number is prime (for numbers divisible by 1 or by\
    \ itself).", "    if length(arr) == 0 \n        return nothing\n    else \n  \
    \      signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes\
    \ = map(abs, arr)\n        return sum(magnitudes * product)\n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia,arrays |>\n<code>", "    if length(arr) ==\
    \ 0 \n        return nothing\n    else \n        signs = map(sign, arr)\n    \
    \    product = prod(signs)\n        magnitudes = map(abs, arr)\n        return\
    \ sum(magnitudes * product)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia\
    \ |>\nI like using reduce for these kinds of problems:\n<code>\nreduce(+, map(abs,\
    \ arr))\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 2:length(arr)\n            product *= signs[i]\n        end\n        return\
    \ product * sum(abs2, arr)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates the sum of squares of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.", "    if length(arr)==0\
    \ \n        return nothing\n    else\n        signs = map(sign, arr)\n       \
    \ product = prod(signs)\n        magnitudes = map(abs, arr)\n        return sum(magnitudes.*product)\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays |>\n<code>", "    if\
    \ length(arr) == 0 \n        return nothing\n    \n    sum = 0\n    sign = 1\n\
    \    for x in arr\n        sum += sign * x\n        sign *= sign\n    end\n  \
    \  return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns True if\
    \ a number is even, False otherwise.", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int64, length(arr)) \n        signs[1]\
    \ = 1\n        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\
    \ \n            product *= signs[i] \n            signs[i] = product \n      \
    \  end\n        return product\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 return nothing\n    \n    sum = 0\n    for i in arr\n \
    \       sum += sign(i) * i\n    end\n    \n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns sum of squares of integers multiplied by product of\
    \ all signs of each number in the array, represented by 1, -1 or 0.", "    if\
    \ length(arr) == 0 \n        return nothing\n    end\n    \n    sum_signs = sum(map(sign,\
    \ arr))\n    \n    product = 1\n    for x in arr\n        product *= sign(x)\n\
    \    end\n    \n    return sum_signs * product\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates the sum of squares of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing\n    end\n    \n    signs = zeros(Int, length(arr))\n\
    \    signs[1] = 1\n    signs[end] = -1\n    \n    product = prod(signs)\n    \n\
    \    sum_of_magnitudes = sum(abs.(arr .- product))\n    \n    return sum_of_magnitudes\
    \ * product\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates the sum of squares\
    \ of integers multiplied by product of all signs of each number in the array,\
    \ represented by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing\n\
    \    end\n    signs = zeros(Int, length(arr))\n    for x in arr\n        signs[x]\
    \ = signs[x] + 1\n    end\n    signs = signs / sum(signs)\n    product = 1\n \
    \   for x in arr\n        product = product * signs[x]\n    end\n    return product\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nTask 3\nWrite a function that returns number of integers in arr which\
    \ are divisible by given number.", "    if length(arr)==0\n        return nothing\n\
    \    else\n        sum = 0\n        for n in arr\n            sign = sign(n)\n\
    \            sum += sign*abs(n)\n        end\n        return sum\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns True if a number is odd and False otherwise.",
  "    if length(arr) == 0 \n        return nothing\n    \n    signs = zeros(Int64,\
    \ length(arr))\n    signs[arr .== 1] = 1\n    signs[arr .== -1] = -1\n    signs[arr\
    \ .== 0] = 0\n    \n    prod = signs .* prod(signs)\n    \n    return sum(abs.(prod))\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns True if a number is even, False\
    \ otherwise. Test it on all numbers from 0 to 20.", "    if length(arr) == 0 return\
    \ nothing\n    sum = 0\n    for i in arr\n        sum += sign(i) * i\n    end\n\
    \    return sum\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ sum of absolute values of numbers in an array.", "    if length(arr) == 0 \n\
    \        return nothing\n    elseif length(arr) == 1 \n        return arr[1]\n\
    \    else\n        sum = 0\n        for n in arr\n            sum += sign(n) *\
    \ n\n        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing\n    elseif length(arr) == 1 \n\
    \        return arr[1]\n    else\n        signs = zeros(Int64, length(arr))\n\
    \        for i in 1:length(arr)\n            signs[i] = sign(arr[i])\n       \
    \ end\n        mags = map(abs, arr)\n        mags = map(sign, mags)\n        mags\
    \ = map(prod, mags)\n        mags = map(sum, mags)\n        return sum(mags)\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia |>\n<code>", "    if\
    \ length(arr)==0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        signs = filter(x -> x==1, signs)\n        signs = filter(x ->\
    \ x==-1, signs)\n        signs = filter(x -> x==0, signs)\n        signs = map(prod,\
    \ signs)\n        signs = filter(x -> x==1, signs)\n        signs = filter(x ->\
    \ x==-1, signs)\n        signs = filter(x -> x==0, signs)\n        signs = map(sum,\
    \ signs)\n        return signs\n    end\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nI like your solution, but I wonder why you use `map` instead of\
    \ `filter`?\n<|/ c |>\n<| c |>\nI guess `filter` would be more efficient, since\
    \ it stops iterating once it finds a match. `map` will iterate over the entire\
    \ array and return a vector of the results.\n<|/ c |>\n<| c |>\n`filter` will\
    \ stop iterating once it finds a match, but `map` will iterate over the entire\
    \ array. `filter` will stop iterating once it finds a match, but `map` will iterate\
    \ over the entire array. `filter` will stop iterating once it finds a match, but\
    \ `map` will iterate over the entire array. `filter` will stop iterating once\
    \ it finds a match, but `map` will iterate over the entire array. `filter` will\
    \ stop iterating once it finds a match, but `map` will iterate over the entire\
    \ array. `filter` will stop iterating once it finds a match, but `map` will iterate\
    \ over the entire array. `filter` will stop iterating once it finds a match, but\
    \ `map` will iterate over the entire array. `filter` will stop iterating once\
    \ it finds a match, but `map` will iterate over the entire array. `filter` will\
    \ stop iterating once it finds a match, but `map` will iterate over the entire\
    \ array. `filter` will stop iterating once it finds a match, but `map` will iterate\
    \ over the entire array. `filter` will stop iterating once it finds a match, but\
    \ `map` will iterate over the entire array. `filter` will stop iterating once\
    \ it finds a match, but `map` will iterate over the entire array. `filter` will\
    \ stop iterating once it finds a match, but `map` will iterate over the entire\
    \ array. `filter` will stop iterating once it finds a match, but `map` will iterate ",
  "    if length(arr) == 0 \n        return nothing\n    end\n    signs = zeros(Int,\
    \ length(arr))\n    for i in 1:length(arr)\n        signs[i] = sign(arr[i])\n\
    \    end\n    prod = 1\n    for i in 1:length(arr)\n        prod *= signs[i]\n\
    \    end\n    sum = 0\n    for i in 1:length(arr)\n        sum += signs[i] * abs(arr[i])\n\
    \    end\n    return sum * prod\nend\n</code>\n<|/ a tags=julia,arrays |>\n<|\
    \ a |>\n<code>", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = map(sign, arr) \n        product = prod(signs) \n        magnitudes\
    \ = map(abs, arr) \n        return product * sum(magnitudes) \n    end\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    if length(arr) ==\
    \ 0 \n        return nothing\n    else \n        signs = map(sign, arr)\n    \
    \    product = prod(signs)\n        magnitudes = map(abs, arr)\n        sum_magnitudes\
    \ = sum(magnitudes)\n        return product * sum_magnitudes\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        signs = filter(x -> x != 0,\
    \ signs)\n        product = prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        return product\n    end\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd, False otherwise.", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        product = prod(signs)\n  \
    \      magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>",
  "    if length(arr)==0\n        return nothing\n    \n    sum = 0\n    for i in\
    \ arr\n        sum += i\n    end\n    \n    prod = 1\n    for i in arr\n     \
    \   prod *= i\n    end\n    \n    return sum * prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is even or odd.", "    if length(arr) == 0 \n        return\
    \ nothing\n    end\n    \n    signs = zeros(Int64, length(arr))\n    signs[arr\
    \ .< 0] = -1\n    signs[arr .> 0] = 1\n    \n    sum_of_mags = sum(signs .* arr)\n\
    \    \n    return sum_of_mags\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is divisible by 3 and False otherwise. Test it on all numbers from\
    \ 1 to 100.", "    if length(arr) == 0 \n        return nothing\n    else \n \
    \       signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes\
    \ = map(abs, arr)\n        return sum(magnitudes * product)\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes an array and returns its product of absolute values.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        product = prod(signs)\n        magnitudes = map(abs, arr)\n  \
    \      return sum(magnitudes * product)\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia,arrays |>\n<code>", "    if length(arr) == 0 \n        return\
    \ nothing\n    else \n        signs = map(sign, arr)\n        signs = filter(x\
    \ -> x != 0, signs)\n        signs = filter(x -> x == 0, signs)\n        signs\
    \ = filter(x -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n\
    \        signs = map(x -> x * prod(signs), arr)\n        signs = reduce(*, signs)\n\
    \        return signs\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is odd and False otherwise. Test it on all numbers from 1 to 20.",
  "    if length(arr)==0\n        return nothing\n    else\n        signs = map(sign,\
    \ arr)\n        signs = filter(x -> x != 0, signs)\n        signs = map(x -> x*prod(signs),\
    \ arr)\n        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers in arr\nand returns the sum.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        product\
    \ = signs * prod(signs)\n        sum_of_magnitudes = sum(abs.(arr .- product))\n\
    \        return sum_of_magnitudes \n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\n<code>", "    if length(arr) == 0 \n        return nothing\n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        sum_of_mags = sum(abs.(arr .* signs))\n        prod_of_signs =\
    \ prod(signs)\n        return sum_of_mags * prod_of_signs\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd and False otherwise.", "   \
    \ if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        signs = filter(x -> x != 0, signs)\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        magnitudes = filter(x -> x != 0,\
    \ magnitudes)\n        magnitudes = map(abs, magnitudes)\n        magnitudes =\
    \ filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n\
    \        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs,\
    \ magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes\
    \ = map(abs, magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n\
    \        magnitudes = map(abs, magnitudes)\n        magnitudes = filter(x -> x\
    \ != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n        magnitudes\
    \ = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n\
    \        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs,\
    \ magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes\
    \ = map(abs, magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n\
    \        magnitudes = map(abs, magnitudes)\n        magnitudes = filter(x -> x\
    \ != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n        magnitudes\
    \ = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n\
    \        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs,\
    \ magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes\
    \ = map(abs, magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n\
    \        magnitudes = map(abs, magnitudes)\n        magnitudes = filter(x -> x\
    \ != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n        magnitudes\
    \ = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n\
    \        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs,\
    \ magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n        magnitudes\
    \ = map(abs, magnitudes)\n        magnitudes = filter(x -> x != 0, magnitudes)\n\
    \        magnitudes = map(abs, magnitudes)\n        magnitudes = filter(x -> x\
    \ != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n        magnitudes\
    \ = filter(x -> x != 0, magnitudes)\n        magnitudes = map(abs, magnitudes)\n\
    \        magnitudes = ", "    if length(arr) == 0 \n        return nothing\n \
    \   elseif length(arr) == 1 \n        return arr[1]\n    elseif length(arr) ==\
    \ 2 \n        return arr[1]*arr[2]\n    elseif length(arr) > 2 \n        sum =\
    \ 0\n        for i = 1:length(arr) \n            sum = sum + arr[i]*sign(arr[i])\n\
    \        end\n        return sum\n    end\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays\
    \ |>\n<code>", "    if length(arr) == 0 \n        return nothing\n    elseif length(arr)\
    \ == 1 \n        return arr[1]\n    elseif arr[1] < 0 \n        return -arr[1]\n\
    \    elseif arr[1] > 0 \n        return arr[1]\n    elseif arr[2] < 0 \n     \
    \   return -arr[2]\n    elseif arr[2] > 0 \n        return arr[2]\n    elseif\
    \ arr[3] < 0 \n        return -arr[3]\n    elseif arr[3] > 0 \n        return\
    \ arr[3]\n    elseif arr[4] < 0 \n        return -arr[4]\n    elseif arr[4] >\
    \ 0 \n        return arr[4]\n    elseif arr[5] < 0 \n        return -arr[5]\n\
    \    elseif arr[5] > 0 \n        return arr[5]\n    elseif arr[6] < 0 \n     \
    \   return -arr[6]\n    elseif arr[6] > 0 \n        return arr[6]\n    elseif\
    \ arr[7] < 0 \n        return -arr[7]\n    elseif arr[7] > 0 \n        return\
    \ arr[7]\n    elseif arr[8] < 0 \n        return -arr[8]\n    elseif arr[8] >\
    \ 0 \n        return arr[8]\n    elseif arr[9] < 0 \n        return -arr[9]\n\
    \    elseif arr[9] > 0 \n        return arr[9]\n    elseif arr[10] < 0 \n    \
    \    return -arr[10]\n    elseif arr[10] > 0 \n        return arr[10]\n    elseif\
    \ arr[11] < 0 \n        return -arr[11]\n    elseif arr[11] > 0 \n        return\
    \ arr[11]\n    elseif arr[12] < 0 \n        return -arr[12]\n    elseif arr[12]\
    \ > 0 \n        return arr[12]\n    elseif arr[13] < 0 \n        return -arr[13]\n\
    \    elseif arr[13] > 0 \n        return arr[13]\n    elseif arr[14] < 0 \n  \
    \      return -arr[14]\n    elseif arr[14] > 0 \n        return arr[14]\n    elseif\
    \ arr[15] < 0 \n        return -arr[15]\n    elseif arr[15] > 0 \n        return\
    \ arr[15]\n    elseif arr[16] < 0 \n        return -arr[16]\n    elseif arr[16]\
    \ > 0 \n        return arr[16]\n    elseif arr[17] < 0 \n        return -arr[17]\n\
    \    elseif arr[17] > 0 \n        return arr[17]\n    elseif arr[18] < 0 \n  \
    \      return -arr[18]\n    elseif arr[18] > 0 \n        return arr[18]\n    elseif\
    \ arr[19] < 0 \n        return -arr[19]\n    elseif arr[19] > 0 \n        return\
    \ arr[19]\n    elseif arr[20] < 0 \n        return -arr[20]\n    elseif arr[20]\
    \ > 0 \n        return arr[20]\n    elseif arr[21] < 0 \n", "    if length(arr)\
    \ == 0 \n        return nothing\n    \n    sum = 0\n    for x in arr\n       \
    \ sum += sign(x)*abs(x)\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes an array arr of integers and returns its product of absolute values.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        sum_of_mags\
    \ = sum(abs.(arr .* signs))\n        return sum_of_mags\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "    if length(arr) == 0 \n\
    \        return nothing \n    else \n        signs = map(sign, arr) \n       \
    \ signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs)\
    \ \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs) \n\
    \        return signs * prod(map(abs, arr)) \n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        product = prod(signs)\n  \
    \      return product * sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is even, False otherwise. \nWrite a function that returns\
    \ True if a number is odd, False otherwise. \nWrite a function that returns True\
    \ if a number is positive, False otherwise. \nWrite a function that returns True\
    \ if a number is negative, False otherwise. \nWrite a function that returns True\
    \ if a number is zero, False otherwise. \nWrite a function that returns True if\
    \ a number is strictly positive, False otherwise. \nWrite a function that returns\
    \ True if a number is strictly negative, False otherwise. \nWrite a function that\
    \ returns True if a number is strictly zero, False otherwise. \nWrite a function\
    \ that returns True if a number is strictly positive, strictly negative or zero,\
    \ False otherwise. \nWrite a function that returns True if a number is strictly\
    \ negative, strictly positive or zero, False otherwise. \nWrite a function that\
    \ returns True if a number is strictly zero, strictly positive or negative, False\
    \ otherwise. \nWrite a function that returns True if a number is strictly positive,\
    \ strictly negative or zero, strictly positive or negative or zero, False otherwise.\
    \ \nWrite a function that returns True if a number is strictly negative, strictly\
    \ positive or zero, strictly positive or negative or zero, False otherwise. \n\
    Write a function that returns True if a number is strictly zero, strictly positive\
    \ or negative, strictly positive or negative or zero, strictly positive or negative\
    \ or zero, False otherwise. \nWrite a function that returns True if a number is\
    \ strictly positive, strictly negative or zero, strictly positive or negative\
    \ or zero, strictly positive or negative or zero, strictly positive or negative\
    \ or zero, False otherwise. \nWrite a function that returns True if a number is\
    \ strictly negative, strictly positive or zero, strictly positive or negative\
    \ or zero, strictly positive or negative or zero, strictly positive or negative\
    \ or zero, strictly positive or negative or zero, False otherwise. \nWrite a function\
    \ that returns True if a number is strictly zero, strictly positive or negative,\
    \ strictly positive or negative or zero, strictly positive or negative or zero,\
    \ strictly positive or negative or zero, strictly positive or negative or zero,\
    \ strictly positive or negative or zero, False otherwise", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = prod(signs) \n        mags = map(abs, arr)\
    \ \n        mags = filter(x -> x != 0, mags) \n        mags = filter(x -> x ==\
    \ 0, mags) \n        mags = filter(x -> x == 1, mags) \n        mags = filter(x\
    \ -> x == -1, mags) \n        mags = prod(mags) \n        return signs * mags\
    \ \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work.\
    \ `prod_signs([1, 2, 2, -4])` returns `9` instead of `0`.\n<|/ c |>\n<| c |>\n\
    I tested it on Julia 0.6.2 and it works. I guess it depends on your Julia version.\
    \ Which version are you using?\n<|/ c |>\n<| c |>\nI'm using 0.6.2. I'll try it\
    \ on 0.6.3\n<|/ c |>\n<| c |>\nI tested it on 0.6.3 and it works. I guess it depends\
    \ on your Julia version. Which version are you using?\n<|/ c |>\n<| c |>\nI'm\
    \ using 0.6.3\n<|/ c |>\n<| a tags=julia,arrays,function |>\nI believe this can\
    \ be done more efficiently using broadcasting and the built-in function prod.\n\
    <code>", "    if length(arr) == 0 \n        return nothing\n    else \n      \
    \  signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes =\
    \ map(abs, arr)\n        return sum(magnitudes * product)\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "    if length(arr)==0\n   \
    \     return nothing\n    end\n    signs=zeros(Int64, length(arr))\n    signs[1]=1\n\
    \    signs[end-1]=1\n    signs[2:end-1]=signs[1:end-1]\n    signs=signs*arr\n\
    \    return sum(abs2.(signs))\nend\n</cell>\n<code language=julia-1.3>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is odd, False otherwise. \nThe function should work for negative\
    \ and positive numbers.", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        product = prod(signs)\n  \
    \      return product * sum(signs)\n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=julia |>\n<code>", "    if length(arr) == 0 \n        return nothing\n\
    \    elseif length(arr) == 1 \n        return arr[1]\n    else\n        signs\
    \ = zeros(Int, length(arr))\n        for i = 1:length(arr)\n            signs[i]\
    \ = sign(arr[i])\n        end\n        \n        sum_of_mags = sum(map(abs, arr))\n\
    \        \n        product = prod(signs)\n        return sum_of_mags * product\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes an array of integers\
    \ and returns the sum of all integers multiplied by product of all signs of each\
    \ number in the array, represented by 1, -1 or 0.", "    if length(arr) == 0 \n\
    \        return nothing\n    elseif length(arr) == 1 \n        return arr[1]\n\
    \    elseif length(arr) == 2 \n        return arr[1]*arr[2]\n    elseif length(arr)\
    \ == 3 \n        return arr[1]*arr[2]*arr[3]\n    elseif length(arr) == 4 \n \
    \       return arr[1]*arr[2]*arr[3]*arr[4]\n    elseif length(arr) == 5 \n   \
    \     return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]\n    elseif length(arr) == 6 \n\
    \        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]\n    elseif length(arr)\
    \ == 7 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]\n   \
    \ elseif length(arr) == 8 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]\n\
    \    elseif length(arr) == 9 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]\n\
    \    elseif length(arr) == 10 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]\n\
    \    elseif length(arr) == 11 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]\n\
    \    elseif length(arr) == 12 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]\n\
    \    elseif length(arr) == 13 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]*arr[13]\n\
    \    elseif length(arr) == 14 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]*arr[13]*arr[14]\n\
    \    elseif length(arr) == 15 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]*arr[13]*arr[14]*arr[15]\n\
    \    elseif ", "    if length(arr) == 0 \n        return nothing\n    \n    signs\
    \ = zeros(Int, length(arr))\n    for (i,x) in enumerate(arr)\n        signs[i]\
    \ = sign(x) * sign(i)\n    end\n    \n    sum_of_mags = sum(abs.(signs))\n   \
    \ \n    product = prod(signs)\n    \n    return sum_of_mags * product\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of positive numbers in an array.", "    if\
    \ length(arr) == 0 \n        return nothing\n    else \n        sum_of_mags =\
    \ sum(map(abs, arr))\n        prod_of_signs = prod(map(sign, arr))\n        return\
    \ sum_of_mags * prod_of_signs\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns True if two arrays have the same elements, False otherwise.", "    if\
    \ length(arr) == 0 \n        return nothing \n    \n    signs = zeros(Int, length(arr))\n\
    \    for x in arr \n        signs[x] = signs[x] + 1 \n    end\n    \n    prod\
    \ = 1\n    for x in arr \n        prod = prod * x \n    end\n    \n    return\
    \ prod * sum(signs)\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array arr\
    \ of integers and returns its product of absolute values.", "    if length(arr)\
    \ == 0 \n        return nothing\n    \n    sum = 0\n    for i in arr\n       \
    \ sum += sign(i) * i\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\n4.3 Sum of magnitudes", "    if\
    \ length(arr) == 0 \n        return nothing\n    \n    signs = zeros(Int, length(arr))\n\
    \    signs[1] = 1\n    signs[end] = -1\n    \n    product = 1\n    for i in 1:length(arr)\n\
    \        product *= signs[i]\n    end\n    \n    return product * sum(abs.(arr))\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns True if a number is odd and\
    \ False otherwise.", "    if length(arr)==0 \n        return nothing\n    else\
    \ \n        signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes\
    \ = map(abs, arr)\n        return sum(magnitudes) * product\n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "    if length(arr)==0 \n  \
    \      return nothing\n    else \n        signs = map(sign, arr)\n        signs\
    \ = filter(x -> x==1, signs)\n        signs = filter(x -> x==-1, signs)\n    \
    \    signs = filter(x -> x==0, signs)\n        signs = prod(signs)\n        mags\
    \ = map(abs, arr)\n        mags = map(abs, mags)\n        mags = filter(x -> x==0,\
    \ mags)\n        mags = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1,\
    \ mags)\n        mags = sum(mags)\n        return mags * signs\n    end\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=julia |>\n<code>", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr) \n            product *= signs[i] \n            signs[i]\
    \ = 0\n        end\n        return product * sum(abs2, arr)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that finds the number of positive integers less than or equal to\
    \ a given number n.", "    if length(arr) == 0 \n        return nothing\n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[arr .< 0] = -1\n\
    \        signs[arr .> 0] = 1\n        signs = signs * prod(signs)\n        return\
    \ signs\n    end\nend\n</cell>\n<code language=julia-1.3>", "    if length(arr)==0\
    \ return nothing\n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end]\
    \ = -1\n    return sum(abs2(arr .* signs))\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=julia,arrays |>\n<code>", "    if length(arr) == 0 \n        return\
    \ nothing\n    end\n    \n    signs = zeros(Int, length(arr))\n    signs[arr .<\
    \ 0] = -1\n    signs[arr .> 0] = 1\n    \n    prod = prod(signs)\n    \n    return\
    \ prod * sum(signs)\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns number of\
    \ positive numbers in an array.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = signs(arr) \n        product = prod(signs) \n \
    \       magnitudes = map(abs, arr) \n        sum_magnitudes = sum(magnitudes)\
    \ \n        return product * sum_magnitudes \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd and False otherwise.", "    if length(arr) ==\
    \ 0 return nothing\n    \n    sum = 0\n    sign = 1\n    for x in arr\n      \
    \  sum += sign * x\n        sign *= sign\n    end\n    return sum\nend", "   \
    \ if length(arr) == 0 \n        return nothing \n    else \n        signs = signs(arr)\
    \ \n        signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr))\n\
    \        return sum_of_mags * signs_product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns the number of positive numbers in a given array.", "    if length(arr)\
    \ == 0 \n        return nothing\n    \n    signs = zeros(Int, length(arr))\n \
    \   signs[1] = 1\n    signs[end] = -1\n    \n    product = 1\n    for x in arr\n\
    \        product *= signs[x]\n    end\n    \n    return product\nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        signs = filter(x -> x != 0,\
    \ signs)\n        signs = filter(x -> x == 0, signs)\n        signs = filter(x\
    \ -> x == 1, signs)\n        signs = filter(x -> x == -1, signs)\n        signs\
    \ = map(x -> x * prod(signs), arr)\n        return sum(signs)\n    end\nend\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work if the array contains\
    \ negative numbers. For example, `prod_signs([-1, -2, -3])` returns `-1` instead\
    \ of `0`.\n<|/ c |>\n<| c |>\nI added a solution that works with negative numbers.\
    \ I hope it helps.\n<|/ c |>\n<| a tags=julia |>\n<code>", "    if length(arr)\
    \ == 0 \n        return nothing \n    \n    sum = 0\n    for x in arr \n     \
    \   sum += sign(x)*abs(x)\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr)==0\n        return nothing\n    sum = 0\n    for x in arr\n\
    \        sum += sign(x)*abs(x)\n    end\n    return sum\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a |>\n<code>", "    if length(arr) == 0 \n        return nothing\n  \
    \  elseif length(arr) == 1 \n        return arr[1]\n    else\n        signs =\
    \ zeros(Int64, length(arr))\n        for i in 1:length(arr)\n            signs[i]\
    \ = sign(i) * sign(arr[i])\n        end\n        signs = signs.prod(dims=1)\n\
    \        return signs * prod(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time prod_signs(rand(1:10000, 10000));\n</cell>\n<text>\nExercise 3\nWrite a\
    \ function that returns True if a number is odd and False otherwise."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
