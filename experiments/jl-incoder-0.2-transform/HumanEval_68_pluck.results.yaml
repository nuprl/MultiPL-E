language: jl
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n        \
    \    if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = smallest_index + 1\n            end\n      \
    \  end\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <text>\nProblem 7\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp1q_95rn.jl:50\nin expression starting at\
    \ /tmp/tmpp1q_95rn.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value\n    else\n        smallest_value\n    end\nend\n\
    </cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (ie, from left to right, level by level).\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg2uxmnj_.jl:45\nin expression starting at\
    \ /tmp/tmpg2uxmnj_.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1\n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    if smallest_value % 2 == 0\n        return smallest_value, smallest_index\n\
    \    else\n        smallest_index -= 1\n        smallest_value = arr[smallest_index]\n\
    \        \n        if smallest_value % 2 == 0\n            return smallest_value,\
    \ smallest_index\n        else\n            smallest_index -= 1\n            smallest_value\
    \ = arr[smallest_index]\n            \n            if smallest_value % 2 == 0\n\
    \                return smallest_value, smallest_index\n            else\n   \
    \             smallest_index -= 1\n                smallest_value = arr[smallest_index]\n\
    \                \n                if smallest_value % 2 == 0\n              \
    \      return smallest_value, smallest_index\n                else\n         \
    \           smallest_index -= 1\n                    smallest_value = arr[smallest_index]\n\
    \                    \n                    if smallest_value % 2 == 0\n      \
    \                  return smallest_value, smallest_index\n                   \
    \ else\n                        smallest_index -= 1\n                        smallest_value\
    \ = arr[smallest_index]\n                        \n                        if\
    \ smallest_value % 2 == 0\n                            return smallest_value,\
    \ smallest_index\n                        else\n                            smallest_index\
    \ -= 1\n                            smallest_value = arr[smallest_index]\n   \
    \                         \n                            if smallest_value % 2\
    \ == 0\n                                return smallest_value, smallest_index\n\
    \                            else\n                                smallest_index\
    \ -= 1\n                                smallest_value = arr[smallest_index]\n\
    \                                \n                                if smallest_value\
    \ % 2 == 0\n                                    return smallest_value, smallest_index\n\
    \                                else\n                                    smallest_index\
    \ -= 1\n                                    smallest_value = arr[smallest_index]\n\
    \                                    \n                                    if\
    \ smallest_value % 2 == 0\n                                        return smallest_value,\
    \ smallest_index\n                                    else\n                 \
    \                       smallest_index -= 1\n                                \
    \        smallest_value = arr[smallest_index]\n                              \
    \          \n                                        if smallest_value % 2 ==\
    \ 0\n                                            return smallest_value, smallest_index\n\
    \                                        else\n                              \
    \              smallest_index -= 1\n                                         \
    \   smallest_value = arr[smallest_index]\n                                   \
    \         \n                                            if smallest_value % 2\
    \ == 0\n                                                return smallest_value,\
    \ smallest_index\n                                            else\n         \
    \                                       smallest_index -= 1\n                \
    \                                smallest_value = arr[smallest_index]\n      \
    \                                          \n                                \
    \                if smallest_value % 2 == 0\n                                \
    \                    return smallest_value, smallest_index\n                 \
    \                               else\n                                       \
    \             smallest_index -= 1\n                                          \
    \          smallest_value = arr[smallest_index]\n                            \
    \                        \n                                                  \
    \  if smallest_value % 2 == 0\n                                              \
    \          return \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr2c0awba.jl:1\nin expression starting at /tmp/tmpr2c0awba.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    if\
    \ smallest_index == nothing\n        return Vector{Int64}()\n    else\n      \
    \  return Vector{Int64}([smallest_value, smallest_index])\n    end\nend\n</cell>\n\
    <text>\nProblem 7\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6dwgdg2t.jl:44\nin expression starting at\
    \ /tmp/tmp6dwgdg2t.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smalest_value = 0\n    smallest_index = 0\n    \n    for node in\
    \ arr\n        if node.value % 2 == 0\n            if node.value < smalest_value\n\
    \                smalest_value = node.value\n                smallest_index =\
    \ node\n            end\n        end\n    end\n    \n    if smalest_value == 0\n\
    \        return []\n    end\n    \n    return [smalest_value, smallest_index]\n\
    end\n</cell>\n<text>\nProblem 3\nGiven an array representing a binary tree, return\
    \ the levels of the tree in order from top to bottom.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7zy36j_9.jl:54\nin expression starting at\
    \ /tmp/tmp7zy36j_9.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <text>\nProblem 4\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values. (ie, from left to right, level by level).\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdi4963mr.jl:45\nin expression starting at\
    \ /tmp/tmpdi4963mr.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpyxgz3mk3.jl:42

    '
  stdout: "test set: Error During Test at /tmp/tmpyxgz3mk3.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpyxgz3mk3.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyxgz3mk3.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyxgz3mk3.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpyxgz3mk3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpyxgz3mk3.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyxgz3mk3.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyxgz3mk3.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpyxgz3mk3.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    \n    \n    return Vector{Int64}([smallest_value, smallest_index])\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpduziau25.jl:50

    '
  stdout: "test set: Test Failed at /tmp/tmpduziau25.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpduziau25.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpduziau25.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpduziau25.jl:57\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpduziau25.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpduziau25.jl:52\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \    \n    if smallest_even_index == 0 \n        smallest_even_index == length(arr)\n\
    \    end\n    \n    smallest_value = arr[smallest_even_index]\n    \n    return\
    \ [smallest_value, smallest_even_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([4, 2, 3]) == [2, 1]\n@assert pluck([1, 2, 3]) == [2, 1]\n@assert\
    \ pluck([]) == []\n@assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n</cell>\n<text>\n\
    Practice 3\nPractice 3 is more challenging than practice 2, but still interesting.\n\
    The goal is to find the smallest even value in a given array.\nThe array is represented\
    \ as a vector with non-negative integer values.\nThe function should return a\
    \ list of two elements: the smallest even value and the index of the smallest\
    \ even value.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjr30y69j.jl:47\nin expression starting at\
    \ /tmp/tmpjr30y69j.jl:47\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    \n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = findfirst(x -> x == smallest_even_value, even_values)\n\
    \    \n    if smallest_even_index == -1\n        return Vector{Int64}()\n    \n\
    \    smallest_value = arr[smallest_even_index]\n    \n    smallest_value_and_index\
    \ = Vector{Int64}([smallest_value, smallest_even_index])\n    \n    return smallest_value_and_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ugak2fd.jl:1\nin expression starting at /tmp/tmp8ugak2fd.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [] \n    end\n    smallest_value = minimum(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    return smallest_value, smallest_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp0q8h8flt.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmp0q8h8flt.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Tuple{Int64, Int64} to an object of type Vector{Int64}\n \
    \ Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0q8h8flt.jl:41\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0q8h8flt.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0q8h8flt.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp0q8h8flt.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Tuple{Int64, Int64} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0q8h8flt.jl:41\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0q8h8flt.j"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smalest_value::Int64 = arr[1]\n    smalest_index::Int64 = 1\n  \
    \  \n    for node in arr[2 : end]\n        if node % 2 == 0\n            if node\
    \ < smalest_value\n                smalest_value = node\n                smalest_index\
    \ = smalest_index + 1\n            else\n                if smalest_index > 1\n\
    \                    return [smalest_value, smalest_index]\n                end\n\
    \            end\n        end\n    end\n    \n    return []\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmplp8j21dc.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmplp8j21dc.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplp8j21dc.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplp8j21dc.jl:58\ntest set: Test\
    \ Failed at /tmp/tmplp8j21dc.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplp8j21dc.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplp8j21dc.jl:58\ntest set: Error\
    \ During Test at /tmp/tmplp8j21dc.jl:61\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmplp8j21dc.jl:36\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplp8j21dc.jl:61 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplp8j21dc.jl:58\ntest set:\
    \ Test Failed at /tmp/tmplp8j21dc.jl:62\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplp8j21dc.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-leve"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return []\n    else\n        smallest_value\
    \ = min(even_values)\n        smallest_index = find(even_values == smallest_value)[1]\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Practice 3\nWrite a function that returns the number of nodes in a binary search\
    \ tree\nGiven a binary search tree with non-negative integer nodes,\nyour task\
    \ is to return the number of nodes in the tree.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk4gb4rft.jl:44\nin expression starting at\
    \ /tmp/tmpk4gb4rft.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = find(even_values==smallest_even_value,1)[1]\n      \
    \  return [smallest_even_value,smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of nodes in a binary search\
    \ tree with root node root.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpinj5u_87.jl:44\nin expression starting at\
    \ /tmp/tmpinj5u_87.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\nProblem 3\n\
    Given an array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck one of the nodes and return it.\nThe plucked node should\
    \ be the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph8kn4w5z.jl:51\nin expression starting at\
    \ /tmp/tmph8kn4w5z.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree and a number x, find the node in the tree that\
    \ has value x.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr5an5e6b.jl:44\nin expression starting at\
    \ /tmp/tmpr5an5e6b.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n        \
    \    if smallest_value < node.value\n                smallest_value = node.value\n\
    \                smallest_index = node.index\n            end\n        end\n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of nodes in a binary search\
    \ tree with root node root.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdvpmt6ne.jl:50\nin expression starting at\
    \ /tmp/tmpdvpmt6ne.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 7\nGiven a binary tree,\
    \ return the level order traversal of its nodes' values. (ie, from left to right,\
    \ level by level).\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqcuuc9i1.jl:44\nin expression starting at\
    \ /tmp/tmpqcuuc9i1.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa8spgm7u.jl:44\nin expression starting at\
    \ /tmp/tmpa8spgm7u.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 8\nGiven a binary tree\
    \ and a number x, return the number of nodes in the subtree rooted at that node.\
    \ If there is no such subtree, then return 0.\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnhagu0qy.jl:44\nin expression starting at\
    \ /tmp/tmpnhagu0qy.jl:44\n"
  stdout: ''
