name: HumanEval_34_unique
language: jl
prompt: "\"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2,\
  \ 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\nfunction unique(l::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = unique;\n\t@test(candidate([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])\nend\n"
completions: ["    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nThis does not answer the question. `unique`\
    \ does not remove duplicates.\n<|/ c |>\n<| c |>\nThe question was how to remove\
    \ duplicates. I answered how to remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `unique` does not remove duplicates.\
    \ I said that `unique` does not remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `unique` does not remove duplicates.\
    \ I said that `unique` does not remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `unique` does not remove duplicates.\
    \ I said that `unique` does not remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `unique` does not remove duplicates.\
    \ I said that `unique` does not remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `unique` does not remove duplicates.\
    \ I said that `unique` does not remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `unique` does not remove duplicates.\
    \ I said that `unique` does not remove duplicates. I did not say that `unique`\
    \ does not remove duplicates. I said that `unique` does not remove duplicates.\
    \ I did not say that `unique` does not remove duplicates. I said that `unique`\
    \ does not remove duplicates. I did not say that `", "    seen = Set()\n    unique\
    \ = Set()\n    for i in l\n        if i not in seen\n            unique.add(i)\n\
    \            seen.add(i)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    seen = Set()\n    unique = Set()\n    for x in\
    \ l\n        if !seen.add(x)\n            unique.add(x)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,set,hashmap\
    \ |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])` returns\
    \ `[5,3,9,123]` instead of `[5,2,3,9,123]`.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for me. `unique([5,3,5,2,3,3,9,0,123])` returns `[5,3,9,123]` instead of `[5,2,3,9,123]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])` returns\
    \ `[5,3,9,123]` instead of `[5,2,3,9,123]`.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for me. `unique([5,3,5,2,3,3,9,0,123])` returns `[5,3,9,123]` instead of `[5,2,3,9,123]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])` returns\
    \ `[5,3,9,123]` instead of `[5,2,3,9,123]`.\n<|/ c |>\n<| a dscore=3 |>\nI believe\
    \ that this is the most efficient solution:\n<code>\njulia> function unique(l)\n\
    \           return sort(collect(Iterators.flatten(l)))\n       end\nunique (generic\
    \ function with 1 method)", "    seen = Set()\n    unique = Set()\n    for x in\
    \ l\n        if x not in seen \n            unique.add(x)\n            seen.add(x)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/25814005)\n<|/ c |>\n<| c |>\n\
    I believe this does answer the question. He asked how to remove duplicates from\
    \ a vector, which is what this does. I believe this to be a better solution than\
    \ using sets, because sets are unordered. Also, sets are faster than vectors.\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/25814005)\n<|/ c |>\n<| c |>\nI believe\
    \ this does answer the question. He asked how to remove duplicates from a vector,\
    \ which is what this does. I believe this to be a better solution than using sets,\
    \ because sets are unordered. Also, sets are faster than vectors.\n<|/ c |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/25814005)\n\
    <|/ c |>\n<| a tags=julia,duplicates,vector |>\n<code>\njulia> function unique(l::Vector{Int64})::Vector{Int64}\n\
    \           unique = Set()\n           for i in l\n               if !haskey(unique,\
    \ i)\n                   push!(unique, i)\n               end\n           end\n\
    \           return unique\n       end\nunique (generic function with 1 method)",
  "    seen = Set()\n    uniques = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(uniques, i)\n            seen[i] = true\n        end\n\
    \    end\n    return uniques\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n\
    This does not answer the question. The question was how to remove duplicates from\
    \ an array. Your answer does not do that.\n<|/ c |>\n<| c |>\nI believe this does\
    \ answer the question. `unique` removes duplicates from an array. `unique!` removes\
    \ duplicates from an array. `unique!` modifies the array in place. `unique` returns\
    \ a new array with the unique elements. `unique!` modifies the array in place.\
    \ `unique` returns a new array with the unique elements. `unique!` modifies the\
    \ array in place. `unique` returns a new array with the unique elements. `unique!`\
    \ modifies the array in place. `unique` returns a new array with the unique elements.\
    \ `unique!` modifies the array in place. `unique` returns a new array with the\
    \ unique elements. `unique!` modifies the array in place. `unique` returns a new\
    \ array with the unique elements. `unique!` modifies the array in place. `unique`\
    \ returns a new array with the unique elements. `unique!` modifies the array in\
    \ place. `unique` returns a new array with the unique elements. `unique!` modifies\
    \ the array in place. `unique` returns a new array with the unique elements. `unique!`\
    \ modifies the array in place. `unique` returns a new array with the unique elements.\
    \ `unique!` modifies the array in place.\n<|/ c |>\n<| c |>\n`unique!` modifies\
    \ the array in place. `unique` returns a new array with the unique elements. `unique!`\
    \ modifies the array in place. `unique` returns a new array with the unique elements.\
    \ `unique!` modifies the array in place. `unique` returns a new array with the\
    \ unique elements. `unique!` modifies the array in place. `unique` returns a new\
    \ array with the unique elements. `unique!` modifies the array in place. `unique`\
    \ returns a new array with the unique elements. `unique!` modifies the array in\
    \ place. `unique` returns a new array with the unique elements. `unique!` modifies\
    \ the array in place. `unique` returns a new array with the unique elements. `unique!`\
    \ modifies the array in place. `unique` returns a new array with the unique elements.\
    \ `unique!` modifies the array ", "    unique = Set()\n    for i in l\n      \
    \  if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia,set |>\n<| c |>\n`unique` returns\
    \ a `Set`, not a `Vector`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've\
    \ updated the answer accordingly.\n<|/ c |>\n<| a tags=julia,set |>\n<code>\n\
    julia> using Statistics", "    unique = Set()\n    for i in l\n        unique\
    \ += [i]\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nI like using Sets to do this:\n<code>\njulia> using Sets", "    unique =\
    \ Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays\
    \ |>\nA simple and fast solution is to use Sets:\n<code>\njulia> using Sets",
  "    seen = Set()\n    unique = Set()\n    for i in l\n        if i not in seen\n\
    \            unique.add(i)\n            seen.add(i)\n        end\n    end\n  \
    \  return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique\nend\nunique = @doc $(unique(l))\n\"\"\
    \"\n$(unique(l))", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    seen = Set()\n    unique = Set()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            unique += [i]\n            seen[i] = true\n        end\n   \
    \ end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for x in l\n        unique.add(x)\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            unique[x] = true\n        end\n  \
    \  end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.4>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])` returns\
    \ `[5, 3, 9, 123]`\n<|/ c |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])`\
    \ returns `[5, 3, 9, 123]`\n<|/ c |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])`\
    \ returns `[5, 3, 9, 123]`\n<|/ c |>\n<| c |>\nThis doesn't work for me. `unique([5,3,5,2,3,3,9,0,123])`\
    \ returns `[5, 3, 9, 123]`\n<|/ c |>\n<| a tags=julia |>\nThe answer by is correct,\
    \ but I wanted to add that you can also use an anonymous function as the key argument\
    \ to unique:\n<code>\njulia> unique([5,3,5,2,3,3,9,0,123], x -> x)\n5-element\
    \ Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a dscore=5 |>\n<| a\
    \ tags=julia |>\nThe answer by is correct, but I wanted to add that you can also\
    \ use an anonymous function as the key argument to unique:\n<code>\njulia> unique([5,3,5,2,3,3,9,0,123],\
    \ x -> x)\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a\
    \ dscore=5 |>\n<| a tags=julia |>\nThe accepted answer does not work for me in\
    \ Julia 1.5.1. \n<code>\njulia> unique([5,3,5,2,3,3,9,0,123])\n5-element Array{Int64,1}:\n\
    \ 0\n 2\n 3\n 5\n 9\n 123\n</code>\nI used the following to get unique elements:\n\
    <code>\njulia> unique([5,3,5,2,3,3,9,0,123], x -> x)\n5-element Array{Int64,1}:\n\
    \ 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work\
    \ for me. `unique([5,3,5,", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\nI came up with a solution\
    \ that is quite similar to what proposed, but uses only built-in functions. \n\
    <code>", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThanks for your answer! I edited\
    \ my question to make it more clear what I'm looking for. I'm looking for a function\
    \ that returns an array with unique elements. I edited my question to make it\
    \ more clear what I'm looking for. I'm looking for a function that returns an\
    \ array with unique elements. I edited my question to make it more clear what\
    \ I'm looking for. I'm looking for a function that returns an array with unique\
    \ elements. I edited my question to make it more clear what I'm looking for. I'm\
    \ looking for a function that returns an array with unique elements. I edited\
    \ my question to make it more clear what I'm looking for. I'm looking for a function\
    \ that returns an array with unique elements. I edited my question to make it\
    \ more clear what I'm looking for. I'm looking for a function that returns an\
    \ array with unique elements. I edited my question to make it more clear what\
    \ I'm looking for. I'm looking for a function that returns an array with unique\
    \ elements. I edited my question to make it more clear what I'm looking for. I'm\
    \ looking for a function that returns an array with unique elements. I edited\
    \ my question to make it more clear what I'm looking for. I'm looking for a function\
    \ that returns an array with unique elements. I edited my question to make it\
    \ more clear what I'm looking for. I'm looking for a function that returns an\
    \ array with unique elements. I edited my question to make it more clear what\
    \ I'm looking for. I'm looking for a function that returns an array with unique\
    \ elements. I edited my question to make it more clear what I'm looking for. I'm\
    \ looking for a function that returns an array with unique elements. I edited\
    \ my question to make it more clear what I'm looking for. I'm looking for a function\
    \ that returns an array with unique elements. I edited my question to make it\
    \ more clear what I'm looking for. I'm looking for a function that returns an\
    \ array with unique elements. I edited my question to make it more clear what\
    \ I'm looking for. I'm looking for a function that returns an array with unique\
    \ elements. I edited my question to make it more clear what I'm looking for. I'm\
    \ looking for a function that returns an array with unique elements. I edited\
    \ my question to make it more clear what I'm looking for. I'm looking for a function\
    \ that returns an array with unique elements. I edited my question to make it\
    \ more clear what I'm looking for. I'm looking for a function that returns an\
    \ array with unique elements. I edited my question to make it more clear what\
    \ I'm looking for. I'm looking for a function that returns an array with unique\
    \ elements. I edi", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\nA more efficient solution\
    \ than using Sets is to preallocate the array and use isin to find which elements\
    \ are already in the array:\n<code>", "    unique = Set()\n    unique.insert(l[1])\n\
    \    for x in l[2:end]\n        if x not in unique\n            unique.insert(x)\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting |>\nI came up with a solution using Julia's built-in sort\
    \ function and an anonymous function for the key function:\n<code>\njulia> function\
    \ mysort(x::Vector{Int64}, y::Vector{Int64})\n           return sort(x,y)\n  \
    \     end", "    seen = Set()\n    unique = Vector{Int64}()\n    for x in l\n\
    \        if !haskey(seen, x)\n            push!(unique, x)\n            seen[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    seen = Set()\n    unique = Set()\n    for i in l\n        if i not in seen\
    \ \n            push!(unique, i)\n            push!(seen, i)\n        end\n  \
    \  end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,unique,sorting\
    \ |>\nI believe that Julia's unique function will do what you want.\n<code>\n\
    julia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n\
    \ 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYes, but it will not\
    \ preserve the order. `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` will give `[5, 2,\
    \ 3, 3, 9, 0, 123]`\n<|/ c |>\n<| c |>\nYes, but it will not preserve the order.\
    \ `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` will give `[5, 2, 3, 3, 9, 0, 123]`\n\
    <|/ c |>\n<| c |>\nYes, but it will not preserve the order. `unique([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])` will give `[5, 2, 3, 3, 9, 0, 123]`\n<|/ c |>\n<| c |>\n\
    Yes, but it will not preserve the order. `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])`\
    \ will give `[5, 2, 3, 3, 9, 0, 123]`\n<|/ c |>\n<| c |>\nYes, but it will not\
    \ preserve the order. `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` will give `[5, 2,\
    \ 3, 3, 9, 0, 123]`\n<|/ c |>\n<| a dscore=1 |>\nI believe that Julia's unique\
    \ function will do what you want.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/\
    \ a tags=julia,unique,sorting |>\n<| c |>\nYes, but it will not preserve the order.\
    \ `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` will give `[5, 2, 3, 3, 9, 0, 123]`\n\
    <|/ c |>\n<| c |>\nYes, but it will not preserve the order. `unique([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])` will give `[5, 2, 3, 3, 9, 0, 123]`\n<|/ c |>", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            push!(unique,\
    \ x)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the input vector.\
    \ For example, `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 123]`.\n\
    <|/ c |>\n<| c |>\nYes, you are right. I've added a version that works with repeated\
    \ elements.\n<|/ c |>\n<| a tags=julia,unique |>\nHere is a solution that is similar\
    \ to what has been suggested in the comments, but is more efficient and does not\
    \ require any packages:\n<code>", "    seen = Set()\n    unique = Set()\n    for\
    \ x in l\n        if x not in seen \n            push!(unique, x)\n          \
    \  push!(seen, x)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns the number of unique elements in a list.", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.4>",
  "    seen = Set{Int64}()\n    unique = Set{Int64}()\n    for x in l\n        if\
    \ !seen.add(x)\n            unique.add(x)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            unique[x] = true\n        end\n  \
    \  end\n    return unique\nend\nunique", "    unique = Set()\n    unique.insert(l[1])\n\
    \    unique.insert(l[2])\n    unique.insert(l[3])\n    unique.insert(l[4])\n \
    \   unique.insert(l[5])\n    unique.insert(l[6])\n    unique.insert(l[7])\n  \
    \  unique.insert(l[8])\n    unique.insert(l[9])\n    unique.insert(l[10])\n  \
    \  unique.insert(l[11])\n    unique.insert(l[12])\n    unique.insert(l[13])\n\
    \    unique.insert(l[14])\n    unique.insert(l[15])\n    unique.insert(l[16])\n\
    \    unique.insert(l[17])\n    unique.insert(l[18])\n    unique.insert(l[19])\n\
    \    unique.insert(l[20])\n    unique.insert(l[21])\n    unique.insert(l[22])\n\
    \    unique.insert(l[23])\n    unique.insert(l[24])\n    unique.insert(l[25])\n\
    \    unique.insert(l[26])\n    unique.insert(l[27])\n    unique.insert(l[28])\n\
    \    unique.insert(l[29])\n    unique.insert(l[30])\n    unique.insert(l[31])\n\
    \    unique.insert(l[32])\n    unique.insert(l[33])\n    unique.insert(l[34])\n\
    \    unique.insert(l[35])\n    unique.insert(l[36])\n    unique.insert(l[37])\n\
    \    unique.insert(l[38])\n    unique.insert(l[39])\n    unique.insert(l[40])\n\
    \    unique.insert(l[41])\n    unique.insert(l[42])\n    unique.insert(l[43])\n\
    \    unique.insert(l[44])\n    unique.insert(l[45])\n    unique.insert(l[46])\n\
    \    unique.insert(l[47])\n    unique.insert(l[48])\n    unique.insert(l[49])\n\
    \    unique.insert(l[50])\n    unique.insert(l[51])\n    unique.insert(l[52])\n\
    \    unique.insert(l[53])\n    unique.insert(l[54])\n    unique.insert(l[55])\n\
    \    unique.insert(l[56])\n    unique.insert(l[57])\n    unique.insert(l[58])\n\
    \    unique.insert(l[", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,arrays,unique,sorting |>\n<| a tags=julia,arrays,unique,sorting\
    \ |>\nI wrote a package called UniqueArrays.jl that does this efficiently and\
    \ without loops.\n<code>\nusing UniqueArrays", "    unique = Set()\n    for x\
    \ in l\n        if !haskey(unique, x)\n            unique[x] = 1\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        unique.add(i)\n    end\n    unique\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia,arrays |>\nI came up with this solution:\n\
    <code>", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n<code>\njulia>\
    \ using Statistics", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            unique[x] = true\n        end\n  \
    \  end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=julia,arrays |>\nI came up with this solution:\n<code>", "    unique\
    \ = Set()\n    for x in l\n        unique.add(x)\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` is already implemented in Julia and it does exactly what OP wants.\n\
    <|/ c |>\n<| a tags=julia,unique,arrays |>\n<code>\njulia> using Statistics",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ push!(unique, x)\n        end\n    end\n    return unique\nend\n</cell>\n<text>\n\
    Exercise: Write a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite a function that\
    \ returns the unique elements of a vector\nWrite a function that returns the unique\
    \ elements of a vector\nWrite a function that returns the unique elements of a\
    \ vector\nWrite a function that returns the unique elements of a vector\nWrite\
    \ a function that returns the unique elements of a vector\nWrite ", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            push!(unique,\
    \ x)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays\
    \ |>\nI like using Sets to do this:\n<code>\njulia> a = Set([5,3,5,2,3,3,9,0,123])\n\
    Set{Int64}([5, 3, 9, 0, 123])", "    unique = Set()\n    for i in l\n        if\
    \ !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n   \
    \ return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=2 |>\n\
    I wrote a package that does this for you:\nhttps://github.com/johnmyleswhite/UniqueArrays\n\
    <code>\nusing UniqueArrays", "    unique = sort(unique(l))\n    return unique\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work for me. `unique` returns\
    \ `Int64` not `Vector{Int64}`.\n<|/ c |>\n<| c |>\nI tested it on Julia 1.5.1\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 and it worked\
    \ fine. Maybe you have a different version?\n<|/ c |>\n<| c |>\nI tested it on\
    \ Julia 1.5.1 and it worked fine. Maybe you have a different version?\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.1 and it worked fine. Maybe you have a different\
    \ version?\n<|/ c |>\n<| a dscore=1 |>\nI came up with this:\n<code>", "    seen\
    \ = Set()\n    unique = Set()\n    for i in l\n        if !seen.add(i)\n     \
    \       unique.add(i)\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a |>\nI like to use Sets to do this:\n<code>\njulia> using\
    \ Sets", "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n\
    \            unique[x] = true\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you have duplicate elements\
    \ in the input list. For example, unique([1,1,2,3]) returns [1,2,3] instead of\
    \ [1,2,3]\n<|/ c |>\n<| a dscore=2 |>\nI came up with this solution:\n<code>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\nunique(x::Vector{Int64})\
    \ = unique(x)\nunique(x::Vector{Int64}, x::Vector{Int64}) = unique(x)\nunique(x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}) = unique(x)\nunique(x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}) = unique(x)\nunique(x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}) = unique(x)\nunique(x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64})\
    \ = unique(x)\nunique(x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}) = unique(x)\nunique(x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}) = unique(x)\nunique(x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64},\
    \ x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{Int64}, x::Vector{",
  "    seen = Set()\n    unique = Set()\n    for i in l\n        if !seen.add(i)\n\
    \            unique.add(i)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = Set()\n    unique = unique + l\n   \
    \ unique = unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nI like to use Julia's Sets to do this. They are very\
    \ efficient and easy to use. \n<code>\njulia> using Sets", "    unique = Set()\n\
    \    for i in l\n        unique.add(i)\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't answer the question. `unique` doesn't\
    \ sort the list.\n<|/ c |>\n<| c |>\nThe question was how to remove duplicates\
    \ from a list. `unique` does exactly that. `unique` returns a new list without\
    \ duplicates.\n<|/ c |>\n<| c |>\n`unique` doesn't sort the list. It returns a\
    \ new list without duplicates.\n<|/ c |>\n<| c |>\nYes, but `unique` doesn't sort\
    \ the list. It returns a new list without duplicates.\n<|/ c |>\n<| c |>\nThe\
    \ question was how to remove duplicates from a list. `unique` does exactly that.\
    \ `unique` returns a new list without duplicates.\n<|/ c |>\n<| a |>\n<code>",
  "    unique = Set()\n    for x in l\n        push!(unique, x)\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a tags=julia,arrays,unique,sorting |>\n<| a dscore=2\
    \ |>\nI like using Sets for this kind of thing. \n<code>\njulia> a = [5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123]\njulia> Set(a)\nSet{Int64}\n  5  3  2  9  0  123\n</code>\n\
    <|/ a tags=julia,arrays,unique,sorting |>\n<| a dscore=2 |>\nThe most efficient\
    \ way is to use Sets:\n<code>\njulia> a = [5, 3, 5, 2, 3, 3, 9, 0, 123]\njulia>\
    \ Set(a)\nSet{Int64}\n  5  3  2  9  0  123\n</code>\n<|/ a tags=julia,arrays,unique,sorting\
    \ |>\n<| a |>\nI wrote a function to do this. It uses linear search to find the\
    \ first element that isn't in the array and removes it from the array. \n<code>",
  "    unique = Set()\n    for i in l\n        unique.add(i)\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis should be the\
    \ accepted answer. `unique` has been around since v0.6.\n<|/ c |>\n<| a dscore=4\
    \ |>\nIn Julia v0.7 you can use the function unique:\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n\
    </code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\nIn Julia v0.7\
    \ you can use the function unique:\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=julia,arrays |>\nIn Julia v0.7 you can use the function unique:\n\
    <code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n\
    \ 0\n 2\n 3\n 5\n 9\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nIn Julia v0.7\
    \ you can use the function unique:\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a dscore=3 |>\nIn Julia v0.7 you can use the function unique:\n<code>\n\
    julia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n\
    \ 2\n 3\n 5\n 9\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=3 |>\nIn Julia\
    \ v0.7 you can use the function unique:\n<code>\njulia> unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| a dscore=3 |>\nIn Julia v0.7 you can use the function\
    \ unique:\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThanks for your answer! I actually tried this\
    \ before and got an error saying `MethodError: no method matching getindex(::Set{Int64},\
    \ ::Int64)`. I think it's because `unique` returns a `Set` and not a `Vector`.\
    \ So I changed it to `unique = Vector{Int64}()` and it worked. Thanks again!\n\
    <|/ c |>\n<| c |>\nYes, `Set` does not have a `getindex` method. `Vector` does.\
    \ `Set` has `getindex` method and `Vector` does not. `Vector` has `getindex` method\
    \ and `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `Set` does not. `Vector` has `getindex` method and `Set` does not. `Vector`\
    \ has `getindex` method and `Set` does not. `Vector` has `getindex` method and\
    \ `", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n   \
    \         push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| c |>\nThis is not the fastest solution, since it\
    \ requires iterating over the whole array twice. `unique` can be implemented much\
    \ more efficiently by using a `Set` data structure.\n<|/ c |>\n<| c |>\nI agree,\
    \ this is definitely not ideal. I'll leave it here for posterity, but I agree\
    \ with you that `Set` is the way to go. I'll update my answer accordingly.\n<|/\
    \ c |>\n<| c |>\nI agree that `Set` is the way to go, but I wanted to show that\
    \ `unique` can be implemented much more efficiently by using a `Set` data structure.\n\
    <|/ c |>\n<| c |>\nI agree that `Set` is the way to go, but I wanted to show that\
    \ `unique` can be implemented much more efficiently by using a `Set` data structure.\
    \ `Set` has `O(1)` lookup time, so the whole algorithm is `O(n)` instead of `O(n^2)`.\n\
    <|/ c |>\n<| c |>\nI agree that `Set` is the way to go, but I wanted to show that\
    \ `unique` can be implemented much more efficiently by using a `Set` data structure.\
    \ `Set` has `O(1)` lookup time, so the whole algorithm is `O(n)` instead of `O(n^2)`.\n\
    <|/ c |>\n<| a tags=julia,arrays |>\nThe most efficient way is to use Sets:\n\
    <code>\njulia> using Sets", "    seen = Set()\n    uniques = Vector{Int64}()\n\
    \    for x in l\n        if !haskey(seen, x)\n            push!(uniques, x)\n\
    \            seen[x] = true\n        end\n    end\n    return uniques\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a package called UniqueArrays that\
    \ has a function unique that does exactly what you want. \n<code>\njulia> using\
    \ UniqueArrays", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,unique,arrays |>\n<| a dscore=2 |>\nI like to use\
    \ Sets for this kind of thing:\n<code>\njulia> a = Set([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123]);", "    seen = Set()\n    uniques = Vector{Int64}()\n    for x in l\n\
    \        if !seen.add(x)\n            push!(uniques, x)\n        end\n    end\n\
    \    return uniques\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a vector and returns a vector where each element is the sum of the vector elements\
    \ up to that point. For example, if the input vector is [4, 2, 7, 1, 3] the output\
    \ vector should be [4, 7, 10, 13].", "    unique = Set()\n    for i in l\n   \
    \     unique.add(i)\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if you have duplicates in your vector. For example,\
    \ `unique([1, 1, 2, 3])` returns `[1, 1, 2, 3]`.\n<|/ c |>\n<| a tags=julia,unique,arrays\
    \ |>\nThe solution by is very elegant, but it is slower than the other solutions\
    \ posted so far.\n<code>\njulia> function unique(a::Vector{Int64})\n         \
    \  b = Set()\n           for i in a\n               push!(b,i)\n           end\n\
    \           return b\n       end\nunique (generic function with 1 method)", " \
    \   unique = Set()\n    for i in l\n        if !haskey(unique, i)\n          \
    \  push!(unique, i)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis is not the fastest solution,\
    \ since it creates a new set for every element in the array. `unique` should be\
    \ implemented as a hash table (like `Set`), which should be faster.\n<|/ c |>\n\
    <| c |>\nI agree, however I didn't want to rewrite the `unique` function from\
    \ scratch since I thought the OP was interested in learning how to write it himself.\
    \ I guess I'll leave it here for future reference.\n<|/ c |>\n<| c |>\nI agree\
    \ that `unique` should be implemented as a hash table, but I don't think it should\
    \ be a hash table at all. `unique` should just be implemented as a `Set`, which\
    \ should be faster than a hash table. `unique` should just be implemented as a\
    \ `Set`, which should be faster than a hash table. `unique` should just be implemented\
    \ as a `Set`, which should be faster than a hash table. `unique` should just be\
    \ implemented as a `Set`, which should be faster than a hash table. `unique` should\
    \ just be implemented as a `Set`, which should be faster than a hash table. `unique`\
    \ should just be implemented as a `Set`, which should be faster than a hash table.\
    \ `unique` should just be implemented as a `Set`, which should be faster than\
    \ a hash table. `unique` should just be implemented as a `Set`, which should be\
    \ faster than a hash table. `unique` should just be implemented as a `Set`, which\
    \ should be faster than a hash table. `unique` should just be implemented as a\
    \ `Set`, which should be faster than a hash table. `unique` should just be implemented\
    \ as a `Set`, which should be faster than a hash table. `unique` should just be\
    \ implemented as a `Set`, which should be faster than a hash table. `unique` should\
    \ just be implemented as a `Set`, which should be faster than a hash table. `unique`\
    \ should just be implemented as a `Set`, which should be faster than a hash table.\
    \ `unique` should just be implemented as a `Set`, which should be faster than\
    \ a hash table. `unique` should just be implemented as a `Set`, which should be\
    \ faster than a hash table. `unique` should just be implemented as a `Set`, which\
    \ should be faster than a hash table. `unique` should just be implemented as a\
    \ `Set`, which should be faster than a hash table", "    unique = sort(unique(l))\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n\
    \    unique = Set()\n    for i in l\n        if i not in seen \n            unique.add(i)\n\
    \            seen.add(i)\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work for me. `unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])` returns `[5, 3, 9, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used Julia 0.6.2\n<|/ c |>\n<|\
    \ c |>\nI tested it again and it works. I used Julia 0.6.2\n<|/ c |>\n<| c |>\n\
    I tested it again and it works. I used Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I used Julia 0.6.2\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is not the fastest solution. `unique` function uses `Set`\
    \ which is not the fastest data structure in Julia. `Set` has O(n) complexity\
    \ while `Vector` has O(n^2) complexity.\n<|/ c |>\n<| c |>\nI agree, `Set` has\
    \ O(n) complexity, but `Vector` has O(n^2) complexity. `Vector` is faster than\
    \ `Set` because `Vector` has more memory allocations than `Set`. `Vector` has\
    \ more allocations than `Set` because `Vector` has more memory allocations than\
    \ `Set`. `Vector` has more allocations than `Set` because `Vector` has more memory\
    \ allocations than `Set`. `Vector` has more allocations than `Set` because `Vector`\
    \ has more memory allocations than `Set`. `Vector` has more allocations than `Set`\
    \ because `Vector` has more memory allocations than `Set`. `Vector` has more allocations\
    \ than `Set` because `Vector` has more memory allocations than `Set`. `Vector`\
    \ has more allocations than `Set` because `Vector` has more memory allocations\
    \ than `Set`. `Vector` has more allocations than `Set` because `Vector` has more\
    \ memory allocations than `Set`. `Vector` has more allocations than `Set` because\
    \ `Vector` has more memory allocations than `Set`. `Vector` has more allocations\
    \ than `Set` because `Vector` has more memory allocations than `Set`. `Vector`\
    \ has more allocations than `Set` because `Vector` has more memory allocations\
    \ than `Set`. `Vector` has more allocations than `Set` because `Vector` has more\
    \ memory allocations than `Set`. `Vector` has more allocations than `Set` because\
    \ `Vector` has more memory allocations than `Set`. `Vector` has more allocations\
    \ than `Set` because `Vector` has more memory allocations than `Set`. `Vector`\
    \ has more allocations than `Set` because `Vector` has more memory allocations\
    \ than `Set`. `Vector` has more allocations than `Set` because `Vector` has more\
    \ memory allocations than `Set`. `Vector` has ", "    unique = Set()\n    for\
    \ i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n      \
    \  end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,set\
    \ |>\nIn Julia 1.3 you can use the function Set{T} to create a set and use the\
    \ function union! to add elements to the set. \n<code>\njulia> Set{Int}()\nSet{Int}()",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique.value\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n<code>", "    unique =\
    \ Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>", "    seen = Set()\n    unique = Set()\n    for\
    \ x in l\n        if !seen.add(x)\n            unique.add(x)\n        end\n  \
    \  end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen\
    \ = Set()\n    unique = Set()\n    for x in l\n        if !seen.add(x)\n     \
    \       unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    seen = Set()\n    unique = Set()\n    for x in\
    \ l\n        if !seen.add(x)\n            unique.add(x)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.4>", "    unique = Set()\n\
    \    for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThis doesn't work if there are duplicate elements in the input vector.\
    \ For example, `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 123]`.\n\
    <|/ c |>\n<| c |>\nI believe that should be `unique = Set()`, not `unique = Dict()`.\n\
    <|/ c |>\n<| a tags=julia,unique |>\n<code>", "    unique = Set()\n    for i in\
    \ l\n        if !haskey(unique, i)\n            push!(unique, i)\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n\
    This does not answer the question. OP asked for unique elements in a vector, not\
    \ unique elements in a set.\n<|/ c |>\n<| c |>\nThe question was about unique\
    \ elements in a vector. Your answer does not answer the question. OP asked for\
    \ unique elements in a vector, not unique elements in a set.\n<|/ c |>\n<| c |>\n\
    The question was about unique elements in a vector. Your answer does not answer\
    \ the question. OP asked for unique elements in a vector, not unique elements\
    \ in a set.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\njulia> function unique(x::Vector{Int64})\n\
    \           return Set(x...)\n       end\nunique (generic function with 1 method)",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThis code does not work. `unique` returns a\
    \ `Set` which is not an `Array`. `unique` should be `Vector{Int64}`.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out. I've fixed the code.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI believe that Julia has this functionality built-in:\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n\
    \ 123\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis code does not work.\
    \ `unique` returns a `Set` which is not an `Array`. `unique` should be `Vector{Int64}`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis code does not work. `unique` returns a `Set` which is not\
    \ an `Array`. `unique` should be `Vector{Int64}`.\n<|/ c |>\n<| c |>\nThis code\
    \ does not work. `unique` returns a `Set` which is not an `Array`. `unique` should\
    \ be `Vector{Int64}`.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n\
    \ 123\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code does not work. `unique`\
    \ returns a `Set` which is not an `Array`. `unique` should be `Vector{Int64}`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a tags=", " \
    \   unique = Set()\n    for x in l\n        unique.add(x)\n    end\n    unique\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nI came up with this solution:\n\
    <code>", "    unique = Set()\n    for x in l\n        if !unique.contains(x)\n\
    \            unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\n<code>", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique.value\nend\n</cell>\n\
    <code language=julia-1.5>", "    seen = Set()\n    unique = Set()\n    for x in\
    \ l\n        if !seen.add(x)\n            unique.add(x)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nI believe this should be the accepted answer. `unique`\
    \ should be part of the standard library.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    julia> using Statistics", "    seen = Set()\n    unique = Set()\n    for i in\
    \ l\n        if i not in seen\n            unique.add(i)\n            seen.add(i)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    seen = Set()\n    unique = Set()\n    for i in l\n        if i not in seen\n\
    \            push!(unique, i)\n            push!(seen, i)\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution works\
    \ well for small lists, but it scales poorly for large lists.\n<|/ c |>\n<| c\
    \ |>\nThis solution works well for large lists, but it scales poorly for small\
    \ lists.\n<|/ c |>\n<| c |>\nI agree, this is very slow for small lists. But for\
    \ large lists it works very well.\n<|/ c |>\n<| c |>\nThis solution works well\
    \ for large lists, but it scales poorly for small lists.\n<|/ c |>\n<| c |>\n\
    I agree, this is very slow for small lists. But for large lists it works very\
    \ well.\n<|/ c |>\n<| a dscore=4 |>\n<code>\njulia> using BenchmarkTools", " \
    \   unique = Set()\n    for i in l\n        if !haskey(unique, i)\n          \
    \  push!(unique, i)\n        end\n    end\n    return unique\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a vector of integers and returns a vector\
    \ of integers where the values are the square of those integers. For example,\
    \ square([4, 9, 16, 25]) should return [16, 25, 64, 125]. You may want to use\
    \ map or filter to do this.", "    unique = sort(unique(l))\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            push!(unique, x)\n        end\n  \
    \  end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\nunique", " \
    \   unique = Set()\n    for i in l\n        if !haskey(unique, i)\n          \
    \  push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nThis doesn't work if you have a vector of strings.\
    \ `unique([\"a\", \"b\", \"a\", \"c\"])` returns `[\"a\", \"b\", \"c\"]` instead\
    \ of `[\"a\", \"b\"]`.\n<|/ c |>\n<| a dscore=4 |>\n<code>\njulia> using Statistics",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})\
    \ = unique(l).sorted()\nunique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\n\
    unique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64},\
    \ comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function)\
    \ = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\n\
    unique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64},\
    \ comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function)\
    \ = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\n\
    unique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64},\
    \ comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function)\
    \ = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\n\
    unique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64},\
    \ comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function)\
    \ = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\n\
    unique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64},\
    \ comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function)\
    \ = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\n\
    unique(l::Vector{Int64}, comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64},\
    \ comp::Function) = unique(l).sort(comp)\nunique(l::Vector{Int64}, comp::Function)\
    \ = unique(l).sort(comp)\nunique(l::Vector{Int64}, ", "    seen = Set()\n    unique\
    \ = Set()\n    for x in l\n        if !seen.add(x)\n            unique.add(x)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.3>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    unique = Set()\n    unique.insert(l[1])\n    unique.insert(l[2])\n    unique.insert(l[3])\n\
    \    unique.insert(l[4])\n    unique.insert(l[5])\n    unique.insert(l[6])\n \
    \   unique.insert(l[7])\n    unique.insert(l[8])\n    unique.insert(l[9])\n  \
    \  unique.insert(l[10])\n    unique.insert(l[11])\n    unique.insert(l[12])\n\
    \    unique.insert(l[13])\n    unique.insert(l[14])\n    unique.insert(l[15])\n\
    \    unique.insert(l[16])\n    unique.insert(l[17])\n    unique.insert(l[18])\n\
    \    unique.insert(l[19])\n    unique.insert(l[20])\n    unique.insert(l[21])\n\
    \    unique.insert(l[22])\n    unique.insert(l[23])\n    unique.insert(l[24])\n\
    \    unique.insert(l[25])\n    unique.insert(l[26])\n    unique.insert(l[27])\n\
    \    unique.insert(l[28])\n    unique.insert(l[29])\n    unique.insert(l[30])\n\
    \    unique.insert(l[31])\n    unique.insert(l[32])\n    unique.insert(l[33])\n\
    \    unique.insert(l[34])\n    unique.insert(l[35])\n    unique.insert(l[36])\n\
    \    unique.insert(l[37])\n    unique.insert(l[38])\n    unique.insert(l[39])\n\
    \    unique.insert(l[40])\n    unique.insert(l[41])\n    unique.insert(l[42])\n\
    \    unique.insert(l[43])\n    unique.insert(l[44])\n    unique.insert(l[45])\n\
    \    unique.insert(l[46])\n    unique.insert(l[47])\n    unique.insert(l[48])\n\
    \    unique.insert(l[49])\n    unique.insert(l[50])\n    unique.insert(l[51])\n\
    \    unique.insert(l[52])\n    unique.insert(l[53])\n    unique.insert(l[54])\n\
    \    unique.insert(l[55])\n    unique.insert(l[56])\n    unique.insert(l[57])\n\
    \    unique.insert(l[58])\n    unique.insert(l[", "    seen = Set()\n    unique\
    \ = Vector{Int64}()\n    for x in l \n        if !seen.add(x) \n            push!(unique,\
    \ x)\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = sort(unique(l))\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    seen = Set()\n    unique = Set()\n    for x in l\n        if !haskey(seen,\
    \ x)\n            push!(unique, x)\n            push!(seen, x)\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ work if you have a `Vector{Int64}` with duplicates.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if you have a `Vector{Int64}` with duplicates.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have a `Vector{Int64}` with duplicates.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if you have a `Vector{Int64}` with duplicates.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a `Vector{Int64}` with duplicates.\n\
    <|/ c |>\n<| a tags=julia,unique,sorting |>\nThis should work:\n<code>\njulia>\
    \ using Statistics", "    seen = Set()\n    unique = Vector{Int64}()\n    for\
    \ x in l\n        if !seen.add(x)\n            push!(unique, x)\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the unique elements of a vector, sorted\
    \ and in increasing order.", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique(unique(unique))\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\n<code>\njulia> using Statistics",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.3>", "    seen = Set{Int64}()\n    unique = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n \
    \           push!(seen, i)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the number of unique elements. Test it on some examples. What happens if you\
    \ pass a vector of strings?", "    unique = Set()\n    for i in l\n        if\
    \ !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n   \
    \ return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't answer\
    \ the question, which is about sorting a vector, not about sorting a set.\n<|/\
    \ c |>\n<| c |>\nThe question was about sorting a vector, not a set. Sets are\
    \ unordered collections of unique elements. Vectors are ordered collections of\
    \ unique elements. Sorting vectors is a common operation and I believe this answer\
    \ does answer the question.\n<|/ c |>\n<| c |>\nThe question was about sorting\
    \ a vector, not a set. Sets are unordered collections of unique elements. Vectors\
    \ are ordered collections of unique elements. Sorting vectors is a common operation\
    \ and I believe this answer does answer the question.\n<|/ c |>\n<| c |>\nThis\
    \ answer doesn't answer the question. The question was about sorting a vector,\
    \ not about sorting a set.\n<|/ c |>\n<| c |>\nThe question was about sorting\
    \ a vector, not a set. Sets are unordered collections of unique elements. Vectors\
    \ are ordered collections of unique elements. Sorting vectors is a common operation\
    \ and I believe this answer does answer the question.\n<|/ c |>\n<| a tags=julia\
    \ |>\nThe answer by is correct, but I thought I'd add some explanation as to why\
    \ it works.\nThe reason why it works is because Julia is smart enough to know\
    \ that unique() returns a set, so it can just use the built-in sort! function.\n\
    The reason why it works is because Julia is smart enough to know that unique()\
    \ returns a set, so it can just use the built-in sort! function.\nThe reason why\
    \ it works is because Julia is smart enough to know that unique() returns a set,\
    \ so it can just use the built-in sort! function.\nThe reason why it works is\
    \ because Julia is smart enough to know that unique() returns a set, so it can\
    \ just use the built-in sort! function.\nThe reason why it works is because Julia\
    \ is smart enough to know that unique() returns a set, so it can just use the\
    \ built-in sort! function.\nThe reason why it works is because Julia is smart\
    \ enough to know that unique() returns a set, so it can just use the built-in\
    \ sort! function.\nThe reason why it works is because Julia is smart enough to\
    \ know that unique() returns a set, so it can just use the built-in sort! function.\n\
    The reason why it works is because Julia is ", "    seen = Set()\n    unique =\
    \ Set()\n    for x in l\n        if !seen.add(x)\n            unique.add(x)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nI believe this should be the accepted answer. `unique`\
    \ function from Julia is much faster than the one from Python.\n<|/ c |>\n<| a\
    \ tags=julia,unique,arrays |>\nI believe that Julia has this functionality built-in:\n\
    <code>\njulia> using StatsBase", "    seen = Set()\n    uniques = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(uniques, i)\n\
    \            seen[i] = true\n        end\n    end\n    return uniques\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis doesn't work if you have duplicates in your vector.\
    \ For example, unique([1,1,2,3]) returns [1,2,3] instead of [1,1,2,3]\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have duplicates in your vector. For example,\
    \ unique([1,1,2,3]) returns [1,2,3] instead of [1,1,2,3]\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have duplicates in your vector. For example, unique([1,1,2,3])\
    \ returns [1,2,3] instead of [1,1,2,3]\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have duplicates in your vector. For example, unique([1,1,2,3]) returns [1,2,3]\
    \ instead of [1,1,2,3]\n<|/ c |>\n<| c |>\nThis doesn't work if you have duplicates\
    \ in your vector. For example, unique([1,1,2,3]) returns [1,2,3] instead of [1,1,2,3]\n\
    <|/ c |>\n<| a tags=julia,unique |>\nThe answer by is great, but I wanted to add\
    \ some explanation as to why it works.\nThe reason why it works is because Julia's\
    \ Sets are implemented as hash tables. A hash table is basically a data structure\
    \ that stores unique keys and values together. Hash tables are very fast to look\
    \ up values by key. \nThe reason why Julia's Sets are implemented as hash tables\
    \ is because they allow for fast lookup of unique elements. \nThe reason why Julia's\
    \ Sets are implemented as hash tables is because they allow for fast lookup of\
    \ unique elements. \nThe reason why Julia's Sets are implemented as hash tables\
    \ is because they allow for fast lookup of unique elements. \nThe reason why Julia's\
    \ Sets are implemented as hash tables is because they allow for fast lookup of\
    \ unique elements. \nThe reason why Julia's Sets are implemented as hash tables\
    \ is because they allow for fast lookup of unique elements. \nThe reason why Julia's\
    \ Sets are implemented as hash tables is because they allow for fast lookup of\
    \ unique elements. \nThe reason why Julia's Sets are implemented as hash tables\
    \ is because they allow for fast lookup of unique elements. \nThe reason why Julia's\
    \ Sets are implemented as hash tables is because they allow for fast lookup of\
    \ unique elements. \n", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,set |>\n<| c |>\nThis is not the fastest solution,\
    \ since it requires O(n^2) time complexity. Also it requires O(n) space complexity.\n\
    <|/ c |>\n<| c |>\nThis is not the fastest solution, since it requires O(n^2)\
    \ time complexity. Also it requires O(n) space complexity.\n<|/ c |>\n<| c |>\n\
    I agree with you. My solution requires O(n) space complexity, while yours requires\
    \ O(n^2) space complexity. My solution also requires O(n^2) time complexity, while\
    \ yours requires O(n) time complexity. My solution also requires O(n) space complexity,\
    \ while yours requires O(n) space complexity. My solution also requires O(n) time\
    \ complexity, while yours requires O(n) time complexity. My solution also requires\
    \ O(n) space complexity, while yours requires O(n) space complexity. My solution\
    \ also requires O(n) time complexity, while yours requires O(n) time complexity.\
    \ My solution also requires O(n) space complexity, while yours requires O(n) space\
    \ complexity.\n<|/ c |>\n<| c |>\nI agree with you. My solution requires O(n)\
    \ space complexity, while yours requires O(n^2) space complexity. My solution\
    \ also requires O(n) time complexity, while yours requires O(n) time complexity.\
    \ My solution also requires O(n) space complexity, while yours requires O(n) space\
    \ complexity. My solution also requires O(n) time complexity, while yours requires\
    \ O(n) time complexity. My solution also requires O(n) space complexity, while\
    \ yours requires O(n) space complexity. My solution also requires O(n) time complexity,\
    \ while yours requires O(n) time complexity.\n<|/ c |>\n<| c |>\nI agree with\
    \ you. My solution requires O(n) space complexity, while yours requires O(n^2)\
    \ space complexity. My solution also requires O(n) time complexity, while yours\
    \ requires O(n) time complexity. My solution also requires O(n) space complexity,\
    \ while yours requires O", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if you have duplicates in the\
    \ input vector. For example, `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5,\
    \ 3, 9, 123]`.\n<|/ c |>\n<| c |>\nYes, I forgot about that case. Thanks for pointing\
    \ it out. I've added a fix for it.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "   \
    \ unique = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,set\
    \ |>\n<| a dscore=2 |>\nI came up with this:\n<code>\njulia> function unique(x::Vector{Int64})\n\
    \           return sort(unique(x...))\n       end\nunique (generic function with\
    \ 1 method)", "    unique = Set()\n    unique = unique + l\n    unique = unique\
    \ - Set([l])\n    return unique\nend\n</cell>\n<code language=julia-1.5>", " \
    \   seen = Set()\n    unique = Set()\n    for x in l\n        if !seen.add(x)\n\
    \            unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.3>", "    seen = Set()\n    uniques = Vector{Int64}()\n\
    \    for x in l \n        if !seen.add(x) \n            push!(uniques, x) \n \
    \       end\n    end\n    return uniques\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis does not answer the question. `unique` does not sort the input\
    \ array. `unique` returns a new array with the unique elements. `unique` does\
    \ not sort the input array. `unique` returns a new array with the unique elements.\
    \ `unique` does not sort the input array. `unique` returns a new array with the\
    \ unique elements. `unique` does not sort the input array. `unique` returns a\
    \ new array with the unique elements. `unique` does not sort the input array.\
    \ `unique` returns a new array with the unique elements. `unique` does not sort\
    \ the input array. `unique` returns a new array with the unique elements. `unique`\
    \ does not sort the input array. `unique` returns a new array with the unique\
    \ elements. `unique` does not sort the input array. `unique` returns a new array\
    \ with the unique elements. `unique` does not sort the input array. `unique` returns\
    \ a new array with the unique elements. `unique` does not sort the input array.\
    \ `unique` returns a new array with the unique elements. `unique` does not sort\
    \ the input array. `unique` returns a new array with the unique elements. `unique`\
    \ does not sort the input array. `unique` returns a new array with the unique\
    \ elements. `unique` does not sort the input array. `unique` returns a new array\
    \ with the unique elements. `unique` does not sort the input array. `unique` returns\
    \ a new array with the unique elements. `unique` does not sort the input array.\
    \ `unique` returns a new array with the unique elements. `unique` does not sort\
    \ the input array. `unique` returns a new array with the unique elements. `unique`\
    \ does not sort the input array. `unique` returns a new array with the unique\
    \ elements. `unique` does not sort the input array. `unique` returns a new array\
    \ with the unique elements. `unique` does not sort the input array. `unique` returns\
    \ a new array with the unique elements. `unique` does not sort the input array.\
    \ `unique` returns a new array with the unique elements. `unique` does not sort\
    \ the input array. `unique` returns a new array with the unique elements. `unique`\
    \ does not sort the input array. `unique` returns a new array with the unique\
    \ elements. `unique` does not sort the input array. `unique` returns a new array\
    \ with the unique elements. `unique` does not sort the input array. `", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,set\
    \ |>\n<| c |>\nThis should be the accepted answer. `Set` has `union`, `intersect`\
    \ and `difference` methods which work exactly as expected.\n<|/ c |>\n<| a tags=julia,set\
    \ |>\nI believe that Julia has some built-in set functions. For example, you can\
    \ use the union function on a set of integers:\n<code>\njulia> union([1,2,3],\
    \ [1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nI believe that `union` does not preserve the order of the elements in\
    \ the set. `union([1,2,3], [3,2,1])` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes,\
    \ it does preserve the order. `union([1,2,3], [3,2,1])` returns `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nThe order is preserved if you use `Set` instead of `Array`. `Set([1,2,3])`\
    \ returns `Set([1,2,3])`.\n<|/ c |>\n<| c |>\n`Set` does not preserve the order\
    \ of the elements in the set. `Set([1,2,3])` returns `Set([1,2,3])`.\n<|/ c |>\n\
    <| c |>\n`Set` does not preserve the order of the elements in the set. `Set([1,2,3])`\
    \ returns `Set([1,2,3])`.\n<|/ c |>\n<| a tags=julia,set |>\nThe set package is\
    \ now deprecated in Julia 1.2, and will be removed in Julia 1.3. \nThe recommended\
    \ way to create a set is to use the Set constructor:\n<code>\njulia> Set([1,2,3])\n\
    Set{Int64}([1,2,3])\n</code>\n<|/ a dscore=4 |>\n<| c |>\n`Set` does not preserve\
    \ the order of the elements in the set. `Set([1,2,3])` returns `Set([1,2,3])`.\n\
    <|/ c |>\n<| c |>\n`Set` does not preserve the order of the elements in the set.\
    \ `Set([1,2,3])` returns `Set([1,2,3])`.\n<|/ c |>\n<| a tags=julia,set |>\nThe\
    \ set package is now deprecated in Julia 1.2, and will be removed in Julia 1.3.\
    \ \nThe recommended way to create a set is to use the Set constructor:", "   \
    \ unique = Set()\n    for x in l\n        if !unique.contains(x)\n           \
    \ unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI came up with a solution using\
    \ Julia's Sets:\n<code>\njulia> function unique(x::Vector{Int64})\n          \
    \ return Set(x...)\n       end\nunique (generic function with 1 method)", "  \
    \  unique = Set()\n    for x in l\n        push!(unique, x)\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>", "  \
    \  unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nThis doesn't work if you have a `Vector{Int64}` that\
    \ contains `NaN`s.\n<|/ c |>\n<| c |>\nI added a version that doesn't have this\
    \ problem.\n<|/ c |>\n<| c |>\nI added a version that doesn't have this problem.\n\
    <|/ c |>\n<| a tags=julia |>\n<code>\njulia> function unique(l::Vector{Int64})::Vector{Int64}\n\
    \           unique = Set()\n           for i in l\n               if !haskey(unique,\
    \ i)\n                   push!(unique, i)\n               end\n           end\n\
    \           return unique\n       end\nunique (generic function with 1 method)",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ push!(unique, x)\n        end\n    end\n    return unique\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of unique elements in a list\n\
    Write a function that returns the number of unique elements in a vector\nWrite\
    \ a function that returns the number of unique elements in a matrix\nWrite a function\
    \ that returns the number of unique elements in a sparse matrix", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\nI wrote a Julia package called UniqueArray.jl that does\
    \ exactly what you want. It also has some performance optimizations that can help\
    \ you out a lot.\n<code>\nusing UniqueArray", "    unique = Set()\n    for x in\
    \ l\n        if !haskey(unique, x)\n            push!(unique, x)\n        end\n\
    \    end\n    return unique\nend\nunique(a)", "    unique = Set()\n    for x in\
    \ l\n        if !haskey(unique, x)\n            unique[x] = true\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,unique,arrays\
    \ |>\n<code>\njulia> using Statistics", "    unique = Set()\n    unique.insert(l[1])\n\
    \    unique.insert(l[2])\n    unique.insert(l[3])\n    unique.insert(l[4])\n \
    \   unique.insert(l[5])\n    unique.insert(l[6])\n    unique.insert(l[7])\n  \
    \  unique.insert(l[8])\n    unique.insert(l[9])\n    unique.insert(l[10])\n  \
    \  unique.insert(l[11])\n    unique.insert(l[12])\n    unique.insert(l[13])\n\
    \    unique.insert(l[14])\n    unique.insert(l[15])\n    unique.insert(l[16])\n\
    \    unique.insert(l[17])\n    unique.insert(l[18])\n    unique.insert(l[19])\n\
    \    unique.insert(l[20])\n    unique.insert(l[21])\n    unique.insert(l[22])\n\
    \    unique.insert(l[23])\n    unique.insert(l[24])\n    unique.insert(l[25])\n\
    \    unique.insert(l[26])\n    unique.insert(l[27])\n    unique.insert(l[28])\n\
    \    unique.insert(l[29])\n    unique.insert(l[30])\n    unique.insert(l[31])\n\
    \    unique.insert(l[32])\n    unique.insert(l[33])\n    unique.insert(l[34])\n\
    \    unique.insert(l[35])\n    unique.insert(l[36])\n    unique.insert(l[37])\n\
    \    unique.insert(l[38])\n    unique.insert(l[39])\n    unique.insert(l[40])\n\
    \    unique.insert(l[41])\n    unique.insert(l[42])\n    unique.insert(l[43])\n\
    \    unique.insert(l[44])\n    unique.insert(l[45])\n    unique.insert(l[46])\n\
    \    unique.insert(l[47])\n    unique.insert(l[48])\n    unique.insert(l[49])\n\
    \    unique.insert(l[50])\n    unique.insert(l[51])\n    unique.insert(l[52])\n\
    \    unique.insert(l[53])\n    unique.insert(l[54])\n    unique.insert(l[55])\n\
    \    unique.insert(l[56])\n    unique.insert(l[57])\n    unique.insert(l[58])\n\
    \    unique.insert(l[", "    seen = Set()\n    unique = Vector{Int64}()\n    for\
    \ i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n        \
    \    seen[i] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThis is not the fastest solution, since it\
    \ requires O(n^2) memory and O(n^2) time.\n<|/ c |>\n<| c |>\nYes, I agree. My\
    \ solution was to show that Julia has many ways to solve this problem. My solution\
    \ was to show that Julia has many ways to solve this problem. My solution was\
    \ to show that Julia has many ways to solve this problem. My solution was to show\
    \ that Julia has many ways to solve this problem. My solution was to show that\
    \ Julia has many ways to solve this problem. My solution was to show that Julia\
    \ has many ways to solve this problem. My solution was to show that Julia has\
    \ many ways to solve this problem. My solution was to show that Julia has many\
    \ ways to solve this problem. My solution was to show that Julia has many ways\
    \ to solve this problem. My solution was to show that Julia has many ways to solve\
    \ this problem. My solution was to show that Julia has many ways to solve this\
    \ problem. My solution was to show that Julia has many ways to solve this problem.\
    \ My solution was to show that Julia has many ways to solve this problem. My solution\
    \ was to show that Julia has many ways to solve this problem. My solution was\
    \ to show that Julia has many ways to solve this problem. My solution was to show\
    \ that Julia has many ways to solve this problem. My solution was to show that\
    \ Julia has many ways to solve this problem. My solution was to show that Julia\
    \ has many ways to solve this problem. My solution was to show that Julia has\
    \ many ways to solve this problem. My solution was to show that Julia has many\
    \ ways to solve this problem. My solution was to show that Julia has many ways\
    \ to solve this problem. My solution was to show that Julia has many ways to solve\
    \ this problem. My solution was to show that Julia has many ways to solve this\
    \ problem. My solution was to show that Julia has many ways to solve this problem.\
    \ My solution was to show that Julia has many ways to solve this problem. My solution\
    \ was to show that Julia has many ", "    seen = Set()\n    uniques = Set()\n\
    \    for x in l\n        if x not in seen\n            push!(seen, x)\n      \
    \      push!(uniques, x)\n        end\n    end\n    return uniques\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is not an answer, but a comment.\
    \ Please, use comments for such things.\n<|/ c |>\n<| c |>\nI agree, however I\
    \ do not have enough reputation to comment on other people's posts.\n<|/ c |>\n\
    <| c |>\nI agree with you. But the answer should be an answer, not a comment.\
    \ Comments are for asking questions about a specific problem. Answers are for\
    \ answering a question about the problem itself.\n<|/ c |>\n<| c |>\nI agree with\
    \ you. But the answer should be an answer, not a comment. Comments are for asking\
    \ questions about a specific problem. Answers are for answering a question about\
    \ the problem itself.\n<|/ c |>\n<| a dscore=2 |>\nThis is not an answer, but\
    \ a comment. Please, use comments for such things.\nI agree with you. But the\
    \ answer should be an answer, not a comment. Comments are for asking questions\
    \ about a specific problem. Answers are for answering a question about the problem\
    \ itself.\n<|/ a tags=julia,arrays |>\n<| a dscore=2 |>\n<code>\njulia> using\
    \ Statistics", "    seen = Set()\n    unique = Set()\n    for i in l\n       \
    \ if !seen.add(i)\n            push!(unique, i)\n        end\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 123]`.\n<|/ c |>\n<| c |>\nI\
    \ tested it and it works. I added a link to the full code in the answer.\n<|/\
    \ c |>\n<| c |>\nI tested it and it works. I added a link to the full code in\
    \ the answer.\n<|/ c |>\n<| c |>\nThis doesn't work. `unique([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123])` returns `[5, 3, 9, 123]`.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I added a link to the full code in the answer.\n<|/ c |>\n<| a tags=julia,unique\
    \ |>\nThe answer by is correct, but I wanted to add that you can also use Sets\
    \ to achieve the same thing:\n<code>\njulia> using Sets", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ push!(unique, x)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for i in l\n        unique +=\
    \ [i]\n    end\n    return unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    unique = Set()\n    for x in l\n        push!(unique, x)\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you have\
    \ a vector of strings. I added a solution that works for strings as well.\n<|/\
    \ c |>\n<| a |>\nI wrote a function that does this for you:\n<code>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work if you have a vector of strings. Try `unique([\"a\", \"b\",\
    \ \"a\", \"c\", \"a\", \"b\"])`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it\
    \ before posting it. I just tested it again and it works. I must have done something\
    \ wrong when I first tested it.\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I must have done something wrong when I first tested it.\n<|/ c |>\n<| c |>\n\
    I tested it again and it works. I must have done something wrong when I first\
    \ tested it.\n<|/ c |>\n<| c |>\nI tested it again and it works. I must have done\
    \ something wrong when I first tested it.\n<|/ c |>\n<| a tags=julia,unique |>\n\
    I came up with this solution:\n<code>", "    unique = Set()\n    for i in l\n\
    \        if !haskey(unique, i)\n            push!(unique, i)\n        end\n  \
    \  end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n\
    This doesn't work if you have a vector of strings. `unique([\"a\", \"a\", \"b\"\
    , \"c\", \"c\", \"c\"])` returns `[\"a\", \"b\", \"c\"]` instead of `[\"a\", \"\
    c\"]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a vector of strings.\
    \ `unique([\"a\", \"a\", \"b\", \"c\", \"c\", \"c\"])` returns `[\"a\", \"b\"\
    , \"c\"]` instead of `[\"a\", \"c\"]`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have a vector of strings. `unique([\"a\", \"a\", \"b\", \"c\", \"c\", \"\
    c\"])` returns `[\"a\", \"b\", \"c\"]` instead of `[\"a\", \"c\"]`.\n<|/ c |>\n\
    <| a dscore=4 |>\nI came up with this solution:\n<code>\njulia> function unique(A)\n\
    \           B = copy(A)\n           for i in eachindex(A)\n               if !haskey(B,\
    \ A[i])\n                   push!(B, A[i])\n               end\n           end\n\
    \           return B\n       end\nunique (generic function with 1 method)", " \
    \   unique = Set()\n    for i in l\n        if !haskey(unique, i)\n          \
    \  push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work if you have duplicate elements. `unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 123]`.\n<|/ c |>\n<| c |>\nYes,\
    \ I know. I was just trying to show how to do it. I didn't want to write an entire\
    \ function for it.\n<|/ c |>\n<| c |>\nI see. Thanks for your answer. I am not\
    \ very familiar with Julia yet, so I appreciate your help.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have duplicate elements. `unique([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123])` returns `[5, 3, 9, 123]`.\n<|/ c |>\n<| c |>\nI edited the answer\
    \ to include a version that works with duplicate elements.\n<|/ c |>\n<| a dscore=2\
    \ |>\nA simple and fast solution:\n<code>", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique.value\nend\n</cell>\n\
    <code language=julia-1.4>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if you have duplicate elements\
    \ in the list. For example, unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) returns [5,\
    \ 3, 9, 0, 123].\n<|/ c |>\n<| c |>\nI see what you mean. I've edited my answer\
    \ to include a version that doesn't have this problem.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if you have duplicate elements in the list. For example, unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123]) returns [5, 3, 9, 0, 123].\n<|/ c |>\n<| c |>\nI\
    \ see what you mean. I've edited my answer to include a version that doesn't have\
    \ this problem.\n<|/ c |>\n<| a tags=julia,unique,arrays |>\nI wrote a package\
    \ for this:\nhttps://github.com/jamiewilson/UniqueArrays.jl\n<code>\njulia> using\
    \ UniqueArrays", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a |>\n<| a tags=julia,arrays |>\nThe function unique is defined\
    \ in the Base package and can be imported with Base.unique.\n<|/ a dscore=2 |>\n\
    <| a tags=julia,arrays |>\nThe function unique is defined in the Base package\
    \ and can be imported with Base.unique.\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    The function unique is defined in the Base package and can be imported with Base.unique.\n\
    <|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\nThe function unique is\
    \ defined in the Base package and can be imported with Base.unique.\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nThe function unique is defined in the Base package and\
    \ can be imported with Base.unique.\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\nThe function unique is defined in the Base package and can be imported with\
    \ Base.unique.\n<|/ a dscore=0 |>\n<| a tags=julia,arrays |>\nThe function unique\
    \ is defined in the Base package and can be imported with Base.unique.\n<|/ a\
    \ dscore=0 |>\n<| a tags=julia,arrays |>\nThe function unique is defined in the\
    \ Base package and can be imported with Base.unique.\n<|/ a dscore=0 |>\n<| a\
    \ |>\nThe function unique is defined in the Base package and can be imported with\
    \ Base.unique.\n<|/ a tags=julia,arrays dscore=0 |>\n<| a dscore=0 |>\nThe function\
    \ unique is defined in the Base package and can be imported with Base.unique.\n\
    <|/ a tags=julia,arrays |>\n<| c |>\nPlease add some explanation to your answer\
    \ such that others can learn from it\n<|/ c |>\n<| c |>\nThe function unique is\
    \ defined in the Base package and can be imported with Base.unique.\n<|/ c |>\n\
    <| a tags=julia,arrays |>\nThe function unique is defined in the Base package\
    \ and can be imported with Base.unique.\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    The function unique is defined in the Base package and can be imported with Base.unique.\n\
    <|/ a tags=julia,arrays |>\n<| a dscore=0 |>\nThe function unique is defined in\
    \ the Base package and can be imported with Base.unique.\n<|/ a tag", "    seen\
    \ = Set()\n    unique = Vector{Int64}()\n    for x in l\n        if !seen.add(x)\n\
    \            push!(unique, x)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,arrays |>\n<| a dscore=2 |>\nIn Julia 1.5 you can use\
    \ the function unique.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a |>\nIn Julia 1.5 you can use the function unique.\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n\
    </code>\n<|/ a dscore=2 tags=julia,arrays |>\n<| a |>\nIn Julia 1.5 you can use\
    \ the function unique.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n</code>\n<|/ a dscore=2 tags=julia,arrays\
    \ |>\n<| a dscore=1 |>\nIn Julia 1.5 you can use the function unique.\n<code>\n\
    julia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n\
    \ 2\n 3\n 5\n 9\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=1 |>\nIn Julia\
    \ 1.5 you can use the function unique.\n<code>\njulia> unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| a dscore=1 |>\nIn Julia 1.5 you can use the function\
    \ unique.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n\
    \ 0\n 2\n 3\n 5\n 9\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=1 |>\nIn\
    \ Julia 1.5 you can use the function unique.\n<code>\njulia> unique([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3", "    unique =\
    \ Set()\n    for i in l\n        unique.add(i)\n    end\n    return unique\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe answer by is very good, but\
    \ I thought I'd add my own solution, since I needed something more general.\n\
    <code>", "    seen = Set()\n    uniques = Vector{Int64}()\n    for x in l\n  \
    \      if !seen.add(x)\n            push!(uniques, x)\n        end\n    end\n\
    \    return uniques\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique\nend\nunique(l::Vector{Int64}) = unique(l).keys\n\
    unique(l::Vector{Int64}, k::Int64)::Vector{Int64} \n    unique = Set()\n    for\
    \ x in l\n        if !haskey(unique, x)\n            unique[x] = true\n      \
    \  end\n        if x == k\n            unique[x] = false\n        end\n    end\n\
    \    return unique\nend\nunique(l::Vector{Int64}, k::Int64) = unique(l).keys\n\
    unique(l::Vector{Int64}, k::Int64, v::Int64)::Vector{Int64} \n    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n        if x == k\n            unique[x] = false\n        end\n\
    \        if x == v\n            unique[x] = false\n        end\n    end\n    return\
    \ unique\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64) = unique(l).keys\n\
    unique(l::Vector{Int64}, k::Int64, v::Int64, w::Int64)::Vector{Int64} \n    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n        if x == k\n            unique[x] = false\n    \
    \    end\n        if x == v\n            unique[x] = false\n        end\n    \
    \    if x == w\n            unique[x] = false\n        end\n    end\n    return\
    \ unique\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64, w::Int64) = unique(l).keys\n\
    unique(l::Vector{Int64}, k::Int64, v::Int64, w::Int64, x::Int64)::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n        if x == k\n            unique[x]\
    \ = false\n        end\n        if x == v\n            unique[x] = false\n   \
    \     end\n        if x == w\n            unique[x] = false\n        end\n   \
    \     if x == x\n            unique[x] = false\n        end\n    end\n    return\
    \ unique\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64, w::Int64, x::Int64)\
    \ = unique(l).keys\nunique(l::Vector{Int64}, k::Int64, v", "    unique = Set()\n\
    \    for x in l\n        push!(unique, x)\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis should be the accepted answer. Much more efficient\
    \ than sorting.\n<|/ c |>\n<| a dscore=4 |>\nI came up with a simple solution\
    \ that is quite efficient and does not require any additional packages. \n<code>",
  "    unique = Set()\n    unique = unique + l\n    unique = unique(unique(unique(unique)))\
    \ \n    return unique(unique(unique(unique(unique))))\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia |>\n<code>\njulia> function unique(x::Vector{Int64})::Vector{Int64}\n\
    \           return sort(unique(x)) \n       end\nunique (generic function with\
    \ 1 method)", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for i in l\n\
    \        if !haskey(unique, i)\n            push!(unique, i)\n        end\n  \
    \  end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to avoid the overhead of creating a\
    \ `Set` for each element in the list. Maybe something like `unique!` which would\
    \ modify the list in-place?\n<|/ c |>\n<| c |>\nI guess it would be possible to\
    \ implement a custom `unique!` function that would modify the list in-place, but\
    \ that would require a custom `unique` function as well. I'll try to think about\
    \ it.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require a custom `unique`\
    \ function.\n<|/ c |>\n<| a tags=julia,unique |>\nI like 's solution, but I wonder\
    \ if there is a way to avoid the overhead of creating Set for each element in\
    \ the list. Maybe something like unique! which would modify the list in-place?",
  "    seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen[i] = true\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen\
    \ = Set()\n    unique = Set()\n    for x in l\n        if !seen.add(x)\n     \
    \       unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the input vector. For example, `unique([5, 3, 5, 2, 3, 3, 9, 0, 123, 5])`\
    \ returns `[5, 3, 9, 0, 123, 5]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and\
    \ fixed it by adding `!haskey(unique, i)` condition. Thanks for pointing out.\n\
    <|/ c |>\n<| a dscore=2 |>\nI wrote a Julia package called UniqueArrays.jl which\
    \ does exactly this. It works on any array and doesn't require any additional\
    \ packages.\n<code>\njulia> using UniqueArrays", "    unique = Set()\n    for\
    \ x in l\n        if !haskey(unique, x)\n            unique[x] = true\n      \
    \  end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like your answer, but I think it would be more efficient to just use a `Set`\
    \ instead of a `Dict`.  Also, you could use `Set` instead of `Dict` in the `unique`\
    \ function.\n<|/ c |>\n<| c |>\nYes, I agree that `Set` would be more efficient.\
    \ Thanks for the suggestion.\n<|/ c |>\n<| c |>\nI agree with you that `Set` would\
    \ be more efficient, but I wanted to show how it could be done without `Dict`.\n\
    <|/ c |>\n<| c |>\nI added a version that uses `Set` in the `unique` function.\n\
    <|/ c |>\n<| a tags=julia |>\nHere is a solution using Sets:\n<code>\njulia> function\
    \ unique(l::Vector{Int64})::Vector{Int64}\n           unique = Set()\n       \
    \    for x in l\n               if !haskey(unique, x)\n                   push!(unique,\
    \ x)\n               end\n           end\n           return unique\n       end\n\
    unique (generic function with 1 method)", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !haskey(seen, x)\n            push!(unique, x)\n \
    \           seen[x] = true\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is not the fastest solution, since it requires\
    \ O(n^2) memory and O(n^2) time.\n<|/ c |>\n<| c |>\nI agree, but I believe that\
    \ this is still the fastest solution in Julia. Also the memory requirement is\
    \ O(n).\n<|/ c |>\n<| c |>\nI believe that this is still the fastest solution\
    \ in Julia. Also the memory requirement is O(n).\n<|/ c |>\n<| c |>\nThis is not\
    \ the fastest solution, since it requires O(n^2) memory and O(n^2) time.\n<|/\
    \ c |>\n<| c |>\nI agree, but I believe that this is still the fastest solution\
    \ in Julia. Also the memory requirement is O(n).\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nThe fastest solution in Julia is to use Sets:\n<code>\njulia> using Sets",
  "    unique = Set()\n    unique = unique + l\n    unique = unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    seen = Set()\n    uniques = Set()\n    for i in l\n        if i \u2209 seen\n\
    \            push!(uniques, i)\n            push!(seen, i)\n        end\n    end\n\
    \    return uniques\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe\
    \ most efficient way is to use Sets:\n<code>\njulia> x = Set([1,2,3,4,5,6,7,8,9,10])\n\
    10-element Set{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis doesn't work if you have repeated elements. For example, `unique([1,1,2,2])`\
    \ returns `[1,1,2]` instead of `[1,2,2]`.\n<|/ c |>\n<| c |>\nThanks, I fixed\
    \ the answer.\n<|/ c |>\n<| a tags=julia |>\nI wrote a package called UniqueArrays.jl\
    \ that does exactly this. It also has some nice performance improvements over\
    \ other solutions posted here.\n<code>\nusing UniqueArrays", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n \
    \           push!(unique, i)\n            seen[i] = true\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/27827826)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He asked how to remove\
    \ duplicates from a vector. He also asked how to sort a vector. He also asked\
    \ how to remove duplicates from a set. He also asked how to sort a set. He also\
    \ asked how to remove duplicates from a dictionary. He also asked how to sort\
    \ a dictionary. He also asked how to remove duplicates from a tuple. He also asked\
    \ how to sort a tuple. He also asked how to remove duplicates from a function.\
    \ He also asked how to sort a function. He also asked how to remove duplicates\
    \ from a function. He also asked how to sort a function. He also asked how to\
    \ remove duplicates from a function. He also asked how to sort a function. He\
    \ also asked how to remove duplicates from a function. He also asked how to sort\
    \ a function. He also asked how to remove duplicates from a function. He also\
    \ asked how to sort a function. He also asked how to remove duplicates from a\
    \ function. He also asked how to sort a function. He also asked how to remove\
    \ duplicates from a function. He also asked how to sort a function. He also asked\
    \ how to remove duplicates from a function. He also asked how to sort a function.\
    \ He also asked how to remove duplicates from a function. He also asked how to\
    \ sort a function. He also asked how to remove duplicates from a function. He\
    \ also asked how to sort a function. He also asked how to remove duplicates from\
    \ a function. He also asked how to sort a function. He also asked how to remove\
    \ duplicates from a function. He also asked how to sort a function. He also asked\
    \ how to remove duplicates from a function. He also asked how to sort a function.\
    \ He also asked how to remove duplicates from a function. He also asked how to\
    \ sort a function. He also asked how to remove duplicates from a function. He\
    \ also asked how to sort a function. He also asked how to remove duplicates from\
    \ a function. He also asked how to sort a function. He also asked how to remove\
    \ duplicates from a function. H", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n \
    \           seen[i] = true\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a tags=julia,arrays,unique,sorting |>\n<| a tags=julia,arrays,unique,sorting\
    \ |>\nI wanted to add an answer that uses Julia's built-in function unique.\n\
    <code>\njulia> a = [5, 3, 5, 2, 3, 3, 9, 0, 123]\n5-element Array{Int64,1}:\n\
    \ 5\n 3\n 5\n 2\n 3\n 9\n 0\n 123", "    unique = Set()\n    for x in l\n    \
    \    if !haskey(unique, x)\n            unique[x] = true\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis does not\
    \ answer the question. `unique` should return `[5, 3, 9, 123]` and not `[0, 2,\
    \ 3, 5, 9, 123]`.\n<|/ c |>\n<| c |>\nI agree with you. My answer was more of\
    \ a \"quick and dirty\" solution. I'll edit my answer to reflect your comment.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe answer by is correct, but I thought I'd add some\
    \ explanation as to why it works.\nThe reason why unique() works is because Set()\
    \ is a mutable data structure. Set() is a mutable data structure that stores unique\
    \ elements. When you call unique(), it creates a new Set and stores unique elements\
    \ into that new Set. unique() then returns the unique elements from the new Set.\n\
    The reason why unique() does not work is because Set() is a immutable data structure.\
    \ Set() is a immutable data structure that stores unique elements. When you call\
    \ unique(), it creates a new Set and stores unique elements into that new Set.\
    \ unique() then returns the unique elements from the new Set.\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nThe answer is that Julia is smart enough to know that\
    \ Set() is a set, and that Set() is a set. \n<code>\njulia> Set()\nSet()", " \
    \   unique = Set()\n    for i in l\n        if !haskey(unique, i)\n          \
    \  push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThis doesn't work if you have a `Vector{Int64}`\
    \ that contains `NaN`s.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\njulia> function\
    \ unique(x::Vector{Int64})\n           return sort(unique(x)) \n       end\nunique\
    \ (generic function with 1 method)", "    unique = Set()\n    for x in l\n   \
    \     if !haskey(unique, x)\n            unique[x] = true\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays |>\n<code>\n\
    julia> using Statistics", "    seen = Set{Int64}()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            push!(unique, x)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,performance,unique,arrays |>\n<| c |>\nThanks for\
    \ your answer. Your solution is very fast for small arrays, but for large arrays\
    \ it takes too long. My array is about 20000 elements and it takes about 20 seconds\
    \ to run your code. Do you know any faster solution?\n<|/ c |>\n<| c |>\nI added\
    \ a faster solution to my answer.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your solution is very fast for small arrays, but for large arrays it takes too\
    \ long. My array is about 20000 elements and it takes about 20 seconds to run\
    \ your code. Do you know any faster solution?\n<|/ c |>\n<| c |>\nI added a faster\
    \ solution to my answer.\n<|/ c |>\n<| c |>\nThanks for your answer. Your solution\
    \ is very fast for small arrays, but for large arrays it takes too long. My array\
    \ is about 20000 elements and it takes about 20 seconds to run your code. Do you\
    \ know any faster solution?\n<|/ c |>\n<| a dscore=2 |>\nI believe that Julia\
    \ is optimized for vectorized operations. So I suggest you use Julia's built-in\
    \ unique function instead of writing your own.\n<code>\njulia> a = [5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123]\n5-element Array{Int64,1}:\n 5\n 3\n 5\n 2\n 3\n 9\n 0\n 123",
  "    unique = Set()\n    unique = unique + l\n    unique = unique(unique(unique(unique)))\n\
    \    return unique(unique(unique(unique)))\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique.value\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| a dscore=2 |>\nI believe that you can also use\
    \ unique.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n\
    </code>\n<|/ a tags=julia,arrays |>\n<| a dscore=2 |>\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a tags=julia,arrays |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0,\
    \ 123])\n0-element Array{Int64,1}\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays\
    \ |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    0-element Array{Int64,1}\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\njulia> unique([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a dscore=1 |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    0-element Array{Int64,1}\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\njulia> unique([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n0-element Array{", "    unique = sort(unique(l))\n   \
    \ return unique\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI believe that in Julia\
    \ 1.1 you can use the built-in function unique.\n<|/ a tags=julia,arrays,sorting\
    \ |>\n<| c |>\nYes, but that doesn't work for arrays of Int64. `unique([1,2,2,3])`\
    \ gives `ERROR: MethodError: no method matching unique(::Array{Int64,1})`\n<|/\
    \ c |>\n<| c |>\nAh, I see. Thanks for pointing that out. I'll see if I can find\
    \ a workaround.\n<|/ c |>\n<| c |>\nI added a workaround for arrays of Int64 to\
    \ my answer.\n<|/ c |>\n<| a |>\nI believe that in Julia 1.1 you can use the built-in\
    \ function unique.\n<|/ a tags=julia,arrays,sorting dscore=2 |>\n<| a dscore=2\
    \ |>\nIn Julia 1.1 you can use the built-in function unique.\n<code>\njulia> unique([1,2,2,3])\n\
    3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a tags=julia,arrays,sorting\
    \ |>\n<| a tags=julia,arrays,sorting |>\nIn Julia 1.1 you can use the built-in\
    \ function unique.\n<code>\njulia> unique([1,2,2,3])\n3-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nIn Julia 1.1 you can\
    \ use the built-in function unique.\n<code>\njulia> unique([1,2,2,3])\n3-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a tags=julia,arrays,sorting |>\n<|\
    \ a dscore=1 |>\nIn Julia 1.1 you can use the built-in function unique.\n<code>\n\
    julia> unique([1,2,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/\
    \ a tags=julia,arrays,sorting |>\n<| a tags=julia,arrays,sorting |>\nIn Julia\
    \ 1.1 you can use the built-in function unique.\n<code>\njulia> unique([1,2,2,3])\n\
    3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nIn Julia 1.1 you can use the built-in function unique.\n<code>\n", "   \
    \ seen = Set()\n    unique = Set()\n    for x in l\n        if !seen.add(x)\n\
    \            unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    seen = Set()\n    unique = Set()\n    for x in\
    \ l\n        if !seen.add(x)\n            unique.add(x)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.3>", "    seen = Set()\n\
    \    unique = Set()\n    for i in l\n        if i not in seen \n            push!(unique,\
    \ i)\n            push!(seen, i)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,set |>\n<| a dscore=2 |>\nThe answer by is correct,\
    \ but I wanted to add some additional information for those who are new to Julia.\n\
    The Julia Set is implemented as a HashSet, which is a hash table that stores unique\
    \ elements. In Julia, the syntax for creating a set is Set{T}(), where T is the\
    \ type of the elements in the set. \nThe syntax for creating a set is also different\
    \ for different types of sets. For example, a set created using Set{Int} is different\
    \ than a set created using Set{String}. \nThe syntax for creating a set is also\
    \ different for different types of sets. For example, a set created using Set{Int}\
    \ is different than a set created using Set{String}. \nThe syntax for creating\
    \ a set is also different for different types of sets. For example, a set created\
    \ using Set{Int} is different than a set created using Set{String}. \nThe syntax\
    \ for creating a set is also different for different types of sets. For example,\
    \ a set created using Set{Int} is different than a set created using Set{String}.\
    \ \nThe syntax for creating a set is also different for different types of sets.\
    \ For example, a set created using Set{Int} is different than a set created using\
    \ Set{String}. \nThe syntax for creating a set is also different for different\
    \ types of sets. For example, a set created using Set{Int} is different than a\
    \ set created using Set{String}. \nThe syntax for creating a set is also different\
    \ for different types of sets. For example, a set created using Set{Int} is different\
    \ than a set created using Set{String}. \nThe syntax for creating a set is also\
    \ different for different types of sets. For example, a set created using Set{Int}\
    \ is different than a set created using Set{String}. \nThe syntax for creating\
    \ a set is also different for different types of sets. For example, a set created\
    \ using Set{Int} is different than a set created using Set{String}. \nThe syntax\
    \ for creating a set is also different for different types of sets. For example,\
    \ a set created using Set{Int} is different than a set created using Set{String}.\
    \ \nThe syntax for creating a set is also different for different types of sets.\
    \ For example, a set created using Set{Int} is different than a set created using\
    \ Set{String}. \nThe syntax for ", "    unique = Set()\n    for i in l\n     \
    \   if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThe answer by is\
    \ very good, but I thought I'd add some more information to it that might be useful\
    \ to others.\nThe function unique is defined in the Julia standard library as\
    \ unique(x::Vector{T}) where T is a type. \nThe function unique is defined in\
    \ the Base package as Base.unique(x::Vector{T}) where T is a type. \nThe function\
    \ unique is defined in the Statistics package as Statistics.unique(x::Vector{T})\
    \ where T is a type. \nThe function unique is defined in the StatsBase.jl package\
    \ as StatsBase.unique(x::Vector{T}) where T is a type. \nThe function unique is\
    \ defined in the StatsExtra.jl package as StatsExtra.unique(x::Vector{T}) where\
    \ T is a type. \nThe function unique is defined in the StatsTools.jl package as\
    \ StatsTools.unique(x::Vector{T}) where T is a type. \nThe function unique is\
    \ defined in the StatsPlots.jl package as StatsPlots.unique(x::Vector{T}) where\
    \ T is a type. \nThe function unique is defined in the StatsPlots.jl package as\
    \ StatsPlots.unique(x::Vector{T}) where T is a type. \nThe function unique is\
    \ defined in the StatsPlots.jl package as StatsPlots.unique(x::Vector{T}) where\
    \ T is a type. \nThe function unique is defined in the StatsPlots.jl package as\
    \ StatsPlots.unique(x::Vector{T}) where T is a type. \nThe function unique is\
    \ defined in the StatsPlots.jl package as StatsPlots.unique(x::Vector{T}) where\
    \ T is a type. \nThe function unique is defined in the StatsPlots.jl package as\
    \ StatsPlots.unique(x::Vector{T}) where T is a type. \nThe function unique is\
    \ defined in the StatsPlots.jl package as StatsPlots.unique(x::Vector{T}) where\
    \ T is a type. \nThe function unique is defined in the StatsPlots.jl package as\
    \ StatsPlots.unique(x::Vector{T}) where T is a type. \nThe function unique is\
    \ defined in the StatsPlots.jl package as StatsPlots.unique(x::Vector{T}) where\
    \ T is a type. \nThe function unique is defined in the StatsPlots.jl package as\
    \ StatsPlots.unique(x::Vector{T}) where T", "    unique = Set()\n    for x in\
    \ l\n        if !haskey(unique, x)\n            unique[x] = true\n        end\n\
    \    end\n    return unique.value\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This doesn't work for me. `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5,\
    \ 3, 9, 123]`\n<|/ c |>\n<| c |>\nI tested it on Julia 1.5.2 and it works. What\
    \ version are you using?\n<|/ c |>\n<| c |>\nI'm using Julia 1.5.2\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.2 and it works. What version are you using?\n\
    <|/ c |>\n<| c |>\nI'm using Julia 1.5.2\n<|/ c |>\n<| a dscore=2 |>\nThe accepted\
    \ answer doesn't work for me in Julia 1.5.2 on Mac OS X. Here's a version that\
    \ does:\n<code>", "    seen = Set()\n    uniques = Set()\n    for x in l\n   \
    \     if !seen.add(x)\n            uniques.add(x)\n        end\n    end\n    return\
    \ uniques\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns the\
    \ number of unique elements in a list.", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            push!(unique, x)\n        end\n  \
    \  end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n\
    This doesn't work if you have repeated elements. For example, `unique([1, 1, 2,\
    \ 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nThe\
    \ question was about unique elements. If you have repeated elements, then you\
    \ cannot use sets. If you have repeated elements, then you cannot use sets. If\
    \ you have repeated elements, then you cannot use sets. If you have repeated elements,\
    \ then you cannot use sets. If you have repeated elements, then you cannot use\
    \ sets. If you have repeated elements, then you cannot use sets. If you have repeated\
    \ elements, then you cannot use sets. If you have repeated elements, then you\
    \ cannot use sets. If you have repeated elements, then you cannot use sets. If\
    \ you have repeated elements, then you cannot use sets. If you have repeated elements,\
    \ then you cannot use sets. If you have repeated elements, then you cannot use\
    \ sets. If you have repeated elements, then you cannot use sets. If you have repeated\
    \ elements, then you cannot use sets. If you have repeated elements, then you\
    \ cannot use sets. If you have repeated elements, then you cannot use sets. If\
    \ you have repeated elements, then you cannot use sets. If you have repeated elements,\
    \ then you cannot use sets. If you have repeated elements, then you cannot use\
    \ sets. If you have repeated elements, then you cannot use sets. If you have repeated\
    \ elements, then you cannot use sets. If you have repeated elements, then you\
    \ cannot use sets. If you have repeated elements, then you cannot use sets. If\
    \ you have repeated elements, then you cannot use sets. If you have repeated elements,\
    \ then you cannot use sets. If you have repeated elements, then you cannot use\
    \ sets. If you have repeated elements, then you cannot use sets. If you have repeated\
    \ elements, then you cannot use sets. If you have repeated elements, then you\
    \ cannot use sets. If you have repeated elements, then you cannot use sets. If\
    \ you have repeated elements, then you cannot use sets. If you have repeated elements,\
    \ then you cannot use sets. If you have repeated elements, then you cannot use\
    \ sets. If you have repeated elements, then you cannot use sets. If you have repeated\
    \ elements, then you cannot use sets. If you have repeated elements, then you\
    \ cannot use sets. If you have repeated elements, then you cannot use sets. If\
    \ you have repeated elements, then you cannot use sets. If you have repeated elements,\
    \ then you cannot use sets. If you have repeated elements, then you cannot use\
    \ sets. If you have repeated elements, then you cannot use sets. If you have repeated\
    \ elements, then you ", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = 1\n        end\n    end\n    return unique\nend",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ push!(unique, x)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\n`unique` will remove duplicates from `l` so\
    \ `unique(l) == l` will always be true.\n<|/ c |>\n<| c |>\nThanks, I fixed the\
    \ code. Now it works as intended.\n<|/ c |>\n<| c |>\nI fixed the code again.\
    \ Now it works as intended.\n<|/ c |>\n<| a tags=julia,arrays |>\nI wrote a package\
    \ for this: \nhttps://github.com/jamiewilson/UniqueArrays.jl\n<code>\nusing UniqueArrays",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a |>\n<| a tags=julia,arrays |>\nI like to use Sets to remove duplicates. \n\
    <code>\njulia> a = [1,2,2,3,4,5,5,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    20-element Array{Int64,1}:\n 1\n 2\n 2\n 3\n 4\n 5\n 5\n 5\n 6\n 7\n 8\n 9\n10\n\
    11\n12\n13\n14\n15\n16\n17\n18\n19", "    unique = Set()\n    for i in l\n   \
    \     if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis is not the\
    \ fastest solution. `unique` can be implemented as a `Set` so `push!` can be replaced\
    \ with `add!`.\n<|/ c |>\n<| c |>\nThanks for the suggestion. I've edited my answer\
    \ to include your suggestion.\n<|/ c |>\n<| c |>\nThanks for the suggestion. I've\
    \ edited my answer to include your suggestion.\n<|/ c |>\n<| a dscore=2 |>\nI\
    \ wrote a package called UniqueArrays.jl that does this efficiently and efficiently\
    \ in Julia 1.6.\n<code>\njulia> using UniqueArrays", "    unique = Set()\n   \
    \ for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n  \
    \      end\n    end\n    return unique\nend\nunique", "    seen = Set()\n    unique\
    \ = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n           \
    \ push!(unique, i)\n            seen[i] = true\n        end\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThanks for your answer!\
    \ I didn't know about `Set`. I also found this [link](http://stackoverflow.com/questions/27859831/julia-set-performance-for-unique-elements-in-an-array)\
    \ which suggests that `Set` might be faster than `Dict`\n<|/ c |>\n<| c |>\nYes,\
    \ `Set` should be faster, but `Dict` should be faster still. `Dict` should be\
    \ faster than `Set` because `Dict` uses hashing internally, while `Set` uses linear\
    \ search.\n<|/ c |>\n<| c |>\nI added a benchmark test to my answer. `Set` is\
    \ faster than `Dict` on my machine.\n<|/ c |>\n<| c |>\nThanks for your benchmark!\
    \ I didn't know about `Set` before. I'm still not very familiar with Julia's performance\
    \ optimization. I'm going to try your benchmark test and see how it goes.\n<|/\
    \ c |>\n<| c |>\nI added a benchmark test to my answer. `Set` is faster than `Dict`\
    \ on my machine.\n<|/ c |>\n<| a tags=julia,arrays |>\nHere is a benchmark test\
    \ to compare the performance of Set and Dict on Julia 0.6.1.\n<code>\nusing BenchmarkTools",
  "    seen = Set()\n    uniques = Vector{Int64}()\n    for x in l\n        if !seen.add(x)\n\
    \            push!(uniques, x)\n        end\n    end\n    return uniques\nend\n\
    </cell>\n<code language=julia-1.5>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n\
    <text>\nExercise: Write a function that returns the unique elements of a vector,\
    \ sorted and in increasing order.", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    seen = Set()\n    unique = Set()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            unique += [i]\n            seen[i] = 1\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,performance,unique,arrays\
    \ |>\n<| c |>\nThis is not the fastest solution, since it requires O(n^2) memory\
    \ and O(n^2) time for sorting. Also the memory usage is O(n^2) in both time and\
    \ memory.\n<|/ c |>\n<| c |>\nI agree, this is O(n^2) in time and memory. However\
    \ it is the fastest solution I could find for Julia 1.5.1. I tested it on Julia\
    \ 1.5.1 and it took less than a second for an array of length 10^6. Of course\
    \ this solution does not work for Julia 1.6.\n<|/ c |>\n<| c |>\nThe memory usage\
    \ is O(n^2) in both time and memory because of the `Set` data structure. `unique`\
    \ uses `Dict` internally, so it is O(n) in time and O(n) in memory. `sort` uses\
    \ `Array` internally, so it is O(n) in time and O(1) in memory.\n<|/ c |>\n<|\
    \ c |>\nI tested this on Julia 1.5.1 on Windows 10 and it took less than a second\
    \ for an array of length 10^6. Of course this solution does not work for Julia\
    \ 1.6.\n<|/ c |>\n<| c |>\nI tested this on Julia 1.5.1 on Windows 10 and it took\
    \ less than a second for an array of length 10^6. Of course this solution does\
    \ not work for Julia 1.6.\n<|/ c |>\n<| a tags=julia,performance,unique,arrays\
    \ |>\nI wrote a benchmark comparing the different solutions proposed here (@Mr.\
    \ Sanders and @Mr. Sanders). \n<code>\nusing BenchmarkTools", "    unique = Set()\n\
    \    for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have repeated elements in the array. For\
    \ example, `unique([1,1,2,2])` returns `[1,1,2]`.\n<|/ c |>\n<| a dscore=4 |>\n\
    A simple and efficient solution is to use Sets:\n<code>\njulia> setdiff(1:10,\
    \ 1:10)\nSet{Int64}([1, 2, 3, 4, 5, 6, 7, 8, 9])\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have repeated elements in the array. For\
    \ example, `setdiff(1:10, 1:10)` returns `Set{Int64}([1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9])`.\n<|/ c |>\n<| a dscore=3 |>\nA simple and efficient solution is to use\
    \ Sets:\n<code>\njulia> setdiff(1:10, 1:10)\nSet{Int64}([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9])\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=3 |>\n<code>\njulia>\
    \ unique(1:10)\n10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n\
    </code>\n<|/ a tags=julia,arrays |>\n<| a dscore=3 |>\n<code>\njulia> unique(1:10)\n\
    10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n</code>\n<|/ a\
    \ tags=julia,arrays |>\n<| a tags=julia,arrays |>\n<code>\njulia> unique(1:10)\n\
    10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a dscore=3 |>\n<code>\njulia> unique(1:10)\n10-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n</code>\n<|/ a tags=julia,arrays |>\n<| a\
    \ dscore=3 |>\n<code>\njulia> unique(1:10)\n10-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,set |>\n<| c |>\nThis solution does not preserve the\
    \ order of the elements in the original list. For example, `unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])` returns `[2, 3, 5, 9, 123]`.\n<|/ c |>\n<| c |>\nI agree,\
    \ this is an important point. I added a solution that preserves the order of the\
    \ original list.\n<|/ c |>\n<| a dscore=2 |>\nI came up with a solution that preserves\
    \ the order of the original list. \n<code>", "    unique = Set()\n    unique =\
    \ unique + l\n    unique = unique(unique(unique))\n    return unique(unique(unique))\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for me. `unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 0, 123]`.\n<|/ c |>\n<| c |>\n\
    It works on my machine. Are you sure you copied it correctly? I tested it on Julia\
    \ 0.6.2\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I also tested\
    \ it on 0.6.2. I also tested it on 0.6.3. I'm running on 0.6.2 on Windows. I wonder\
    \ if it's a bug in 0.6.2.\n<|/ c |>\n<| c |>\nI tested it on 0.6.2 on Linux. Maybe\
    \ it's a bug in 0.6.2?\n<|/ c |>\n<| c |>\nI tested it on 0.6.2 on Windows. Maybe\
    \ it's a bug in 0.6.2?\n<|/ c |>\n<| a dscore=2 |>\nThe accepted answer doesn't\
    \ work for me. \n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element\
    \ Array{Int64,1}:\n 5\n 3\n 9\n 123\n 0\n</code>\nI ended up writing my own unique\
    \ function which seems to work fine.\n<code>", "    unique = Set()\n    for x\
    \ in l\n        if !haskey(unique, x)\n            unique[x] = true\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns the number of unique elements in a list\n    >>> unique([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123])\n    6\n    \"\"\"", "    unique = Set()\n    for i\
    \ in l\n        if !haskey(unique, i)\n            push!(unique, i)\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen\
    \ = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen.add(i)\n        end\n   \
    \ end\n    return unique\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\n\
    The most efficient way is to use Sets:\n<code>\njulia> using Sets", "    seen\
    \ = Set()\n    unique = Vector{Int64}()\n    for x in l\n        if !seen.add(x)\n\
    \            push!(unique, x)\n        end\n    end\n    return unique\nend\n\
    </cell>\n<code language=julia-1.5>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the sum of the squares of the integers. \nFor example, sum([1, 2, 3, 4]) should\
    \ return 10 (1 + 4 + 9 + 16).", "    unique = Set()\n    for i in l\n        if\
    \ !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n   \
    \ return unique\nend\n</code>\n<|/ a |>\n<| c |>\nThe `Set` solution is O(n),\
    \ whereas the `Dict` solution is O(n^2). `Set` is more efficient for small lists.\n\
    <|/ c |>\n<| c |>\nI agree, `Set` is more efficient. But the `Dict` solution is\
    \ also O(n^2) in terms of memory usage.\n<|/ c |>\n<| c |>\nThe `Dict` solution\
    \ is O(n) memory usage, since it uses constant memory for its keys and values.\
    \ `Set` uses O(n) memory for its keys and O(n) memory for its values.\n<|/ c |>\n\
    <| c |>\nI agree, `Set` is more efficient in terms of memory usage. But the `Dict`\
    \ solution is also O(n^2) in terms of memory usage.\n<|/ c |>\n<| c |>\nThe `Dict`\
    \ solution is O(n) memory usage, since it uses constant memory for its keys and\
    \ values. `Set` uses O(n) memory for its keys and O(n) memory for its values.\n\
    <|/ c |>\n<| a tags=julia,arrays,unique,sorting |>\n<code>\njulia> using Statistics",
  "    seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen[i] = true\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.3>", "    unique\
    \ = sort(unique(l))\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n`unique` returns a `Set` so\
    \ `unique(l) == unique(l) == Set(l)` will always be true.\n<|/ c |>\n<| c |>\n\
    Yes, I know, but I wanted to keep it simple and avoid the Set() constructor. Also\
    \ I wanted to keep it close to the original code (which was a for loop).\n<|/\
    \ c |>\n<| c |>\nI agree that `Set()` is unnecessary and `Set` constructor is\
    \ unnecessary. But the original code was a for loop and `Set` constructor is unnecessary\
    \ too. `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is unnecessary\
    \ because `Set` constructor is unnecessary because `Set` constructor is ", " \
    \   unique = Set()\n    for x in l\n        if !haskey(unique, x)\n          \
    \  unique[x] = true\n        end\n    end\n    return unique.value\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis code doesn't work. `unique` returns\
    \ a `Set` which doesn't have a `push` method. Also, `push!` doesn't exist either.\
    \ `push!` appends an element to the end of the `Vector`, but `unique` returns\
    \ a `Vector` which doesn't have a `push` method.\n<|/ c |>\n<| c |>\nI fixed the\
    \ code (I hope). `push!` does exist and works as expected.\n<|/ c |>\n<| c |>\n\
    I fixed the code (I hope). `push!` does exist and works as expected.\n<|/ c |>\n\
    <| c |>\nI fixed the code (I hope). `push!` does exist and works as expected.\n\
    <|/ c |>\n<| c |>\nI fixed the code (I hope). `push!` does exist and works as\
    \ expected.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a package for this:\nhttps://github.com/jrm/UniqueArrays.jl\n\
    <code>\njulia> using UniqueArrays", "    unique = Set()\n    for x in l\n    \
    \    if !unique.contains(x)\n            unique.add(x)\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis does\
    \ not answer the question. `unique` does not remove duplicates.\n<|/ c |>\n<|\
    \ c |>\nI agree with you. My answer was meant to be a starting point for OP to\
    \ solve his problem.\n<|/ c |>\n<| a tags=julia,arrays |>\nThe function unique\
    \ in Julia is defined as:\n<code>", "    unique = Set()\n    for x in l\n    \
    \    if !haskey(unique, x)\n            unique[x] = true\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\nI came up with a solution that is very similar to what has suggested, but\
    \ I wanted to share it here in case anyone else is interested.\n<code>", "   \
    \ unique = Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !unique.contains(x)\n          \
    \  unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
