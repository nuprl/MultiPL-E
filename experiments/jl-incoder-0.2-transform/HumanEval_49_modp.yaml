name: HumanEval_49_modp
language: jl
prompt: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n \
  \   3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
  \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
  \ p::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
  \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
  @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
  \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
completions: ["    if n == 0 \n        then return 1\n    else if p == 0 \n      \
    \  then return 0\n    else if p == 1 \n        then return n\n    else if p <\
    \ 0 \n        then return modp(abs(n), abs(p))\n    else if p > 1 \n        then\
    \ return modp(n, p - 1)\n    else if n < 0 \n        then return modp(-n, p)\n\
    \    else if n > p \n        then return modp(n, p - 1)\n    else \n        then\
    \ return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>", "    if\
    \ p == 0 \n        then return 0\n    else if n <= p \n        then return 1\n\
    \    else \n        modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 \n        then\
    \ return 0\n    else if p == 0 \n        then return 1\n    else if n <= p \n\
    \        then return modp(n - 1, p) \n        else return modp((n - p) / 2, p)\
    \ \nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,algorithm,modular-arithmetic\
    \ |>\n<code>", "    if n == 0 \n        then return 1\n    else if p == 0 \n \
    \       then return 0\n    else if p < n \n        then return modp(n - p, p)\n\
    \    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\
    \"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n==0 then return 1\
    \ \n    if n==1 then return p \n    if n==p then return 1 \n    if n<p then return\
    \ modp(modp(n,p)+p, p) \n    else return modp(n%p, p) \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return n*(n+1)/2\n    if p==4\
    \ then return n*(n+1)/2\n    if p==5 then return n*(n+1)/2\n    if p==6 then return\
    \ n*(n+1)/2\n    if p==7 then return n*(n+1)/2\n    if p==8 then return n*(n+1)/2\n\
    \    if p==9 then return n*(n+1)/2\n    if p==10 then return n*(n+1)/2\n    if\
    \ p==11 then return n*(n+1)/2\n    if p==12 then return n*(n+1)/2\n    if p==13\
    \ then return n*(n+1)/2\n    if p==14 then return n*(n+1)/2\n    if p==15 then\
    \ return n*(n+1)/2\n    if p==16 then return n*(n+1)/2\n    if p==17 then return\
    \ n*(n+1)/2\n    if p==18 then return n*(n+1)/2\n    if p==19 then return n*(n+1)/2\n\
    \    if p==20 then return n*(n+1)/2\n    if p==21 then return n*(n+1)/2\n    if\
    \ p==22 then return n*(n+1)/2\n    if p==23 then return n*(n+1)/2\n    if p==24\
    \ then return n*(n+1)/2\n    if p==25 then return n*(n+1)/2\n    if p==26 then\
    \ return n*(n+1)/2\n    if p==27 then return n*(n+1)/2\n    if p==28 then return\
    \ n*(n+1)/2\n    if p==29 then return n*(n+1)/2\n    if p==30 then return n*(n+1)/2\n\
    \    if p==31 then return n*(n+1)/2\n    if p==32 then return n*(n+1)/2\n    if\
    \ p==33 then return n*(n+1)/2\n    if p==34 then return n*(n+1)/2\n    if p==35\
    \ then return n*(n+1)/2\n    if p==36 then return n*(n+1)/2\n    if p==37 then\
    \ return n*(n+1)/2\n    if p==38 then return n*(n+1)/2\n    if p==39 then return\
    \ n*(n+1)/2\n    if p==40 then return n*(n+1)/2\n    if p==41 then return n*(n+1)/2\n\
    \    if p==42 then return n*(n+1)/2\n    if p==43 then return n*(n+1)/2\n    if\
    \ p==44 then return n*(n+1)/2\n    if p==45 ", "    if n == 0 \n        return\
    \ 1 \n    else if p == 0 \n        return 0 \n    else if n <= p \n        return\
    \ modp(n - 1, p) \n    else \n        return modp(n / p, p) \nend \n</cell>\n\
    <code language=julia-1.4>", "    if n < p \n        then return n \n        else\
    \ return modp(n - p, p) \n    end\nend\n</cell>\n<code language=julia-1.5>", " \
    \   if n==0 || p==0 \n        then return 0\n    else if n==1\n        then return\
    \ p\n    else if p==1\n        then return n\n    else if p==2\n        then return\
    \ modp(n-1, 2)\n    else if p==3\n        then return modp(n-1, 3)\n    else if\
    \ p==4\n        then return modp(n-1, 4)\n    else if p==5\n        then return\
    \ modp(n-1, 5)\n    else if p==6\n        then return modp(n-1, 6)\n    else if\
    \ p==7\n        then return modp(n-1, 7)\n    else if p==8\n        then return\
    \ modp(n-1, 8)\n    else if p==9\n        then return modp(n-1, 9)\n    else if\
    \ p==10\n        then return modp(n-1, 10)\n    else if p==11\n        then return\
    \ modp(n-1, 11)\n    else if p==12\n        then return modp(n-1, 12)\n    else\
    \ if p==13\n        then return modp(n-1, 13)\n    else if p==14\n        then\
    \ return modp(n-1, 14)\n    else if p==15\n        then return modp(n-1, 15)\n\
    \    else if p==16\n        then return modp(n-1, 16)\n    else if p==17\n   \
    \     then return modp(n-1, 17)\n    else if p==18\n        then return modp(n-1,\
    \ 18)\n    else if p==19\n        then return modp(n-1, 19)\n    else if p==20\n\
    \        then return modp(n-1, 20)\n    else if p==21\n        then return modp(n-1,\
    \ 21)\n    else if p==22\n        then return modp(n-1, 22)\n    else if p==23\n\
    \        then return modp(n-1, 23)\n    else if p==24\n        then return modp(n-1,\
    \ 24)\n    else if p==25\n        then return modp(n-1, 25)\n    else if p==26\n\
    \        then return modp(n-1, 26)\n    else if p==27\n        then return modp(n-1,\
    \ 27)\n    else if p==28\n        then return modp(n-1, 28)\n    else if p==29\n\
    \        then return modp(n-1, 29)\n    else if p==30\n        then return modp(n-1,\
    \ 30)\n    else if p==", "    if n == 0 \n        then return 1\n    else if p\
    \ == 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-abs(n), abs(p))\n   \
    \ else if n < p \n        then return modp(abs(n), p)\n    else if n == p \n \
    \       then return n\n    else if n % p == 0\n        then return modp(n / p,\
    \ p)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n   \
    \ >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "    if n == 0 then return\
    \ 1\n    if p == 0 then return 0\n    if p < 0 then return modp(abs(n), abs(p))\n\
    \    if p < 2 then return modp(n >> 1, p)\n    if p < 4 then return modp(n >>\
    \ 2, p)\n    if p < 8 then return modp(n >> 3, p)\n    if p < 16 then return modp(n\
    \ >> 4, p)\n    if p < 32 then return modp(n >> 5, p)\n    if p < 64 then return\
    \ modp(n >> 6, p)\n    if p < 128 then return modp(n >> 7, p)\n    if p < 256\
    \ then return modp(n >> 8, p)\n    if p < 512 then return modp(n >> 9, p)\n  \
    \  if p < 1024 then return modp(n >> 10, p)\n    if p < 2048 then return modp(n\
    \ >> 11, p)\n    if p < 4096 then return modp(n >> 12, p)\n    if p < 8192 then\
    \ return modp(n >> 13, p)\n    if p < 16384 then return modp(n >> 14, p)\n   \
    \ if p < 32768 then return modp(n >> 15, p)\n    if p < 65536 then return modp(n\
    \ >> 16, p)\n    if p < 131072 then return modp(n >> 17, p)\n    if p < 262144\
    \ then return modp(n >> 18, p)\n    if p < 524288 then return modp(n >> 19, p)\n\
    \    if p < 1048576 then return modp(n >> 20, p)\n    if p < 2097152 then return\
    \ modp(n >> 21, p)\n    if p < 4194304 then return modp(n >> 22, p)\n    if p\
    \ < 8388608 then return modp(n >> 23, p)\n    if p < 16777216 then return modp(n\
    \ >> 24, p)\n    if p < 33554432 then return modp(n >> 25, p)\n    if p < 67108864\
    \ then return modp(n >> 26, p)\n    if p < 134217728 then return modp(n >> 27,\
    \ p)\n    if p < 268435456 then return modp(n >> 28, p)\n    if p < 536870912\
    \ then return modp(n >> 29, p)\n    if p < 1073741824 then return modp(n >> 30,\
    \ p)\n    if p < 2147483648 then return modp(n >> 31, p)\n    if p < 4294967296\
    \ then return modp(n >> 32, p)\n    if p < 8589934592 then ", "    if p == 0 \n\
    \        then return 0\n    else if n == 0 \n        then return p\n    else if\
    \ p < 0 \n        then return modp(-n, p)\n    else if n < 0 \n        then return\
    \ modp(-n, p)\n    else if p < n \n        then return modp(n, p)\n    else if\
    \ n < p \n        then return modp(n, p)\n    else \n        then return modp(n\
    \ + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>", "    if n <= 0\n    \
    \    error(\"n must be positive\")\n    else if p <= 0\n        error(\"p must\
    \ be positive\")\n    else if p < n\n        error(\"p must be larger than n\"\
    )\n    else if p == 1\n        error(\"p is prime\")\n    else if p == n\n   \
    \     error(\"p is composite\")\n    else if n % p == 0\n        error(\"p is\
    \ not a prime number\")\n    else\n        return modp(n - 1, p) * (p - 1) % p\n\
    end", "    if n == 0 \n        then return 1\n    else if p == 0 \n        then\
    \ return 0\n    else if p == 1 \n        then return n\n    else if p < 0 \n \
    \       then return modp(-n, p)\n    else if p < n \n        then return modp(n,\
    \ p)\n    else return modp(n + p - 1, p)\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 \n        then return 1\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), abs(p))\n    else if\
    \ n < 0 \n        then return modp(-abs(n), abs(p))\n    else if n < p \n    \
    \    then return modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n),\
    \ p)\n    else if n < p \n        then return modp(abs(n), p)\n    else if n <\
    \ p \n        then return modp(-abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n), p)\n\
    \    else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(-abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n), p)\n\
    \    else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(-abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n), p)\n\
    \    else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(-abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n), p)\n\
    \    else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(-abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n), p)\n\
    \    else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return modp(-abs(n), p)\n    else if n < p \n        then return\
    \ modp(abs(n), p)\n    else if n < p \n        then return modp(-abs(n), p)\n\
    \    else if n < p \n        then return modp(abs(n), p)\n    else if n < p \n\
    \        then return mod", "    if n == 0 \n        then return 1\n    else if\
    \ p == 0 \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else if n == p \n      \
    \  then return 1\n    else \n        then return modp(n - p, p)\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. `modp(3, -5)`\
    \ returns `3` instead of `2`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. The function works with negative numbers. I tested it on Julia 1.5.1\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 too. `modp(3, -5)` returns `3` instead\
    \ of `2`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. The\
    \ function works with negative numbers. I tested it on Julia 1.5.1\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.1 too. `modp(3, -5)` returns `3` instead of\
    \ `2`.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution that uses only integer arithmetic:\n\
    <code>", "    if n <= p \n        then return n \n    else \n        modp(n /\
    \ p, p) \nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,modular-arithmetic\
    \ |>\nThe algorithm is simple and straightforward:\n<code>\ndef modpow(a, n):\n\
    \    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    if n\
    \ % 2 == 0:\n        return modpow(a * a, n // 2)\n    else:\n        return modpow(a\
    \ * a, (n - 1) // 2)\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,modular-arithmetic\
    \ |>\n<code>\ndef modpow(x, n):\n    if n == 0:\n        return 1\n    if n ==\
    \ 1:\n        return x\n    if n % 2 == 0:\n        return modpow(x * x, n //\
    \ 2)\n    else:\n        return modpow(x * x, (n - 1) // 2)\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\ndef modpow(x, n):\n    if n == 0:\n        return\
    \ 1\n    if n == 1:\n        return x\n    if n % 2 == 0:\n        return modpow(x\
    \ * x, n // 2)\n    else:\n        return modpow(x * x, (n - 1) // 2)\n</code>\n\
    <|/ a tags=math,algorithm,modular-arithmetic |>\n<| a dscore=1 |>\n<code>\ndef\
    \ modpow(x, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ x\n    if n % 2 == 0:\n        return modpow(x * x, n // 2)\n    else:\n   \
    \     return modpow(x * x, (n - 1) // 2)\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| a dscore=1 |>\n<code>\ndef modpow(x, n):\n    if n == 0:\n        return\
    \ 1\n    if n == 1:\n        return x\n    if n % 2 == 0:\n        return modpow(x\
    \ * x, n // 2)\n    else:\n        return modpow(x * x, (n - 1) // 2)\n</code>\n\
    <|/ a tags=math,algorithm,modular-arithmetic |>\n<| a dscore=1 |>\n<code>\ndef\
    \ modpow(x, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return\
    \ x\n    if n % 2 == 0:\n        return modpow(x * x, n // 2)\n    else:\n   \
    \     return modpow(x * x, (n - 1) // 2)\n</code>\n<|/ a tags=math,algorithm,modular-arithmetic\
    \ |>\n<| a tags=math,algorithm,modular-arithmetic |>\n<code>\ndef modpow(x, n):",
  "    if n==0 then return 1\n    if n==1 then return p\n    if p==0 then return 0\n\
    \    if p==1 then return 1\n    if p==2 then return n\n    if p==3 then return\
    \ modp(n-1, 2)\n    if p==4 then return modp(n-1, 3)\n    if p==5 then return\
    \ modp(n-1, 4)\n    if p==6 then return modp(n-1, 5)\n    if p==7 then return\
    \ modp(n-1, 6)\n    if p==8 then return modp(n-1, 7)\n    if p==9 then return\
    \ modp(n-1, 8)\n    if p==10 then return modp(n-1, 9)\n    if p==11 then return\
    \ modp(n-1, 10)\n    if p==12 then return modp(n-1, 11)\n    if p==13 then return\
    \ modp(n-1, 12)\n    if p==14 then return modp(n-1, 13)\n    if p==15 then return\
    \ modp(n-1, 14)\n    if p==16 then return modp(n-1, 15)\n    if p==17 then return\
    \ modp(n-1, 16)\n    if p==18 then return modp(n-1, 17)\n    if p==19 then return\
    \ modp(n-1, 18)\n    if p==20 then return modp(n-1, 19)\n    if p==21 then return\
    \ modp(n-1, 20)\n    if p==22 then return modp(n-1, 21)\n    if p==23 then return\
    \ modp(n-1, 22)\n    if p==24 then return modp(n-1, 23)\n    if p==25 then return\
    \ modp(n-1, 24)\n    if p==26 then return modp(n-1, 25)\n    if p==27 then return\
    \ modp(n-1, 26)\n    if p==28 then return modp(n-1, 27)\n    if p==29 then return\
    \ modp(n-1, 28)\n    if p==30 then return modp(n-1, 29)\n    if p==31 then return\
    \ modp(n-1, 30)\n    if p==32 then return modp(n-1, 31)\n    if p==33 then return\
    \ modp(n-1, 32)\n    if p==34 then return modp(n-1, 33)\n    if p==35 then return\
    \ modp(n-1, 34)\n    if p==36 then return modp(n-1, 35)\n    if p==37 then return\
    \ modp(n-1, 36)\n    if p==38 then return modp(n-1, 37)\n    if p==39 then return\
    \ modp(n-1, 38)\n    if p==40 then return modp(n-1, 39)", "    if n==0 then return\
    \ 1\n    if n==1 then return p\n    if p==0 then return 0\n    if p==1 then return\
    \ 1\n    if p==2 then return n\n    if p==3 then return modp(n-1, 2)\n    if p==4\
    \ then return modp(n-1, 3)\n    if p==5 then return modp(n-1, 4)\n    if p==6\
    \ then return modp(n-1, 5)\n    if p==7 then return modp(n-1, 6)\n    if p==8\
    \ then return modp(n-1, 7)\n    if p==9 then return modp(n-1, 8)\n    if p==10\
    \ then return modp(n-1, 9)\n    if p==11 then return modp(n-1, 10)\n    if p==12\
    \ then return modp(n-1, 11)\n    if p==13 then return modp(n-1, 12)\n    if p==14\
    \ then return modp(n-1, 13)\n    if p==15 then return modp(n-1, 14)\n    if p==16\
    \ then return modp(n-1, 15)\n    if p==17 then return modp(n-1, 16)\n    if p==18\
    \ then return modp(n-1, 17)\n    if p==19 then return modp(n-1, 18)\n    if p==20\
    \ then return modp(n-1, 19)\n    if p==21 then return modp(n-1, 20)\n    if p==22\
    \ then return modp(n-1, 21)\n    if p==23 then return modp(n-1, 22)\n    if p==24\
    \ then return modp(n-1, 23)\n    if p==25 then return modp(n-1, 24)\n    if p==26\
    \ then return modp(n-1, 25)\n    if p==27 then return modp(n-1, 26)\n    if p==28\
    \ then return modp(n-1, 27)\n    if p==29 then return modp(n-1, 28)\n    if p==30\
    \ then return modp(n-1, 29)\n    if p==31 then return modp(n-1, 30)\n    if p==32\
    \ then return modp(n-1, 31)\n    if p==33 then return modp(n-1, 32)\n    if p==34\
    \ then return modp(n-1, 33)\n    if p==35 then return modp(n-1, 34)\n    if p==36\
    \ then return modp(n-1, 35)\n    if p==37 then return modp(n-1, 36)\n    if p==38\
    \ then return modp(n-1, 37)\n    if p==39 then return modp(n-1, 38)\n    if p==40\
    \ then return modp(n-1, 39)", "    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if p < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 0 \n        error(\"modp requires non-zero integers\")\n \
    \   else if p == 1 \n        return n\n    else \n        return modp(n - 1, p)\
    \ \nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
