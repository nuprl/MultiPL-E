language: jl
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2vl7q1ta.jl:30\nin expression starting at\
    \ /tmp/tmp2vl7q1ta.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = Dict{String,\
    \ Int}()\n    for extension in extensions\n        extension_strength[extension]\
    \ = length(extension) - length(replace(extension, uppercase(extension), \"\"))\n\
    \    end\n    \n    sorted_extensions = sort(collect(extension_strength.values))\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = reverse(collect(sorted_extensions))\n    \n   \
    \ sorted_extensions = collect(sorted_extensions)\n    \n    sorted_extensions\
    \ = reverse(collect(sorted_extensions))\n    \n    sorted_extensions = collect(sorted_extensions)\n\
    \    \n    sorted_extensions = \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpch_g97ug.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpch_g97ug.jl:1\n\
    in expression starting at /tmp/tmpch_g97ug.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1 \n    \n    for extension in extensions_sorted\n    \
    \    \n        extension_upper = uppercase(extension)\n        extension_lower\
    \ = lowercase(extension)\n        \n        if extension_upper == extension_lower\n\
    \            \n            strength = strength + 1 \n            \n        elseif\
    \ extension_upper == extension_lower\n            \n            strength = strength\
    \ + 0.5 \n            \n        elseif extension_upper == extension_lower\n  \
    \          \n            strength = strength + 0.25 \n            \n        elseif\
    \ extension_upper == extension_lower\n            \n            strength = strength\
    \ + 0.125 \n            \n        elseif extension_upper == extension_lower\n\
    \            \n            strength = strength + 0.0625 \n            \n     \
    \   elseif extension_upper == extension_lower\n            \n            strength\
    \ = strength + 0.03125 \n            \n        elseif extension_upper == extension_lower\n\
    \            \n            strength = strength + 0.015625\n            \n    \
    \    elseif extension_upper == extension_lower\n            \n            strength\
    \ = strength + 0.0078125 \n            \n        elseif extension_upper == extension_lower\n\
    \            \n            strength = strength + 0.00390625 \n            \n \
    \       elseif extension_upper == extension_lower\n            \n            strength\
    \ = strength + 0.001953125 \n            \n        elseif extension_upper == extension_lower\n\
    \            \n            strength = strength + 0.0009765625 \n            \n\
    \        elseif extension_upper == extension_lower\n            \n           \
    \ strength = strength + 0.000703125 \n            \n        elseif extension_upper\
    \ == extension_lower\n            \n            strength = strength + 0.0005078125\
    \ \n            \n        elseif extension_upper == extension_lower\n        \
    \    \n            strength = strength + 0.00039453125 \n            \n      \
    \  elseif extension_upper == extension_lower\n            \n            strength\
    \ = strength + 0.0001953125 \n            \n        elseif extension_upper ==\
    \ extension_lower\n            \n            strength = strength + 0.0001220703125\
    \ \n            \n        elseif extension_upper == extension_lower\n        \
    \    \n            strength = strength + 0.00006103515625\n            \n    \
    \    elseif extension_upper == extension_lower\n            \n            strength\
    \ = strength + 0.000030517578125\n            \n        elseif extension_upper\
    \ == extension_lower\n            \n            strength = strength + 0.0000152587890625\n\
    \            \n        elseif extension_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpce5gvasb.jl:1\nin expression starting at /tmp/tmpce5gvasb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    \n    if strength_of_extension == -1\n        return class_name\n \
    \   else\n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp780jpcm_.jl:25\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp780jpcm_.jl:1\n\
    in expression starting at /tmp/tmp780jpcm_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,ext) in enumerate(extensions)\n        extension_strength[i]\
    \ = length(ext) - length(replace(ext, uppercase(ext), \"\"))\n    end\n    \n\
    \    idx = findfirst(x -> x > 0, extension_strength)\n    if idx == nothing\n\
    \        return class_name\n    end\n    \n    idx = idx[1]\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = findfirst(x -> x <\
    \ 0, extension_strength)\n    if idx == nothing\n        return class_name\n \
    \   end\n    \n    idx = idx[1]\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = findfirst(x -> x > 0, extension_strength)\n\
    \    if idx == nothing\n        return class_name\n    end\n    \n    idx = idx[1]\n\
    \    \n    if extension_strength[idx] == 0\n        return class_name\n    end\n\
    \    \n    idx = findfirst(x -> x < 0, extension_strength)\n    if idx == nothing\n\
    \        return class_name\n    end\n    \n    idx = idx[1]\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = findfirst(x -> x >\
    \ 0, extension_strength)\n    if idx == nothing\n        return class_name\n \
    \   end\n    \n    idx = idx[1]\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = findfirst(x -> x < 0, extension_strength)\n\
    \    if idx == nothing\n        return class_name\n    end\n    \n    idx = idx[1]\n\
    \    \n    if extension_strength[idx] == 0\n        return class_name\n    end\n\
    \    \n    idx = findfirst(x -> x > 0, extension_strength)\n    if idx == nothing\n\
    \        return class_name\n    end\n    \n    idx = idx[1]\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = findfirst(x -> x <\
    \ 0, extension_strength)\n    if idx == nothing\n        return class_name\n \
    \   end\n    \n    idx = idx[1]\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = findfirst(x -> x > 0, extension_strength)\n\
    \    if idx == nothing\n        return class_name\n    end\n    \n    idx = idx[1]\n\
    \    \n    if extension_strength[idx] == 0\n        return class_name\n    end\n\
    \    \n    idx = findfirst(x -> x < 0, extension_strength)\n    if idx == nothing\n\
    \        return class_name\n    end\n    \n    idx = idx[1]\n    \n    if extension_strength\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0nvwfgfv.jl:1\nin expression starting at /tmp/tmp0nvwfgfv.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and a list\
    \ of strings as arguments and returns a string with the first letter of each string\
    \ in the list repeated n times. \nFor example, if the list is [\"a\", \"b\", \"\
    c\"] and the integer n is 2, the function should return \"aaa\".\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdo9dzl4u.jl:30\nin expression starting at\
    \ /tmp/tmpdo9dzl4u.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and a list\
    \ of strings as arguments and returns the string with the longest common prefix.\
    \ \nFor example, if the input string is \"abcde\" and a list of strings is [\"\
    ab\", \"cd\", \"e\"], the function should return \"ab\".\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpflpg8but.jl:30\nin expression starting at\
    \ /tmp/tmpflpg8but.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.Be\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.HH\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.II\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.KK\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\", \"OO\"]) == \"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl_gk_f6p.jl:30\nin expression starting at\
    \ /tmp/tmpl_gk_f6p.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1\n    \n    for extension in extensions_sorted\n     \
    \   \n        if isupper(extension)\n            \n            strength = strength\
    \ + length(extension) - length(extension)\n            \n        elseif islower(extension)\n\
    \            \n            strength = strength + length(extension) - length(extension)\n\
    \            \n        else\n            \n            strength = strength + length(extension)\
    \ - length(extension)\n            \n        end\n        \n    end\n    \n  \
    \  if strength > 0\n        \n        return class_name .. \".\" .. extensions_sorted[end]\n\
    \        \n    else\n        \n        return class_name\n        \n    end\n\
    \    \nend\n</cell>\n<code language=julia-1.5>\n@time Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string and a list of strings as arguments and returns a string with\
    \ the first string in the list concatenated with the second string. \nExample:\
    \ \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.a\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.ab\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\", [\"a\", \"b\", \"c\"])\n\"my_string.abc\"\
    \n>>> Concatenate_Strings(\"my_string\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaif_pk37.jl:53\nin expression starting at\
    \ /tmp/tmpaif_pk37.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        \n        strength = length(extensions_sorted)\n   \
    \     \n    end\n    \n    return class_name * \".\" .* extensions_sorted[strength]\n\
    end\n</cell>\n<text>\nProblem 4\nWrite a function that takes as input a class\
    \ name and a list of extensions, and returns the name of the class with the strongest\
    \ extension.\nExample: \n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"])\n    \"my_class.AA\"\n\"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3q32wkd1.jl:32\nin expression starting at\
    \ /tmp/tmp3q32wkd1.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        \n        extensions_sorted = sort(extensions)\n        \n        strength_of_extension\
    \ = extensions_sorted[1] - extensions_sorted[2]\n        \n        if strength_of_extension\
    \ == -1\n            return class_name\n        else\n            \n         \
    \   extensions_sorted = sort(extensions)\n            \n            strength_of_extension\
    \ = extensions_sorted[1] - extensions_sorted[2]\n            \n            if\
    \ strength_of_extension == -1\n                return class_name\n           \
    \ else\n                \n                extensions_sorted = sort(extensions)\n\
    \                \n                strength_of_extension = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                \n                if strength_of_extension\
    \ == -1\n                    return class_name\n                else\n       \
    \             \n                    extensions_sorted = sort(extensions)\n   \
    \                 \n                    strength_of_extension = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                    \n                    if strength_of_extension\
    \ == -1\n                        return class_name\n                    else\n\
    \                        \n                        extensions_sorted = sort(extensions)\n\
    \                        \n                        strength_of_extension = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                        \n                        if\
    \ strength_of_extension == -1\n                            return class_name\n\
    \                        else\n                            \n                \
    \            extensions_sorted = sort(extensions)\n                          \
    \  \n                            strength_of_extension = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                            \n                     \
    \       if strength_of_extension == -1\n                                return\
    \ class_name\n                            else\n                             \
    \   \n                                extensions_sorted = sort(extensions)\n \
    \                               \n                                strength_of_extension\
    \ = extensions_sorted[1] - extensions_sorted[2]\n                            \
    \    \n                                if strength_of_extension == -1\n      \
    \                              return class_name\n                           \
    \     else\n                                    \n                           \
    \         extensions_sorted = sort(extensions)\n                             \
    \       \n                                    strength_of_extension = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                                    \n             \
    \                       if strength_of_extension == -1\n                     \
    \                   return class_name\n                                    else\n\
    \                                        \n                                  \
    \      extensions_sorted = sort(extensions)\n                                \
    \        \n                                        strength_of_extension = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                                        \n         \
    \                               if strength_of_extension == -1\n             \
    \                               return class_name\n                          \
    \              else\n                                            \n          \
    \                                  extensions_sorted = sort(extensions)\n    \
    \                                        \n                                  \
    \          strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \                                            \n                              \
    \              if strength_of_extension == -1\n                              \
    \                  return class_name\n                                       \
    \     else\n                                                \n               \
    \                                 extensions_sorted = sort(extensions)\n     \
    \                                           \n                               \
    \                 strength_of_extension = extensions_sorted\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpyylezll6.jl:104\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyylezll6.jl:1\n\
    in expression starting at /tmp/tmpyylezll6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp02kgbxdp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp02kgbxdp.jl:1\n\
    in expression starting at /tmp/tmp02kgbxdp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_map = Dict{String, Int}()\n    \n    for extension in extensions_sorted\n\
    \        \n        extension_upper = uppercase(extension)\n        \n        if\
    \ !haskey(strength_map, extension_upper)\n            strength_map[extension_upper]\
    \ = 1\n        else\n            strength_map[extension_upper] += 1\n        end\n\
    \    end\n    \n    strength_sorted = sort(strength_map, reverse=true)\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbtwniqq5.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbtwniqq5.jl:1\n\
    in expression starting at /tmp/tmpbtwniqq5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\
    \    The extensions are to be used to load additional classes to the class. The\n\
    \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n    You should find the strongest extension and return a string in this \n\
    \    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
    \ with the same strength, you should\n    choose the one that comes first in the\
    \ list.\n    For example, if you are given \"Slices\" as the class and a list\
    \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for i=1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i])-length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    extension_strength = sort(extension_strength)\n \
    \   \n    return class_name * \".\" * extensions[extension_strength[1]]\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a string and a list of\
    \ strings as arguments. \nThe function should return a string in the following\
    \ format: \n    ClassName[ExtensionName1, ExtensionName2, ..., ExtensionNameN]\n\
    For example, if the string was \"my_class\" and the list of strings was [\"AA\"\
    , \"Be\", \"CC\"] \nthen the function should return \"my_class.AA, my_class.Be,\
    \ my_class.CC\"\nHint: Use a for loop to iterate through the list of strings and\
    \ concatenate them to the string.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9rkfj4zf.jl:30\nin expression starting at\
    \ /tmp/tmp9rkfj4zf.jl:30\n"
  stdout: ''
