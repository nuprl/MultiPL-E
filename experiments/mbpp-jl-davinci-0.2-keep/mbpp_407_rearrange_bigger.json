{
  "name": "mbpp_407_rearrange_bigger",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\nfunction rearrange_bigger(n::Int64)::Any \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = rearrange_bigger;\n\t@test(candidate(12) == 21)\n\t@test(candidate(10) == false)\n\t@test(candidate(102) == 120)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[i] < digits[j]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_arr = [parse(Int64, i) for i in n_str]\n\t\n\tif length(n_arr) == 1\n\t\treturn -1\n\tend\n\t\n\ti = length(n_arr) - 1\n\twhile i > 1\n\t\tif n_arr[i] > n_arr[i - 1]\n\t\t\tbreak\n\t\tend\n\t\ti -= 1\n\tend\n\t\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\tj = length(n_arr)\n\twhile j > i\n\t\tif n_arr[j] > n_arr[i - 1]\n\t\t\tbreak\n\t\tend\n\t\tj -= 1\n\tend\n\t\n\tn_arr[i - 1], n_arr[j] = n_arr[j], n_arr[i - 1]\n\t\n\tn_arr[i:end] = sort(n_arr[i:end])\n\t\n\treturn parse(Int64, join(n_arr, \"\"))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i = 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the digit found above\n\t\t\t# that is larger than the digit found above\n\t\t\tsmallest_index = i+1\n\t\t\tfor j = i+1:length(n_str)\n\t\t\t\tif n_str[j] < n_str[smallest_index] && n_str[j] > n_str[i]\n\t\t\t\t\tsmallest_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the two digits\n\t\t\ttemp = n_str[i]\n\t\t\tn_str[i] = n_str[smallest_index]\n\t\t\tn_str[smallest_index] = temp\n\t\t\t# sort the digits to the right of the digit found above\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t# return the new number\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_list = [parse(Int64, i) for i in n_str]\n\tn_len = length(n_list)\n\t\n\t# find the first digit that is smaller than its right neighbor\n\tfor i in 1:n_len-1\n\t\tif n_list[i] < n_list[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit is found, the number is the largest possible\n\tif i == n_len-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:n_len\n\t\tif n_list[j] > n_list[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to the right of the pivot\n\tn_list[i], n_list[j] = n_list[j], n_list[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tn_list[i+1:n_len] = reverse(n_list[i+1:n_len])\n\t\n\t# convert the list to a string and return it\n\treturn join(n_list)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\t# and swap it with the pivot\n\t\t\tpivot = i\n\t\t\tsmallest = i+1\n\t\t\tfor j in i+2:length(n_str)\n\t\t\t\tif n_str[j] > n_str[pivot] && n_str[j] < n_str[smallest]\n\t\t\t\t\tsmallest = j\n\t\t\t\tend\n\t\t\tend\n\t\t\tn_str[pivot], n_str[smallest] = n_str[smallest], n_str[pivot]\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tn_str[pivot+1:end] = sort(n_str[pivot+1:end])\n\t\t\t# convert back to int\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i in 1:n_str_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_str_len\n\t\t\t\tif n_str[j] > n_str[i]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\tn_str[i+1:n_str_len] = sort(n_str[i+1:n_str_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# your code here\n\treturn 0\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_big",
    "\t# convert to string\n\tstr_n = string(n)\n\t# convert to array\n\tarr_n = [parse(Int64, str_n[i]) for i in 1:length(str_n)]\n\t# find the first decreasing element\n\tfor i in 2:length(arr_n)\n\t\tif arr_n[i] > arr_n[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if there is no decreasing element, return -1\n\tif i == length(arr_n)\n\t\treturn -1\n\tend\n\t# find the smallest element that is bigger than arr_n[i-1]\n\tmin_idx = i\n\tfor j in i:length(arr_n)\n\t\tif arr_n[j] > arr_n[i-1] && arr_n[j] < arr_n[min_idx]\n\t\t\tmin_idx = j\n\t\tend\n\tend\n\t# swap arr_n[i-1] and arr_n[min_idx]\n\tarr_n[i-1], arr_n[min_idx] = arr_n[min_idx], arr_n[i-1]\n\t# sort the rest of the array\n\tarr_n[i:end] = sort(arr_n[i:end])\n\t# convert back to number\n\treturn parse(Int64, join(arr_n))\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in length(digits):-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)\n\t\tif digits[i] > digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# check if the number is negative\n\tif n < 0\n\t\tprintln(\"The number is negative\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a single digit\n\tif n < 10\n\t\tprintln(\"The number is a single digit\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a palindrome\n\tif ispalindrome(n)\n\t\tprintln(\"The number is a palindrome\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tCreate the next bigger number by rearranging the digits of a given number.\n\t\n\tParameters\n\t----------\n\tn : Int64\n\t\tThe number to rearrange.\n\t\n\tReturns\n\t-------\n\tAny\n\t\tThe next bigger number.\n\t\"\"\"\n\t\n\t# Convert to string\n\tn_str = string(n)\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, the number is the largest possible\n\tif i == length(n_str)-1\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot with the smallest digit to its right\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\n\t# Sort the digits to the right of the pivot\n\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\n\t# Convert back to integer\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get the length of the string\n\tn_len = length(n_str)\n\t# get the last digit\n\tlast_digit = parse(Int64, n_str[n_len])\n\t# get the second last digit\n\tsecond_last_digit = parse(Int64, n_str[n_len-1])\n\t# if the last digit is greater than the second last digit\n\tif last_digit > second_last_digit\n\t\t# swap the digits\n\t\tn_str[n_len] = second_last_digit\n\t\tn_str[n_len-1] = last_digit\n\t\t# return the string\n\t\treturn n_str\n\telse\n\t\t# return -1\n\t\treturn -1\n\tend\nend",
    "\t# n = 123456789\n\t# n = 123456798\n\t# n = 123456879\n\t# n = 123456897\n\t# n = 123456978\n\t# n = 123456987\n\t# n = 123457689\n\t# n = 123457698\n\t# n = 123457869\n\t# n = 123457896\n\t# n = 123457968\n\t# n = 123457986\n\t# n = 123458679\n\t# n = 123458697\n\t# n = 123458769\n\t# n = 123458796\n\t# n = 123458967\n\t# n = 123458976\n\t# n = 123459678\n\t# n = 123459687\n\t# n = 123459768\n\t# n = 123459786\n\t# n = 123459867\n\t# n = 123459876\n\t# n = 123465789\n\t# n = 123465798\n\t# n = 123465879\n\t# n = 123465897\n\t# n = 123465978\n\t# n = 123465987\n\t# n = 123466579\n\t# n = 123466597\n\t# n = 123466759\n\t# n = 123466795\n\t# n = 123466957\n\t# n = 123466975\n\t# n = 123467459\n\t# n = 123467495\n\t# n = 123467549\n\t# n = 123467594\n\t# n = 123467954\n\t# n = 123467945\n\t# n = 123468549\n\t# n = 123468594\n\t# n = 123468954\n\t# n = 123468579\n\t# n = 123468597\n\t# n = 123468759\n\t# n = 123468795\n\t# n = 123468957\n\t# n = 123468975\n\t# n = 123469578\n\t# n = 123469587\n\t# n = 123469758\n\t# n = 123469785\n\t# n = 123469957\n\t# n = 123469975\n\t# n",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first decreasing element\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest element greater than n_arr[i]\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < n_arr[min_idx]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap\n\t\t\tn_arr[i], n_arr[min_idx] = n_arr[min_idx], n_arr[i]\n\t\t\t# sort the rest\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = \"\"\n\t\t\tfor i in 1:length(n_arr)\n\t\t\t\tn_str *= string(n_arr[i])\n\t\t\tend\n\t\t\t# convert to int\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\treturn n_int\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i = 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\t\t\tfor j = i+1:length(n_str)\n\t\t\t\tif n_str[j] > n_str[i]\n\t\t\t\t\t# swap the pivot with the smallest digit to its right\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\t# sort the digits to the right of the pivot\n\t\t\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t\t\t# return the new number\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if no bigger number exists, return -1\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\t# find the smallest digit in the right that is larger than n_str[i-1]\n\t\t\tsmallest_larger_idx = findfirst(x -> x > n_str[i-1], n_str[i:end])\n\t\t\t# swap the digits\n\t\t\tn_str[i-1], n_str[i+smallest_larger_idx-1] = n_str[i+smallest_larger_idx-1], n_str[i-1]\n\t\t\t# sort the digits in the right\n\t\t\tn_str[i:end] = sort(n_str[i:end])\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tfor i in 1:n_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_len\n\t\t\t\tif n_str[j] > n_str[i]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\tn_str[i+1:n_len] = sort(n_str[i+1:n_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) takes an integer n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, return -1.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] > digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(reverse(digits[i+1:end]), join(digits[1:i], \"\")))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[1:i],digits[i+1:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tif i == length(digits)\n\t\t\treturn -1\n\t\tend\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits[1:i+1]))*10^(length(digits)-i-1) + parse(Int64, join(reverse(digits[i+1:end])))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tReturn the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first decreasing element\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] > n_arr[i+1]\n\t\t\t# swap with the smallest element in the right side\n\t\t\t# that is bigger than the decreasing element\n\t\t\t# and sort the right side\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string and return\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\t# if no decreasing element is found, return -1\n\treturn -1\nend",
    "\t# n = 123456789\n\t# n = 123456798\n\t# n = 123456879\n\t# n = 123456897\n\t# n = 123456978\n\t# n = 123456987\n\t# n = 123457689\n\t# n = 123457698\n\t# n = 123457789\n\t# n = 123457798\n\t# n = 123457869\n\t# n = 123457896\n\t# n = 123457968\n\t# n = 123457986\n\t# n = 123458679\n\t# n = 123458697\n\t# n = 123458769\n\t# n = 123458796\n\t# n = 123458967\n\t# n = 123458976\n\t# n = 123459678\n\t# n = 123459687\n\t# n = 123459768\n\t# n = 123459786\n\t# n = 123459867\n\t# n = 123459876\n\t# n = 123465789\n\t# n = 123465798\n\t# n = 123465879\n\t# n = 123465897\n\t# n = 123465978\n\t# n = 123465987\n\t# n = 123466579\n\t# n = 123466597\n\t# n = 123466759\n\t# n = 123466795\n\t# n = 123466957\n\t# n = 123466975\n\t# n = 123467459\n\t# n = 123467495\n\t# n = 123467549\n\t# n = 123467594\n\t# n = 123467954\n\t# n = 123467945\n\t# n = 123468549\n\t# n = 123468594\n\t# n = 123468954\n\t# n = 123468579\n\t# n = 123468597\n\t# n = 123468759\n\t# n = 123468795\n\t# n = 123468957\n\t# n = 123468975\n\t# n = 123469547\n\t# n = 123469574\n\t# n = 123469754\n\t# n = 123469785\n\t# n",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_len = length(n_str)\n\tfor i in n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tn_str[i], n_str[i-1] = n_str[i-1], n_str[i]\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(123)\n\t132\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1243)\n\t1324\n\t\n\tjulia> rearrange_bigger(12345)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\t",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# Convert number to string\n\tn_str = string(n)\n\t# Convert string to array\n\tn_arr = [x for x in n_str]\n\t# Get the length of the array\n\tn_len = length(n_arr)\n\t# Create a new array to store the result\n\tn_res = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the result\n\tn_idx = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_old = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_old = collect(1:n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new = collect(1:n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp = collect(1:n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp2 = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp2 = collect(1:n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp3 = Array{Any}(undef, n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp3 = collect(1:n_len)\n\t# Create a new array to store the index of the original number\n\tn_idx_new_tmp4 = Array{Any}(undef",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t12453\n\t\n\tjulia> rearrange_bigger(12453)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345",
    "\t# Convert to string\n\tn_str = string(n)\n\t# Convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# Find the first decreasing element\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# Find the smallest element greater than n_arr[i]\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] < n_arr[min_idx] && n_arr[j] > n_arr[i]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# Swap\n\t\t\tn_arr[i], n_arr[min_idx] = n_arr[min_idx], n_arr[i]\n\t\t\t# Sort the remaining elements\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# Convert to string\n\t\t\tn_str = \"\"\n\t\t\tfor i in 1:length(n_arr)\n\t\t\t\tn_str = n_str * string(n_arr[i])\n\t\t\tend\n\t\t\t# Return\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t# If no such element exists\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t#find the first digit that is smaller than the one to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t#swap the two digits\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\t#sort the remaining digits\n\t\t\tn_arr[i+2:end] = sort(n_arr[i+2:end])\n\t\t\t#convert to string\n\t\t\tn_str = join(n_arr)\n\t\t\t#convert to int\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\treturn n_int\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first index where the number is smaller than the next number\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if the number is already the biggest possible, return -1\n\tif i == length(n_arr)\n\t\treturn -1\n\tend\n\t# find the smallest number that is bigger than the number at index i\n\t# and swap them\n\tfor j in i+1:length(n_arr)\n\t\tif n_arr[j] > n_arr[i]\n\t\t\ttmp = n_arr[i]\n\t\t\tn_arr[i] = n_arr[j]\n\t\t\tn_arr[j] = tmp\n\t\t\tbreak\n\t\tend\n\tend\n\t# sort the numbers after index i\n\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t# convert back to string and return\n\treturn parse(Int64, join(n_arr))\nend",
    "\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t21354",
    "\tdigits = collect(digits(n))\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\t\n\t# find the first digit from the right that is smaller than the digit to its right\n\tfor i in n_str_len:-1:1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, the number is the largest possible\n\tif i == 0\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:n_str_len\n\t\tif n_str[j] > n_str[i] && (j == i+1 || n_str[j] < n_str[j-1])\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to its right that is larger than the pivot\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tn_str[i+1:n_str_len] = reverse(n_str[i+1:n_str_len])\n\t\n\treturn parse(Int64, n_str)\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 987654321\n\t# n = 1234\n\t# n = 12\n\t# n = 123\n\t# n = 1234\n\t# n = 12345\n\t# n = 123456\n\t# n = 1234567\n\t# n = 12345678\n\t# n = 123456789\n\t# n = 1234567890\n\t# n = 12345678901\n\t# n = 123456789012\n\t# n = 1234567890123\n\t# n = 12345678901234\n\t# n = 123456789012345\n\t# n = 1234567890123456\n\t# n = 12345678901234567\n\t# n = 123456789012345678\n\t# n = 1234567890123456789\n\t# n = 12345678901234567890\n\t# n = 123456789012345678901\n\t# n = 1234567890123456789012\n\t# n = 12345678901234567890123\n\t# n = 123456789012345678901234\n\t# n = 1234567890123456789012345\n\t# n = 12345678901234567890123456\n\t# n = 123456789012345678901234567\n\t# n = 1234567890123456789012345678\n\t# n = 12345678901234567890123456789\n\t# n = 123456789012345678901234567890\n\t# n = 1234567890123456789012345678901\n\t# n = 12345678901234567890123456789012\n\t# n = 123456789012345678901234567890123\n\t# n = 1234567890123456789012345678901234\n\t# n = 12345678901234567890123456789012345\n\t# n = 123456789012345678901234567",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_str_arr = collect(n_str)\n\tn_str_arr_rev = reverse(n_str_arr)\n\tfor i in 1:n_str_len-1\n\t\tif n_str_arr_rev[i] > n_str_arr_rev[i+1]\n\t\t\tn_str_arr_rev[i], n_str_arr_rev[i+1] = n_str_arr_rev[i+1], n_str_arr_rev[i]\n\t\t\tn_str_arr = reverse(n_str_arr_rev)\n\t\t\treturn parse(Int64, join(n_str_arr))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tThis function takes an integer and returns the next bigger integer by rearranging the digits of the given number.\n\t\"\"\"\n\tn_string = string(n)\n\tn_length = length(n_string)\n\tn_array = [parse(Int64, n_string[i]) for i in 1:n_length]\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:n_length-1\n\t\tif n_array[i] < n_array[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, the number is the largest possible\n\tif i == n_length-1\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:n_length\n\t\tif n_array[j] > n_array[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot with the smallest digit to its right\n\tn_array[i], n_array[j] = n_array[j], n_array[i]\n\t\n\t# Reverse the digits to the right of the pivot\n\tn_array[i+1:n_length] = reverse(n_array[i+1:n_length])\n\t\n\t# Convert the array to a string and return the result\n\treturn parse(Int64, join(n_array))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first decreasing digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit greater than n_arr[i]\n\t\t\tmin_digit = n_arr[i+1]\n\t\t\tmin_digit_index = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < min_digit\n\t\t\t\t\tmin_digit = n_arr[j]\n\t\t\t\t\tmin_digit_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the digits\n\t\t\tn_arr[i], n_arr[min_digit_index] = n_arr[min_digit_index], n_arr[i]\n\t\t\t# sort the digits after i\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string and return\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\treturn -1\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i in 1:n_str_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_str_len\n\t\t\t\tif n_str[i] < n_str[j]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit that is bigger than the digit at i\n\t\t\tmin_bigger = n_arr[i+1]\n\t\t\tmin_bigger_index = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < min_bigger\n\t\t\t\t\tmin_bigger = n_arr[j]\n\t\t\t\t\tmin_bigger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the digits\n\t\t\tn_arr[i], n_arr[min_bigger_index] = n_arr[min_bigger_index], n_arr[i]\n\t\t\t# sort the digits after i\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string and return\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\t# if no digit is smaller than the next digit, return -1\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first decreasing digit\n\ti = length(digits) - 1\n\twhile i > 1 && digits[i] >= digits[i-1]\n\t\ti -= 1\n\tend\n\t\n\t# if no decreasing digit found, then no rearrangement possible\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the decreasing digit\n\t# that is greater than the decreasing digit\n\tj = i\n\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\tj += 1\n\tend\n\t\n\t# swap the decreasing digit with the smallest digit to the right\n\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\n\t# reverse the digits to the right of the decreasing digit\n\tdigits[i:end] = reverse(digits[i:end])\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_str_arr = collect(n_str)\n\tn_arr = collect(n)\n\t\n\t# find the first digit that is smaller than the digit to its right\n\tfor i = n_str_len-1:-1:1\n\t\tif n_str_arr[i] < n_str_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if all digits are in descending order, no bigger number can be formed\n\tif i == 0\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit on the right side of (i-1)th digit that is greater than the (i-1)th digit\n\tx = n_str_arr[i]\n\tsmallest = i\n\tfor j = i+1:n_str_len\n\t\tif n_str_arr[j] > n_str_arr[i-1] && n_str_arr[j] < x\n\t\t\tsmallest = j\n\t\t\tx = n_str_arr[j]\n\t\tend\n\tend\n\t\n\t# swap the smallest digit with (i-1)th digit\n\tn_str_arr[i-1], n_str_arr[smallest] = n_str_arr[smallest], n_str_arr[i-1]\n\t\n\t# sort the digits after (i-1)th digit in ascending order\n\tn_str_arr[i:n_str_len] = sort(n_str_arr[i:n_str_len])\n\t\n\t# convert the array back to number\n\tn_str_arr = join(n_str_arr)\n\tn_str_arr = parse(Int64, n_str_arr)\n\t\n\treturn n_str_arr\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = collect(digits(n))\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_string = string(n)\n\t#convert to array\n\tn_array = [char for char in n_string]\n\t#find the first digit that is smaller than the one after it\n\tfor i in 1:length(n_array)\n\t\tif n_array[i] < n_array[i+1]\n\t\t\t#swap the two digits\n\t\t\tn_array[i], n_array[i+1] = n_array[i+1], n_array[i]\n\t\t\t#convert to string\n\t\t\tn_string = join(n_array)\n\t\t\t#convert to integer\n\t\t\tn = parse(Int64, n_string)\n\t\t\treturn n\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\t# find the smallest digit that is bigger than digits[i-1]\n\t\t\t# and swap it with digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\ttmp = digits[j-1]\n\t\t\tdigits[j-1] = digits[i-1]\n\t\t\tdigits[i-1] = tmp\n\t\t\t# sort the digits after digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) takes an integer n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, return -1.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tif n_len == 1\n\t\treturn -1\n\tend\n\tfor i in 1:n_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_len\n\t\t\t\tif n_str[i] < n_str[j]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\treturn parse(Int64, n_str[1:i] * sort(n_str[i+1:n_len]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\trearrange_bigger(n) takes a number n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, return -1.\n\t\"\"\"\n\t\n\t# Convert n to a string\n\tn_string = string(n)\n\t\n\t# Create an array of the digits of n\n\tn_digits = [parse(Int64, n_string[i]) for i in 1:length(n_string)]\n\t\n\t# Find the first digit from the right that is smaller than the digit to its right\n\tfor i in length(n_digits):-1:2\n\t\tif n_digits[i] > n_digits[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, return -1\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the digit found above that is larger than the digit found above\n\tfor j in i:length(n_digits)\n\t\tif n_digits[j] > n_digits[i-1] && (j == i || n_digits[j] <= n_digits[j-1])\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the digits found above\n\tn_digits[i-1], n_digits[j] = n_digits[j], n_digits[i-1]\n\t\n\t# Reverse the digits to the right of the digit found above\n\tn_digits[i:end] = reverse(n_digits[i:end])\n\t\n\t# Convert the array of digits to a number\n\treturn parse(Int64, join(n_digits))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get length of string\n\tn_len = length(n_str)\n\t# get the last digit\n\tlast_digit = parse(Int64, n_str[end])\n\t# get the second last digit\n\tsecond_last_digit = parse(Int64, n_str[end-1])\n\t# get the third last digit\n\tthird_last_digit = parse(Int64, n_str[end-2])\n\t# get the fourth last digit\n\tfourth_last_digit = parse(Int64, n_str[end-3])\n\t# get the fifth last digit\n\tfifth_last_digit = parse(Int64, n_str[end-4])\n\t# get the sixth last digit\n\tsixth_last_digit = parse(Int64, n_str[end-5])\n\t# get the seventh last digit\n\tseventh_last_digit = parse(Int64, n_str[end-6])\n\t# get the eighth last digit\n\teighth_last_digit = parse(Int64, n_str[end-7])\n\t# get the ninth last digit\n\tninth_last_digit = parse(Int64, n_str[end-8])\n\t# get the tenth last digit\n\ttenth_last_digit = parse(Int64, n_str[end-9])\n\t# get the eleventh last digit\n\televenth_last_digit = parse(Int64, n_str[end-10])\n\t# get the twelfth last digit\n\ttwelfth_last_digit = parse(Int64, n_str[end-11])\n\t# get the thirteenth last digit\n\tthirteenth_last_digit = parse(Int64, n_str[end-12])\n\t# get the fourteenth last digit\n\tfourteenth_last_digit = parse(Int64, n_str[end-13])\n\t# get the fifteenth last digit\n\tfifteenth_last_digit = parse(Int64, n_str[end-14])\n\t# get the sixteenth last digit\n\tsixteenth_last_digit = parse(Int64, n_str[end-15",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, the number is the largest possible\n\tif i == length(n_arr)-1\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(n_arr)\n\t\tif n_arr[j] > n_arr[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot with the smallest digit to the right of the pivot\n\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t\n\t# Sort the digits to the right of the pivot\n\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\n\t# Convert the array to a string and return it\n\treturn join(string.(n_arr))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t21354\n\t\n\tjulia> rearrange",
    "\t# check if n is a positive integer\n\tif n < 0\n\t\treturn \"Error: n must be a positive integer\"\n\tend\n\t# check if n is a single digit\n\tif n < 10\n\t\treturn \"Error: n must be a positive integer with at least two digits\"\n\tend\n\t# convert n to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# check if n is already the largest number\n\tif i == length(n_str)-1\n\t\treturn \"Error: n is already the largest number\"\n\tend\n\t# find the smallest digit to the right of n_str[i] that is larger than n_str[i]\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap n_str[i] and n_str[j]\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t# sort the digits to the right of n_str[i]\n\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t# convert n_str to integer\n\treturn parse(Int64, n_str)\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\t# find the smallest digit greater than n_str[i-1]\n\t\t\tsmallest_greater_idx = i\n\t\t\tfor j = i+1:n_str_len\n\t\t\t\tif n_str[j] > n_str[i-1] && n_str[j] < n_str[smallest_greater_idx]\n\t\t\t\t\tsmallest_greater_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap\n\t\t\ttmp = n_str[i-1]\n\t\t\tn_str[i-1] = n_str[smallest_greater_idx]\n\t\t\tn_str[smallest_greater_idx] = tmp\n\t\t\t# sort the rest\n\t\t\tn_str[i:n_str_len] = sort(n_str[i:n_str_len])\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\t\tjulia> rearrange_bigger(12345)\n\t\t12354\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i in 1:n_str_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_str_len\n\t\t\t\tif n_str[j] > n_str[i]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\tn_str[i+1:n_str_len] = sort(n_str[i+1:n_str_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\ti = length(digits) - 1\n\twhile i > 1\n\t\tif digits[i] > digits[i-1]\n\t\t\tbreak\n\t\tend\n\t\ti -= 1\n\tend\n\tif i == 1\n\t\treturn -1\n\tend\n\tj = length(digits)\n\twhile j > i\n\t\tif digits[j] > digits[i-1]\n\t\t\tbreak\n\t\tend\n\t\tj -= 1\n\tend\n\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\tdigits[i:end] = reverse(digits[i:end])\n\treturn parse(Int64, join(digits))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\treturn parse(Int64, join(reverse(digits[i+1:end]), \"\"))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# n = 12345\n\t# n_str = \"12345\"\n\t# n_str[1] = \"1\"\n\t# n_str[2] = \"2\"\n\t# n_str[3] = \"3\"\n\t# n_str[4] = \"4\"\n\t# n_str[5] = \"5\"\n\t# n_str[6] = \"6\"\n\t# n_str[7] = \"7\"\n\t# n_str[8] = \"8\"\n\t# n_str[9] = \"9\"\n\t# n_str[10] = \"10\"\n\t# n_str[11] = \"11\"\n\t# n_str[12] = \"12\"\n\t# n_str[13] = \"13\"\n\t# n_str[14] = \"14\"\n\t# n_str[15] = \"15\"\n\t# n_str[16] = \"16\"\n\t# n_str[17] = \"17\"\n\t# n_str[18] = \"18\"\n\t# n_str[19] = \"19\"\n\t# n_str[20] = \"20\"\n\t# n_str[21] = \"21\"\n\t# n_str[22] = \"22\"\n\t# n_str[23] = \"23\"\n\t# n_str[24] = \"24\"\n\t# n_str[25] = \"25\"\n\t# n_str[26] = \"26\"\n\t# n_str[27] = \"27\"\n\t# n_str[28] = \"28\"\n\t# n_str[29] = \"29\"\n\t# n_str[30] = \"30\"\n\t# n_str[31] = \"31\"\n\t# n_str[32] = \"32\"\n\t# n_str[33] = \"33\"\n\t# n_str[34] = \"34\"\n\t# n_str[35] = \"35\"\n\t# n_str[36] = \"36\"\n\t# n_str[37] = \"37\"\n\t# n_str[38] = \"38\"",
    "\t# convert to string\n\tstr_n = string(n)\n\t# convert to array\n\tarr_n = [parse(Int64, str_n[i]) for i in 1:length(str_n)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(arr_n)-1\n\t\tif arr_n[i] < arr_n[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tfor j in i+1:length(arr_n)\n\t\t\t\tif arr_n[j] > arr_n[i]\n\t\t\t\t\t# swap the pivot with the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\t\t\tarr_n[i], arr_n[j] = arr_n[j], arr_n[i]\n\t\t\t\t\t# sort the digits to the right of the pivot in ascending order\n\t\t\t\t\tarr_n[i+1:end] = sort(arr_n[i+1:end])\n\t\t\t\t\t# convert to string\n\t\t\t\t\tstr_n = join(arr_n)\n\t\t\t\t\t# convert to int\n\t\t\t\t\treturn parse(Int64, str_n)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits)-1:-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64,n_str[i]) for i in 1:length(n_str)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] < n_arr[min_idx] && n_arr[j] > n_arr[i]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot with the smallest digit to its right\n\t\t\tn_arr[i], n_arr[min_idx] = n_arr[min_idx], n_arr[i]\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = join(n_arr)\n\t\t\t# convert to int\n\t\t\tn = parse(Int64,n_str)\n\t\t\t# return the new number\n\t\t\treturn n\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[j-1]\n\t\t\tdigits[j-1] = temp\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10 \n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tswap!(digits, i, i+1)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_len = length(n_str)\n\t\n\t# Check if number is already the biggest possible\n\tif n_str == string(10^n_len - 1)\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the smallest possible\n\tif n_str == string(10^(n_len-1))\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the biggest possible\n\tif n_str == string(10^n_len - 1)\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the smallest possible\n\tif n_str == string(10^(n_len-1))\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the biggest possible\n\tif n_str == string(10^n_len - 1)\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the smallest possible\n\tif n_str == string(10^(n_len-1))\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the biggest possible\n\tif n_str == string(10^n_len - 1)\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the smallest possible\n\tif n_str == string(10^(n_len-1))\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the biggest possible\n\tif n_str == string(10^n_len - 1)\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the smallest possible\n\tif n_str == string(10^(n_len-1))\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the biggest possible\n\tif n_str == string(10^n_len - 1)\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the smallest possible\n\tif n_str == string(10^(n_len-1))\n\t\treturn -1\n\tend\n\t\n\t# Check if number is already the biggest possible\n\tif",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string, split into chars, sort, join, convert back to int\n\treturn parse(Int64, join(sort(split(string(n)))))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first decreasing digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit larger than n_arr[i]\n\t\t\tsmallest_larger = n_arr[i+1]\n\t\t\tsmallest_larger_index = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < smallest_larger\n\t\t\t\t\tsmallest_larger = n_arr[j]\n\t\t\t\t\tsmallest_larger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap n_arr[i] and smallest_larger\n\t\t\tn_arr[i], n_arr[smallest_larger_index] = n_arr[smallest_larger_index], n_arr[i]\n\t\t\t# sort the rest of the array\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# return the result\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\t# if no decreasing digit is found, return -1\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12453\n\t\n\tjulia> rearrange_bigger(12453)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t12543\n\t\n\tjulia> rearrange_bigger(12543)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t154",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[1:i+1]))*10^(length(digits)-i-1) + parse(Int64, join(reverse(digits[i+1:end])))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\ttemp = digits[i-1]\n\t\t\tdigits[i-1] = digits[j-1]\n\t\t\tdigits[j-1] = temp\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\tdigits = digits(n)\n\tif digits[end] > digits[end-1]\n\t\treturn n\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[end-i] > digits[end-i-1]\n\t\t\ttemp = digits[end-i]\n\t\t\tdigits[end-i] = digits[end-i-1]\n\t\t\tdigits[end-i-1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in length(digits):-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i-1]\n\t\t\tdigits[i-1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# Convert the number to a string\n\ts = string(n)\n\t# Convert the string to an array of characters\n\ta = collect(s)\n\t# Get the length of the array\n\tl = length(a)\n\t# Initialize a variable to store the index of the pivot\n\tp = 0\n\t# Loop through the array\n\tfor i in 1:l-1\n\t\t# If the current element is greater than the next element\n\t\tif a[i] > a[i+1]\n\t\t\t# Set the pivot to the current index\n\t\t\tp = i\n\t\t\t# Break the loop\n\t\t\tbreak\n\t\tend\n\tend\n\t# If the pivot is not zero\n\tif p != 0\n\t\t# Initialize a variable to store the index of the successor\n\t\ts = 0\n\t\t# Loop through the array from the pivot to the end\n\t\tfor i in p:l\n\t\t\t# If the current element is greater than the pivot\n\t\t\tif a[i] > a[p]\n\t\t\t\t# Set the successor to the current index\n\t\t\t\ts = i\n\t\t\t\t# Break the loop\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\t# Swap the pivot and the successor\n\t\ta[p], a[s] = a[s], a[p]\n\t\t# Reverse the array from the pivot to the end\n\t\treverse!(a, p+1:l)\n\t\t# Return the array as a string\n\t\treturn join(a)\n\t# If the pivot is zero\n\telse\n\t\t# Return -1\n\t\treturn -1\n\tend\nend",
    "\t\"\"\"\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tn_arr = zeros(Int64, n_len)\n\tfor i in 1:n_len\n\t\tn_arr[i] = parse(Int64, n_str[i])\n\tend\n\tn_arr_sorted = sort(n_arr, rev=true)\n\tif n_arr == n_arr_sorted\n\t\treturn -1\n\telse\n\t\tn_arr_sorted_str = \"\"\n\t\tfor i in 1:n_len\n\t\t\tn_arr_sorted_str = n_arr_sorted_str * string(n_arr_sorted[i])\n\t\tend\n\t\tn_arr_sorted_int = parse(Int64, n_arr_sorted_str)\n\t\tn_arr_sorted_int_str = string(n_arr_sorted_int)\n\t\tn_arr_sorted_int_str_len = length(n_arr_sorted_int_str)\n\t\tn_arr_sorted_int_str_arr = zeros(Int64, n_arr_sorted_int_str_len)\n\t\tfor i in 1:n_arr_sorted_int_str_len\n\t\t\tn_arr_sorted_int_str_arr[i] = parse(Int64, n_arr_sorted_int_str[i])\n\t\tend\n\t\tn_arr_sorted_int_str_arr_sorted = sort(n_arr_sorted_int_str_arr)\n\t\tn_arr_sorted_int_str_arr_sorted_str = \"\"\n\t\tfor i in 1:n_arr_sorted_int_str_len\n\t\t\tn_arr_sorted_int_str_arr_sorted_str = n_arr_sorted_int_str_arr_sorted_str * string(n_arr_sorted_int_str_arr_sorted[i])",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of characters\n\tn_arr = collect(n_str)\n\t# find the first decreasing digit from the right\n\tfor i in 1:length(n_arr)\n\t\tif n_arr[end-i] > n_arr[end-i+1]\n\t\t\t# swap with the smallest digit to the right that is bigger than the decreasing digit\n\t\t\tfor j in 1:length(n_arr)-i\n\t\t\t\tif n_arr[end-i] < n_arr[end-i+j]\n\t\t\t\t\t# swap\n\t\t\t\t\ttemp = n_arr[end-i+j]\n\t\t\t\t\tn_arr[end-i+j] = n_arr[end-i]\n\t\t\t\t\tn_arr[end-i] = temp\n\t\t\t\t\t# sort the digits to the right of the decreasing digit\n\t\t\t\t\tn_arr[end-i+1:end] = sort(n_arr[end-i+1:end])\n\t\t\t\t\t# convert to string\n\t\t\t\t\tn_str = join(n_arr)\n\t\t\t\t\t# convert to integer\n\t\t\t\t\tn_int = parse(Int64, n_str)\n\t\t\t\t\treturn n_int\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123",
    "\t\"\"\"\n\tGiven a number, rearrange the digits to create the next bigger number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j in i:length(digits)\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\ttemp = digits[j]\n\t\t\t\t\tdigits[j] = digits[i-1]\n\t\t\t\t\tdigits[i-1] = temp\n\t\t\t\t\tbreak\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\n\tif digits == digits(n)\n\t\treturn \"No bigger number possible\"\n\tend\n\treturn parse(Int64, join(digits))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first decreasing element\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] > n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if all elements are decreasing, return -1\n\tif i == length(n_arr)\n\t\treturn -1\n\tend\n\t# find the smallest element greater than n_arr[i]\n\tmin_idx = i+1\n\tfor j in i+1:length(n_arr)\n\t\tif n_arr[j] > n_arr[i] && n_arr[j] < n_arr[min_idx]\n\t\t\tmin_idx = j\n\t\tend\n\tend\n\t# swap n_arr[i] and n_arr[min_idx]\n\tn_arr[i], n_arr[min_idx] = n_arr[min_idx], n_arr[i]\n\t# sort the rest of the array\n\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t# convert to string and return\n\treturn parse(Int64, join(n_arr, \"\"))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# swap the two digits\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\t# convert back to string\n\t\t\tn_str = join(n_arr)\n\t\t\t# convert back to integer\n\t\t\tn = parse(Int64, n_str)\n\t\t\treturn n\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[i] < digits[j]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#rearrange the digits of a given number to create the next bigger number\n\t#if the number is already the biggest possible, return -1\n\t#if the number is negative, return -1\n\tif n < 0\n\t\treturn -1\n\tend\n\t\n\t#convert the number to a string\n\tn_string = string(n)\n\t\n\t#find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_string)-1\n\t\tif n_string[i] < n_string[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t#if no such digit exists, the number is already the biggest possible\n\tif i == length(n_string)-1\n\t\treturn -1\n\tend\n\t\n\t#find the smallest digit to the right of the digit found above that is larger than it\n\tfor j in i+1:length(n_string)\n\t\tif n_string[j] > n_string[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t#swap the two digits\n\ttemp = n_string[i]\n\tn_string[i] = n_string[j]\n\tn_string[j] = temp\n\t\n\t#sort the digits to the right of the swapped digits\n\tn_string[i+1:end] = sort(n_string[i+1:end])\n\t\n\t#convert the string back to an integer\n\treturn parse(Int64, n_string)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[j]\n\t\t\t\t\tdigits[j] = digits[i]\n\t\t\t\t\tdigits[i] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[i+1:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array of chars\n\tn_arr = collect(n_str)\n\t#find the first index where the next digit is smaller than the current one\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t#if no such index exists, return -1\n\tif i == length(n_arr)-1\n\t\treturn -1\n\tend\n\t#find the smallest digit that is bigger than n_arr[i]\n\tmin_index = i+1\n\tfor j in i+2:length(n_arr)\n\t\tif n_arr[j] > n_arr[i] && n_arr[j] < n_arr[min_index]\n\t\t\tmin_index = j\n\t\tend\n\tend\n\t#swap the digits at i and min_index\n\ttemp = n_arr[i]\n\tn_arr[i] = n_arr[min_index]\n\tn_arr[min_index] = temp\n\t#sort the digits after i\n\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t#convert back to string\n\tn_str = join(n_arr)\n\t#convert to int\n\tn_int = parse(Int64, n_str)\n\treturn n_int\nend",
    "\tdigits = digits(n)\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tsmallest_larger_index = i+1\n\t\t\tfor j in i+2:length(digits)\n\t\t\t\tif digits[j] > digits[i] && digits[j] < digits[smallest_larger_index]\n\t\t\t\t\tsmallest_larger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot with the smallest larger digit\n\t\t\tdigits[i], digits[smallest_larger_index] = digits[smallest_larger_index], digits[i]\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t# return the new number\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\treturn -1\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\n\t# n = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tReturn the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t-------\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t21354\n\t\n\tjulia> rearrange_",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tif i == length(digits)\n\t\treturn -1\n\tend\n\t\n\tfor j in length(digits):-1:i+1\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\tdigits[i+1:end] = sort(digits[i+1:end], rev=true)\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tmin_index = i+1\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] < digits[min_index] && digits[j] > digits[i]\n\t\t\t\t\tmin_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[min_index]\n\t\t\tdigits[min_index] = temp\n\t\t\t\n\t\t\treturn parse(Int64, join(digits[i:end]))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tThis function takes an integer and returns the next bigger number by rearranging the digits of a given number.\n\tIf no bigger number exists, it returns -1.\n\t\"\"\"\n\t\n\t# convert the number to a string\n\tn_string = string(n)\n\t\n\t# find the length of the string\n\tn_length = length(n_string)\n\t\n\t# find the index of the first digit that is smaller than the digit to its right\n\tfor i in 1:n_length-1\n\t\tif n_string[i] < n_string[i+1]\n\t\t\tindex = i\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, return -1\n\tif index == 0\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the digit at index that is larger than the digit at index\n\tfor i in index+1:n_length\n\t\tif n_string[i] > n_string[index]\n\t\t\tindex2 = i\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the digits at index and index2\n\tn_string[index], n_string[index2] = n_string[index2], n_string[index]\n\t\n\t# sort the digits to the right of index\n\tn_string[index+1:n_length] = sort(n_string[index+1:n_length])\n\t\n\t# convert the string back to an integer\n\treturn parse(Int64, n_string)\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\tn_str = string(n)\n\t\n\tif length(n_str) == 1\n\t\treturn -1\n\tend\n\t\n\t# find the first decreasing digit from the right\n\tdecreasing_digit_index = length(n_str)\n\tfor i in length(n_str):-1:1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tdecreasing_digit_index = i\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tif decreasing_digit_index == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit greater than the decreasing digit\n\tsmallest_digit_index = decreasing_digit_index + 1\n\tfor i in decreasing_digit_index+1:length(n_str)\n\t\tif n_str[i] > n_str[decreasing_digit_index] && n_str[i] < n_str[smallest_digit_index]\n\t\t\tsmallest_digit_index = i\n\t\tend\n\tend\n\t\n\t# swap the decreasing digit with the smallest digit\n\ttemp = n_str[decreasing_digit_index]\n\tn_str[decreasing_digit_index] = n_str[smallest_digit_index]\n\tn_str[smallest_digit_index] = temp\n\t\n\t# sort the digits to the right of the decreasing digit\n\tn_str[decreasing_digit_index+1:length(n_str)] = sort(n_str[decreasing_digit_index+1:length(n_str)])\n\t\n\treturn parse(Int64, n_str)\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\tfor j in length(digits):i+1\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, then the number is already the largest possible\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to its right\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# sort the digits to the right of the pivot\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\n\t# convert the digits back to an integer\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\tGiven an integer n, return the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be made, return -1.\n\t\"\"\"\n\t\n\t# Convert n to a string\n\tn_str = string(n)\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, return -1\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot and the smallest digit to its right\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\n\t# Sort the digits to the right of the pivot\n\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\n\t# Convert the string to an integer\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\treturn parse(Int64, join(digits[1:i]..., digits[i+1], digits[i], digits[i+2:end]...))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tfor j = n_str_len:-1:i\n\t\t\t\tif n_str[j] > n_str[i-1]\n\t\t\t\t\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\t\t\t\t\tn_str[i:end] = sort(n_str[i:end])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t#find the first index where the next number is bigger\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t#swap\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\t#sort the rest\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end], rev=true)\n\t\t\t#convert to string\n\t\t\tn_str = join(n_arr)\n\t\t\t#convert to int\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\treturn n_int\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# create a list of digits\n\tdigits = digits(n)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit to the right of the digit that is smaller than the digit to its right\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\t# swap the two digits\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\t# sort the digits to the right of the digit that is smaller than the digit to its right\n\t\t\t\t\tsort!(digits[i+1:end])\n\t\t\t\t\t# return the number\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[i] < digits[j]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) takes an integer n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, it returns -1.\n\t\"\"\"\n\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j = length(digits):-1:i\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\t\t\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\t# get the digits of n\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the digit after it\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, return -1\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit that is bigger than digits[i]\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap digits[i] and digits[j]\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# sort the digits after digits[i]\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\n\t# return the rearranged number\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\trearrange_bigger(n) returns the next bigger number than n by rearranging the digits of n.\n\tIf there is no bigger number, it returns -1.\n\t\n\tExample:\n\tjulia> rearrange_bigger(123)\n\t132\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1243)\n\t1324\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange",
    "\t\"\"\"\n\tThis function rearranges the digits of a given number to create the next bigger number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_str_arr = collect(n_str)\n\tn_str_arr_sorted = sort(n_str_arr)\n\tn_str_arr_sorted_rev = reverse(n_str_arr_sorted)\n\tn_str_arr_sorted_rev_str = join(n_str_arr_sorted_rev)\n\tn_str_arr_sorted_rev_str_int = parse(Int64, n_str_arr_sorted_rev_str)\n\tif n_str_arr_sorted_rev_str_int == n\n\t\treturn -1\n\tend\n\tfor i in 1:n_str_len\n\t\tif n_str_arr_sorted_rev[i] > n_str_arr[n_str_len-i+1]\n\t\t\tn_str_arr_sorted_rev[i], n_str_arr[n_str_len-i+1] = n_str_arr[n_str_len-i+1], n_str_arr_sorted_rev[i]\n\t\t\tn_str_arr_sorted_rev_str = join(n_str_arr_sorted_rev)\n\t\t\tn_str_arr_sorted_rev_str_int = parse(Int64, n_str_arr_sorted_rev_str)\n\t\t\treturn n_str_arr_sorted_rev_str_int\n\t\tend\n\tend\nend",
    "\t# get all permutations of the digits of n\n\tperms = permutations(digits(n))\n\t# sort the permutations in ascending order\n\tperms = sort(perms)\n\t# find the index of n in the sorted permutations\n\tidx = findall(x->x==n, perms)[1]\n\t# return the next bigger number\n\treturn perms[idx+1]\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\ttemp = digits[i-1]\n\t\t\tdigits[i-1] = digits[j-1]\n\t\t\tdigits[j-1] = temp\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n)",
    "\t# Convert to string\n\tn_str = string(n)\n\t# Convert to array of chars\n\tn_arr = collect(n_str)\n\t# Find the first element from the right that is smaller than the next element\n\tfor i in length(n_arr):-1:1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# Find the smallest element to the right of i that is larger than n_arr[i]\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i]\n\t\t\t\t\t# Swap i and j\n\t\t\t\t\ttemp = n_arr[i]\n\t\t\t\t\tn_arr[i] = n_arr[j]\n\t\t\t\t\tn_arr[j] = temp\n\t\t\t\t\t# Sort the rest of the array\n\t\t\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t\t\t# Convert to string and return\n\t\t\t\t\treturn parse(Int64, join(n_arr))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# If no such element is found, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits[1:i], digits[i+1:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_str_arr = [parse(Int64, n_str[i]) for i in 1:n_str_len]\n\tn_str_arr_rev = reverse(n_str_arr)\n\tfor i in 1:n_str_len\n\t\tif n_str_arr_rev[i] > n_str_arr_rev[i+1]\n\t\t\tn_str_arr_rev[i], n_str_arr_rev[i+1] = n_str_arr_rev[i+1], n_str_arr_rev[i]\n\t\t\tbreak\n\t\tend\n\tend\n\tn_str_arr_rev = reverse(n_str_arr_rev)\n\tn_str_arr_rev_str = \"\"\n\tfor i in 1:n_str_len\n\t\tn_str_arr_rev_str *= string(n_str_arr_rev[i])\n\tend\n\treturn parse(Int64, n_str_arr_rev_str)\nend",
    "\t\"\"\"\n\tThis function rearranges the digits of a given number to create the next bigger number.\n\t\"\"\"\n\tdigits = digits(n)\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# If all digits are in descending order, then the next bigger number is not possible\n\tif i == length(digits)-1\n\t\treturn \"Not possible\"\n\tend\n\t# Find the smallest digit on the right side of (i-1)'th digit that is greater than digits[i-1]\n\tx = digits[i]\n\tsmallest = i\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > x && digits[j] < digits[smallest]\n\t\t\tsmallest = j\n\t\tend\n\tend\n\t# Swap the above found smallest digit with digits[i-1]\n\tdigits[i], digits[smallest] = digits[smallest], digits[i]\n\t# Sort the digits after digits[i-1] in ascending order\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t# Return the next bigger number\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_length = length(n_str)\n\tfor i in n_length:-1:1\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tn_str[i], n_str[i-1] = n_str[i-1], n_str[i]\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tInput: n::Int64\n\tOutput: Any\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_rev = string(reverse(n_str))\n\tn_str_rev_sorted = sort(n_str_rev)\n\tn_str_sorted = string(reverse(n_str_rev_sorted))\n\tif n_str_sorted == n_str\n\t\treturn -1\n\tend\n\tn_str_sorted_int = parse(Int64, n_str_sorted)\n\treturn n_str_sorted_int\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) takes an integer n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, it returns -1.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tif n_len == 1\n\t\treturn -1\n\tend\n\tfor i in n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tfor j in i:n_len\n\t\t\t\tif n_str[j] > n_str[i-1]\n\t\t\t\t\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\t\t\t\t\tn_str = n_str[1:i] * sort(n_str[i:n_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tlen_digits = length(digits)\n\tfor i in len_digits:-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j in i:len_digits\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\ttemp = digits[i-1]\n\t\t\t\t\tdigits[i-1] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[1:i]..., join(sort(digits[i:len_digits])...)))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = sort(digits(n))\n\tfor i in reverse(1:length(digits))\n\t\tif digits[i] > digits[i-1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i-1]\n\t\t\tdigits[i-1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get the length of the string\n\tn_len = length(n_str)\n\t# create an array of the digits\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:n_len]\n\t# find the index of the first digit that is smaller than the digit to its right\n\tfor i in 1:n_len-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\tif i == n_len\n\t\treturn -1\n\tend\n\t# find the smallest digit to the right of the digit found above that is larger than it\n\tfor j in i+1:n_len\n\t\tif n_arr[j] > n_arr[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the digits\n\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t# sort the digits to the right of the digit found above in ascending order\n\tn_arr[i+1:n_len] = sort(n_arr[i+1:n_len])\n\t# convert the array to a string\n\tn_str = join(n_arr)\n\t# convert the string to an integer\n\tn_int = parse(Int64, n_str)\n\t# return the integer\n\treturn n_int\nend",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end], rev=true)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) takes an integer n and returns the next bigger number that can be formed by rearranging the digits of n.\n\t\n\tIf no bigger number can be formed, the function returns -1.\n\t\"\"\"\n\t\n\t# convert n to a string\n\tn_string = string(n)\n\t\n\t# find the first digit from the right that is smaller than the digit to its left\n\tfor i in 1:length(n_string)-1\n\t\tif n_string[end-i] < n_string[end-i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, return -1\n\tif i == length(n_string)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of n_string[end-i] that is larger than n_string[end-i]\n\tfor j in 1:length(n_string)-i\n\t\tif n_string[end-i] < n_string[end-i-j]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap n_string[end-i] and n_string[end-i-j]\n\tn_string[end-i], n_string[end-i-j] = n_string[end-i-j], n_string[end-i]\n\t\n\t# sort the digits to the right of n_string[end-i] in ascending order\n\tn_string[end-i+1:end] = sort(n_string[end-i+1:end])\n\t\n\t# convert n_string back to an integer\n\treturn parse(Int64, n_string)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#rearrange the digits of a given number\n\t#to create the next bigger number\n\t#if it's not possible, return -1\n\t\n\t#convert the number to a string\n\t#and split it into an array of chars\n\tn_str = string(n)\n\tn_arr = split(n_str, \"\")\n\t\n\t#find the first digit that is smaller than the one after it\n\t#and store its index\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tfirst_smaller = i\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t#if no such digit exists, return -1\n\tif first_smaller == nothing\n\t\treturn -1\n\tend\n\t\n\t#find the smallest digit that is bigger than the digit at first_smaller\n\t#and store its index\n\tsmallest_bigger = first_smaller + 1\n\tfor i in first_smaller+1:length(n_arr)\n\t\tif n_arr[i] > n_arr[first_smaller] && n_arr[i] < n_arr[smallest_bigger]\n\t\t\tsmallest_bigger = i\n\t\tend\n\tend\n\t\n\t#swap the digits\n\tn_arr[first_smaller], n_arr[smallest_bigger] = n_arr[smallest_bigger], n_arr[first_smaller]\n\t\n\t#sort the digits after the first_smaller\n\tn_arr[first_smaller+1:end] = sort(n_arr[first_smaller+1:end])\n\t\n\t#convert the array of chars to a string\n\t#and convert the string to an integer\n\tn_str = join(n_arr, \"\")\n\tn = parse(Int64, n_str)\n\t\n\treturn n\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# Get the digits of the number\n\tdigits = digits(n)\n\t# Get the length of the number\n\tlen = length(digits)\n\t# Get the last digit\n\tlast = digits[len]\n\t# Get the second last digit\n\tsecond_last = digits[len-1]\n\t# Get the third last digit\n\tthird_last = digits[len-2]\n\t# Get the fourth last digit\n\tfourth_last = digits[len-3]\n\t# Get the fifth last digit\n\tfifth_last = digits[len-4]\n\t# Get the sixth last digit\n\tsixth_last = digits[len-5]\n\t# Get the seventh last digit\n\tseventh_last = digits[len-6]\n\t# Get the eighth last digit\n\teighth_last = digits[len-7]\n\t# Get the ninth last digit\n\tninth_last = digits[len-8]\n\t# Get the tenth last digit\n\ttenth_last = digits[len-9]\n\t# Get the eleventh last digit\n\televenth_last = digits[len-10]\n\t# Get the twelfth last digit\n\ttwelfth_last = digits[len-11]\n\t# Get the thirteenth last digit\n\tthirteenth_last = digits[len-12]\n\t# Get the fourteenth last digit\n\tfourteenth_last = digits[len-13]\n\t# Get the fifteenth last digit\n\tfifteenth_last = digits[len-14]\n\t# Get the sixteenth last digit\n\tsixteenth_last = digits[len-15]\n\t# Get the seventeenth last digit\n\tseventeenth_last = digits[len-16]\n\t# Get the eighteenth last digit\n\teighteenth_last = digits[len-17]\n\t# Get the nineteenth last digit\n\tnineteenth_last = digits[len-18]\n\t# Get the twentieth last digit\n\ttwentieth_last = digits[len-19]\n\t# Get the twenty first last digit\n\ttwenty_first_last = digits[len-20]\n\t# Get the twenty second last digit\n\ttwenty_second_last = digits[len-21]\n\t# Get the twenty third",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# swap the two digits\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\t# convert back to string\n\t\t\tn_str = join(n_arr)\n\t\t\t# convert to integer\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\t# return the integer\n\t\t\treturn n_int\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tdigits_sorted = sort(digits)\n\tif digits == digits_sorted\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)\n\t\tif digits[i] != digits_sorted[i]\n\t\t\tj = findfirst(digits_sorted .== digits[i])\n\t\t\tdigits[i], digits_sorted[j] = digits_sorted[j], digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\treturn parse(Int64, join(digits_sorted))\nend",
    "\t#rearrange the digits of a given number to create the next bigger number\n\t#if the number is already the biggest, return -1\n\t#if the number is a single digit, return -1\n\t#if the number is negative, return -1\n\t#if the number is 0, return -1\n\t#if the number is a float, return -1\n\t#if the number is a string, return -1\n\t#if the number is a character, return -1\n\t#if the number is a boolean, return -1\n\t#if the number is a complex, return -1\n\t#if the number is a rational, return -1\n\t#if the number is an integer, return the next bigger number\n\t#if the number is an array, return -1\n\t#if the number is a tuple, return -1\n\t#if the number is a dictionary, return -1\n\t#if the number is a set, return -1\n\t#if the number is a range, return -1\n\t#if the number is a struct, return -1\n\t#if the number is a module, return -1\n\t#if the number is a function, return -1\n\t#if the number is a type, return -1\n\t#if the number is a pointer, return -1\n\t#if the number is a weak reference, return -1\n\t#if the number is a task, return -1\n\t#if the number is a channel, return -1\n\t#if the number is a condition, return -1\n\t#if the number is a finalizer, return -1\n\t#if the number is a generator, return -1\n\t#if the number is a coroutine, return -1\n\t#if the number is a task, return -1\n\t#if the number is a channel, return -1\n\t#if the number is a condition, return -1\n\t#if the number is a finalizer, return -1\n\t#if the number is a generator, return -1\n\t#if the number is a coroutine, return -1\n\t#if the number is a task, return -1\n\t#if the number is a channel, return -1\n\t#if the number is a condition, return -1\n\t#if the number",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# swap the digits\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\t# convert back to string\n\t\t\tn_str = join(n_arr)\n\t\t\t# convert back to integer\n\t\t\tn = parse(Int64, n_str)\n\t\t\treturn n\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# find the first digit from the right that is smaller than the one to its right\n\t# find the smallest digit to its right that is bigger than the digit found in step 1\n\t# swap the digits found in steps 1 and 2\n\t# sort the digits to the right of the digit found in step 1 in ascending order\n\t# return the number\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[end-i] > digits[end-i+1]\n\t\t\tfor j in end-i+1:end\n\t\t\t\tif digits[j] > digits[end-i]\n\t\t\t\t\tdigits[j], digits[end-i] = digits[end-i], digits[j]\n\t\t\t\t\tdigits[end-i+1:end] = sort(digits[end-i+1:end])\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_len = length(n_str)\n\tfor i in n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tj = i\n\t\t\twhile j < n_len && n_str[j] > n_str[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tn_str[i-1], n_str[j-1] = n_str[j-1], n_str[i-1]\n\t\t\tn_str[i:n_len] = sort(n_str[i:n_len])\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)\n\t\tif digits[i] > digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\t# Convert to string\n\tn_str = string(n)\n\t\n\t# Find the first digit that can be swapped\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no digit can be swapped, return -1\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit that is larger than n_str[i]\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the digits\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\n\t# Sort the digits after the swapped digit\n\tn_str = n_str[1:i] * sort(n_str[i+1:end])\n\t\n\t# Convert back to integer\n\treturn parse(Int64, n_str)\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\t\n\t# find the first digit from the right that is smaller than the digit to its right\n\tfor i in 1:n_str_len-1\n\t\tif n_str[end-i] > n_str[end-i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, the number is already the largest possible\n\tif i == n_str_len\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tpivot = n_str[end-i]\n\tfor j in 1:n_str_len-i\n\t\tif n_str[end-i+j] > pivot\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to its right\n\tn_str[end-i] = n_str[end-i+j]\n\tn_str[end-i+j] = pivot\n\t\n\t# sort the digits to the right of the pivot\n\tn_str[end-i+1:end] = sort(n_str[end-i+1:end])\n\t\n\treturn parse(Int64, n_str)\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tlength = length(digits)\n\t# get the index of the first digit that is smaller than the digit to its right\n\tindex = findfirst(digits[1:length-1] .< digits[2:length])\n\t# if there is no such digit, return -1\n\tif index == nothing\n\t\treturn -1\n\tend\n\t# get the index of the smallest digit that is larger than the digit at the index\n\tsmallest_index = findfirst(digits .> digits[index+1])\n\t# swap the digits at the index and the smallest index\n\tdigits[index+1], digits[smallest_index] = digits[smallest_index], digits[index+1]\n\t# sort the digits from the index+1 to the end\n\tdigits[index+1:length] = sort(digits[index+1:length])\n\t# return the number\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) takes an integer n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be found, it returns -1.\n\t\"\"\"\n\t\n\t# convert n to a string\n\tn_string = string(n)\n\t\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_string)-1\n\t\tif n_string[i] < n_string[i+1]\n\t\t\tfirst_smaller_index = i\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no digit is smaller than the digit to its right, return -1\n\tif first_smaller_index == nothing\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the first digit that is smaller than the digit to its right\n\tsmallest_index = first_smaller_index + 1\n\tfor i in first_smaller_index+1:length(n_string)\n\t\tif n_string[i] < n_string[smallest_index] && n_string[i] > n_string[first_smaller_index]\n\t\t\tsmallest_index = i\n\t\tend\n\tend\n\t\n\t# swap the first digit that is smaller than the digit to its right with the smallest digit to the right of it\n\tn_string[first_smaller_index], n_string[smallest_index] = n_string[smallest_index], n_string[first_smaller_index]\n\t\n\t# sort the digits to the right of the first digit that is smaller than the digit to its right\n\tn_string[first_smaller_index+1:end] = sort(n_string[first_smaller_index+1:end])\n\t\n\t# convert the string to an integer and return it\n\treturn parse(Int64, n_string)\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the next\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, the number is already the biggest\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit that is bigger than digits[i]\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap digits[i] and digits[j]\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# sort the digits after digits[i]\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExamples\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12453\n\t\n\tjulia> rearrange_bigger(12453)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t12543\n\t\n\tjulia> rearrange_bigger(12543)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t213",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert the number to a string\n\tn_str = string(n)\n\t# convert the string to an array of characters\n\tn_arr = collect(n_str)\n\t# convert the array of characters to an array of integers\n\tn_arr = parse.(Int64, n_arr)\n\t# get the length of the array\n\tn_len = length(n_arr)\n\t# initialize a counter\n\ti = n_len - 1\n\t# initialize a boolean flag\n\tflag = false\n\t# loop through the array\n\twhile i > 0\n\t\t# if the current element is greater than the previous element\n\t\tif n_arr[i] > n_arr[i-1]\n\t\t\t# set the flag to true\n\t\t\tflag = true\n\t\t\t# break the loop\n\t\t\tbreak\n\t\tend\n\t\t# decrement the counter\n\t\ti -= 1\n\tend\n\t# if the flag is true\n\tif flag\n\t\t# get the index of the minimum element in the array\n\t\tmin_idx = argmin(n_arr[i:end]) + i - 1\n\t\t# swap the elements\n\t\tn_arr[i-1], n_arr[min_idx] = n_arr[min_idx], n_arr[i-1]\n\t\t# sort the array\n\t\tsort!(n_arr[i:end])\n\t\t# convert the array to a string\n\t\tn_str = join(n_arr)\n\t\t# return the string\n\t\treturn n_str\n\telse\n\t\t# return -1\n\t\treturn -1\n\tend\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# n = 12345\n\t# n = 12354\n\t# n = 12453\n\t# n = 12534\n\t# n = 13245\n\t# n = 13542\n\t# n = 14532\n\t# n = 15342\n\t# n = 21345\n\t# n = 31245\n\t# n = 41235\n\t# n = 51234\n\t# n = 51342\n\t# n = 51423\n\t# n = 51432\n\t# n = 52314\n\t# n = 52341\n\t# n = 53124\n\t# n = 53142\n\t# n = 53214\n\t# n = 53241\n\t# n = 53412\n\t# n = 53421\n\t# n = 54123\n\t# n = 54132\n\t# n = 54213\n\t# n = 54231\n\t# n = 54312\n\t# n = 54321\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t# n = 543210\n\t",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first element that is smaller than the next one\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest element that is bigger than the current one\n\t\t\tmin_index = i+1\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] < n_arr[min_index] && n_arr[j] > n_arr[i]\n\t\t\t\t\tmin_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the two elements\n\t\t\ttmp = n_arr[i]\n\t\t\tn_arr[i] = n_arr[min_index]\n\t\t\tn_arr[min_index] = tmp\n\t\t\t# sort the rest of the array\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = \"\"\n\t\t\tfor i in 1:length(n_arr)\n\t\t\t\tn_str = n_str * string(n_arr[i])\n\t\t\tend\n\t\t\t# convert to int\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\treturn n_int\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tswap!(digits, i, i+1)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend"
  ]
}