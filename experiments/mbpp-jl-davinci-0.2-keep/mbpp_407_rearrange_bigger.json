{
  "name": "mbpp_407_rearrange_bigger",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\nfunction rearrange_bigger(n::Int64)::Any \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = rearrange_bigger;\n\t@test(candidate(12) == 21)\n\t@test(candidate(10) == false)\n\t@test(candidate(102) == 120)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[i] < digits[j]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_arr = [parse(Int64, i) for i in n_str]\n\t\n\tif length(n_arr) == 1\n\t\treturn -1\n\tend\n\t\n\ti = length(n_arr) - 1\n\twhile i > 1\n\t\tif n_arr[i] > n_arr[i - 1]\n\t\t\tbreak\n\t\tend\n\t\ti -= 1\n\tend\n\t\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\tj = length(n_arr)\n\twhile j > i\n\t\tif n_arr[j] > n_arr[i - 1]\n\t\t\tbreak\n\t\tend\n\t\tj -= 1\n\tend\n\t\n\tn_arr[i - 1], n_arr[j] = n_arr[j], n_arr[i - 1]\n\t\n\tn_arr[i:end] = sort(n_arr[i:end])\n\t\n\treturn parse(Int64, join(n_arr, \"\"))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the digit to its right\n\tfor i = 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the digit found above\n\t\t\t# that is larger than the digit found above\n\t\t\tsmallest_index = i+1\n\t\t\tfor j = i+1:length(n_str)\n\t\t\t\tif n_str[j] < n_str[smallest_index] && n_str[j] > n_str[i]\n\t\t\t\t\tsmallest_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the two digits\n\t\t\ttemp = n_str[i]\n\t\t\tn_str[i] = n_str[smallest_index]\n\t\t\tn_str[smallest_index] = temp\n\t\t\t# sort the digits to the right of the digit found above\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t# return the new number\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_list = [parse(Int64, i) for i in n_str]\n\tn_len = length(n_list)\n\t\n\t# find the first digit that is smaller than its right neighbor\n\tfor i in 1:n_len-1\n\t\tif n_list[i] < n_list[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit is found, the number is the largest possible\n\tif i == n_len-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:n_len\n\t\tif n_list[j] > n_list[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to the right of the pivot\n\tn_list[i], n_list[j] = n_list[j], n_list[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tn_list[i+1:n_len] = reverse(n_list[i+1:n_len])\n\t\n\t# convert the list to a string and return it\n\treturn join(n_list)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\t# and swap it with the pivot\n\t\t\tpivot = i\n\t\t\tsmallest = i+1\n\t\t\tfor j in i+2:length(n_str)\n\t\t\t\tif n_str[j] > n_str[pivot] && n_str[j] < n_str[smallest]\n\t\t\t\t\tsmallest = j\n\t\t\t\tend\n\t\t\tend\n\t\t\tn_str[pivot], n_str[smallest] = n_str[smallest], n_str[pivot]\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tn_str[pivot+1:end] = sort(n_str[pivot+1:end])\n\t\t\t# convert back to int\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i in 1:n_str_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_str_len\n\t\t\t\tif n_str[j] > n_str[i]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\tn_str[i+1:n_str_len] = sort(n_str[i+1:n_str_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# your code here\n\treturn 0\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15324\n\t\n\tjulia> rearrange_big",
    "\t# convert to string\n\tstr_n = string(n)\n\t# convert to array\n\tarr_n = [parse(Int64, str_n[i]) for i in 1:length(str_n)]\n\t# find the first decreasing element\n\tfor i in 2:length(arr_n)\n\t\tif arr_n[i] > arr_n[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if there is no decreasing element, return -1\n\tif i == length(arr_n)\n\t\treturn -1\n\tend\n\t# find the smallest element that is bigger than arr_n[i-1]\n\tmin_idx = i\n\tfor j in i:length(arr_n)\n\t\tif arr_n[j] > arr_n[i-1] && arr_n[j] < arr_n[min_idx]\n\t\t\tmin_idx = j\n\t\tend\n\tend\n\t# swap arr_n[i-1] and arr_n[min_idx]\n\tarr_n[i-1], arr_n[min_idx] = arr_n[min_idx], arr_n[i-1]\n\t# sort the rest of the array\n\tarr_n[i:end] = sort(arr_n[i:end])\n\t# convert back to number\n\treturn parse(Int64, join(arr_n))\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in length(digits):-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)\n\t\tif digits[i] > digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# check if the number is negative\n\tif n < 0\n\t\tprintln(\"The number is negative\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a single digit\n\tif n < 10\n\t\tprintln(\"The number is a single digit\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a palindrome\n\tif ispalindrome(n)\n\t\tprintln(\"The number is a palindrome\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation(n)\n\t\tprintln(\"The number is a permutation of another number\")\n\t\treturn\n\tend\n\t\n\t# check if the number is a permutation of another number\n\tif ispermutation",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tCreate the next bigger number by rearranging the digits of a given number.\n\t\n\tParameters\n\t----------\n\tn : Int64\n\t\tThe number to rearrange.\n\t\n\tReturns\n\t-------\n\tAny\n\t\tThe next bigger number.\n\t\"\"\"\n\t\n\t# Convert to string\n\tn_str = string(n)\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, the number is the largest possible\n\tif i == length(n_str)-1\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot with the smallest digit to its right\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\n\t# Sort the digits to the right of the pivot\n\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\n\t# Convert back to integer\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get the length of the string\n\tn_len = length(n_str)\n\t# get the last digit\n\tlast_digit = parse(Int64, n_str[n_len])\n\t# get the second last digit\n\tsecond_last_digit = parse(Int64, n_str[n_len-1])\n\t# if the last digit is greater than the second last digit\n\tif last_digit > second_last_digit\n\t\t# swap the digits\n\t\tn_str[n_len] = second_last_digit\n\t\tn_str[n_len-1] = last_digit\n\t\t# return the string\n\t\treturn n_str\n\telse\n\t\t# return -1\n\t\treturn -1\n\tend\nend"
  ]
}