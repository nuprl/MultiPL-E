{
  "name": "mbpp_265_list_split",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\nfunction list_split(S::Any, step::Int64)::Any \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = list_split;\n\t@test(candidate([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], 3) == [[\"a\", \"d\", \"g\", \"j\", \"m\"], [\"b\", \"e\", \"h\", \"k\", \"n\"], [\"c\", \"f\", \"i\", \"l\"]])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]])\n\t@test(candidate([\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\"], 2) == [[\"python\", \"C\", \"DBMS\"], [\"java\", \"C++\", \"SQL\"]])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tn = length(S)\n\tif n == 0\n\t\treturn []\n\tend\n\tif n <= step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:n], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn S\n\tend\nend",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\tif length(S) > step\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\ti = 1\n\twhile i <= length(S)\n\t\tpush!(result, S[i:i+step-1])\n\t\ti += step\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == 2\n\t\treturn [S[1:2:end], S[2:2:end]]\n\tend\n\tif step == 3\n\t\treturn [S[1:3:end], S[2:3:end], S[3:3:end]]\n\tend\n\tif step == 4\n\t\treturn [S[1:4:end], S[2:4:end], S[3:4:end], S[4:4:end]]\n\tend\n\tif step == 5\n\t\treturn [S[1:5:end], S[2:5:end], S[3:5:end], S[4:5:end], S[5:5:end]]\n\tend\n\tif step == 6\n\t\treturn [S[1:6:end], S[2:6:end], S[3:6:end], S[4:6:end], S[5:6:end], S[6:6:end]]\n\tend\n\tif step == 7\n\t\treturn [S[1:7:end], S[2:7:end], S[3:7:end], S[4:7:end], S[5:7:end], S[6:7:end], S[7:7:end]]\n\tend\n\tif step == 8\n\t\treturn [S[1:8:end], S[2:8:end], S[3:8:end], S[4:8:end], S[5:8:end], S[6:8:end], S[7:8:end], S[8:8:end]]\n\tend\n\tif step == 9\n\t\treturn [S[1:9:end], S[2:9:end], S[3:9:end], S[4:9:end], S[5:9:end], S[6:9:end], S[7:9:end",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif isa(S, Array)\n\t\tif step > length(S)\n\t\t\terror(\"Step must be less than the length of the list\")\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\tif step > length(S)\n\t\t\terror(\"Step must be less than the length of the list\")\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\terror(\"Input must be an array or string\")\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i = 1:step:length(S)\n\t\tresult = [result; S[i:min(i+step-1, length(S))]]\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\telseif step == 1\n\t\treturn [S]\n\telse\n\t\tresult = []\n\t\tfor i in 1:step:length(S)\n\t\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\t\tend\n\t\treturn result\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif isa(S, Vector)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\telse\n\t\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\t\tend\n\telse\n\t\terror(\"Input must be a vector\")\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\tresult = Array{Any,1}[]\n\t\tfor i in 1:step:length(S)\n\t\t\tif i+step-1 <= length(S)\n\t\t\t\tpush!(result, S[i:i+step-1])\n\t\t\telse\n\t\t\t\tpush!(result, S[i:end])\n\t\t\tend\n\t\tend\n\t\treturn result\n\tend\n\tif isa(S, String)\n\t\tresult = String[]\n\t\tfor i in 1:step:length(S)\n\t\t\tif i+step-1 <= length(S)\n\t\t\t\tpush!(result, S[i:i+step-1])\n\t\t\telse\n\t\t\t\tpush!(result, S[i:end])\n\t\t\tend\n\t\tend\n\t\treturn result\n\tend\nend",
    "\tif length(S) == 0\n\t\treturn []\n\telse\n\t\treturn [S[1:step]] * list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step < 1\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tFunction to split a list into sublists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [[x] for x in S]\n\tend\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif length(S) == 0\n\t\treturn []\n\telse\n\t\treturn [S[1:step]] * list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1]; list_split(S[step:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:length(S)])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif length(S) == 0\n\t\treturn []\n\telseif length(S) < step\n\t\treturn [S]\n\telse\n\t\treturn [S[1:step]] * list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step < 1\n\t\treturn []\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\treturn [S[i:i+step] for i in 1:step:length(S)]\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\tif length(S) < step\n\t\treturn S\n\tend\n\treturn [S[1:step]; list_split(S[step+1:end], step)]\nend",
    "\tif length(S) == 0\n\t\treturn S\n\tend\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tn = length(S)\n\tif n == 0\n\t\treturn []\n\tend\n\tif step == 0\n\t\treturn []\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > n\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn []\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:n\n\t\tpush!(result, S[i:min(i+step-1, n)])\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\tprintln(\"Error: step must be greater than 0\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step >= length(S)\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\t>>> list_split([1,2,3,4,5,6], 2)\n\t[[1,2], [3,4], [5,6]]\n\t\"\"\"\n\tif length(S) == 0\n\t\treturn []\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step]]\n\tend\nend",
    "\tif isa(S, Array)\n\t\tS = S[:]\n\tend\n\tif isa(S, String)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Vector)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Tuple)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Set)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Dict)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Deque)\n\t\tS = collect(S)\n\tend\n\tif isa(S, LinkedList)\n\t\tS = collect(S)\n\tend\n\tif isa(S, PriorityQueue)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Stack)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Queue)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Tree)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Graph)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Heap)\n\t\tS = collect(S)\n\tend\n\tif isa(S, HashSet)\n\t\tS = collect(S)\n\tend\n\tif isa(S, HashMap)\n\t\tS = collect(S)\n\tend\n\tif isa(S, BitArray)\n\t\tS = collect(S)\n\tend\n\tif isa(S, SparseMatrixCSC)\n\t\tS = collect(S)\n\tend\n\tif isa(S, SparseMatrixCSR)\n\t\tS = collect(S)\n\tend\n\tif isa(S, SparseVector)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Vector)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Matrix)\n\t\tS = collect(S)\n\tend\n\tif isa(S,",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tn = length(S)\n\tif n % step != 0\n\t\treturn \"Error: step does not divide length of list\"\n\tend\n\tnew_list = []\n\tfor i in 1:step:n\n\t\tnew_list = [new_list; S[i:i+step-1]]\n\tend\n\treturn new_list\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, BitArray)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, BitSet)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Bool)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Int64)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Float64)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Complex)\n",
    "\t\"\"\"\n\tFunction that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\tprintln(\"Error: step must be greater than 0\")\n\telse\n\t\tif isa(S, Array)\n\t\t\tL = length(S)\n\t\t\tif L < step\n\t\t\t\treturn S\n\t\t\telse\n\t\t\t\treturn [S[i:i+step-1] for i in 1:step:L]\n\t\t\tend\n\t\telse\n\t\t\tprintln(\"Error: input must be an array\")\n\t\tend\n\tend\nend",
    "\tif step == 0\n\t\treturn [S]\n\tend\n\tif length(S) <= step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:length(S)])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 2)\n\t[[1,2],[3,4],[5,6],[7,8],[9,10]]\n\t\"\"\"\n\treturn [S[i:i+step] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tS is a list, step is the number of elements in each sublist.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step == 0\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\tif isa(S, Dict)\n\t\treturn [S]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S]\n\tend\n\tif isa(S, Set)\n\t\treturn [S]\n\tend\n\tif isa(S, Int64)\n\t\treturn [S]\n\tend\n\tif isa(S, Float64)\n\t\treturn [S]\n\tend\n\tif isa(S, String)\n\t\treturn [S]\n\tend\n\tif isa(S, Bool)\n\t\treturn [S]\n\tend\n\tif isa(S, Symbol)\n\t\treturn [S]\n\tend\n\tif isa(S, Nothing)\n\t\treturn [S]\n\tend\n\tif isa(S, Any)\n\t\treturn [S]\n\tend\n\tif isa(S, Union)\n\t\treturn [S]\n\tend\n\tif isa(S, Function)\n\t\treturn [S]\n\tend\n\tif isa(S, Type)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractArray)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractString)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractFloat)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractInt)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSet)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractDict)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractVector)\n\t\t",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\tstep = length(S) + step\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0.\")\n\tend\n\t\n\tif length(S) < step\n\t\treturn S\n\tend\n\t\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\tif isa(S, Array)\n\t\tif length(S) < step\n\t\t\treturn S\n\t\telse\n\t\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\t\tend\n\telseif isa(S, String)\n\t\tif length(S) < step\n\t\t\treturn S\n\t\telse\n\t\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\t\tend\n\telse\n\t\tprintln(\"Error: Input must be an array or string\")\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [[x] for x in S]\n\tend\n\tif step > length(S)\n\t\treturn [[x] for x in S]\n\tend\n\tif step < 0\n\t\treturn [reverse(S[i:i+step]) for i in 1:step:length(S)]\n\tend\n\treturn [S[i:i+step] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tTakes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\tprintln(\"Step must be greater than 0\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tThis function takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [[x] for x in S]\n\tend\n\tif step > length(S)\n\t\treturn [[x] for x in S]\n\tend\n\tif step < 0\n\t\treturn list_split(reverse(S), abs(step))\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\tif length(S) < step\n\t\treturn [S]\n\telse\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\tif step <= 0\n\t\treturn S\n\tend\n\tif length(S) <= step\n\t\treturn S\n\tend\n\treturn [S[1:step]; list_split(S[step+1:end], step)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif length(S) == 0\n\t\treturn S\n\tend\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\tif length(S) < step\n\t\treturn S\n\tend\n\treturn [S[1:step]; list_split(S[step+1:end], step)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn \"Error: step must be less than or equal to the length of the list\"\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\t>>> list_split([1,2,3,4,5,6,7,8,9], 2)\n\t[[1,2,3,4,5], [6,7,8,9]]\n\t\"\"\"\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i = 1:step:length(S)\n\t\tif i + step - 1 > length(S)\n\t\t\tpush!(result, S[i:end])\n\t\telse\n\t\t\tpush!(result, S[i:i + step - 1])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\t\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:length(S)])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tS: list\n\tstep: Int64\n\t\"\"\"\n\tif step < 1\n\t\tprintln(\"step must be greater than 0\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Array)\n\t\treturn [S[i:i+step-1,:] for i in 1:step:size(S)[1]]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif length(S) == 0\n\t\treturn [S]\n\tend\n\tif length(S) == 1\n\t\treturn [S]\n\tend\n\tif length(S) == 2\n\t\treturn [S]\n\tend\n\tif step == 2\n\t\treturn [S[1:2:end], S[2:2:end]]\n\tend\n\tif step == 3\n\t\treturn [S[1:3:end], S[2:3:end], S[3:3:end]]\n\tend\n\tif step == 4\n\t\treturn [S[1:4:end], S[2:4:end], S[3:4:end], S[4:4:end]]\n\tend\n\tif step == 5\n\t\treturn [S[1:5:end], S[2:5:end], S[3:5:end], S[4:5:end], S[5:5:end]]\n\tend\n\tif step == 6\n\t\treturn [S[1:6:end], S[2:6:end], S[3:6:end], S[4:6:end], S[5:6:end], S[6:6:end]]\n\tend\n\tif step == 7\n\t\treturn [S[1:7:end], S[2:7:end], S[3:7:end], S[4:7:end], S[5:7:end], S[6:7:end], S[7:7:end]]\n\tend\n\tif step == 8\n\t\treturn [S[1:8:end], S[2:8:end], S[3:8:end], S[4:8:end], S[5:8:end], S",
    "\t\"\"\"\n\t>>> list_split([1,2,3,4,5,6], 2)\n\t[[1,2],[3,4],[5,6]]\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractArray)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractRange)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractSet)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractString)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractDict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractVector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Abstract",
    "\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\tif length(S) > step\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\tif length(S) > step\n\t\treturn [S[1:step]]*list_split(S[step+1:end],step)\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step-1]; list_split(S[step:end], step)]\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step]]\n\tend\nend",
    "\tif step < 1\n\t\treturn \"step must be a positive integer\"\n\tend\n\tn = length(S)\n\tif n % step == 0\n\t\treturn [S[i:i+step-1] for i in 1:step:n]\n\telse\n\t\treturn [S[i:i+step-1] for i in 1:step:n-1] * [S[n-n%step+1:n]]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]]*list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\telseif step == 1\n\t\treturn S\n\telseif step == 2\n\t\treturn S\n\telseif step == 3\n\t\treturn S\n\telseif step == 4\n\t\treturn S\n\telseif step == 5\n\t\treturn S\n\telseif step == 6\n\t\treturn S\n\telseif step == 7\n\t\treturn S\n\telseif step == 8\n\t\treturn S\n\telseif step == 9\n\t\treturn S\n\telseif step == 10\n\t\treturn S\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn list_split(reverse(S), -step)\n\tend\n\tout = []\n\tfor i in 1:step:length(S)\n\t\tpush!(out, S[i:min(i+step-1, length(S))])\n\tend\n\treturn out\nend",
    "\tif step < 1\n\t\treturn \"Step must be greater than 0\"\n\tend\n\tif isa(S, Array)\n\t\tif isa(S[1], Array)\n\t\t\treturn \"Input must be a list of numbers\"\n\t\tend\n\tend\n\tif isa(S, Tuple)\n\t\tif isa(S[1], Tuple)\n\t\t\treturn \"Input must be a list of numbers\"\n\t\tend\n\tend\n\tif isa(S, Dict)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, String)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Set)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Int64)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Float64)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Bool)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Symbol)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Function)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Nothing)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Number)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, AbstractArray)\n\t\tif isa(S[1], AbstractArray)\n\t\t\treturn \"Input must be a list of numbers\"\n\t\tend\n\tend\n\tif isa(S, AbstractString)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, AbstractDict)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, AbstractSet)\n\t\treturn \"Input must be a list of numbers\"\n\tend\n\tif isa(S, Abstract",
    "\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"Error: S must be an Array or String\"\n\tend\nend",
    "\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step] list_split(S[step+1:end], step)]\n\tend\nend",
    "\tn = length(S)\n\tif n == 0\n\t\treturn S\n\tend\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > n\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:n\n\t\tif i+step-1 <= n\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:n])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list S into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif isa(S, Array)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractRange)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractVector)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, AbstractMatrix)\n\t\tif step > length(S",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\treturn \"step must be greater than 0\"\n\tend\n\t\n\tif isa(S, AbstractString)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractDict)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSet)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractArray)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractVector)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractMatrix)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractRange)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixCSC)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixCSR)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrix)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseVector)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixCOO)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixDiagonal)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixRow)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixColumn)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixBand)\n\t\tS = collect(S)\n\tend\n\t\n\tif isa(S, AbstractSparseMatrixBidiagonal)\n\t\tS =",
    "\t\"\"\"\n\tSplits a list into sublists of size step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\treturn [S[1:step]; list_split(S[step+1:end], step)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif isa(S,Array)\n\t\tS = collect(S)\n\tend\n\tif isa(S,Dict)\n\t\tS = collect(keys(S))\n\tend\n\tif isa(S,Set)\n\t\tS = collect(S)\n\tend\n\tif isa(S,String)\n\t\tS = collect(S)\n\tend\n\tif isa(S,Tuple)\n\t\tS = collect(S)\n\tend\n\tif isa(S,Int64)\n\t\tS = collect(1:S)\n\tend\n\tif isa(S,Float64)\n\t\tS = collect(1:round(Int64,S))\n\tend\n\tif isa(S,Range)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractArray)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractVector)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractSet)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractDict)\n\t\tS = collect(keys(S))\n\tend\n\tif isa(S,AbstractString)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractTuple)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractInt)\n\t\tS = collect(1:S)\n\tend\n\tif isa(S,AbstractFloat)\n\t\tS = collect(1:round(Int64,S))\n\tend\n\tif isa(S,AbstractRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S,AbstractRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S,",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [[S[i]] for i in 1:step]\n\tend\n\tif step > length(S)\n\t\treturn [[S[i]] for i in 1:length(S)]\n\tend\n\treturn [[S[i] for i in 1:step], list_split(S[step+1:end], step)]\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1], list_split(S[step:end], step)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif length(S) == 0\n\t\treturn []\n\tend\n\tif length(S) == 1\n\t\treturn [S]\n\tend\n\tif length(S) == 2\n\t\treturn [S[1], S[2]]\n\tend\n\tif length(S) == 3\n\t\treturn [S[1], S[2], S[3]]\n\tend\n\tif length(S) == 4\n\t\treturn [S[1], S[2], S[3], S[4]]\n\tend\n\tif length(S) == 5\n\t\treturn [S[1], S[2], S[3], S[4], S[5]]\n\tend\n\tif length(S) == 6\n\t\treturn [S[1], S[2], S[3], S[4], S[5], S[6]]\n\tend\n\tif length(S) == 7\n\t\treturn [S[1], S[2], S[3], S[4], S[5], S[6], S[7]]\n\tend\n\tif length(S) == 8\n\t\treturn [S[1], S[2], S[3], S[4], S[5], S[6], S[7], S[8]]\n\tend\n\tif length(S) == 9\n\t\treturn [S[1], S[2], S[3], S[4], S[5], S[6], S[7], S[8], S[9]]\n\tend\n\tif length(S) == 10\n\t\treturn [S[1], S[2], S[3], S[4], S[5], S[6], S[7], S[8], S[9], S[10]]\n\tend\n\tif length(S) == 11\n\t\treturn [S[1], S[2], S[3], S[4], S[5], S[6], S[7],",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\treturn \"Step must be greater than 0\"\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\tif length(S) > step\n\t\treturn [S[1:step]] * list_split(S[step+1:end], step)\n\tend\nend",
    "\t\"\"\"\n\tThis function takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\tprintln(\"Step cannot be 0\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\tprintln(\"Step cannot be greater than the length of the list\")\n\t\treturn\n\tend\n\tif step < 0\n\t\tprintln(\"Step cannot be negative\")\n\t\treturn\n\tend\n\tif step == length(S)\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 > length(S)\n\t\t\tpush!(result, S[i:end])\n\t\telse\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i = 1:step:length(S)\n\t\tresult = [result; S[i:min(i+step-1, length(S))]]\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\tprintln(\"Step must be a positive integer\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tS: list\n\tstep: integer\n\t\"\"\"\n\tsplit_list = []\n\tfor i in 1:step:length(S)\n\t\tpush!(split_list, S[i:i+step-1])\n\tend\n\treturn split_list\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:length(S)])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 2)\n\t[[1,2],[3,4],[5,6],[7,8],[9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 3)\n\t[[1,2,3],[4,5,6],[7,8,9],[10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 4)\n\t[[1,2,3,4],[5,6,7,8],[9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 5)\n\t[[1,2,3,4,5],[6,7,8,9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 6)\n\t[[1,2,3,4,5,6],[7,8,9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 7)\n\t[[1,2,3,4,5,6,7],[8,9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 8)\n\t[[1,2,3,4,5,6,7,8],[9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 9)\n\t[[1,2,3,4,5,6,7,8,9],[10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 10)\n\t[[1,2,3,4,5,6,7,8,9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 11)\n\t[[1,2,3,4,5",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1]; list_split(S[step:end], step)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\terror(\"Step must be non-zero\")\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif isa(S, AbstractString)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractArray)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractDict)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractSet)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:length(S)])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1], list_split(S[step:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\terror(\"Step must be positive\")\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\treturn \"step must be greater than 0\"\n\tend\n\tif isa(S, Array)\n\t\tif step > length(S)\n\t\t\treturn \"step must be less than or equal to the length of the array\"\n\t\tend\n\t\tresult = []\n\t\tfor i in 1:step:length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\t\treturn result\n\telseif isa(S, String)\n\t\tif step > length(S)\n\t\t\treturn \"step must be less than or equal to the length of the string\"\n\t\tend\n\t\tresult = []\n\t\tfor i in 1:step:length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\t\treturn result\n\telse\n\t\treturn \"input must be an array or string\"\n\tend\nend",
    "\tif step < 1\n\t\treturn \"Step must be greater than 0\"\n\tend\n\t\n\tif typeof(S) == Array{Any,1}\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif typeof(S) == String\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"Input must be an array or a string\"\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\treturn [S[i:i+step] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tresult = []\n\tfor i = 1:step:length(S)\n\t\tif i + step - 1 > length(S)\n\t\t\tresult = [result; S[i:end]]\n\t\telse\n\t\t\tresult = [result; S[i:i+step-1]]\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"Error: input must be an Array, String, or Dict\"\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, AbstractString)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == 2\n\t\treturn [S[1:2:end], S[2:2:end]]\n\tend\n\tif step == 3\n\t\treturn [S[1:3:end], S[2:3:end], S[3:3:end]]\n\tend\n\tif step == 4\n\t\treturn [S[1:4:end], S[2:4:end], S[3:4:end], S[4:4:end]]\n\tend\n\tif step == 5\n\t\treturn [S[1:5:end], S[2:5:end], S[3:5:end], S[4:5:end], S[5:5:end]]\n\tend\n\tif step == 6\n\t\treturn [S[1:6:end], S[2:6:end], S[3:6:end], S[4:6:end], S[5:6:end], S[6:6:end]]\n\tend\n\tif step == 7\n\t\treturn [S[1:7:end], S[2:7:end], S[3:7:end], S[4:7:end], S[5:7:end], S[6:7:end], S[7:7:end]]\n\tend\n\tif step == 8\n\t\treturn [S[1:8:end], S[2:8:end], S[3:8:end], S[4:8:end], S[5:8:end], S[6:8:end], S[7:8:end], S[8:8:end]]\n\tend\n\tif step == 9\n\t\treturn [S[1:9:end], S[2:9:end], S[3:9:end], S[4:9:end], S[5:9:end], S[6:9:end], S[7:9:end], S[8:9:end], S[9",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be a positive integer.\")\n\tend\n\tif isa(S, Array)\n\t\tif step > length(S)\n\t\t\treturn S\n\t\telse\n\t\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\t\tend\n\telseif isa(S, String)\n\t\tif step > length(S)\n\t\t\treturn S\n\t\telse\n\t\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\t\tend\n\telse\n\t\terror(\"Input must be an array or string.\")\n\tend\nend",
    "\tif step <= 0\n\t\terror(\"Step must be positive\")\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, AbstractString)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\terror(\"Input must be a vector or string\")\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\telseif step == 1\n\t\treturn [S]\n\telse\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\tif step <= 0\n\t\terror(\"Step must be positive\")\n\tend\n\tif length(S) == 0\n\t\treturn []\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"Error: input must be an array or string\"\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step < 1\n\t\terror(\"step must be greater than 0\")\n\tend\n\tif isa(S, Array)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Vector)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Tuple)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Set)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Dict)\n\t\tS = collect(S)\n\tend\n\tif isa(S, String)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractString)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractDict)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractSet)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractVector)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractTuple)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractArray)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractRNG)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractUnitRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractFloat)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractInt)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChar)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractBool)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractComplex)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractIrrational)\n\t\tS = collect(S)\n\tend\n\tif isa",
    "\t\"\"\"\n\t\tlist_split(S::Any, step::Int64)::Any\n\t\t\n\t\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0.\")\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1]; list_split(S[step:end], step)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1]; list_split(S[step:end], step)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list S into a list of lists, each of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end],step)\nend",
    "\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"Error: S must be an array or string\"\n\tend\nend",
    "\t\"\"\"\n\tSplit a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step]]*list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step < 1\n\t\tprintln(\"Step must be greater than 0\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step == length(S) - 1\n\t\treturn [S[1:step], S[step+1:end]]\n\tend\n\tif step == length(S) - 2\n\t\treturn [S[1:step], S[step+1:step+1], S[step+2:end]]\n\tend\n\tif step == length(S) - 3\n\t\treturn [S[1:step], S[step+1:step+1], S[step+2:step+2], S[step+3:end]]\n\tend\n\tif step == length(S) - 4\n\t\treturn [S[1:step], S[step+1:step+1], S[step+2:step+2], S[step+3:step+3], S[step+4:end]]\n\tend\n\tif step == length(S) - 5\n\t\treturn [S[1:step], S[step+1:step+1], S[step+2:step+2], S[step+3:step+3], S[step+4:step+4], S[step+5:end]]\n\tend\n\tif step == length(S) - 6\n\t\treturn [S[1:step], S[step+1:step+1], S[step+2:step+2], S[step+3:step+3], S[step+4:step+4], S[step+5:step+5], S[step+6:end]]\n\tend\n\tif step == length(S) - 7\n\t\treturn [S[1:step], S[step+1:step+1], S[step+2:step+2], S[step+3:step+3], S[step+4:step+4], S[step+5:step+5], S[step+6:step+6], S[",
    "\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tFunction that splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) == 0\n\t\treturn []\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]]*list_split(S[step+1:end], step)\nend",
    "\tif step < 1\n\t\tprintln(\"Step must be greater than 0\")\n\t\treturn\n\tend\n\tif isa(S, AbstractString)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Vector)\n\t\tS = [S]\n\tend\n\tif isa(S, Array)\n\t\tif length(S) == 0\n\t\t\treturn S\n\t\tend\n\t\tif isa(S[1], AbstractString)\n\t\t\tS = [collect(S[i]) for i in 1:length(S)]\n\t\tend\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:min(i+step-1, length(S)):step] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:min(i+step-1, length(S)):step,:] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) == 0\n\t\treturn S\n\tend\n\tif length(S) == 1\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn S\n\tend\n\tif length(S) > step\n\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif length(S) == 0\n\t\treturn []\n\telse\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, BitArray)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, BitSet)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Deque)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, LinkedList)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, PriorityQueue)\n\t\treturn [S[i:i+step-",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step <= 0\n\t\terror(\"step must be positive\")\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Array)\n\t\treturn [S[:,i:i+step-1] for i in 1:step:size(S,2)]\n\telse\n\t\terror(\"list must be a Vector or Array\")\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\tprintln(\"Step must be a positive integer\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\t#initialize the list\n\tlist_of_lists = []\n\t\n\t#initialize the first list\n\tnew_list = []\n\t\n\t#initialize the counter\n\tcounter = 1\n\t\n\t#loop through the list\n\tfor i in S\n\t\t#if the counter is less than the step\n\t\tif counter < step\n\t\t\t#add the element to the list\n\t\t\tpush!(new_list, i)\n\t\t\t#increment the counter\n\t\t\tcounter += 1\n\t\telse\n\t\t\t#add the element to the list\n\t\t\tpush!(new_list, i)\n\t\t\t#add the list to the list of lists\n\t\t\tpush!(list_of_lists, new_list)\n\t\t\t#reset the list\n\t\t\tnew_list = []\n\t\t\t#reset the counter\n\t\t\tcounter = 1\n\t\tend\n\tend\n\t\n\t#if the list is not empty\n\tif length(new_list) != 0\n\t\t#add the list to the list of lists\n\t\tpush!(list_of_lists, new_list)\n\tend\n\t\n\t#return the list of lists\n\treturn list_of_lists\nend",
    "\t\"\"\"\n\tThis function takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn \"step cannot be 0\"\n\telseif step < 0\n\t\treturn \"step cannot be negative\"\n\telseif step > length(S)\n\t\treturn \"step cannot be greater than the length of the list\"\n\telse\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif length(S) == 0\n\t\treturn []\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 > length(S)\n\t\t\tpush!(result, S[i:end])\n\t\telse\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1]; list_split(S[step:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 > length(S)\n\t\t\tpush!(result, S[i:end])\n\t\telse\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tTakes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif length(S) == 0\n\t\treturn [S]\n\tend\n\tif length(S) == 1\n\t\treturn [S]\n\tend\n\tif length(S) == 2\n\t\treturn [S]\n\tend\n\tif length(S) == 3\n\t\treturn [S]\n\tend\n\tif length(S) == 4\n\t\treturn [S]\n\tend\n\tif length(S) == 5\n\t\treturn [S]\n\tend\n\tif length(S) == 6\n\t\treturn [S]\n\tend\n\tif length(S) == 7\n\t\treturn [S]\n\tend\n\tif length(S) == 8\n\t\treturn [S]\n\tend\n\tif length(S) == 9\n\t\treturn [S]\n\tend\n\tif length(S) == 10\n\t\treturn [S]\n\tend\n\tif length(S) == 11\n\t\treturn [S]\n\tend\n\tif length(S) == 12\n\t\treturn [S]\n\tend\n\tif length(S) == 13\n\t\treturn [S]\n\tend\n\tif length(S) == 14\n\t\treturn [S]\n\tend\n\tif length(S) == 15\n\t\treturn [S]\n\tend\n\tif length(S) == 16\n\t\treturn [S]\n\tend\n\tif length(S) == 17\n\t\treturn [S]\n\tend\n\tif length(S) == 18\n\t\treturn [S]\n\tend\n\tif length(S) == 19\n\t\treturn [S]\n\tend\n\tif length(S) == 20\n\t\treturn",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\terror(\"Step must be a positive integer.\")\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i = 1:step:length(S)\n\t\tresult = [result; S[i:min(i+step-1, length(S))]]\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step == 0\n\t\tprintln(\"Step cannot be 0\")\n\t\treturn\n\tend\n\tif step < 0\n\t\tprintln(\"Step cannot be negative\")\n\t\treturn\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\tprintln(\"Step cannot be greater than the length of the list\")\n\t\treturn\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step < 1\n\t\tthrow(ArgumentError(\"step must be greater than 0\"))\n\tend\n\tif isa(S, AbstractString)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, AbstractVector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, AbstractMatrix)\n\t\treturn [S[i:i+step-1,:] for i in 1:step:size(S,1)]\n\telse\n\t\tthrow(ArgumentError(\"S must be a string, vector, or matrix\"))\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step < 1\n\t\treturn \"step must be greater than 0\"\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"S must be an array or string\"\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 > length(S)\n\t\t\tpush!(result, S[i:end])\n\t\telse\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 2)\n\t[[1,2,3,4,5], [6,7,8,9,10]]\n\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 3)\n\t[[1,2,3,4], [5,6,7], [8,9,10]]\n\t\"\"\"\n\tif step == 0\n\t\treturn \"Error: step cannot be 0\"\n\tend\n\tif step > length(S)\n\t\treturn \"Error: step cannot be greater than length of list\"\n\tend\n\tif step < 0\n\t\treturn \"Error: step cannot be negative\"\n\tend\n\tif isa(S, String)\n\t\treturn \"Error: list cannot be a string\"\n\tend\n\tif isa(step, String)\n\t\treturn \"Error: step cannot be a string\"\n\tend\n\tif isa(S, Float64)\n\t\treturn \"Error: list cannot be a float\"\n\tend\n\tif isa(step, Float64)\n\t\treturn \"Error: step cannot be a float\"\n\tend\n\tif isa(S, Bool)\n\t\treturn \"Error: list cannot be a boolean\"\n\tend\n\tif isa(step, Bool)\n\t\treturn \"Error: step cannot be a boolean\"\n\tend\n\tif isa(S, Int64)\n\t\treturn \"Error: list cannot be an integer\"\n\tend\n\tif isa(step, Int64)\n\t\treturn \"Error: step cannot be an integer\"\n\tend\n\tif isa(S, Symbol)\n\t\treturn \"Error: list cannot be a symbol\"\n\tend\n\tif isa(step, Symbol)\n\t\treturn \"Error: step cannot be a symbol\"\n\tend\n\tif isa(S, Dict)\n\t\treturn \"Error: list cannot be a dictionary\"\n\tend\n\tif isa(step, Dict)\n\t\treturn \"Error: step cannot be a dictionary\"\n\tend\n\tif isa(S, T",
    "    return [S[i:i+step] for i in 1:step:length(S)]\nend",
    "\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step] list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Tuple)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, BitArray)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, BitSet)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Deque)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S, Channel)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\n\tif isa(S",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\treturn \"step must be greater than 0\"\n\tend\n\tif step > length(S)\n\t\treturn \"step must be less than or equal to the length of the list\"\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, String)\n\t\treturn [S]\n\tend\n\tif isa(S, Int64)\n\t\treturn [S]\n\tend\n\tif isa(S, Float64)\n\t\treturn [S]\n\tend\n\tif isa(S, Bool)\n\t\treturn [S]\n\tend\n\tif isa(S, Symbol)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractDict)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSet)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractRange)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractArray)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractVector)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractMatrix)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCSC)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCSR)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrix)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseVector)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseArray)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCSC)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCSR)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrix)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseVector)\n\t\treturn [S]\n\tend\n\t",
    "\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif isa(S, Dict)\n\t\treturn \"Error: Dict not supported\"\n\tend\n\tif isa(S, String)\n\t\treturn \"Error: String not supported\"\n\tend\n\tif isa(S, Set)\n\t\treturn \"Error: Set not supported\"\n\tend\n\tif isa(S, Tuple)\n\t\treturn \"Error: Tuple not supported\"\n\tend\n\tif isa(S, Int64)\n\t\treturn \"Error: Int64 not supported\"\n\tend\n\tif isa(S, Float64)\n\t\treturn \"Error: Float64 not supported\"\n\tend\n\tif isa(S, Bool)\n\t\treturn \"Error: Bool not supported\"\n\tend\n\tif isa(S, Complex)\n\t\treturn \"Error: Complex not supported\"\n\tend\n\tif isa(S, BigInt)\n\t\treturn \"Error: BigInt not supported\"\n\tend\n\tif isa(S, BigFloat)\n\t\treturn \"Error: BigFloat not supported\"\n\tend\n\tif isa(S, BigComplex)\n\t\treturn \"Error: BigComplex not supported\"\n\tend\n\tif isa(S, Number)\n\t\treturn \"Error: Number not supported\"\n\tend\n\tif isa(S, AbstractString)\n\t\treturn \"Error: AbstractString not supported\"\n\tend\n\tif isa(S, AbstractArray)\n\t\treturn \"Error: AbstractArray not supported\"\n\tend\n\tif isa(S, AbstractSet)\n\t\treturn \"Error: AbstractSet not supported\"\n\tend\n\tif isa(S, AbstractDict)\n\t\treturn \"Error: AbstractDict not supported\"\n\tend\n\tif isa(S, AbstractTuple)\n\t\treturn \"Error: AbstractTuple not supported\"\n\tend\n\tif isa(S, AbstractFloat)\n\t\treturn \"Error: AbstractFloat not supported\"\n\tend\n\tif isa(S, AbstractInt)\n\t\treturn \"Error: AbstractInt not supported\"",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1]; list_split(S[step:end], step)]\n\tend\nend",
    "\t\"\"\"\n\t\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 2)\n\t\t[[1,2,3,4,5], [6,7,8,9,10]]\n\t\t>>> list_split([1,2,3,4,5,6,7,8,9,10], 3)\n\t\t[[1,2,3,4], [5,6,7], [8,9,10]]\n\t\"\"\"\n\tif step == 0\n\t\treturn \"Error: step cannot be 0\"\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tresult = [result; S[i:min(i+step-1, length(S))]]\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tn = length(S)\n\tif n == 0\n\t\treturn []\n\telseif n < step\n\t\treturn [S]\n\telse\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step > length(S)\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list S into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"step must be greater than 0\")\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif isa(S, AbstractString)\n\t\tS = collect(S)\n\tend\n\tif isa(S, Vector)\n\t\tn = length(S)\n\t\tif n < step\n\t\t\treturn S\n\t\tend\n\t\tS = reshape(S, (n\u00f7step, step))\n\t\treturn S\n\tend\n\tif isa(S, Matrix)\n\t\tn, m = size(S)\n\t\tif n < step\n\t\t\treturn S\n\t\tend\n\t\tS = reshape(S, (n\u00f7step, step, m))\n\t\treturn S\n\tend\n\tif isa(S, Tuple)\n\t\tn = length(S)\n\t\tif n < step\n\t\t\treturn S\n\t\tend\n\t\tS = reshape(S, (n\u00f7step, step))\n\t\treturn S\n\tend\n\terror(\"S must be a string, vector, matrix, or tuple\")\nend",
    "\t\"\"\"\n\tSplits a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn []\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step <= 0\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif isa(S, Vector)\n\t\tif isa(S[1], Vector)\n\t\t\treturn \"Error: input must be a list of numbers\"\n\t\tend\n\t\tif length(S) % step != 0\n\t\t\treturn \"Error: step must be a factor of the length of the list\"\n\t\tend\n\t\tresult = []\n\t\tfor i = 1:step:length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\t\treturn result\n\telseif isa(S, String)\n\t\tif length(S) % step != 0\n\t\t\treturn \"Error: step must be a factor of the length of the list\"\n\t\tend\n\t\tresult = []\n\t\tfor i = 1:step:length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\tend\n\t\treturn result\n\telse\n\t\treturn \"Error: input must be a list of numbers or a string\"\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step <= 0\n\t\terror(\"Step must be positive\")\n\tend\n\tif isa(S, AbstractArray)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractString)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractDict)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractSet)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractRange)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(S, AbstractChannel)\n\t\tS = collect(S)\n\tend\n\tif isa(",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn S\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)-step+1\n\t\tpush!(result, S[i:i+step-1])\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tS is the list to be split\n\tstep is the number of elements in each sublist\n\t\"\"\"\n\tif step == 0\n\t\treturn \"step cannot be zero\"\n\tend\n\tif step == 1\n\t\treturn S\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn \"step cannot be greater than the length of the list\"\n\tend\n\tif step < 0\n\t\treturn \"step cannot be negative\"\n\tend\n\tif isa(S, String)\n\t\treturn \"list_split does not work with strings\"\n\tend\n\tif isa(S, Int64)\n\t\treturn \"list_split does not work with integers\"\n\tend\n\tif isa(S, Float64)\n\t\treturn \"list_split does not work with floats\"\n\tend\n\tif isa(S, Bool)\n\t\treturn \"list_split does not work with booleans\"\n\tend\n\tif isa(S, Symbol)\n\t\treturn \"list_split does not work with symbols\"\n\tend\n\tif isa(S, Dict)\n\t\treturn \"list_split does not work with dictionaries\"\n\tend\n\tif isa(S, Tuple)\n\t\treturn \"list_split does not work with tuples\"\n\tend\n\tif isa(S, Set)\n\t\treturn \"list_split does not work with sets\"\n\tend\n\tif isa(S, Function)\n\t\treturn \"list_split does not work with functions\"\n\tend\n\tif isa(S, Type)\n\t\treturn \"list_split does not work with types\"\n\tend\n\tif isa(S, Module)\n\t\treturn \"list_split does not work with modules\"\n\tend\n\tif isa(S, Any)\n\t\treturn \"list_split does not work with any\"\n\tend\n\tif isa(S, Union)\n\t\treturn \"list_split does not work with unions\"\n\tend\n\tif isa(S, Nothing)\n\t\treturn \"list_split does not work with nothing\"\n\t",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend"
  ]
}