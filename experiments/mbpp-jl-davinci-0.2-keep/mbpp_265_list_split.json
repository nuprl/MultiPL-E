{
  "name": "mbpp_265_list_split",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\nfunction list_split(S::Any, step::Int64)::Any \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = list_split;\n\t@test(candidate([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], 3) == [[\"a\", \"d\", \"g\", \"j\", \"m\"], [\"b\", \"e\", \"h\", \"k\", \"n\"], [\"c\", \"f\", \"i\", \"l\"]])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]])\n\t@test(candidate([\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\"], 2) == [[\"python\", \"C\", \"DBMS\"], [\"java\", \"C++\", \"SQL\"]])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tn = length(S)\n\tif n == 0\n\t\treturn []\n\tend\n\tif n <= step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:n], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif isa(S, Array)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Dict)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Set)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn S\n\tend\nend",
    "\t\"\"\"\n\tSplit a list for every nth element.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\tif length(S) > step\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\ti = 1\n\twhile i <= length(S)\n\t\tpush!(result, S[i:i+step-1])\n\t\ti += step\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == 2\n\t\treturn [S[1:2:end], S[2:2:end]]\n\tend\n\tif step == 3\n\t\treturn [S[1:3:end], S[2:3:end], S[3:3:end]]\n\tend\n\tif step == 4\n\t\treturn [S[1:4:end], S[2:4:end], S[3:4:end], S[4:4:end]]\n\tend\n\tif step == 5\n\t\treturn [S[1:5:end], S[2:5:end], S[3:5:end], S[4:5:end], S[5:5:end]]\n\tend\n\tif step == 6\n\t\treturn [S[1:6:end], S[2:6:end], S[3:6:end], S[4:6:end], S[5:6:end], S[6:6:end]]\n\tend\n\tif step == 7\n\t\treturn [S[1:7:end], S[2:7:end], S[3:7:end], S[4:7:end], S[5:7:end], S[6:7:end], S[7:7:end]]\n\tend\n\tif step == 8\n\t\treturn [S[1:8:end], S[2:8:end], S[3:8:end], S[4:8:end], S[5:8:end], S[6:8:end], S[7:8:end], S[8:8:end]]\n\tend\n\tif step == 9\n\t\treturn [S[1:9:end], S[2:9:end], S[3:9:end], S[4:9:end], S[5:9:end], S[6:9:end], S[7:9:end",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif isa(S, Array)\n\t\tif step > length(S)\n\t\t\terror(\"Step must be less than the length of the list\")\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\tif step > length(S)\n\t\t\terror(\"Step must be less than the length of the list\")\n\t\tend\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\terror(\"Input must be an array or string\")\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\t\n\tresult = []\n\tfor i = 1:step:length(S)\n\t\tresult = [result; S[i:min(i+step-1, length(S))]]\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step < 0\n\t\treturn S\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step == 0\n\t\treturn S\n\telseif step == 1\n\t\treturn [S]\n\telse\n\t\tresult = []\n\t\tfor i in 1:step:length(S)\n\t\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\t\tend\n\t\treturn result\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step < 1\n\t\terror(\"Step must be greater than 0\")\n\tend\n\tif isa(S, Vector)\n\t\tif step > length(S)\n\t\t\treturn [S]\n\t\telse\n\t\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\t\tend\n\telse\n\t\terror(\"Input must be a vector\")\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, Array)\n\t\tresult = Array{Any,1}[]\n\t\tfor i in 1:step:length(S)\n\t\t\tif i+step-1 <= length(S)\n\t\t\t\tpush!(result, S[i:i+step-1])\n\t\t\telse\n\t\t\t\tpush!(result, S[i:end])\n\t\t\tend\n\t\tend\n\t\treturn result\n\tend\n\tif isa(S, String)\n\t\tresult = String[]\n\t\tfor i in 1:step:length(S)\n\t\t\tif i+step-1 <= length(S)\n\t\t\t\tpush!(result, S[i:i+step-1])\n\t\t\telse\n\t\t\t\tpush!(result, S[i:end])\n\t\t\tend\n\t\tend\n\t\treturn result\n\tend\nend",
    "\tif length(S) == 0\n\t\treturn []\n\telse\n\t\treturn [S[1:step]] * list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step < 1\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tpush!(result, S[i:min(i+step-1, length(S))])\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tFunction to split a list into sublists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [[x] for x in S]\n\tend\n\treturn [S[i:i+step-1] for i in 1:step:length(S)]\nend",
    "\t\"\"\"\n\tSplits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i+step-1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend"
  ]
}