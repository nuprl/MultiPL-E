{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\"\"\"\nfunction max_sub_array_sum_repeated(a::Vector{Int64}, n::Int64, k::Int64)::Int64 \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = max_sub_array_sum_repeated;\n\t@test(candidate([10, 20, -30, -1], 4, 3) == 30)\n\t@test(candidate([-1, 10, 20], 3, 2) == 59)\n\t@test(candidate([-1, -2, -3], 3, 3) == -1)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = -Inf \n\tmax_ending_here = 0\n\t\n\t# stores maximum sum of subarray that \n\t# is a part of k-repeated array \n\tmax_k_repeated_subarray = -Inf \n\t\n\t# stores starting index of maximum sum \n\t# subarray that is a part of k-repeated array \n\tstart = 0\n\tend = 0\n\ts = 0\n\t\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i \n\t\tmax_ending_here += a[i] \n\t\t\n\t\t# if maximum sum is negative, set it to 0 \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0\n\t\t\ts = i + 1\n\t\tend\n\t\t\n\t\t# update result if current subarray sum is found \n\t\t# to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\t\tstart = s \n\t\t\tend = i \n\t\tend\n\tend\n\t\n\t# stores sum of all array elements \n\tsum_all = 0\n\t\n\t# stores sum of subarray between start and end \n\tsum_now = 0\n\t\n\t# if maximum sum is negative in original array \n\tif max_so_far < 0 \n\t\t# traverse the array to find sum of all \n\t\t# array elements \n\t\tfor i in 1:n \n\t\t\tsum_all += a[i] \n\t\tend\n\t\t\n\t\t# result is sum of all elements multiplied \n\t\t# by k \n\t\treturn sum_all * k \n\tend\n\t\n\t# traverse the subarray between start and end \n\t# to find sum of that subarray \n\tfor i in start:end \n\t\tsum_now += a[i] \n\tend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "    max_sum = 0\n    for i = 1:n\n        curr_sum = 0\n        for j = i:n\n            curr_sum += a[j]\n            if curr_sum > max_sum\n                max_sum = curr_sum\n            end\n        end\n    end\n    return max_sum * k\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 2:k\n\t\tmax_ending_here = 0\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\tend\n\t\tmax_so_far = max(max_so_far, max_ending_here)\n\tend\n\treturn max_so_far\nend",
    "\t# k is an integer which is the number of times the array is repeated\n\t# n is the length of the array\n\t# a is the array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmin_subarray_sum = 0\n\tfor i in 1:n\n\t\tmin_subarray_sum += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tcurr_sum = 0\n\tfor i in 1:n\n\t\tcurr_sum += a[i]\n\t\tmax_ending_here = max(curr_sum, max_ending_here + a[i])\n\t\tmax_so_far = max(max_so_far, max_ending_here)\n\tend\n\tmax_wrap = curr_sum + max_so_far\n\treturn max(max_wrap, max_subarray_sum)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_so_far = max_so_far + a[i]\n\tend\n\tif max_so_far > 0\n\t\tmax_so_far = max_so_far * k\n\t\tmax_so_far = max_so_far - (max_kadane * (k - 2))\n\t\tif max_so_far < max_kadane\n\t\t\treturn max_kadane\n\t\telse\n\t\t\treturn max_so_far\n\t\tend\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# Find the sum of the original array \n\tmax_sum := 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t\n\t# Find the sum of the middle elements \n\t# i.e. the elements which are common \n\t# in the repeated array \n\tmid_sum := 0\n\tfor i in 1:n\n\t\tmid_sum += a[i]\n\tend\n\tmid_sum := mid_sum * (k - 2)\n\t\n\t# Find the sum of the last subarray \n\t# i.e. the elements which are common \n\t# in the repeated array \n\tlast_sum := 0\n\tfor i in 1:n\n\t\tlast_sum += a[i]\n\tend\n\t\n\t# Find the sum of the whole array \n\t# i.e. the elements which are common \n\t# in the repeated array \n\ttotal_sum := 0\n\tfor i in 1:n\n\t\ttotal_sum += a[i]\n\tend\n\ttotal_sum := total_sum * k\n\t\n\t# Return the maximum of the three \n\t# sums calculated above \n\treturn max(max_sum, mid_sum, last_sum, total_sum)\nend",
    "\t# Find the sum of the first window of size n \n\tmax_sum = sum(a[1:n]) \n\twindow_sum = max_sum ",
    "\t# kadane's algorithm to find maximum \n\t# subarray sum for standard array \n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum with middle elements \n\t# as boundaries \n\tmax_sum = 0\n\tmin_val = 0\n\tfor i in 1:n \n\t\tmax_sum = max_sum + a[i] \n\t\tmin_val = min(min_val, max_sum) \n\tend\n\tmax_sum = 0\n\tfor i in 1:n \n\t\tmax_sum = max_sum + a[i] \n\tend\n\t# Case 1 (Only rotation, No-wrap around) \n\tmax_kadane = max_so_far \n\t# Case 2 (Wrap around) \n\tif max_sum > 0\n\t\tmax_kadane = max(max_kadane, max_sum * k + min_val) \n\telse\n\t\t# Case 3 (No wrap around) \n\t\tmax_kadane = max(max_kadane, max_sum) \n\tend\n\treturn max_kadane \nend",
    "\t# Find the sum of the first subarray \n\t# and initialize the result \n\tmax_so_far = sum(a[1:n]) \n\tmax_ending_here = max_so_far \n\t\n\t# Find the sum of the remaining subarrays \n\tfor i in 2:k \n\t\tmax_ending_here = max_ending_here + sum(a[1:n]) - n * a[n] \n\t\tmax_so_far = max(max_so_far, max_ending_here) \n\tend\n\t\n\treturn max_so_far \nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t# Find the sum of the elements in the array which are not part of the max sub array\n\tcurr_sum := 0\n\tfor i in 1:n\n\t\tcurr_sum += a[i] * (k - 1)\n\t\tcurr_sum -= a[i]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + sum(a) - n*a[i-1]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t\n\t# find the max sum of subarray in the original array\n\tmax_sum_original = max_sub_array_sum(a, n)\n\t\n\t# find the max sum of subarray in the original array\n\tmax_sum_all = sum(a)\n\t\n\t# find the min sum of subarray in the original array\n\tmin_sum_all = sum(a)\n\t\n\t# find the min sum of subarray in the original array\n\tmin_sum_original = min_sub_array_sum(a, n)\n\t\n\t# find the max sum of subarray in the repeated array\n\tmax_sum_repeated = max_sum_all * k\n\t\n\t# find the min sum of subarray in the repeated array\n\tmin_sum_repeated = min_sum_all * k\n\t\n\t# find the max sum of subarray in the repeated array\n\tmax_sum_repeated = max(max_sum_repeated, max_sum_original + (max_sum_all * (k-2)) + min_sum_original)\n\t\n\t# find the min sum of subarray in the repeated array\n\tmin_sum_repeated = min(min_sum_repeated, min_sum_original + (min_sum_all * (k-2)) + max_sum_original)\n\t\n\treturn max_sum_repeated\nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t# Find the sum of the middle elements\n\tmid_sum := 0\n\tfor i in 1:n\n\t\tmid_sum += a[i] * (k - 2)\n\tend\n\t# Find the sum of the first and last elements\n\tfirst_sum := 0\n\tlast_sum := 0\n\tfor i in 1:n\n\t\tfirst_sum += a[i]\n\t\tlast_sum += a[i]\n\tend\n\t# Find the maximum sum\n\tmax_sum := max(max_sum, mid_sum, first_sum, last_sum)\n\treturn max_sum\nend",
    "\t# Initialize result \n\tmax_sum := 0\n\t# Consider all blocks starting with i. \n\tfor i in 1:n\n\t\tcurr_sum := 0\n\t\t# Calculate sum of current block \n\t\tfor j in 1:n \n\t\t\tcurr_sum += a[j]\n\t\tend\n\t\t# Update result if required \n\t\tif curr_sum > max_sum \n\t\t\tmax_sum := curr_sum\n\t\tend\n\tend\n\treturn max_sum\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tmax_ending_here = max(0, max_ending_here) \n\t\t# update result if current subarray sum is found to be greater \n\t\tmax_so_far = max(max_so_far, max_ending_here) \n\tend\n\t# max sum is sum of max subarray sum found in k iterations \n\t# as there can be negative elements, taking minimum with 0 \n\treturn max(0, max_so_far * k) \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t\"\"\"\n\ta: array of integers\n\tn: length of array\n\tk: number of times to repeat array\n\t\"\"\"\n\t# find max subarray sum in original array\n\tmax_sub_array_sum(a, n)\n\t\n\t# find min subarray sum in original array\n\tmin_sub_array_sum(a, n)\n\t\n\t# find sum of the original array\n\tsum_of_array(a, n)\n\t\n\t# find max sum of the array by repeating the array k times\n\tmax_sum = max(sum_of_array * k, max_sub_array_sum)\n\t\n\t# find min sum of the array by repeating the array k times\n\tmin_sum = min(sum_of_array * k, min_sub_array_sum)\n\t\n\t# return max sum of the array by repeating the array k times\n\treturn max(max_sum, sum_of_array * (k - 2) + max_sub_array_sum)\nend",
    "\t# Find the sum of the first window \n\tmax_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum with all elements\n\tmax_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t# if all elements are negative\n\tif max_sum < 0\n\t\treturn max_so_far\n\tend\n\t# max sum repeating k-2 times\n\tmax_sum = max_sum * (k-2)\n\t# overall max sum\n\treturn max(max_sum, max_so_far)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:k\n\t\tfor j in 1:n\n\t\t\tmax_ending_here = max_ending_here + a[j]\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_ending_here = 0\n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\treturn max(a)\n\tend\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\treturn max(max_so_far, max_wrap)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_sub_array_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_so_far = max_so_far + a[i]\n\t\tif max_so_far < 0\n\t\t\tmax_so_far = 0\n\t\tend\n\t\tif max_sub_array_sum < max_so_far\n\t\t\tmax_sub_array_sum = max_so_far\n\t\tend\n\tend\n\treturn max_sub_array_sum * k\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_so_far = max_so_far + a[i]\n\tend\n\tmax_so_far = max_so_far * (k - 2)\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\treturn max(max_so_far, max_subarray_sum)\nend",
    "\t# Find the sum of the original array \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t\n\t# Find the maximum value of the sum \n\t# of the subarray \n\tmax_val = max_sum\n\tfor i in 1:n\n\t\tcurr_sum = 0\n\t\tfor j in 1:n\n\t\t\tcurr_sum += a[j]\n\t\tend\n\t\tmax_val = max(max_val, curr_sum)\n\tend\n\t\n\t# Return maximum sum \n\treturn max_val * k\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum(a, n)\n\tif max_wrap > max_subarray_sum\n\t\tmax_subarray_sum = max_wrap\n\tend\n\treturn max_subarray_sum\nend",
    "\t# Find maximum sum subarray using kadane's \n\t# algorithm. Since the array is circular, we \n\t# need to handle case when middle element \n\t# (or those near middle) is part of maximum \n\t# sum subarray. In that case, we can individually \n\t# find out maximum sum subarray in left and right \n\t# parts and combine to get the maximum sum \n\t# subarray crossing the middle elements. \n\t# In other case, maximum sum subarray may \n\t# not cross the middle elements, so we need \n\t# to handle that case separately. \n\t\n\t# Case 1: get the maximum sum subarray from \n\t#         the first part of k-repeated array \n\t#         i.e., i from 0 to n-1 \n\tmax_kadane = kadane(a, n) \n\t\n\t# Case 2: Now find the maximum sum subarray \n\t#         from the middle part \n\t#         i.e., i from n to 2n-1 \n\tmax_wrap = 0\n\tfor i in 1:n \n\t\tmax_wrap += a[i] \n\tend\n\t\n\t# Case 3: Maximum sum will be formed by \n\t#         maximum sum subarray from first \n\t#         part + maximum sum subarray from \n\t#         middle part + maximum sum subarray \n\t#         from last part \n\tmax_wrap = max_wrap + kadane(a, n) \n\t\n\t# The maximum of all cases \n\treturn max(max_kadane, max_wrap) \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of size n\n\t\n\t# create a new array of size n*k\n\tb = zeros(Int64, n*k)\n\t\n\t# copy the original array k times\n\tfor i in 1:k\n\t\tb[(i-1)*n+1:i*n] = a\n\tend\n\t\n\t# find the maximum subarray sum\n\treturn max_sub_array_sum(b, n*k)\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# stores ending index of maximum sum subarray found so far \n\tend = 0\n\t# stores starting index of maximum sum subarray found so far \n\tstart = 0\n\t# stores ending index of maximum sum subarray ending at current position \n\ts = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here += a[i]\n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\t\ts = i + 1\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\t\tstart = s\n\t\t\tend = i\n\t\tend\n\tend\n\t# stores sum of all elements of the original array \n\ttotal_sum = 0\n\tfor i in 1:n\n\t\ttotal_sum += a[i]\n\tend\n\t# if total_sum of the original array is negative, \n\t# max sum will be maximum subarray sum of the original array \n\tif total_sum > max_so_far\n\t\tmax_so_far = total_sum\n\tend\n\t# if max sum is negative, then all numbers in the array are negative \n\tif max_so_far < 0\n\t\tmax_so_far = 0\n\tend\n\t# maximum sum of subarray is sum of max subarray \n\t# of original array and max subarray of (k-2) repeated array \n\treturn max_so_far * k - total_sum\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is the array\n\t# returns the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\n\t# initialize the maximum sum\n\tmax_sum = 0\n\t\n\t# initialize the current sum\n\tcurr_sum = 0\n\t\n\t# loop over the array\n\tfor i in 1:n\n\t\t# add the current element to the current sum\n\t\tcurr_sum += a[i]\n\t\t\n\t\t# if the current sum is negative, then set the current sum to 0\n\t\tif curr_sum < 0\n\t\t\tcurr_sum = 0\n\t\tend\n\t\t\n\t\t# update the maximum sum\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t\n\t# initialize the maximum sum of the array\n\tmax_array_sum = max_sum\n\t\n\t# initialize the minimum sum of the array\n\tmin_array_sum = 0\n\t\n\t# initialize the total sum of the array\n\ttotal_array_sum = 0\n\t\n\t# loop over the array\n\tfor i in 1:n\n\t\t# add the current element to the total sum of the array\n\t\ttotal_array_sum += a[i]\n\t\t\n\t\t# update the minimum sum of the array\n\t\tmin_array_sum = min(min_array_sum, total_array_sum)\n\tend\n\t\n\t# if the total sum of the array is positive\n\tif total_array_sum > 0\n\t\t# return the maximum sum of the array\n\t\treturn max(max_sum, total_array_sum * (k - 2) + max_sum)\n\tend\n\t\n\t# if the total sum of the array is negative\n\tif total_array_sum < 0\n\t\t# return the maximum sum of the array\n\t\treturn max(max_sum, total_array_sum * (k - 2) + max_sum)\n\tend\n\t\n\t# return the maximum sum of the array\n\treturn max_sum\n",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far > 0\n\t\treturn max(max_so_far, max_subarray_sum * (k - 2))\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i = 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\treturn max_so_far\n\tend\n\tmax_so_far = max_so_far * k\n\tmax_prefix_sum = 0\n\tmax_suffix_sum = 0\n\tcurr_prefix_sum = 0\n\tcurr_suffix_sum = 0\n\tfor i = 1:n\n\t\tcurr_prefix_sum += a[i]\n\t\tmax_prefix_sum = max(max_prefix_sum, curr_prefix_sum)\n\t\tcurr_suffix_sum += a[n - i + 1]\n\t\tmax_suffix_sum = max(max_suffix_sum, curr_suffix_sum)\n\tend\n\treturn max(max_so_far, max_prefix_sum + max_suffix_sum + (k - 2) * max_prefix_sum)\nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t# Find the sum of the prefix sum array\n\tprefix_sum := 0\n\tfor i in 1:n\n\t\tprefix_sum += a[i]\n\t\ta[i] = prefix_sum\n\tend\n\t# Find the sum of the suffix sum array\n\tsuffix_sum := 0\n\tfor i in n:-1:1\n\t\tsuffix_sum += a[i]\n\t\ta[i] = max(a[i], suffix_sum)\n\tend\n\t# Find the maximum sum of the subarray\n\tfor i in 1:n\n\t\tmax_sum = max(max_sum, k * a[i])\n\tend\n\treturn max_sum\nend",
    "\t# Find the sum of the first window of size n \n\tmax_sum := 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tcurr_sum := max_sum\n\tfor i in n+1:n*k\n\t\tcurr_sum += a[i % n] - a[(i-n) % n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t\n\treturn max_sum\nend",
    "\t# Find the sum of the original array \n\tmax_sum = 0\n\tcurr_sum = 0\n\tfor i in 1:n\n\t\tcurr_sum += a[i]\n\tend\n\tmax_sum = curr_sum\n\t# Find the sum of next k-1 subarrays \n\t# and update max_sum if needed \n\tfor j in 2:k\n\t\tcurr_sum = 0\n\t\tfor i in 1:n\n\t\t\tcurr_sum += a[i]\n\t\tend\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t# k is an integer which is the number of times the array is repeated\n\t# n is the length of the array\n\t# a is the array\n\t\n\t# find the maximum subarray sum in the original array\n\tmax_sub_array_sum = max_sub_array_sum_kadane(a, n)\n\t\n\t# find the sum of the entire array\n\tarray_sum = sum(a)\n\t\n\t# find the maximum subarray sum of the array repeated k times\n\tmax_sub_array_sum_repeated = max_sub_array_sum + (k - 2) * array_sum\n\t\n\t# if the maximum subarray sum of the array repeated k times is less than the maximum subarray sum of the original array, return the maximum subarray sum of the original array\n\tif max_sub_array_sum_repeated < max_sub_array_sum\n\t\treturn max_sub_array_sum\n\tend\n\t\n\t# otherwise, return the maximum subarray sum of the array repeated k times\n\treturn max_sub_array_sum_repeated\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = -Inf \n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\tend\n\t# max_so_far is the maximum sum of subarray in original array, say B \n\t# max(sum of subarray B) + max(sum of subarray B repeated k times) \n\t# = max(sum of subarray B) + max(sum of subarray B) * (k-1) \n\t# = max(sum of subarray B) * k \n\treturn max_so_far * k \nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of integers\n\t\n\t# find the maximum sum of the contiguous subarray in the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# find the minimum sum of the contiguous subarray in the original array\n\tmin_so_far = 0\n\tmin_ending_here = 0\n\tfor i in 1:n\n\t\tmin_ending_here += a[i]\n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\tif min_so_far > min_ending_here\n\t\t\tmin_so_far = min_ending_here\n\t\tend\n\tend\n\t\n\t# find the sum of the original array\n\tsum_of_array = 0\n\tfor i in 1:n\n\t\tsum_of_array += a[i]\n\tend\n\t\n\t# if the sum of the array is positive, then the maximum sum of the contiguous subarray in the modified array is the maximum sum of the contiguous subarray in the original array repeated k times\n\tif sum_of_array > 0\n\t\treturn max_so_far * k\n\t# if the sum of the array is negative, then the maximum sum of the contiguous subarray in the modified array is the maximum sum of the contiguous subarray in the original array repeated k times minus the minimum sum of the contiguous subarray in the original array repeated k-1 times\n\telseif sum_of_array < 0\n\t\treturn max_so_far * k - min_so_far * (k-1)\n\t# if the sum of the array is zero, then the maximum sum of the contiguous subarray in the modified array is the maximum sum of",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Use the maximum sum of previous window as initial maximum sum for next window \n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + (a[i] - a[i-n])\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\twindow_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\twindow_sum = max_sum\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i in n+1:2*n\n\t\twindow_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, window_sum)\n\tend\n\t# Return maximum sum of k consecutive windows of size n \n\treturn max_sum * k\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\tfor i in 1:n \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update maximum sum so far, if needed \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\tend\n\t# max sum is greater than 0 \n\tif max_so_far > 0 \n\t\treturn max_so_far * k \n\tend\n\t# max sum is less than 0 \n\tmax_so_far = 0\n\tfor i in 1:n \n\t\tmax_so_far += a[i] \n\tend\n\t# k is 1 \n\tif k == 1 \n\t\treturn max_so_far \n\tend\n\t# max sum is greater than 0 \n\tif max_so_far > 0 \n\t\treturn max_so_far * k \n\tend\n\t# max sum is less than 0 \n\tmax_element = a[1] \n\tfor i in 2:n \n\t\tif max_element < a[i] \n\t\t\tmax_element = a[i] \n\t\tend\n\tend\n\treturn max_element \nend",
    "\t# a is the array, n is the length of the array, k is the number of times to repeat the array\n\t# find the maximum sum subarray of the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# find the minimum sum subarray of the original array\n\tmin_so_far = 0\n\tmin_ending_here = 0\n\tfor i in 1:n\n\t\tmin_ending_here = min_ending_here + a[i]\n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\tif min_so_far > min_ending_here\n\t\t\tmin_so_far = min_ending_here\n\t\tend\n\tend\n\t# find the maximum sum subarray of the modified array\n\t# if all the elements in the array are negative, then the maximum sum subarray is the maximum element\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\tend\n\t# if the sum of the original array is positive, then the maximum sum subarray of the modified array is the sum of the original array multiplied by k minus the minimum sum subarray of the original array\n\tif sum(a) > 0\n\t\treturn k * sum(a) - min_so_far\n\tend\n\t# if the sum of the original array is negative, then the maximum sum subarray of the modified array is the maximum sum subarray of the original array\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_so_far = max_so_far + sum(a)\n\t\tif max_so_far < max_subarray_sum\n\t\t\tmax_so_far = max_subarray_sum\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_subarray_sum\n\t\treturn max_wrap\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\t# Find the sum of the first subarray \n\t# and initialize the result \n\tmax_so_far = sum(a) \n\tmax_end = max_so_far \n\t\n\t# Find the sum of the next subarrays and \n\t# update the result if required \n\tfor i in 1:n-1 \n\t\tmax_end = max_end + sum(a) - n*a[i] \n\t\tmax_so_far = max(max_so_far, max_end) \n\tend\n\t\n\treturn max_so_far * k \nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i = n+1:n*k\n\t\tcurr_sum += a[i % n] - a[i - n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max(max_subarray_sum, max_so_far)\n\treturn max_subarray_sum * k\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\treturn max(max_kadane, max_wrap)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_so_far = max_so_far + a[i]\n\t\tif max_so_far > max_subarray_sum\n\t\t\tmax_subarray_sum = max_so_far\n\t\tend\n\tend\n\treturn max_subarray_sum * k\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\twindow_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend\n\twindow_sum = max_sum\n\t\n\t# Move the window by one element. \n\tfor i = n+1:length(a)\n\t\twindow_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, window_sum)\n\tend\n\t\n\t# max_sum is the maximum sum in the first window. \n\t# Compute sums of remaining windows by removing \n\t# first element of previous window and adding last \n\t# element of current window. \n\tfor i = 2:k\n\t\twindow_sum = 0\n\t\tfor j = 1:n\n\t\t\twindow_sum += a[j]\n\t\tend\n\t\tmax_sum = max(max_sum, window_sum)\n\t\tfor j = n+1:length(a)\n\t\t\twindow_sum += a[j] - a[j-n]\n\t\t\tmax_sum = max(max_sum, window_sum)\n\t\tend\n\tend\n\treturn max_sum\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\t# max sum with corner elements\n\tmax_corner_sum = 0\n\tfor i in 1:n\n\t\tmax_corner_sum += a[i]\n\tend\n\tmax_corner_sum = max_corner_sum * k\n\t# max sum repeating the array\n\tmax_sum = max_corner_sum\n\tfor i in 1:n\n\t\tmax_sum += (k - 1) * a[i]\n\tend\n\t# max sum with all elements\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\tend\n\tmax_wrap *= k\n\t# compare all the sums and return the maximum\n\treturn max(max_kadane, max_corner_sum, max_sum, max_wrap)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_sub_array_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\tif max_wrap > max_sub_array_sum\n\t\treturn max_wrap\n\telse\n\t\treturn max_sub_array_sum\n\tend\nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t# Find the sum of the middle elements\n\t# if k is even\n\tif k % 2 == 0\n\t\tmax_sum := max_sum + sum(a[2:n-1]) * (k/2 - 1)\n\telse\n\t\tmax_sum := max_sum + sum(a[2:n-1]) * (k/2)\n\tend\n\t# Find the sum of the corner elements\n\tmax_sum := max_sum + a[1] * (k-1) + a[n-1] * (k-1)\n\treturn max_sum\nend",
    "\t\n\t# Find the sum of the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# Find the sum of the whole array\n\tmax_whole_array = 0\n\tfor i in 1:n\n\t\tmax_whole_array += a[i]\n\tend\n\t\n\t# Find the sum of the repeated array\n\tif max_whole_array > 0\n\t\tmax_repeated_array = max_whole_array * k\n\telse\n\t\tmax_repeated_array = max_so_far\n\tend\n\t\n\t# Find the sum of the array in between\n\tmax_in_between = max_repeated_array\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_in_between < max_ending_here\n\t\t\tmax_in_between = max_ending_here\n\t\tend\n\tend\n\t\n\t# Return the maximum sum\n\treturn max(max_repeated_array, max_in_between)\nend",
    "\t# Find sum of all elements \n\ttotal_sum = sum(a) \n\t\n\t# Find maximum sum of subarray \n\t# using Kadane's algorithm \n\tmax_sum = max_sub_array_sum(a, n) \n\t\n\t# Maximum sum of subarray is sum of all \n\t# elements when k is 1 \n\tif k == 1: \n\t\treturn max_sum \n\tend\n\t\n\t# Case 1 \n\tif max_sum < 0: \n\t\treturn max_sum \n\tend\n\t\n\t# Case 2 \n\treturn max(max_sum, (total_sum * (k - 2) + max_sum)) \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\treturn max_so_far\n\tend\n\tmax_so_far = max_so_far * k\n\tmax_prefix_sum = 0\n\tmin_prefix_sum = 0\n\tprefix_sum = 0\n\tfor i in 1:n\n\t\tprefix_sum = prefix_sum + a[i]\n\t\tif max_prefix_sum < prefix_sum\n\t\t\tmax_prefix_sum = prefix_sum\n\t\tend\n\t\tif min_prefix_sum > prefix_sum\n\t\t\tmin_prefix_sum = prefix_sum\n\t\tend\n\tend\n\tmax_suffix_sum = 0\n\tmin_suffix_sum = 0\n\tsuffix_sum = 0\n\tfor i in n:-1:1\n\t\tsuffix_sum = suffix_sum + a[i]\n\t\tif max_suffix_sum < suffix_sum\n\t\t\tmax_suffix_sum = suffix_sum\n\t\tend\n\t\tif min_suffix_sum > suffix_sum\n\t\t\tmin_suffix_sum = suffix_sum\n\t\tend\n\tend\n\tmax_suffix_sum = max_suffix_sum * (k - 2)\n\tmin_suffix_sum = min_suffix_sum * (k - 2)\n\treturn max(max_so_far, max_prefix_sum + max_suffix_sum, max_prefix_sum + min_suffix_sum)\nend",
    "\t\"\"\"\n\tFind the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\"\"\"\n\tmax_so_far = -Inf\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = -Inf\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum(a, n, k)\n\tif max_wrap > max_subarray_sum\n\t\tmax_subarray_sum = max_wrap\n\tend\n\treturn max_subarray_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_subarray_sum_circular(a, n)\n\tif max_wrap > max_subarray_sum\n\t\treturn max_wrap\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\tend\n\t# max sum is sum of max subarray sum of each (n*k) subarrays \n\treturn max_so_far * k \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# Find the sum of the original array \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t\n\t# Find the sum of the middle elements \n\t# i.e. sum of the subarray A[1], A[2], ..., A[n] \n\tcurr_val = 0\n\tfor i in 1:n\n\t\tcurr_val += a[i]\n\tend\n\t\n\t# Initialize result \n\tmax_val = curr_val\n\t\n\t# Traverse middle elements \n\tfor j in 2:k\n\t\t# Update current value \n\t\tcurr_val = 0\n\t\tfor i in 1:n\n\t\t\tcurr_val += a[i]\n\t\tend\n\t\t\n\t\t# Update result if required \n\t\tmax_val = max(max_val, curr_val)\n\tend\n\t\n\t# Return result \n\treturn max(max_val, max_sum)\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum \n\tfor i in n+1:2n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Use the maximum sum of previous window as initial sum of next window \n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + (a[i*n] - a[(i-1)*n])\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# Initialize result \n\tres := 0\n\t\n\t# Find sum of first subarray \n\t# across k groups \n\tfor i in 1:n \n\t\tres += a[i] \n\tend\n\t\n\t# Initialize curr_val to store sum of \n\t# current subarray \n\tcurr_val := res \n\t\n\t# Calculate sum of remaining subarrays \n\tfor i in 1:n \n\t\t\n\t\t# Calculate sum of next group in \n\t\t# current subarray. \n\t\tcurr_val := curr_val - a[i] + a[(i % n) + 1] \n\t\t\n\t\t# Update result if required \n\t\tif curr_val > res \n\t\t\tres := curr_val \n\t\tend\n\tend\n\t\n\treturn res \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:k\n\t\tmax_ending_here = 0\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\t\tif max_so_far < 0\n\t\t\treturn max_so_far\n\t\tend\n\tend\n\tmax_so_far = max_so_far * k\n\tprefix_sum = 0\n\tsuffix_sum = 0\n\tfor i in 1:n\n\t\tprefix_sum = prefix_sum + a[i]\n\t\tsuffix_sum = suffix_sum + a[n-i+1]\n\t\tif prefix_sum > max_so_far\n\t\t\tmax_so_far = prefix_sum\n\t\tend\n\t\tif suffix_sum > max_so_far\n\t\t\tmax_so_far = suffix_sum\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Find the maximum sum of other windows by \n\t# removing the first element of previous \n\t# window and adding the last element of \n\t# current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + sum(a) - n*a[i-1]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum is sum of max subarray sum of each (concatenated) subarray \n\treturn max_so_far * k\nend",
    "\t# max_sum is used to store maximum sum \n\t# subarray_sum is used to store sum of \n\t# elements of every subarray \n\tmax_sum = subarray_sum = 0\n\t\n\t# len is used to store length of first \n\t# subarray. Initialize len by n \n\tlen = n\n\t\n\t# k > 1 because sum of first subarray \n\t# is calculated and stored in max_sum \n\twhile k > 1\n\t\t# Calculate sum of next subarray and \n\t\t# update len to length of this subarray \n\t\tif len < n\n\t\t\tlen += 1\n\t\tend\n\t\t\n\t\t# for loop to calculate sum of every \n\t\t# subarray from a[0] to a[len-1] \n\t\tfor i in 1:len\n\t\t\tsubarray_sum += a[i]\n\t\tend\n\t\t\n\t\t# Update max_sum if required \n\t\tif subarray_sum > max_sum\n\t\t\tmax_sum = subarray_sum\n\t\tend\n\t\t\n\t\t# Calculate sum of next subarray and \n\t\t# update len to length of this subarray \n\t\tif len < n\n\t\t\tlen += 1\n\t\tend\n\t\t\n\t\t# for loop to calculate sum of every \n\t\t# subarray from a[n-len+1] to a[n-1] \n\t\tfor i in n-len+1:n\n\t\t\tsubarray_sum += a[i]\n\t\tend\n\t\t\n\t\t# Update max_sum if required \n\t\tif subarray_sum > max_sum\n\t\t\tmax_sum = subarray_sum\n\t\tend\n\t\t\n\t\t# Decrease k by 1 \n\t\tk -= 1\n\tend\n\t\n\t# Return maximum sum \n\treturn max_sum\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of integers\n\t# return the maximum sum of a contiguous array in the modified array\n\t\n\t# the maximum sum of a contiguous array in the modified array is the maximum sum of a contiguous array in the original array multiplied by k\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array in the original array is the maximum sum of a contiguous array in the original array\n\t# the maximum sum of a contiguous array",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1)\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is the length of the array\n\t# a is the array\n\t\n\t# find the maximum subarray sum for the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# find the minimum subarray sum for the original array\n\tmin_so_far = 0\n\tmin_ending_here = 0\n\tfor i in 1:n\n\t\tmin_ending_here = min_ending_here + a[i]\n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\tif min_so_far > min_ending_here\n\t\t\tmin_so_far = min_ending_here\n\t\tend\n\tend\n\t\n\t# find the sum of the original array\n\ttotal_sum = 0\n\tfor i in 1:n\n\t\ttotal_sum = total_sum + a[i]\n\tend\n\t\n\t# if the total sum of the array is positive, then the maximum subarray sum is the maximum subarray sum of the original array\n\tif total_sum > 0\n\t\treturn max(max_so_far, total_sum*(k-2) + max_so_far)\n\telseif total_sum < 0\n\t\treturn max(max_so_far, total_sum*(k-2) + max_so_far)\n\telse\n\t\treturn max_so_far\n\tend\nend",
    "\t# Find the sum of the first subarray \n\t# and initialize the result \n\tsum = 0\n\tfor i in 1:n\n\t\tsum += a[i]\n\tend\n\t\n\t# Compute sum of remaining subarrays \n\t# and find the maximum sum \n\tcurr_sum = sum\n\tfor i in 1:n\n\t\tcurr_sum += (k - 1) * a[i]\n\t\tsum = max(sum, curr_sum)\n\tend\n\t\n\treturn sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of size n\n\t# a[i] is an integer denoting the ith element of the array\n\t# return the maximum sum of a contiguous subarray in the modified array\n\t\n\t# create a new array with k copies of the original array\n\tb = repeat(a, k)\n\t\n\t# create a variable to store the maximum sum\n\tmax_sum = 0\n\t\n\t# create a variable to store the current sum\n\tcurrent_sum = 0\n\t\n\t# loop through the new array\n\tfor i in 1:length(b)\n\t\t# add the current element to the current sum\n\t\tcurrent_sum += b[i]\n\t\t\n\t\t# if the current sum is less than 0, reset the current sum to 0\n\t\tif current_sum < 0\n\t\t\tcurrent_sum = 0\n\t\tend\n\t\t\n\t\t# if the current sum is greater than the maximum sum, update the maximum sum\n\t\tif current_sum > max_sum\n\t\t\tmax_sum = current_sum\n\t\tend\n\tend\n\t\n\t# return the maximum sum\n\treturn max_sum\nend",
    "\t# kadane's algorithm to find maximum subarray sum\n\t# stores maximum sum subarray found so far\n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position\n\tmax_ending_here = 0\n\t# traverse the given array\n\tfor i in 1:n\n\t\t# update maximum sum of subarray \"ending\" at index i (by adding\n\t\t# current element to maximum sum ending at previous index i-1)\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\t# if maximum sum is negative, set it to 0 (which represents\n\t\t# an empty subarray)\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum is sum of max subarray sum of each (concatenated) subarray\n\treturn max_so_far * k\nend",
    "\t\"\"\"\n\tFind the sum of max subarray sum of the given array repeated k times.\n\t\"\"\"\n\tmax_sum_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_sum_so_far = max_ending_here\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here - a[i] + a[i]\n\t\tmax_sum_so_far = max(max_sum_so_far, max_ending_here)\n\tend\n\tmax_sum_so_far = max(max_sum_so_far, max_ending_here)\n\treturn max_sum_so_far * k\nend",
    "\t\n\t# Find sum of the original array. \n\tmax_sum := sum(a) \n\t\n\t# Find sum of the middle elements \n\t# formed by joining two copies \n\t# of the original array. \n\tcurr_val := 0\n\tfor i in 1:n \n\t\tcurr_val += a[i] \n\tend\n\t\n\t# If k is even \n\tif k % 2 == 0 \n\t\tcurr_val += curr_val \n\telse\n\t\tcurr_val += sum(a) \n\tend\n\t\n\t# Update maximum sum \n\tif curr_val > max_sum \n\t\tmax_sum := curr_val \n\tend\n\t\n\t# Find maximum sum by including \n\t# middle elements in the subarray \n\tfor i in 1:n \n\t\tcurr_val := 0\n\t\tfor j in 1:k \n\t\t\tcurr_val += a[(i + j - 1) % n] \n\t\tend\n\t\tif curr_val > max_sum \n\t\t\tmax_sum := curr_val \n\t\tend\n\tend\n\t\n\treturn max_sum \nend",
    "\tmax_ending_here = 0\n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\t\tif max_so_far < 0\n\t\t\treturn max_so_far\n\t\tend\n\tend\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\treturn max(max_so_far, max_wrap)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum(a, n, 1)\n\tif max_wrap > max_subarray_sum\n\t\treturn max_wrap\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\treturn max(max_subarray_sum, max_wrap)\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = -Inf \n\tmax_ending_here = 0\n\tfor i in 1:n \n\t\tmax_ending_here += a[i] \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0 \n\t\tend\n\tend\n\t# stores maximum sum of subarray that \n\t# is a part of given array \n\tmax_subarray_sum = max_so_far \n\t# max sum is sum of all elements when \n\t# k is 1 \n\tif k == 1 \n\t\treturn max_subarray_sum \n\tend\n\t# stores sum of all elements \n\tarray_sum = sum(a) \n\t# max sum is sum of all elements multiplied \n\t# by k when all elements are -ve \n\tif max_subarray_sum < 0 \n\t\treturn max_subarray_sum * k \n\tend\n\t# case when k is 2 \n\tif k == 2 \n\t\treturn max(max_subarray_sum, array_sum + max_subarray_sum) \n\tend\n\t# find maximum sum by including elements \n\t# of array in the subarray \n\t# i.e., 2*max_subarray_sum_kadane \n\t# - array_sum \n\treturn max(max_subarray_sum, 2*max_subarray_sum - array_sum) \nend",
    "\t\"\"\"\n\ta: array\n\tn: length of array\n\tk: number of times to repeat array\n\t\"\"\"\n\t\n\t# find max sum of subarray in original array\n\tmax_sum_subarray = max_sub_array_sum(a, n)\n\t\n\t# find sum of entire array\n\tarray_sum = sum(a)\n\t\n\t# find max sum of subarray in repeated array\n\tmax_sum_subarray_repeated = max_sum_subarray + (k - 1) * array_sum\n\t\n\treturn max_sum_subarray_repeated\nend",
    "\t# Find the sum of the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# Find the sum of the whole array\n\tsum_of_array = 0\n\tfor i in 1:n\n\t\tsum_of_array += a[i]\n\tend\n\t\n\t# Find the sum of the max subarray\n\tmax_sub_array_sum = max_so_far\n\t\n\t# Find the sum of the max subarray repeated k times\n\tmax_sub_array_sum_repeated = max_sub_array_sum * k\n\t\n\t# Find the sum of the whole array repeated k times\n\tsum_of_array_repeated = sum_of_array * k\n\t\n\t# Find the sum of the whole array repeated k-1 times\n\tsum_of_array_repeated_k_1 = sum_of_array_repeated - sum_of_array\n\t\n\t# Find the sum of the whole array repeated k-2 times\n\tsum_of_array_repeated_k_2 = sum_of_array_repeated_k_1 - sum_of_array\n\t\n\t# Find the sum of the whole array repeated k-3 times\n\tsum_of_array_repeated_k_3 = sum_of_array_repeated_k_2 - sum_of_array\n\t\n\t# Find the sum of the whole array repeated k-4 times\n\tsum_of_array_repeated_k_4 = sum_of_array_repeated_k_3 - sum_of_array\n\t\n\t# Find the sum of the whole array repeated k-5 times\n\tsum_of_array_repeated_k_5 = sum_of_array_repeated_k_4 - sum_of_array\n\t\n\t# Find the sum of the",
    "\t# Initialize result \n\tresult = 0\n\t\n\t# Find sum of all subarrays \n\t# and find the maximum sum \n\tfor i in 1:n\n\t\tcurr_sum = 0\n\t\tfor j in 1:k\n\t\t\tcurr_sum += a[(i - 1) % n + 1]\n\t\t\tresult = max(result, curr_sum)\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t\n\t# Find the sum of the first window of size n\n\tmax_sum = sum(a[1:n])\n\twindow_sum = max_sum\n\t\n\t# Move the window by one element.\n\tfor i in n+1:length(a)\n\t\twindow_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, window_sum)\n\tend\n\t\n\t# Compute the maximum sum by considering the elements\n\t# in all windows.\n\tmax_sum = max(max_sum, window_sum)\n\t\n\t# The maximum sum is of size n*k. Divide the sum by k\n\t# to get the maximum sum of the subarray of size n.\n\treturn max_sum * k\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_subarray_sum\n\t\treturn max_wrap\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:k\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the sum of the first subarray \n\t# and initialize the result \n\tmax_so_far = sum(a[1:n]) \n\tmax_ending_here = max_so_far \n\t\n\t# Find the sum of the remaining subarrays \n\tfor i in 2:k \n\t\tmax_ending_here = max_ending_here + sum(a[1:n]) - n * a[n] \n\t\tmax_so_far = max(max_so_far, max_ending_here) \n\tend\n\t\n\treturn max_so_far \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_subarray_sum = max_subarray_sum + a[i]\n\tend\n\tmax_subarray_sum = max(max_subarray_sum, max_so_far)\n\treturn max_subarray_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\t\tif max_so_far < 0\n\t\t\treturn max_so_far\n\t\tend\n\tend\n\tmax_so_far = max_so_far * k\n\tmax_prefix_sum = 0\n\tmax_suffix_sum = 0\n\tcurr_prefix_sum = 0\n\tcurr_suffix_sum = 0\n\tfor i in 1:n\n\t\tcurr_prefix_sum = curr_prefix_sum + a[i]\n\t\tif max_prefix_sum < curr_prefix_sum\n\t\t\tmax_prefix_sum = curr_prefix_sum\n\t\tend\n\t\tcurr_suffix_sum = curr_suffix_sum + a[n - i + 1]\n\t\tif max_suffix_sum < curr_suffix_sum\n\t\t\tmax_suffix_sum = curr_suffix_sum\n\t\tend\n\tend\n\treturn max(max_so_far, max_prefix_sum + max_suffix_sum + (k - 2) * max_prefix_sum)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap += max_subarray_sum\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif k == 1\n\t\treturn max_subarray_sum\n\telse\n\t\treturn max(max_subarray_sum, max_wrap)\n\tend\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of integers\n\t\n\t# find the maximum sum of the contiguous subarray in the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# find the minimum sum of the contiguous subarray in the original array\n\tmin_so_far = 0\n\tmin_ending_here = 0\n\tfor i in 1:n\n\t\tmin_ending_here = min_ending_here + a[i]\n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\tif min_so_far > min_ending_here\n\t\t\tmin_so_far = min_ending_here\n\t\tend\n\tend\n\t\n\t# find the sum of the original array\n\ttotal = 0\n\tfor i in 1:n\n\t\ttotal = total + a[i]\n\tend\n\t\n\t# find the maximum sum of the contiguous subarray in the modified array\n\tif k == 1\n\t\treturn max_so_far\n\telseif max_so_far < total\n\t\treturn max_so_far\n\telseif min_so_far > 0\n\t\treturn max_so_far\n\telse\n\t\treturn max(max_so_far, total * (k - 2) + max_so_far)\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_ending_here = 0\n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\tend\n\treturn max_so_far * k\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tmax_ending_here = max(max_ending_here, 0) \n\t\t# update result if current subarray sum is found to be greater \n\t\tmax_so_far = max(max_so_far, max_ending_here) \n\tend \n\t# return maximum sum of subarray \n\treturn max_so_far * k \nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\tmax_ending_here = 0\n\t\n\t# stores maximum sum of subarray that \n\t# is a part of k-repeated array \n\tmax_subarray_sum = 0\n\t\n\t# stores ending index of maximum sum subarray \n\t# found so far \n\tend = 0\n\t\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i \n\t\tmax_ending_here += a[i]\n\t\t\n\t\t# if maximum sum is negative, set it to 0 \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t\n\t\t# update result if current subarray sum is found \n\t\t# to be greater \n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\t\tend = i\n\t\tend\n\tend\n\t\n\t# stores minimum sum subarray of size \n\t# at-least 1 \n\tmin_so_far = 0\n\tmin_ending_here = 0\n\t\n\t# stores minimum sum of subarray that \n\t# is a part of k-repeated array \n\tmin_subarray_sum = 0\n\t\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update minimum sum of subarray \"ending\" at index i \n\t\tmin_ending_here += a[i]\n\t\t\n\t\t# if minimum sum is positive, set it to 0 \n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\t\n\t\t# update result if current subarray sum is found \n\t\t# to be less \n\t\tif min_so_far > min_ending_here\n\t\t\tmin_so_far = min_ending_here\n\t\tend\n\tend\n\t\n\t# if array sum is negative, then",
    "\t\n\t# kadane's algorithm to find maximum \n\t# sum subarray in first row. \n\tmax_so_far = 0\n\tmax_ending_here = 0\n\t\n\tfor i in 1:n \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# max sum is should be at-least the max \n\t# sum of the row \n\tmax_sum = max_so_far \n\t\n\t# initialize sum of middle rows \n\tsum = 0\n\tfor i in 1:n \n\t\tsum += a[i] \n\tend\n\t\n\t# go over middle rows \n\tfor i in 2:k-1\n\t\t# update columns elements \n\t\t# which are part of middle \n\t\t# rows \n\t\tfor j in 1:n \n\t\t\ttemp = a[j] \n\t\t\ta[j] = sum \n\t\t\tsum = sum + a[j] - temp \n\t\tend\n\t\t\n\t\t# max sum is should be at-least the max \n\t\t# sum of the row \n\t\tmax_so_far = 0\n\t\tmax_ending_here = 0\n\t\t\n\t\t# kadane's algorithm to find maximum \n\t\t# sum subarray in this row. \n\t\tfor j in 1:n \n\t\t\tmax_ending_here = max_ending_here + a[j] \n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\tend\n\t\t\n\t\t# update overall max sum \n\t\tif max_so_far > max_sum\n\t\t",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is the length of the array\n\t# a is the array\n\t\n\t# find the maximum subarray sum for the original array\n\tmax_sub_array_sum(a, n)\n\t\n\t# find the minimum subarray sum for the original array\n\tmin_sub_array_sum(a, n)\n\t\n\t# find the sum of the original array\n\tsum_of_array(a, n)\n\t\n\t# find the maximum subarray sum for the modified array\n\tmax_sub_array_sum(a, n) * k\n\t\n\t# find the minimum subarray sum for the modified array\n\tmin_sub_array_sum(a, n) * k\n\t\n\t# find the sum of the modified array\n\tsum_of_array(a, n) * k\n\t\n\t# find the maximum subarray sum for the modified array\n\tmax(max_sub_array_sum(a, n), sum_of_array(a, n) * k, max_sub_array_sum(a, n) * k)\nend",
    "\t# Find the sum of the original array \n\tmax_sum := sum(a) \n\t\n\t# Find the sum of the elements \n\t# in the array with modulo k \n\tcurr_sum := sum(a .% k) \n\t\n\t# Initialize the value of result \n\tres := max_sum \n\t\n\t# Traverse through the array \n\t# and find the maximum sum \n\t# of the subarray with modulo k \n\tfor i in 1:n \n\t\tcurr_sum := curr_sum + max_sum \n\t\tcurr_sum := curr_sum - (a[i] % k) \n\t\tres := max(res, curr_sum) \n\tend\n\t\n\treturn res \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = -Inf \n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0 \n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\tend\n\t# max_so_far is the maximum sum of subarray in original array, say B \n\t# max_so_far repeating the array k times is k*max_so_far \n\tmax_kadane = k * max_so_far \n\t# stores sum of all array elements \n\tsum_total = 0\n\t# max sum with corner elements will be: \n\t# sum of all array elements - \n\t# minimum sum of subarray in the original array \n\tmin_so_far = Inf \n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update sum_total \n\t\tsum_total = sum_total + a[i] \n\t\t# update minimum sum found so far \n\t\tmin_so_far = min(min_so_far, sum_total) \n\tend\n\t# max sum with corner elements is: \n\t# sum of all array elements - \n\t# minimum sum of subarray in the original array \n\tmax_wrap = sum_total - min_so_far \n\t# the maximum is maximum of: \n\t# 1",
    "\t# Compute sum of first window of size n \n\tmax_sum = sum(a[1:n]) \n\twindow_sum = max_sum ",
    "\t# Find the sum of the first subarray\n\t# and initialize the result \n\tmax_so_far = 0\n\tfor i = 1:n\n\t\tmax_so_far += a[i]\n\tend\n\t# Initialize the result \n\tmax_total = max_so_far\n\t# Find the sum of remaining subarrays \n\t# and update the result \n\tfor i = 2:k\n\t\tcurr_max = 0\n\t\tfor j = 1:n\n\t\t\tcurr_max += a[j]\n\t\tend\n\t\tmax_total = max(max_total, curr_max + max_so_far)\n\t\tmax_so_far = curr_max\n\tend\n\treturn max_total\nend",
    "\t\n\t# kadane's algorithm to find maximum \n\t# subarray sum for standard array \n\tmax_so_far = 0\n\tmax_ending_here = 0\n\t\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# Case 1: When all numbers in arr[] are \n\t# positive \n\tif max_so_far > 0\n\t\treturn max_so_far * k\n\tend\n\t\n\t# Case 2: When all numbers in arr[] are \n\t# negative \n\tmax_sum = a[1]\n\tfor i in 2:n\n\t\tif a[i] > max_sum\n\t\t\tmax_sum = a[i]\n\t\tend\n\tend\n\t\n\treturn max_sum * k\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Find the maximum sum of other windows by \n\t# removing the first element of previous \n\t# window and adding the last element of \n\t# current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + sum(a) - n*a[i-1]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_so_far = max_so_far + a[i]\n\t\tif max_so_far > max_subarray_sum\n\t\t\tmax_subarray_sum = max_so_far\n\t\tend\n\tend\n\treturn max_subarray_sum * k\nend",
    "\t# max_so_far = 0\n\t# max_ending_here = 0\n\t# for i in 1:n\n\t# \tmax_ending_here = max_ending_here + a[i]\n\t# \tif max_ending_here < 0\n\t# \t\tmax_ending_here = 0\n\t# \tend\n\t# \tif max_so_far < max_ending_here\n\t# \t\tmax_so_far = max_ending_here\n\t# \tend\n\t# end\n\t# return max_so_far * k\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far == 0\n\t\treturn max_so_far\n\tend\n\tmax_so_far = 0\n\tmin_ending_here = 0\n\tfor i in 1:n\n\t\tmin_ending_here = min_ending_here + a[i]\n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\tif max_so_far > min_ending_here\n\t\t\tmax_so_far = min_ending_here\n\t\tend\n\tend\n\treturn max(sum(a) * (k - 2), max_so_far)\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# stores ending index of maximum sum subarray found so far \n\tend = 0\n\t# stores starting index of maximum sum subarray found so far \n\tstart = 0\n\t# stores ending index of maximum sum subarray ending at current \n\t# position \n\ts = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here += a[i]\n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0\n\t\t\ts = i + 1\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here\n\t\t\tstart = s \n\t\t\tend = i \n\t\tend\n\tend\n\t# if max_so_far is 0, then all numbers in given array are negative \n\tif max_so_far == 0 \n\t\tmax_so_far = a[1] \n\t\tstart = end = 1\n\t\tfor i in 2:n \n\t\t\tif a[i] > max_so_far \n\t\t\t\tmax_so_far = a[i] \n\t\t\t\tstart = end = i \n\t\t\tend\n\t\tend\n\tend\n\t# stores sum of all numbers \n\ttotal_sum = 0\n\tfor i in 1:n \n\t\ttotal_sum += a[i] \n\tend\n\t# if all numbers in given array are negative, then maximum sum is \n\t# maximum of all numbers \n",
    "\t# Find the sum of the first subarray \n\t# and initialize the result \n\tmax_so_far = sum(a) \n\tcurr_max = max_so_far \n\t\n\t# Find the sum of the remaining subarrays \n\tfor i in 1:n \n\t\tcurr_max = curr_max + sum(a) - n*a[i] \n\t\tmax_so_far = max(max_so_far, curr_max) \n\tend\n\t\n\treturn max_so_far \nend",
    "\t# Find the sum of the original array \n\tmax_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend",
    "\tmax_ending_here = 0\n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tif max_wrap < 0\n\t\treturn max_so_far\n\tend\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\treturn max_so_far + max_wrap * (k - 2)\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = -Inf ",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = a[1] \n\t# stores maximum sum of subarray ending at current position \n\tcurr_max = a[1] \n\tfor i = 2:n \n\t\t# max ending at current position \n\t\tcurr_max = max(a[i], curr_max + a[i]) \n\t\t# updating max_so_far, if needed \n\t\tmax_so_far = max(max_so_far, curr_max) \n\tend\n\t# kadane's algorithm to find maximum subarray sum \n\t# repeating the array multiple times \n\tmax_so_far = max_so_far * k \n\t# for circular subarray \n\tfor i = 1:n \n\t\tcurr_max = max(a[i], curr_max + a[i]) \n\t\tmax_so_far = max(max_so_far, curr_max) \n\tend\n\treturn max_so_far \nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum with no wrapping\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\t# max sum with wrapping\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_ending_here\n\t# return max of two\n\tmax(max_wrap, max_so_far)\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\tif max_wrap > max_subarray_sum\n\t\tmax_subarray_sum = max_wrap\n\tend\n\treturn max_subarray_sum\nend",
    "\t# Find the sum of the original array \n\tmax_sum := sum(a) \n\t# Find the sum of the middle elements \n\t# i.e. sum excluding the corner elements \n\tcurr_val := 0\n\tfor i in 1:n\n\t\tcurr_val += a[i] \n\tend\n\tcurr_val := curr_val * k - sum(a) \n\t# Compare and return the maximum sum \n\treturn max(max_sum, curr_val) \nend",
    "\t# Find sum of all elements \n\tsum_all = sum(a) \n\t\n\t# Find sum of elements in original array \n\tsum_orig = sum(a[1:n]) \n\t\n\t# Find sum of maximum sum subarray \n\t# in the modified array \n\tmax_sum = sum_orig \n\t\n\tfor i in 1:n \n\t\tsum_orig = sum_orig - a[i] + a[i + n] \n\t\tmax_sum = max(max_sum, sum_orig) \n\tend\n\t\n\t# Return maximum sum \n\treturn max(max_sum, sum_all * k) \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Find the maximum sum of other windows by \n\t# removing the first element of previous \n\t# window and adding the last element of \n\t# current window. \n\tfor i in 2:k-1\n\t\tcurr_sum = curr_sum + sum(a) - n*a[i-1]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# Find the sum of the first subarray \n\t# This is required because the maximum sum may be starting from the second subarray \n\tmax_so_far = 0\n\tfor i = 1:n\n\t\tmax_so_far += a[i]\n\tend",
    "\tmax_sum = 0\n\tfor i in 1:n\n\t\tcurr_sum = 0\n\t\tfor j in 1:k\n\t\t\tcurr_sum += a[(i + j - 1) % n]\n\t\tend\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t# Find the sum of the original array \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t\n\t# Find the maximum sum of the array formed by repeating the given array k times \n\tmax_sum = max_sum * k\n\t\n\t# Find the maximum sum of the array formed by repeating the given array k times \n\t# with one element excluded in every iteration \n\tfor i in 1:n\n\t\tcurr_sum = 0\n\t\tfor j in 1:n\n\t\t\tcurr_sum += a[j]\n\t\tend\n\t\tcurr_sum = curr_sum * (k - 1)\n\t\tcurr_sum = curr_sum - (n * a[i])\n\t\t\n\t\tif curr_sum > max_sum\n\t\t\tmax_sum = curr_sum\n\t\tend\n\tend\n\t\n\treturn max_sum\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = -Inf \n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0 \n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\tend\n\t# max sum is sum of max subarray sum of each (concatenated) array \n\treturn max_so_far * k \nend",
    "\t\"\"\"\n\t\tFind the maximum possible sum of a subarray in the given array.\n\t\"\"\"\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tcurr_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i = n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# The maximum sum is maximum of all sums computed in above loop. \n\treturn max_sum*k - sum(a)\nend",
    "\tmax_sum = 0\n\tfor i in 1:n\n\t\tcurr_sum = 0\n\t\tfor j in 1:k\n\t\t\tcurr_sum += a[(i + j - 1) % n]\n\t\tend\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t# Find the sum of the middle elements\n\t# This is required if k is even\n\tmid_sum := 0\n\tfor i in 1:n\n\t\tmid_sum += a[i] * (k - 2)\n\tend\n\t# Find the sum of the first and last elements\n\t# This is required if k is even\n\tfirst_last_sum := 0\n\tfor i in 1:n\n\t\tfirst_last_sum += a[i] * (k - 1)\n\tend\n\t# Find the maximum of all the three sums\n\tmax_sum = max(max_sum, mid_sum, first_last_sum)\n\treturn max_sum\nend",
    "\t# kadane's algorithm to find maximum sum subarray in a 1D array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# Case 1: when the array elements are all negative\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\t\treturn max_so_far\n\tend\n\t\n\t# Case 2: when the array has at least one positive element\n\tsum_of_array = sum(a)\n\tmax_so_far = max_so_far * k\n\t\n\t# Case 2a: when k is 1, we simply return max_so_far as result\n\tif k == 1\n\t\treturn max_so_far\n\tend\n\t\n\t# Case 2b: when k is more than 1, we need to look whether (sum_of_array * (k-2)) + max_so_far is greater or not\n\t# If it is greater, then we return it, otherwise we return max_so_far\n\tif sum_of_array > 0\n\t\treturn max(max_so_far, sum_of_array * (k-2) + max_so_far)\n\telse\n\t\treturn max_so_far\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_subarray_sum\n\t\treturn max_wrap\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum \n\tfor i = n + 1:n * k\n\t\tcurr_sum += a[i % n + 1] - a[i - n + 1]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\t# Find the sum of the first window\n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t\n\t# Find the sum of the remaining windows by removing the first element of the previous window and adding the last element of the current window\n\tcurr_sum = max_sum\n\tfor i in n+1:n*k\n\t\tcurr_sum += a[i % n] - a[(i - n) % n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t\n\treturn max_sum\nend",
    "\t# kadane's algorithm to find maximum sum subarray in linear time \n\tmax_so_far = a[1] \n\tcurr_max = a[1] \n\tfor i in 2:n \n\t\tcurr_max = max(a[i], curr_max + a[i]) \n\t\tmax_so_far = max(max_so_far, curr_max) \n\tend\n\t# max sum with repetition \n\tmax_sum = max_so_far * k \n\t# case 2 \n\t# individual max sum \n\tmax_ending_here = 0\n\tmin_ending_here = 0\n\tfor i in 1:n \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\tmin_ending_here = min_ending_here + a[i] \n\t\tmax_ending_here = max(max_ending_here, 0) \n\t\tmin_ending_here = min(min_ending_here, 0) \n\tend\n\t# max sum with repetition \n\tmax_sum = max(max_sum, (max_ending_here * k)) \n\t# case 3 \n\t# max and min sum with repetition \n\t# to handle corner elements \n\tmax_sum = max(max_sum, (max_ending_here + min_ending_here) * (k - 1) + max_ending_here) \n\treturn max_sum \nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i = 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_sub_array_sum = max_so_far\n\tmax_wrap = 0\n\tfor i = 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap += max_sub_array_sum_repeated(a, n, 1)\n\tif max_wrap > max_sub_array_sum\n\t\tmax_sub_array_sum = max_wrap\n\tend\n\treturn max_sub_array_sum\nend",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of size n\n\t# return the maximum sum of a contiguous array in the modified array\n\t# which is formed by repeating the given array k times\n\t\n\t# initialize the maximum sum of a contiguous array in the modified array\n\tmax_sum = 0\n\t\n\t# initialize the maximum sum of a contiguous array in the original array\n\tmax_sum_original = 0\n\t\n\t# initialize the maximum sum of a contiguous array in the modified array\n\t# which is formed by repeating the given array k times\n\tmax_sum_repeated = 0\n\t\n\t# initialize the sum of a contiguous array in the original array\n\tsum_original = 0\n\t\n\t# initialize the sum of a contiguous array in the modified array\n\t# which is formed by repeating the given array k times\n\tsum_repeated = 0\n\t\n\t# initialize the minimum sum of a contiguous array in the original array\n\tmin_sum_original = 0\n\t\n\t# initialize the minimum sum of a contiguous array in the modified array\n\t# which is formed by repeating the given array k times\n\tmin_sum_repeated = 0\n\t\n\t# iterate over the array\n\tfor i in 1:n\n\t\t# update the maximum sum of a contiguous array in the original array\n\t\tmax_sum_original = max(max_sum_original, a[i])\n\t\t\n\t\t# update the sum of a contiguous array in the original array\n\t\tsum_original += a[i]\n\t\t\n\t\t# update the minimum sum of a contiguous array in the original array\n\t\tmin_sum_original = min(min_sum_original, sum_original)\n\t\t\n\t\t# update the maximum sum of a contiguous array in the modified array\n\t\t# which is formed by repeating the given array k times\n\t\tmax_sum_repeated = max(max_sum_repeated, sum_repeated)\n\t\t\n\t\t# update the sum of a contiguous array in the modified array\n\t\t# which is formed by repeating the given array k times\n\t\tsum_repeated += a[i]\n\t",
    "\t# Find the sum of the first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tcurr_sum = max_sum\n\tfor i in n+1:length(a)\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Return maximum sum of k such windows. \n\treturn max_sum * k\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k)\n\treturn max(max_wrap, max_kadane)\nend",
    "\t# Find the maximum sum subarray in the first \n\t# and second half \n\tmax_sum = max_sub_array_sum(a, n) \n\t\n\t# The maximum sum is sum of all elements \n\t# when k is 2. \n\tif (k == 2): \n\t\treturn max_sum * k \n\t\n\t# Case 1: Maximum sum subarray is in first half \n\t# and minimum sum subarray is in second half \n\tmin_sum = min_sub_array_sum(a, n) \n\tmax_sum_first_half = max_sum \n\t\n\t# Case 2: Maximum sum subarray is in second half \n\t# and minimum sum subarray is in first half \n\tmax_sum_second_half = min_sum * (k - 2) + max_sum \n\t\n\t# Return the maximum of two cases \n\treturn max(max_sum_first_half, max_sum_second_half) \nend",
    "\t# Find the sum of all elements \n\ttotal_sum = sum(a) \n\t\n\t# Find the sum of subarray \n\t# formed by repeating the \n\t# array k times \n\tcurr_val = sum(a[1:n]) \n\t\n\t# Initialize the value of result \n\tres = curr_val \n\t\n\t# Starting index of current subarray. \n\tstart = 0\n\t\n\t# Traverse throught the array \n\tfor i in 1:n \n\t\t\n\t\t# Update current sum \n\t\tcurr_val = curr_val - a[i-1] + a[(i-1+n)%n] \n\t\t\n\t\t# If current sum is greater than \n\t\t# previous sum, then update it \n\t\tif curr_val > res \n\t\t\tres = curr_val \n\t\t\tstart = i \n\t\tend\n\tend \n\t\n\t# Return the maximum sum \n\treturn res * k - (total_sum - res) \nend",
    "\t\n\t# Find the sum of the first window\n\tmax_sum = sum(a[1:n])\n\tcurr_sum = max_sum\n\t\n\t# Move the window by one element\n\t# Add the next element and subtract the first element of previous window\n\tfor i in 1:n\n\t\tcurr_sum = curr_sum + a[i]*(k-1) - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n\n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i]\n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum is sum of max subarray sum of each (n*k) subarrays \n\treturn max_so_far * k\nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t# Find the sum of the middle elements\n\t# if k is even\n\tif k % 2 == 0\n\t\tmax_sum := max_sum + sum(a[2:n-1]) * (k/2 - 1)\n\telse\n\t\tmax_sum := max_sum + sum(a[2:n-1]) * (k/2)\n\tend\n\t# Find the sum of the corner elements\n\tmax_sum := max_sum + a[1] * (k-1) + a[n-1] * (k-1)\n\treturn max_sum\nend",
    "\t# Find the sum of the original array \n\tmax_sum = 0\n\tfor i = 1:n \n\t\tmax_sum += a[i] \n\tend\n\t\n\t# Find the maximum sum of the non-contiguous array \n\tmax_non_contiguous_sum = max_sum \n\tfor i = 1:n \n\t\tmax_non_contiguous_sum = max(max_non_contiguous_sum, a[i]) \n\tend\n\t\n\t# If all elements are negative \n\tif max_non_contiguous_sum < 0 \n\t\treturn max_non_contiguous_sum \n\tend\n\t\n\t# Find the maximum sum of the contiguous array \n\tmax_contiguous_sum = max_sum \n\tfor i = 1:n \n\t\tmax_contiguous_sum = max(max_contiguous_sum, a[i] + max_contiguous_sum) \n\tend\n\t\n\t# Return the maximum sum of the modified array \n\treturn max(max_contiguous_sum, max_sum * k) \nend",
    "\t# Find the sum of the first subarray \n\t# of size n \n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_so_far += a[i]\n\tend\n\t# Find the sum of the next subarrays \n\t# and compare with the maximum sum \n\t# so far \n\tcurr_sum = max_so_far \n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tcurr_sum += a[j]\n\t\t\tcurr_sum -= a[j-n]\n\t\t\tmax_so_far = max(max_so_far, curr_sum)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max_so_far is the maximum sum of subarray in original array, say B \n\t# max_so_far repeating the array k times is k * max_so_far \n\tmax_so_far = k * max_so_far \n\t# max sum with corner elements will be: \n\t# max_so_far = max_so_far + (k-1)*sum(all elements except corner elements) \n\t# sum of all array elements \n\ttotal_sum = sum(a) \n\t# sum of all array elements except corner elements \n\tcorner_sum = 0\n\t# find sum of corner elements \n\tfor i in 1:n \n\t\tcorner_sum += a[i] \n\t\ta[i] = -a[i] \n\tend\n\t# If all elements are negative, then sum is maximum sum \n\tif total_sum < 0\n\t\treturn total_sum\n\tend\n\t# sum of array elements except corner elements \n\ttotal_sum = total_sum - corner_sum \n\t# max sum with corner elements will be: \n\t# max_so_far = max_",
    "\t# k is an integer denoting the number of times the array is repeated\n\t# n is an integer denoting the size of the array\n\t# a is an array of size n\n\t# return the maximum sum of a contiguous array in the modified array\n\t\n\t# find the maximum sum of a contiguous array in the original array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# find the minimum sum of a contiguous array in the original array\n\tmin_so_far = 0\n\tmin_ending_here = 0\n\tfor i in 1:n\n\t\tmin_ending_here = min_ending_here + a[i]\n\t\tif min_ending_here > 0\n\t\t\tmin_ending_here = 0\n\t\tend\n\t\tif min_so_far > min_ending_here\n\t\t\tmin_so_far = min_ending_here\n\t\tend\n\tend\n\t\n\t# find the sum of the original array\n\tsum_of_array = 0\n\tfor i in 1:n\n\t\tsum_of_array = sum_of_array + a[i]\n\tend\n\t\n\t# find the maximum sum of a contiguous array in the modified array\n\tif k == 1\n\t\treturn max_so_far\n\telseif sum_of_array > 0\n\t\treturn max(max_so_far, sum_of_array * (k - 2) + max_so_far)\n\telse\n\t\treturn max(max_so_far, sum_of_array * (k - 2) + max_so_far - min_so_far)\n\tend\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\t# max sum is sum of all elements when all elements are positive\n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\t# max sum is sum of all elements when all elements are negative\n\tmin_sum = 0\n\tfor i in 1:n\n\t\tmin_sum += a[i]\n\tend\n\tif k == 1\n\t\treturn max_kadane\n\telseif k == 2\n\t\treturn max(max_kadane, max_sum + min_sum)\n\telse\n\t\treturn max(max_kadane, max_sum + min_sum + (k - 2) * max_sum)\n\tend\nend",
    "\t\"\"\"\n\tFind the maximum possible sum of a contiguous subarray in the given array which is repeated k times.\n\t\"\"\"\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + (k-1)*a[i]\n\t\tif max_ending_here > max_so_far\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t\n\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t\n\t# Find the sum of the middle elements\n\t# This is done because we are repeating the array\n\t# So the middle elements will be added twice\n\t# So we subtract the sum of the middle elements once\n\tcurr_val := 0\n\tfor i in 1:n\n\t\tcurr_val += i * a[i]\n\tend\n\t\n\t# Initialize the result\n\tmax_val := curr_val\n\t\n\t# Iterate for middle elements\n\tfor j in 1:n\n\t\t# Update the current value\n\t\tcurr_val = curr_val - (n * a[j]) + (a[j] * k)\n\t\t\n\t\t# Update the result if required\n\t\tif curr_val > max_val\n\t\t\tmax_val = curr_val\n\t\tend\n\tend\n\t\n\t# Return the maximum sum\n\treturn max_val\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t# Find the sum of the first subarray \n\t# and initialize the result \n\tmax_sum = 0\n\tfor i = 1:n \n\t\tmax_sum += a[i] \n\tend\n\t\n\t# Find the sum of the remaining subarrays \n\t# and update the result \n\tcurr_sum = max_sum \n\tfor i = 2:k \n\t\tcurr_sum = curr_sum + (sum(a) * (k - i + 1)) \n\t\tmax_sum = max(max_sum, curr_sum) \n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tif max_so_far > 0\n\t\treturn max(max_so_far, max_subarray_sum * (k - 2))\n\telse\n\t\treturn max_subarray_sum\n\tend\nend",
    "\t\"\"\"\n\t\ta: array\n\t\tn: length of array\n\t\tk: number of times to repeat array\n\t\"\"\"\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_kadane = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_so_far\n\tif max_wrap > max_kadane\n\t\treturn max_wrap\n\telse\n\t\treturn max_kadane\n\tend\nend",
    "\t\n\t# Find the sum of first subarray\n\t# (i.e. subarray starting from index 0 and ending at index n-1)\n\tmax_sum := sum(a)\n\t\n\t# Find the sum of remaining subarrays\n\t# Consider every subarray and find the maximum sum\n\t# possible by including elements of the subarray\n\tfor i in 1:n\n\t\tcurr_sum := 0\n\t\tfor j in 1:n\n\t\t\tcurr_sum += a[j]\n\t\tend\n\t\tmax_sum := max(max_sum, curr_sum)\n\t\t\n\t\t# Rotate the array by 1\n\t\ttemp := a[0]\n\t\tfor j in 1:n-1\n\t\t\ta[j-1] := a[j]\n\t\tend\n\t\ta[n-1] := temp\n\tend\n\t\n\t# Return the maximum possible sum\n\treturn max_sum * k\nend",
    "\t# Find the sum of the original array\n\tmax_sum := sum(a)\n\t\n\t# Find the sum of the middle elements\n\t# i.e. sum of the subarray between two middle\n\t# rows\n\tmid_sum := 0\n\tfor i in 1:n\n\t\tmid_sum += a[i] * (k - 2)\n\tend\n\t\n\t# Initialize answer\n\tans := max_sum + mid_sum\n\t\n\t# Handle corner elements\n\t# Starting corner\n\tcorner_sum := 0\n\tfor i in 1:n\n\t\tcorner_sum += a[i]\n\t\tans := max(ans, corner_sum)\n\t\tcorner_sum := max(corner_sum, 0)\n\tend\n\t\n\t# Ending corner\n\tcorner_sum := 0\n\tfor i in n:-1:1\n\t\tcorner_sum += a[i]\n\t\tans := max(ans, corner_sum)\n\t\tcorner_sum := max(corner_sum, 0)\n\tend\n\t\n\treturn ans\nend",
    "    max_so_far = 0\n    max_ending_here = 0\n    for i = 1:n\n        max_ending_here = max_ending_here + a[i]\n        if max_ending_here < 0\n            max_ending_here = 0\n        end\n        if max_so_far < max_ending_here\n            max_so_far = max_ending_here\n        end\n    end\n    max_subarray_sum = max_so_far\n    max_wrap = 0\n    for i = 1:n\n        max_wrap += a[i]\n        a[i] = -a[i]\n    end\n    max_wrap = max_wrap + max_sub_array_sum(a, n, k)\n    if max_wrap > max_subarray_sum\n        return max_wrap\n    else\n        return max_subarray_sum\n    end\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here += a[i]\n\tend\n\tmax_so_far = max_ending_here\n\tfor i in 1:k-1\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tmax_ending_here = max(max_ending_here, 0)\n\t\t\tmax_so_far = max(max_so_far, max_ending_here)\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_subarray_sum = max_so_far\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\tmax_wrap += max_sub_array_sum(a, n, k)\n\tif max_wrap > max_subarray_sum\n\t\tmax_subarray_sum = max_wrap\n\tend\n\treturn max_subarray_sum\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\twindow_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\twindow_sum = max_sum\n\tfor i in n+1:2*n\n\t\twindow_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, window_sum)\n\tend\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i in 2:k-1\n\t\twindow_sum = window_sum + sum(a[i*n+1:(i+1)*n])\n\t\tmax_sum = max(max_sum, window_sum)\n\tend\n\treturn max_sum\nend",
    "\t\"\"\"\n\ta: array of integers\n\tn: length of array\n\tk: number of times to repeat array\n\t\"\"\"\n\t# create a new array of length n*k\n\tb = zeros(Int64, n*k)\n\t# fill the new array with the original array repeated k times\n\tfor i in 1:k\n\t\tb[(i-1)*n+1:i*n] = a\n\tend\n\t# find the maximum subarray sum of the new array\n\treturn max_sub_array_sum(b, n*k)\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Find the maximum sum of other windows by \n\t# removing the first element of previous \n\t# window and adding the last element of \n\t# current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + sum(a) - n * a[i-1]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_ending_here = 0\n\tmax_so_far = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap = max_wrap + a[i]\n\t\ta[i] = -a[i]\n\tend\n\tif max_wrap < 0\n\t\treturn max_so_far\n\tend\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\treturn max_so_far + max_wrap * (k - 2)\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum with no wrapping\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\t# max subarray sum with wrapping\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap = max_wrap + max_ending_here\n\t# compare and return\n\tif max_wrap > max_so_far\n\t\treturn max_wrap\n\telse\n\t\treturn max_so_far\n\tend\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum \n\tfor i in n+1:2n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Use the maximum sum of previous window as initial maximum sum for next window \n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i in 2:k\n\t\tcurr_sum = curr_sum + (a[i] - a[i-n])\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:k\n\t\tmax_ending_here = 0\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:k\n\t\tmax_ending_here = 0\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i = 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i = n+1:2*n\n\t\tcurr_sum += a[i] - a[i-n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Use the maximum sum of previous window as initial maximum sum for remaining windows \n\tmax_sum = max_sum * k\n\t# Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n\tfor i = 1:n\n\t\tcurr_sum = curr_sum - a[i] + a[i+n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend",
    "\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:k\n\t\tmax_ending_here = 0\n\t\tfor j in 1:n\n\t\t\tmax_ending_here += a[j]\n\t\t\tif max_ending_here < 0\n\t\t\t\tmax_ending_here = 0\n\t\t\tend\n\t\t\tif max_so_far < max_ending_here\n\t\t\t\tmax_so_far = max_ending_here\n\t\t\tend\n\t\tend\n\tend\n\treturn max_so_far\nend",
    "\t# kadane's algorithm\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum with non-contiguous elements\n\tmax_non_contiguous = 0\n\tfor i in 1:n\n\t\tif a[i] > 0\n\t\t\tmax_non_contiguous += a[i]\n\t\tend\n\tend\n\t# return max of kadane's algorithm and max sum with non-contiguous elements\n\treturn max(max_so_far, max_non_contiguous * k)\nend",
    "\t# kadane's algorithm to find maximum sum subarray in a 1D array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i = 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t\n\t# Case 1: when the array elements are all negative\n\tif max_so_far == 0\n\t\tmax_so_far = maximum(a)\n\t\tif max_so_far <= 0\n\t\t\treturn max_so_far\n\t\tend\n\tend\n\t\n\t# Case 2: when the array has at-least one positive element\n\tsum_total = sum(a)\n\tmax_so_far = max_so_far + sum_total * (k - 2)\n\t\n\t# Case 3: handle the corner elements\n\tcorner_elements_sum = 0\n\tfor i = 1:n\n\t\tcorner_elements_sum = corner_elements_sum + a[i]\n\t\tmax_so_far = max(max_so_far, corner_elements_sum)\n\t\tcorner_elements_sum = max(corner_elements_sum, 0)\n\tend\n\t\n\tcorner_elements_sum = 0\n\tfor i = n:-1:1\n\t\tcorner_elements_sum = corner_elements_sum + a[i]\n\t\tmax_so_far = max(max_so_far, corner_elements_sum)\n\t\tcorner_elements_sum = max(corner_elements_sum, 0)\n\tend\n\t\n\treturn max_so_far\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = sum(a[1:n]) \n\tcurr_sum = max_sum ",
    "\t# kadane's algorithm to find maximum subarray sum \n\t# stores maximum sum subarray found so far \n\tmax_so_far = 0\n\t# stores maximum sum of subarray ending at current position \n\tmax_ending_here = 0\n\t# traverse the given array \n\tfor i in 1:n \n\t\t# update maximum sum of subarray \"ending\" at index i (by adding \n\t\t# current element to maximum sum ending at previous index i-1) \n\t\tmax_ending_here = max_ending_here + a[i] \n\t\t# if maximum sum is negative, set it to 0 (which represents \n\t\t# an empty subarray) \n\t\tif max_ending_here < 0 \n\t\t\tmax_ending_here = 0\n\t\tend\n\t\t# update result if current subarray sum is found to be greater \n\t\tif max_so_far < max_ending_here \n\t\t\tmax_so_far = max_ending_here \n\t\tend\n\tend\n\t# stores sum of all array elements \n\ttotal_sum = 0\n\tfor i in 1:n \n\t\ttotal_sum += a[i] \n\tend\n\t# if total sum is negative, return maximum subarray sum found so far \n\tif total_sum < 0 \n\t\treturn max_so_far \n\tend\n\t# else return maximum sum by including the elements repeating k times \n\treturn max(max_so_far, total_sum * k) \nend",
    "\t# kadane's algorithm to find maximum sum subarray in a 1D array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\t# max sum with non-wrapping subarray\n\tmax_non_wrap = max_so_far\n\t# max sum with wrapping subarray\n\tmax_wrap = 0\n\tfor i in 1:n\n\t\tmax_wrap += a[i]\n\t\ta[i] = -a[i]\n\tend\n\t# max sum with non-wrapping subarray is sum of the array\n\tmax_so_far = 0\n\tmax_ending_here = 0\n\tfor i in 1:n\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif max_ending_here < 0\n\t\t\tmax_ending_here = 0\n\t\tend\n\t\tif max_so_far < max_ending_here\n\t\t\tmax_so_far = max_ending_here\n\t\tend\n\tend\n\tmax_wrap += max_so_far\n\t# return maximum of two cases\n\tif max_wrap > max_non_wrap\n\t\treturn max_wrap\n\telse\n\t\treturn max_non_wrap\n\tend\nend",
    "\t# Find the maximum sum subarray in first window of size n \n\tmax_sum = 0\n\tfor i in 1:n\n\t\tmax_sum += a[i]\n\tend\n\tcurr_sum = max_sum\n\tfor i in 1:n\n\t\tcurr_sum += a[i]\n\t\tcurr_sum -= a[i - n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\t# Find the maximum sum of other windows by repeating the array \n\tmax_sum = max_sum * k\n\t# Find the maximum sum of last window \n\tfor i in 1:n\n\t\tcurr_sum += a[i]\n\t\tcurr_sum -= a[i - n]\n\t\tmax_sum = max(max_sum, curr_sum)\n\tend\n\treturn max_sum\nend"
  ]
}