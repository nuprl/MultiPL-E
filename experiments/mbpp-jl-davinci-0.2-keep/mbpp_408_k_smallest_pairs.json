{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\nfunction k_smallest_pairs(nums1::Vector{Int64}, nums2::Vector{Int64}, k::Int64)::Vector{Vector{Int64}} \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = k_smallest_pairs;\n\t@test(candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]])\n\t@test(candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]])\n\t@test(candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# Heapify\n\tfor i = k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the smallest k elements\n\tres = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\tres[i] = [heap[1][2], heap[1][3]]\n\t\t\n\t\t# Replace the root with the next element\n\t\tif heap[1][2] < n1\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\telse\n\t\t\theap[1] = heap[k - i + 1]\n\t\tend\n\t\t\n\t\t# Heapify\n\t\theapify(heap, 1, k - i)\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, (1, 1))\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tresult[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 + 1 <= n1 && !visited_has(visited, (i1 + 1, i2))\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tvisited_add!(visited, (i1 + 1, i2))\n\t\tend\n\t\tif i2 + 1 <= n2 && !visited_has(visited, (i1, i2 + 1))\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\t\tvisited_add!(visited, (i1, i2 + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# extract the k smallest pairs\n\tfor i in k+1:n*m\n\t\tif heap[1][1] > nums1[(i-1) div m + 1] + nums2[(i-1) mod m + 1]\n\t\t\theap[1] = [nums1[(i-1) div m + 1] + nums2[(i-1) mod m + 1], (i-1) div m + 1, (i-1) mod m + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# return the k smallest pairs\n\treturn heap\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# heap to store the pairs\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the heap\n\tfor i in 1:k\n\t\tif i <= n\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tbuild_heap!(heap)\n\t\n\t# pop the top element and push the next element\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the top element\n\t\ttop = pop_heap!(heap)\n\t\t\n\t\t# push the next element\n\t\tif top[3] < m\n\t\t\tpush!(heap, [top[1], nums2[top[3] + 1], top[3] + 1])\n\t\tend\n\t\t\n\t\t# build the heap\n\t\tbuild_heap!(heap)\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t_, x, y = pop!(pq)\n\t\tresult[i] = [nums1[x], nums2[y]]\n\t\tif x + 1 <= n1 && !visited_contains(visited, x + 1, y)\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\t\tvisited_add(visited, x + 1, y)\n\t\tend\n\t\tif y + 1 <= n2 && !visited_contains(visited, x, y + 1)\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\tvisited_add(visited, x, y + 1)\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tresult[i] = [nums1[i], nums2[j]]\n\t\tif i + 1 <= n1 && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= n2 && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add(visited, i, j + 1)\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\theap = Heap(k)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap.data[1].val[1], heap.data[1].val[2]]\n\t\tpop!(heap)\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tresult[i] = [nums1[1], nums2[1]]\n\tend\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif nums1[i] + nums2[j] < result[k][1] + result[k][2]\n\t\t\t\tresult[k] = [nums1[i], nums2[j]]\n\t\t\t\tresult = sort(result, by = x -> x[1] + x[2])\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# nums1 = [1, 7, 11]\n\t# nums2 = [2, 4, 6]\n\t# k = 3\n\t# Output: [[1,2],[1,4],[1,6]] \n\t# Explanation: The first 3 pairs are returned from the sequence: \n\t#              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\t\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 2\n\t# Output: [1,1],[1,1]\n\t# Explanation: The first 2 pairs are returned from the sequence: \n\t#              [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\t\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n\t# Output: [1,3],[2,3]\n\t# Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n\t\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# Output: [1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# extract the top k elements\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\tif heap[1][2] < n1 && heap[1][3] < n2\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\telseif heap[1][2] == n1\n\t\t\theap[1] = [nums1[n1] + nums2[heap[1][3] + 1], n1, heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[n2], heap[1][2] + 1, n2]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort nums1 and nums2\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the heap\n\theap = Heap(k)\n\t\n\t# push the first k pairs into the heap\n\tfor i in 1:k\n\t\tif i <= length(nums1)\n\t\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\t\tend\n\tend\n\t\n\t# pop the first k pairs from the heap\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the pair with the smallest sum\n\t\tpair = pop!(heap)\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# push the next pair into the heap\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpq = PriorityQueue()\n\tfor i in 1:length(nums1)\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\tresult = []\n\twhile k > 0 && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpairs = Vector{Vector{Int64}}()\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(pairs, [nums1[i] nums2[j]])\n\t\tend\n\tend\n\t\n\tsort!(pairs, by = x -> x[1] + x[2])\n\treturn pairs[1:k]\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\t\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue(k)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif pq.size() < k\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\telse\n\t\t\t\tif pq.top()[1] > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(pq)\n\t\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[pq.top()[2]], nums2[pq.top()[3]]]\n\t\tpop!(pq)\n\tend\n\treturn result\nend",
    "\t# sort the two arrays\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# initialize the index of the two arrays\n\ti = 1\n\tj = 1\n\t# initialize the index of the result\n\tindex = 1\n\t# loop until the result is full\n\twhile index <= k\n\t\t# if the first array is exhausted\n\t\tif i > length(nums1)\n\t\t\t# add the rest of the second array to the result\n\t\t\tfor m = j:length(nums2)\n\t\t\t\tresult[index] = [nums1[i-1], nums2[m]]\n\t\t\t\tindex += 1\n\t\t\tend\n\t\t\t# break the loop\n\t\t\tbreak\n\t\t# if the second array is exhausted\n\t\telseif j > length(nums2)\n\t\t\t# add the rest of the first array to the result\n\t\t\tfor m = i:length(nums1)\n\t\t\t\tresult[index] = [nums1[m], nums2[j-1]]\n\t\t\t\tindex += 1\n\t\t\tend\n\t\t\t# break the loop\n\t\t\tbreak\n\t\t# if the sum of the two elements is smaller than the sum of the previous two elements\n\t\telseif nums1[i] + nums2[j] < nums1[i-1] + nums2[j-1]\n\t\t\t# add the current pair to the result\n\t\t\tresult[index] = [nums1[i], nums2[j]]\n\t\t\t# increment the index of the result\n\t\t\tindex += 1\n\t\t\t# increment the index of the first array\n\t\t\ti += 1\n\t\t# if the sum of the two elements is larger than the sum of the previous two elements\n\t\telse\n\t\t\t# add the current pair to the result\n\t\t\tresult[index] = [nums1[i-1], nums2[j]]\n\t\t\t# increment the index of the result\n\t",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort nums1 and nums2\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the heap\n\theap = Heap(nums1[1] + nums2[1])\n\t\n\t# initialize the index of nums1 and nums2\n\tnums1_index = 1\n\tnums2_index = 1\n\t\n\t# initialize the result\n\tresult = []\n\t\n\twhile nums1_index <= length(nums1) && nums2_index <= length(nums2) && length(result) < k\n\t\t# push the sum of the current element of nums1 and nums2 into the heap\n\t\tpush!(heap, nums1[nums1_index] + nums2[nums2_index])\n\t\t\n\t\t# pop the smallest element from the heap\n\t\tsmallest_sum = pop!(heap)\n\t\t\n\t\t# push the pair into the result\n\t\tpush!(result, [smallest_sum - nums2[nums2_index], nums2[nums2_index]])\n\t\t\n\t\t# update the index of nums1 and nums2\n\t\tif nums1_index == length(nums1)\n\t\t\tnums2_index += 1\n\t\telseif nums2_index == length(nums2)\n\t\t\tnums1_index += 1\n\t\telse\n\t\t\tif nums1[nums1_index + 1] + nums2[nums2_index] < nums1[nums1_index] + nums2[nums2_index + 1]\n\t\t\t\tnums1_index += 1\n\t\t\telse\n\t\t\t\tnums2_index += 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize the heap\n\theap = Heap{Tuple{Int64, Int64, Int64}}()\n\t# Push the first element of nums1 and nums2 into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# Initialize the visited vector\n\tvisited = Vector{Tuple{Int64, Int64}}()\n\t# Push the first element of nums1 and nums2 into the visited vector\n\tpush!(visited, (1, 1))\n\t# Loop k times\n\tfor i in 1:k\n\t\t# Pop the smallest element from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t# Push the element into the result vector\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# If i + 1 is less than the length of nums1 and (i + 1, j) is not in the visited vector\n\t\tif i + 1 <= length(nums1) && (i + 1, j) \u2209 visited\n\t\t\t# Push (i + 1, j) into the visited vector\n\t\t\tpush!(visited, (i + 1, j))\n\t\t\t# Push (nums1[i + 1] + nums2[j], i + 1, j) into the heap\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t# If j + 1 is less than the length of nums2 and (i, j + 1) is not in the visited vector\n\t\tif j + 1 <= length(nums2) && (i, j + 1) \u2209 visited\n\t\t\t# Push (i, j + 1) into the visited vector\n\t\t\tpush!(visited, (i, j + 1))\n\t\t\t# Push (nums1[i] + nums2[j + 1], i, j + 1) into the heap\n\t\t\tpush!(heap,",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\ti = 1\n\tj = 1\n\tfor l in 1:k\n\t\tif i < n1 && j < n2\n\t\t\tif nums1[i] + nums2[j] < nums1[i] + nums2[j+1]\n\t\t\t\tpairs[l] = [nums1[i], nums2[j]]\n\t\t\t\tj += 1\n\t\t\telse\n\t\t\t\tpairs[l] = [nums1[i], nums2[j+1]]\n\t\t\t\ti += 1\n\t\t\tend\n\t\telseif i < n1\n\t\t\tpairs[l] = [nums1[i], nums2[j]]\n\t\t\ti += 1\n\t\telse\n\t\t\tpairs[l] = [nums1[i], nums2[j+1]]\n\t\t\tj += 1\n\t\tend\n\tend\n\treturn pairs\nend"
  ]
}