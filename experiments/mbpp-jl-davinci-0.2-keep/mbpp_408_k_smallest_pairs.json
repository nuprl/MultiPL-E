{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\nfunction k_smallest_pairs(nums1::Vector{Int64}, nums2::Vector{Int64}, k::Int64)::Vector{Vector{Int64}} \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = k_smallest_pairs;\n\t@test(candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]])\n\t@test(candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]])\n\t@test(candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# Heapify\n\tfor i = k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the smallest k elements\n\tres = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\tres[i] = [heap[1][2], heap[1][3]]\n\t\t\n\t\t# Replace the root with the next element\n\t\tif heap[1][2] < n1\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\telse\n\t\t\theap[1] = heap[k - i + 1]\n\t\tend\n\t\t\n\t\t# Heapify\n\t\theapify(heap, 1, k - i)\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, (1, 1))\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tresult[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 + 1 <= n1 && !visited_has(visited, (i1 + 1, i2))\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tvisited_add!(visited, (i1 + 1, i2))\n\t\tend\n\t\tif i2 + 1 <= n2 && !visited_has(visited, (i1, i2 + 1))\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\t\tvisited_add!(visited, (i1, i2 + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# extract the k smallest pairs\n\tfor i in k+1:n*m\n\t\tif heap[1][1] > nums1[(i-1) div m + 1] + nums2[(i-1) mod m + 1]\n\t\t\theap[1] = [nums1[(i-1) div m + 1] + nums2[(i-1) mod m + 1], (i-1) div m + 1, (i-1) mod m + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# return the k smallest pairs\n\treturn heap\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# heap to store the pairs\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the heap\n\tfor i in 1:k\n\t\tif i <= n\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tbuild_heap!(heap)\n\t\n\t# pop the top element and push the next element\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the top element\n\t\ttop = pop_heap!(heap)\n\t\t\n\t\t# push the next element\n\t\tif top[3] < m\n\t\t\tpush!(heap, [top[1], nums2[top[3] + 1], top[3] + 1])\n\t\tend\n\t\t\n\t\t# build the heap\n\t\tbuild_heap!(heap)\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t_, x, y = pop!(pq)\n\t\tresult[i] = [nums1[x], nums2[y]]\n\t\tif x + 1 <= n1 && !visited_contains(visited, x + 1, y)\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\t\tvisited_add(visited, x + 1, y)\n\t\tend\n\t\tif y + 1 <= n2 && !visited_contains(visited, x, y + 1)\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\tvisited_add(visited, x, y + 1)\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tresult[i] = [nums1[i], nums2[j]]\n\t\tif i + 1 <= n1 && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= n2 && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add(visited, i, j + 1)\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\theap = Heap(k)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap.data[1].val[1], heap.data[1].val[2]]\n\t\tpop!(heap)\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tresult[i] = [nums1[1], nums2[1]]\n\tend\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif nums1[i] + nums2[j] < result[k][1] + result[k][2]\n\t\t\t\tresult[k] = [nums1[i], nums2[j]]\n\t\t\t\tresult = sort(result, by = x -> x[1] + x[2])\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# nums1 = [1, 7, 11]\n\t# nums2 = [2, 4, 6]\n\t# k = 3\n\t# Output: [[1,2],[1,4],[1,6]] \n\t# Explanation: The first 3 pairs are returned from the sequence: \n\t#              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\t\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 2\n\t# Output: [1,1],[1,1]\n\t# Explanation: The first 2 pairs are returned from the sequence: \n\t#              [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\t\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n\t# Output: [1,3],[2,3]\n\t# Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n\t\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# Output: [1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# extract the top k elements\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\tif heap[1][2] < n1 && heap[1][3] < n2\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\telseif heap[1][2] == n1\n\t\t\theap[1] = [nums1[n1] + nums2[heap[1][3] + 1], n1, heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[n2], heap[1][2] + 1, n2]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort nums1 and nums2\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the heap\n\theap = Heap(k)\n\t\n\t# push the first k pairs into the heap\n\tfor i in 1:k\n\t\tif i <= length(nums1)\n\t\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\t\tend\n\tend\n\t\n\t# pop the first k pairs from the heap\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the pair with the smallest sum\n\t\tpair = pop!(heap)\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# push the next pair into the heap\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpq = PriorityQueue()\n\tfor i in 1:length(nums1)\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\tresult = []\n\twhile k > 0 && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpairs = Vector{Vector{Int64}}()\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(pairs, [nums1[i] nums2[j]])\n\t\tend\n\tend\n\t\n\tsort!(pairs, by = x -> x[1] + x[2])\n\treturn pairs[1:k]\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\t\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue(k)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif pq.size() < k\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\telse\n\t\t\t\tif pq.top()[1] > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(pq)\n\t\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[pq.top()[2]], nums2[pq.top()[3]]]\n\t\tpop!(pq)\n\tend\n\treturn result\nend",
    "\t# sort the two arrays\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# initialize the index of the two arrays\n\ti = 1\n\tj = 1\n\t# initialize the index of the result\n\tindex = 1\n\t# loop until the result is full\n\twhile index <= k\n\t\t# if the first array is exhausted\n\t\tif i > length(nums1)\n\t\t\t# add the rest of the second array to the result\n\t\t\tfor m = j:length(nums2)\n\t\t\t\tresult[index] = [nums1[i-1], nums2[m]]\n\t\t\t\tindex += 1\n\t\t\tend\n\t\t\t# break the loop\n\t\t\tbreak\n\t\t# if the second array is exhausted\n\t\telseif j > length(nums2)\n\t\t\t# add the rest of the first array to the result\n\t\t\tfor m = i:length(nums1)\n\t\t\t\tresult[index] = [nums1[m], nums2[j-1]]\n\t\t\t\tindex += 1\n\t\t\tend\n\t\t\t# break the loop\n\t\t\tbreak\n\t\t# if the sum of the two elements is smaller than the sum of the previous two elements\n\t\telseif nums1[i] + nums2[j] < nums1[i-1] + nums2[j-1]\n\t\t\t# add the current pair to the result\n\t\t\tresult[index] = [nums1[i], nums2[j]]\n\t\t\t# increment the index of the result\n\t\t\tindex += 1\n\t\t\t# increment the index of the first array\n\t\t\ti += 1\n\t\t# if the sum of the two elements is larger than the sum of the previous two elements\n\t\telse\n\t\t\t# add the current pair to the result\n\t\t\tresult[index] = [nums1[i-1], nums2[j]]\n\t\t\t# increment the index of the result\n\t",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort nums1 and nums2\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the heap\n\theap = Heap(nums1[1] + nums2[1])\n\t\n\t# initialize the index of nums1 and nums2\n\tnums1_index = 1\n\tnums2_index = 1\n\t\n\t# initialize the result\n\tresult = []\n\t\n\twhile nums1_index <= length(nums1) && nums2_index <= length(nums2) && length(result) < k\n\t\t# push the sum of the current element of nums1 and nums2 into the heap\n\t\tpush!(heap, nums1[nums1_index] + nums2[nums2_index])\n\t\t\n\t\t# pop the smallest element from the heap\n\t\tsmallest_sum = pop!(heap)\n\t\t\n\t\t# push the pair into the result\n\t\tpush!(result, [smallest_sum - nums2[nums2_index], nums2[nums2_index]])\n\t\t\n\t\t# update the index of nums1 and nums2\n\t\tif nums1_index == length(nums1)\n\t\t\tnums2_index += 1\n\t\telseif nums2_index == length(nums2)\n\t\t\tnums1_index += 1\n\t\telse\n\t\t\tif nums1[nums1_index + 1] + nums2[nums2_index] < nums1[nums1_index] + nums2[nums2_index + 1]\n\t\t\t\tnums1_index += 1\n\t\t\telse\n\t\t\t\tnums2_index += 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize the heap\n\theap = Heap{Tuple{Int64, Int64, Int64}}()\n\t# Push the first element of nums1 and nums2 into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# Initialize the visited vector\n\tvisited = Vector{Tuple{Int64, Int64}}()\n\t# Push the first element of nums1 and nums2 into the visited vector\n\tpush!(visited, (1, 1))\n\t# Loop k times\n\tfor i in 1:k\n\t\t# Pop the smallest element from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t# Push the element into the result vector\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# If i + 1 is less than the length of nums1 and (i + 1, j) is not in the visited vector\n\t\tif i + 1 <= length(nums1) && (i + 1, j) \u2209 visited\n\t\t\t# Push (i + 1, j) into the visited vector\n\t\t\tpush!(visited, (i + 1, j))\n\t\t\t# Push (nums1[i + 1] + nums2[j], i + 1, j) into the heap\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t# If j + 1 is less than the length of nums2 and (i, j + 1) is not in the visited vector\n\t\tif j + 1 <= length(nums2) && (i, j + 1) \u2209 visited\n\t\t\t# Push (i, j + 1) into the visited vector\n\t\t\tpush!(visited, (i, j + 1))\n\t\t\t# Push (nums1[i] + nums2[j + 1], i, j + 1) into the heap\n\t\t\tpush!(heap,",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\ti = 1\n\tj = 1\n\tfor l in 1:k\n\t\tif i < n1 && j < n2\n\t\t\tif nums1[i] + nums2[j] < nums1[i] + nums2[j+1]\n\t\t\t\tpairs[l] = [nums1[i], nums2[j]]\n\t\t\t\tj += 1\n\t\t\telse\n\t\t\t\tpairs[l] = [nums1[i], nums2[j+1]]\n\t\t\t\ti += 1\n\t\t\tend\n\t\telseif i < n1\n\t\t\tpairs[l] = [nums1[i], nums2[j]]\n\t\t\ti += 1\n\t\telse\n\t\t\tpairs[l] = [nums1[i], nums2[j+1]]\n\t\t\tj += 1\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited = add!(visited, (1, 1))\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, x, y) = pop!(pq)\n\t\tresult[i] = [nums1[x], nums2[y]]\n\t\tif x + 1 <= n1 && !(x + 1, y) in visited\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\t\tvisited = add!(visited, (x + 1, y))\n\t\tend\n\t\tif y + 1 <= n2 && !(x, y + 1) in visited\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\tvisited = add!(visited, (x, y + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif pairs[l][1] + pairs[l][2] > pairs[l+1][1] + pairs[l+1][2]\n\t\t\t\t\t\ttmp = pairs[l]\n\t\t\t\t\t\tpairs[l] = pairs[l+1]\n\t\t\t\t\t\tpairs[l+1] = tmp\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tidx = Vector{Int64}(undef, n1)\n\tfor i in 1:n1\n\t\tidx[i] = 1\n\tend\n\tfor i in 1:k\n\t\tmin_val = nums1[1] + nums2[1]\n\t\tmin_idx = [1, 1]\n\t\tfor j in 1:n1\n\t\t\tif idx[j] <= n2 && nums1[j] + nums2[idx[j]] < min_val\n\t\t\t\tmin_val = nums1[j] + nums2[idx[j]]\n\t\t\t\tmin_idx = [j, idx[j]]\n\t\t\tend\n\t\tend\n\t\tpairs[i] = [nums1[min_idx[1]], nums2[min_idx[2]]]\n\t\tidx[min_idx[1]] += 1\n\tend\n\treturn pairs\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t\n\t# push the first pair of elements into the queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\t\n\t# create a vector to store the k smallest pairs\n\tk_smallest = Vector{Vector{Int64}}()\n\t\n\t# while the queue is not empty and the size of the k_smallest vector is less than k\n\twhile !isempty(pq) && length(k_smallest) < k\n\t\t# pop the pair with the smallest sum\n\t\tsum, i, j = pop!(pq)\n\t\t\n\t\t# add the pair to the k_smallest vector\n\t\tpush!(k_smallest, [nums1[i], nums2[j]])\n\t\t\n\t\t# if the index i is less than n, add the pair (i + 1, j) to the queue\n\t\tif i < n && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\t# if the index j is less than m, add the pair (i, j + 1) to the queue\n\t\tif j < m && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn k_smallest\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in div(k, 2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the heap\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\tif heap[1][2] == n1\n\t\t\tif heap[1][3] == n2\n\t\t\t\theap[1] = heap[k]\n\t\t\telse\n\t\t\t\theap[1] = [nums1[n1] + nums2[heap[1][3] + 1], n1, heap[1][3] + 1]\n\t\t\tend\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i + 1 <= n1 && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= n2 && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add(visited, i, j + 1)\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the heap size\n\theap_size = 0\n\t\n\t# Initialize the index of the first array\n\ti = 1\n\t\n\t# Initialize the index of the second array\n\tj = 1\n\t\n\twhile i <= length(nums1) && j <= length(nums2)\n\t\tif heap_size < k\n\t\t\theap_size += 1\n\t\t\theap[heap_size] = [nums1[i] + nums2[j], i, j]\n\t\t\t\n\t\t\t# Heapify the heap\n\t\t\theapify(heap, heap_size)\n\t\telse\n\t\t\tif nums1[i] + nums2[j] < heap[1][1]\n\t\t\t\theap[1] = [nums1[i] + nums2[j], i, j]\n\t\t\t\t\n\t\t\t\t# Heapify the heap\n\t\t\t\theapify(heap, heap_size)\n\t\t\tend\n\t\tend\n\t\t\n\t\tif j < length(nums2)\n\t\t\tj += 1\n\t\telse\n\t\t\ti += 1\n\t\t\tj = 1\n\t\tend\n\tend\n\t\n\t# Construct the result\n\tfor i in 1:heap_size\n\t\tresult[i] = [nums1[heap[i][2]], nums2[heap[i][3]]]\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\tpq = PriorityQueue(max)\n\tfor i in 1:n\n\t\tfor j in 1:m\n\t\t\tif length(pq) < k\n\t\t\t\tpush!(pq, [nums1[i], nums2[j]])\n\t\t\telse\n\t\t\t\tif nums1[i] + nums2[j] < pq[1][1] + pq[1][2]\n\t\t\t\t\tpop!(pq)\n\t\t\t\t\tpush!(pq, [nums1[i], nums2[j]])\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn collect(pq)\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\t\n\twhile length(result) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i < n1 && !visited_contains(visited, i+1, j)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tvisited_add!(visited, i+1, j)\n\t\tend\n\t\tif j < n2 && !visited_contains(visited, i, j+1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\t\tvisited_add!(visited, i, j+1)\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 0, 0]\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# push the next pair with the same first element\n\t\tif pair[3] < n2 - 1\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\tend\n\t\t\n\t\t# push the next pair with the same second element\n\t\tif pair[2] < n1 - 1 && pair[3] == 0\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\t# Output: [[1,2],[1,4],[1,6]]\n\t# Explanation: The first 3 pairs are returned from the sequence:\n\t#              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\t#\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 2\n\t# Output: [1,1],[1,1]\n\t# Explanation: The first 2 pairs are returned from the sequence:\n\t#              [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\t#\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 3\n\t# Output: [1,3],[2,3]\n\t# Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n\t#\n\t# nums1 = [1,2,4,5,6]\n\t# nums2 = [3,5,7,9]\n\t# k = 3\n\t# Output: [1,3],[2,3],[1,5]\n\t# Explanation: All possible pairs are returned from the sequence: [1,3],[2,3],[1,5],[5,3],[4,3],[5,5],[6,3],[4,5],[6,5],[5,7],[6,7],[5,9],[6,9]\n\t\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t\n\t# push the first element of the first array and the first element of the second array\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n",
    "\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\t\n\tif k > n * m\n\t\tk = n * m\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n && j < m\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif i < n\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telseif j < m\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort the two arrays\n\tsort!(nums1)\n\tsort!(nums2)\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t\n\t# push the first element of each array into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# while the priority queue is not empty and the result size is less than k\n\twhile !isempty(pq) && length(result) < k\n\t\t# pop the top element from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t\n\t\t# push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# if i is less than the length of nums1 and (i + 1, j) is not visited\n\t\tif i < length(nums1) && !(i + 1, j) in visited\n\t\t\t# push (i + 1, j) into the priority queue\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\t\n\t\t\t# add (i + 1, j) into the visited set\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\t# if j is less than the length of nums2 and (i, j + 1) is not visited\n\t\tif j < length(nums2) && !(i, j + 1) in visited\n\t\t\t# push (i, j + 1) into the priority queue\n\t\t\tpush!(pq, (nums1[i] +",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k:-1:2\n\t\t\t\t\tif pairs[l][1] + pairs[l][2] < pairs[l-1][1] + pairs[l-1][2]\n\t\t\t\t\t\tpairs[l], pairs[l-1] = pairs[l-1], pairs[l]\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\t\n\twhile length(res) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif j == 1 && i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t# sort the two arrays\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize the result array\n\tresult = Vector{Vector{Int64}}()\n\t# initialize the heap\n\theap = Heap()\n\t# push the first element of the first array and the first element of the second array into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# initialize the visited array\n\tvisited = Vector{Vector{Bool}}(undef, length(nums1), length(nums2))\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tvisited[i, j] = false\n\t\tend\n\tend\n\tvisited[1, 1] = true\n\t# iterate k times\n\tfor i in 1:k\n\t\t# pop the smallest element from the heap\n\t\t(sum, idx1, idx2) = pop!(heap)\n\t\t# push the element into the result array\n\t\tpush!(result, [nums1[idx1], nums2[idx2]])\n\t\t# push the next element of the first array and the current element of the second array into the heap\n\t\tif idx1 < length(nums1) && !visited[idx1 + 1, idx2]\n\t\t\tpush!(heap, (nums1[idx1 + 1] + nums2[idx2], idx1 + 1, idx2))\n\t\t\tvisited[idx1 + 1, idx2] = true\n\t\tend\n\t\t# push the current element of the first array and the next element of the second array into the heap\n\t\tif idx2 < length(nums2) && !visited[idx1, idx2 + 1]\n\t\t\tpush!(heap, (nums1[idx1] + nums2[idx2 + 1], idx1, idx2 + 1))\n\t\t\tvisited[idx1, idx2 + 1",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= length(nums1) && i <= length(nums2)\n\t\t\theap[i] = [nums1[i], nums2[i]]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tparent = div(j, 2)\n\t\t\tif heap[parent][1] + heap[parent][2] > heap[j][1] + heap[j][2]\n\t\t\t\theap[parent], heap[j] = heap[j], heap[parent]\n\t\t\tend\n\t\t\tj = parent\n\t\tend\n\tend\n\t\n\t# Extract the minimum element from the heap and insert the next element from the same array\n\tfor i in k+1:length(nums1) * length(nums2)\n\t\tif i <= length(nums1)\n\t\t\theap[1] = [nums1[i], heap[1][2]]\n\t\telse\n\t\t\theap[1] = [heap[1][1], nums2[i - length(nums1)]]\n\t\tend\n\t\t\n\t\tj = 1\n\t\twhile 2 * j <= k\n\t\t\tchild = 2 * j\n\t\t\tif child < k && heap[child][1] + heap[child][2] > heap[child + 1][1] + heap[child + 1][2]\n\t\t\t\tchild += 1\n\t\t\tend\n\t\t\tif heap[j][1] + heap[j][2] > heap[child][1] + heap[child][2]\n\t\t\t\theap[j], heap[child] = heap[child], heap[j]\n\t\t\tend\n\t\t\tj = child\n\t\tend\n\t",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort the two arrays\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the heap\n\theap = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# initialize the visited set\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\t# loop\n\twhile length(result) < k && !isempty(heap)\n\t\t# pop the smallest pair\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# push the next possible pairs\n\t\tif i < length(nums1) && !(i + 1, j) in visited\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j < length(nums2) && !(i, j + 1) in visited\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tresult = zeros(k, 2)\n\t\n\tfor i in 1:k\n\t\tresult[i, :] = [nums1[1], nums2[1]]\n\tend\n\t\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < result[k, 1] + result[k, 2]\n\t\t\t\tresult[k, :] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif result[l, 1] + result[l, 2] > result[l+1, 1] + result[l+1, 2]\n\t\t\t\t\t\ttemp = result[l, :]\n\t\t\t\t\t\tresult[l, :] = result[l+1, :]\n\t\t\t\t\t\tresult[l+1, :] = temp\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i = div(k, 2):-1:1\n\t\theapify!(heap, i, k)\n\tend\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = heap[1]\n\t\tif result[i][3] == n2\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\t\theapify!(heap, 1, length(heap))\n\t\telse\n\t\t\theap[1] = [result[i][1], nums2[result[i][3] + 1], result[i][3] + 1]\n\t\t\theapify!(heap, 1, length(heap))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}()\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\tend\n\t\n\t# Heapify the heap\n\theapify!(heap, 1:length(heap), lt=x->x[1]+x[2] < y->y[1]+y[2])\n\t\n\t# Get the k smallest pairs\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the smallest pair\n\t\tpair = pop!(heap)\n\t\tpush!(result, pair[1:2])\n\t\t\n\t\t# Add the next pair from the second array\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, [pair[1], nums2[pair[3]+1], pair[3]+1])\n\t\t\theapify!(heap, 1:length(heap), lt=x->x[1]+x[2] < y->y[1]+y[2])\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n && j < m\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n && j < m - 1\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tif length(nums1) * length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif length(nums1) > length(nums2)\n\t\tnums1, nums2 = nums2, nums1\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Tuple{Int64, Int64, Int64}}(undef, k)\n\theap[1] = (nums1[1] + nums2[1], 1, 1)\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\t# get the smallest pair\n\t\tpair = heap[1]\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# remove the smallest pair from the heap\n\t\theap[1] = heap[end]\n\t\tpop!(heap)\n\t\t\n\t\t# add the next pair from the same array\n\t\tif pair[2] < n && pair[3] < m\n\t\t\tif pair[2] < pair[3]\n\t\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\telse\n\t\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\tend\n\t\tend\n\t\t\n\t\t# heapify\n\t\theapify!(heap)\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i = 2:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\theapify!(heap)\n\t\n\t# find k smallest pairs\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= length(heap)\n\t\t\tres[i] = [nums1[heap[1][2]], nums2[heap[1][3]]]\n\t\t\tif heap[1][3] < n2\n\t\t\t\theap[1][1] = nums1[heap[1][2]] + nums2[heap[1][3] + 1]\n\t\t\t\theap[1][3] += 1\n\t\t\telse\n\t\t\t\theap[1] = heap[end]\n\t\t\t\tpop!(heap)\n\t\t\tend\n\t\t\theapify!(heap)\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif length(result) < k\n\t\t\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\telse\n\t\t\t\tmax_index = 0\n\t\t\t\tmax_value = 0\n\t\t\t\tfor l in 1:length(result)\n\t\t\t\t\tif result[l][1] + result[l][2] > max_value\n\t\t\t\t\t\tmax_value = result[l][1] + result[l][2]\n\t\t\t\t\t\tmax_index = l\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif nums1[i] + nums2[j] < max_value\n\t\t\t\t\tresult[max_index] = [nums1[i], nums2[j]]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}()\n\tfor i in 1:n\n\t\tpush!(heap, [nums1[i] + nums2[1], i, 1])\n\tend\n\t\n\t# heapify\n\theapify!(heap)\n\t\n\t# pop k elements\n\tres = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the top element\n\t\ttop = pop!(heap)\n\t\tpush!(res, [nums1[top[2]], nums2[top[3]]])\n\t\t\n\t\t# push the next element\n\t\tif top[3] < m\n\t\t\tpush!(heap, [nums1[top[2]] + nums2[top[3] + 1], top[2], top[3] + 1])\n\t\tend\n\t\t\n\t\t# heapify\n\t\theapify!(heap)\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, 1, 1)\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n1 && !visited_has(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add!(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= n2 && !visited_has(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add!(visited, i, j + 1)\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 0, 0]\n\t\n\t# initialize the result\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the visited\n\tvisited = Vector{Vector{Bool}}(undef, n, m)\n\tvisited[1, 1] = true\n\t\n\t# initialize the heap size\n\tsize = 1\n\t\n\t# iterate k times\n\tfor i in 1:k\n\t\t# pop the smallest pair\n\t\tpair = heap[1]\n\t\theap[1] = heap[size]\n\t\tsize -= 1\n\t\t\n\t\t# store the pair in the result\n\t\tres[i] = [nums1[pair[2] + 1], nums2[pair[3] + 1]]\n\t\t\n\t\t# push the next pair\n\t\tif pair[2] + 1 < n && pair[3] + 1 < m && !visited[pair[2] + 1, pair[3] + 1]\n\t\t\tsize += 1\n\t\t\theap[size] = [nums1[pair[2] + 1] + nums2[pair[3] + 1], pair[2] + 1, pair[3] + 1]\n\t\t\tvisited[pair[2] + 1, pair[3] + 1] = true\n\t\tend\n\t\t\n\t\tif pair[2] + 1 < n && !visited[pair[2] + 1, pair[3]]\n\t\t\tsize += 1\n\t\t\theap[size] = [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]]\n\t\t\tvisited[pair[2] + 1, pair[3]] = true\n",
    "\t# Initialize a heap\n\theap = Heap()\n\t# Initialize a set to store the pairs\n\tpairs = Set()\n\t# Initialize a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# Push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# Push the first pair into the set\n\tpush!(pairs, (1, 1))\n\t# Iterate k times\n\tfor i in 1:k\n\t\t# Pop the pair with the smallest sum\n\t\t(sum, i, j) = pop!(heap)\n\t\t# Push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# If the pair has a right neighbor\n\t\tif j < length(nums2)\n\t\t\t# If the right neighbor is not in the set\n\t\t\tif !(i, j + 1) in pairs\n\t\t\t\t# Push the right neighbor into the heap\n\t\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\t\t# Push the right neighbor into the set\n\t\t\t\tpush!(pairs, (i, j + 1))\n\t\t\tend\n\t\tend\n\t\t# If the pair has a bottom neighbor\n\t\tif i < length(nums1)\n\t\t\t# If the bottom neighbor is not in the set\n\t\t\tif !(i + 1, j) in pairs\n\t\t\t\t# Push the bottom neighbor into the heap\n\t\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\t\t# Push the bottom neighbor into the set\n\t\t\t\tpush!(pairs, (i + 1, j))\n\t\t\tend\n\t\tend\n\tend\n\t# Return the result\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tif k > length(nums1)*length(nums2)\n\t\tk = length(nums1)*length(nums2)\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\tend\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i = 1:k\n\t\tif i <= n\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\tbuild_max_heap!(heap)\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i = 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tresult[i] = heap[1][1:2]\n\t\t\n\t\tif heap[1][3] < m\n\t\t\theap[1][1] = nums1[heap[1][3] + 1]\n\t\t\theap[1][2] = nums2[heap[1][3] + 1]\n\t\t\theap[1][3] += 1\n\t\telse\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\tend\n\t\t\n\t\tmax_heapify!(heap, 1)\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tresult[i] = [nums1[1], nums2[1]]\n\tend\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif nums1[i] + nums2[j] < result[k][1] + result[k][2]\n\t\t\t\tresult[k] = [nums1[i], nums2[j]]\n\t\t\t\tresult = sort(result, by = x -> x[1] + x[2])\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# use a min heap to store the pairs\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i in 2:k\n\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\tend\n\t\n\t# build the min heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the min element and push the next element\n\tfor i in k+1:n1 * n2\n\t\tmin_pair = heap[1]\n\t\tif min_pair[2] == n1\n\t\t\theap[1] = [nums1[min_pair[2]] + nums2[min_pair[3] + 1], min_pair[2], min_pair[3] + 1]\n\t\telseif min_pair[3] == n2\n\t\t\theap[1] = [nums1[min_pair[2] + 1] + nums2[min_pair[3]], min_pair[2] + 1, min_pair[3]]\n\t\telse\n\t\t\tif nums1[min_pair[2] + 1] + nums2[min_pair[3]] < nums1[min_pair[2]] + nums2[min_pair[3] + 1]\n\t\t\t\theap[1] = [nums1[min_pair[2] + 1] + nums2[min_pair[3]], min_pair[2] + 1, min_pair[3]]\n\t\t\telse\n\t\t\t\theap[1] = [nums1[min_pair[2]] + nums2[min_pair[3",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = [([nums1[1] + nums2[1]], 1, 1)]\n\t\n\t# Initialize the result\n\tresult = []\n\t\n\t# Initialize the set to store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\t\n\t# Initialize the counter\n\tcounter = 0\n\t\n\twhile counter < k && length(heap) > 0\n\t\t# Pop the smallest pair from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t\n\t\t# Append the pair to the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Increment the counter\n\t\tcounter += 1\n\t\t\n\t\t# Add the next pair to the heap\n\t\tif i + 1 <= length(nums1) && !(i + 1, j) in visited\n\t\t\tpush!(heap, ([nums1[i + 1] + nums2[j]], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\t# Add the next pair to the heap\n\t\tif j + 1 <= length(nums2) && !(i, j + 1) in visited\n\t\t\tpush!(heap, ([nums1[i] + nums2[j + 1]], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in 1:k\n\t\theapify(heap, i)\n\tend\n\t\n\t# pop the smallest pair\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = pop!(heap)\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i] nums2[1]]\n\tend\n\t\n\tfor i in k+1:length(nums1)\n\t\theap[1] = [nums1[i] nums2[1]]\n\t\theap = min_heapify(heap, 1)\n\tend\n\t\n\tfor j in 2:length(nums2)\n\t\tfor i in 1:k\n\t\t\theap[i] = [heap[i][1] nums2[j]]\n\t\tend\n\t\theap = min_heapify(heap, 1)\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\ti = 1\n\twhile i <= k\n\t\tval, idx1, idx2 = pop!(pq)\n\t\tres[i] = [nums1[idx1], nums2[idx2]]\n\t\tif idx1 < n1 && idx2 + 1 <= n2\n\t\t\tpush!(pq, (nums1[idx1] + nums2[idx2 + 1], idx1, idx2 + 1))\n\t\tend\n\t\tif idx1 + 1 <= n1 && idx2 < n2\n\t\t\tpush!(pq, (nums1[idx1 + 1] + nums2[idx2], idx1 + 1, idx2))\n\t\tend\n\t\ti += 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\tend\n\t\tif i1 < n1 && i2 < n2 - 1\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tbuild_max_heap!(heap)\n\t\n\t# extract the max element\n\tfor i in k+1:k*n2\n\t\tif i <= n1*n2\n\t\t\tmax_elem = heap[1]\n\t\t\theap[1] = [nums1[max_elem[3]], nums2[max_elem[2]+1], max_elem[3]]\n\t\t\tmax_heapify!(heap, 1)\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i], nums2[i], 1]\n\tend\n\t\n\t# Heapify\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the smallest element\n\tfor i in k+1:n*m\n\t\tif nums1[(i-1)%n+1] + nums2[(i-1)//n+1] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[(i-1)%n+1], nums2[(i-1)//n+1], 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# Pop the rest\n\tfor i in k+1:n*m\n\t\tif nums1[(i-1)%n+1] + nums2[(i-1)//n+1] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[(i-1)%n+1], nums2[(i-1)//n+1], 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# Return the result\n\treturn heap\nend",
    "\t# sort the two arrays\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}()\n\t# initialize the first pair\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t# initialize the visited array\n\tvisited = Array{Bool}(length(nums1), length(nums2))\n\tvisited[1, 1] = true\n\t# loop k times\n\tfor i in 1:k\n\t\t# get the smallest pair\n\t\tpair = pop!(heap)\n\t\t# push the pair into the result\n\t\tpush!(result, [pair[2], pair[3]])\n\t\t# get the index of the first element in the pair\n\t\ti1 = pair[2]\n\t\t# get the index of the second element in the pair\n\t\ti2 = pair[3]\n\t\t# if the first element can be incremented\n\t\tif i1 < length(nums1) && !visited[i1 + 1, i2]\n\t\t\t# increment the first element\n\t\t\tpush!(heap, [nums1[i1 + 1] + nums2[i2], i1 + 1, i2])\n\t\t\t# mark the new pair as visited\n\t\t\tvisited[i1 + 1, i2] = true\n\t\tend\n\t\t# if the second element can be incremented\n\t\tif i2 < length(nums2) && !visited[i1, i2 + 1]\n\t\t\t# increment the second element\n\t\t\tpush!(heap, [nums1[i1] + nums2[i2 + 1], i1, i2 + 1])\n\t\t\t# mark the new pair as visited\n\t\t\tvisited[i1, i2 + 1] = true\n\t\tend\n\tend\n\t# return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t# initialize the heap\n\theap = Heap(n1 * n2)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t# pop the k smallest pairs\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(heap)\n\t\tres[i] = [nums1[i], nums2[j]]\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i], nums2[1], 1]\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in 1:k\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the heap\n\tfor i in k+1:n1*n2\n\t\tif i <= n1*n2\n\t\t\theap[1] = [nums1[i\u00f7n2+1], nums2[i\u00f7n1+1], i\u00f7n1+1]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn heap\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] * nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\theap = BinaryHeap()\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(heap, nums1[i] * nums2[j])\n\t\tend\n\tend\n\t\n\tresult = Vector{Int64}()\n\tfor i in 1:k\n\t\tpush!(result, pop!(heap))\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Create a heap\n\theap = Heap(k)\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif heap.size < k\n\t\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\t\telse\n\t\t\t\tif heap.heap[1].first > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(heap)\n\t\t\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\t\t\telse\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# Create a result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap.heap[i].second, heap.heap[i].third]\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n && j < m\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n && j < m\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\t\tif i2 == 1 && i1 < n1\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Create a heap of size k\n\theap = Heap{Tuple{Int64, Int64}}(k)\n\t\n\t# Add the first element of the first array to the heap\n\tpush!(heap, (nums1[1] + nums2[1], (1, 1)))\n\t\n\t# Create a set to store the indices of the elements already added to the heap\n\tset = Set{Tuple{Int64, Int64}}()\n\tpush!(set, (1, 1))\n\t\n\t# Create a vector to store the k smallest pairs\n\tk_smallest_pairs = Vector{Vector{Int64}}(k)\n\t\n\t# Iterate until the heap is empty\n\twhile !isempty(heap)\n\t\t# Pop the top element from the heap\n\t\t(sum, (i, j)) = pop!(heap)\n\t\t\n\t\t# Add the popped element to the k_smallest_pairs vector\n\t\tpush!(k_smallest_pairs, [nums1[i], nums2[j]])\n\t\t\n\t\t# If the heap is not full, add the next element from the first array to the heap\n\t\tif length(heap) < k && i < length(nums1)\n\t\t\tif !in(set, (i + 1, j))\n\t\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], (i + 1, j)))\n\t\t\t\tpush!(set, (i + 1, j))\n\t\t\tend\n\t\tend\n\t\t\n\t\t# If the heap is not full, add the next element from the second array to the heap\n\t\tif length(heap) < k && j < length(nums2)\n\t\t\tif !in(set, (i, j + 1))\n\t\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], (i, j + 1)))\n\t\t\t\tpush!(set,",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\t# create a heap\n\theap = Heap()\n\t\n\t# push the first element of each array into the heap\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop k elements from the heap\n\tresult = []\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# iterate through the heap\n\tfor i in 1:k\n\t\t# get the smallest pair\n\t\tpair = heap[1]\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# remove the smallest pair\n\t\theap[1] = heap[end]\n\t\tpop!(heap)\n\t\t\n\t\t# add the next pair\n\t\tif pair[2] == n\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\telseif pair[3] == m\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\telse\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\tend\n\t\t\n\t\t# heapify\n\t\theapify!(heap)\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = [(nums1[1] + nums2[1], 1, 1)]\n\t\n\t# Initialize the result\n\tresult = []\n\t\n\t# Initialize the visited array\n\tvisited = zeros(Int64, length(nums1), length(nums2))\n\tvisited[1, 1] = 1\n\t\n\twhile k > 0 && length(heap) > 0\n\t\t# Pop the smallest element from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t\n\t\t# Append the pair to the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Check if the next element in nums1 is valid\n\t\tif i < length(nums1) && visited[i + 1, j] == 0\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited[i + 1, j] = 1\n\t\tend\n\t\t\n\t\t# Check if the next element in nums2 is valid\n\t\tif j < length(nums2) && visited[i, j + 1] == 0\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited[i, j + 1] = 1\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\t\n\twhile !isempty(pq) && length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i == length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == length(nums2)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t# sort the two arrays\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i = 2:k\n\t\tif i <= length(nums1)\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[i - length(nums1)] + nums2[2], i - length(nums1), 2]\n\t\tend\n\tend\n\t# build the heap\n\tfor i = div(k, 2):-1:1\n\t\theap = heap_down(heap, i)\n\tend\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\tif heap[1][3] < length(nums2)\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[1], heap[1][2] + 1, 1]\n\t\tend\n\t\theap = heap_down(heap, 1)\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\tn = length(nums1)\n\tm = length(nums2)\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = []\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add!(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= m && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add!(visited, i, j + 1)\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\tpair = pop!(pq)\n\t\tpush!(res, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\tif pair[2] < n1 && pair[3] < n2\n\t\t\tpush!(pq, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\tend\n\t\t\n\t\tif pair[2] < n1 && pair[3] < n2 - 1\n\t\t\tpush!(pq, (nums1[pair[2] + 1] + nums2[pair[3] + 1], pair[2] + 1, pair[3] + 1))\n\t\tend\n\t\t\n\t\tif pair[2] < n1 - 1 && pair[3] < n2\n\t\t\tpush!(pq, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t# build the heap\n\tfor i = k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t# pop the smallest element from the heap\n\tfor i = k+1:n1 * n2\n\t\tif nums1[(i-1) / n2 + 1] + nums2[(i-1) % n2 + 1] < heap[1][1]\n\t\t\theap[1] = [nums1[(i-1) / n2 + 1] + nums2[(i-1) % n2 + 1], (i-1) / n2 + 1, (i-1) % n2 + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\treturn heap\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tnums1_idx = 1\n\tnums2_idx = 1\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile nums1_idx <= length(nums1) && nums2_idx <= length(nums2) && k > 0\n\t\tif nums1[nums1_idx] <= nums2[nums2_idx]\n\t\t\tpush!(result, [nums1[nums1_idx], nums2[nums2_idx]])\n\t\t\tnums1_idx += 1\n\t\telse\n\t\t\tpush!(result, [nums1[nums1_idx], nums2[nums2_idx]])\n\t\t\tnums2_idx += 1\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\twhile nums1_idx <= length(nums1) && k > 0\n\t\tpush!(result, [nums1[nums1_idx], nums2[nums2_idx]])\n\t\tnums1_idx += 1\n\t\tk -= 1\n\tend\n\t\n\twhile nums2_idx <= length(nums2) && k > 0\n\t\tpush!(result, [nums1[nums1_idx], nums2[nums2_idx]])\n\t\tnums2_idx += 1\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Heap{Tuple{Int64, Int64, Int64}}()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the visited array\n\tvisited = Vector{Bool}(undef, length(nums1), length(nums2))\n\tvisited[1, 1] = true\n\t\n\t# Start the loop\n\tfor i in 1:k\n\t\t# Get the current smallest pair\n\t\tcurrent_pair = pop!(heap)\n\t\t\n\t\t# Add the current pair to the result\n\t\tresult[i] = [nums1[current_pair[2]], nums2[current_pair[3]]]\n\t\t\n\t\t# Check if the current pair has a right neighbor\n\t\tif current_pair[3] < length(nums2) && !visited[current_pair[2], current_pair[3] + 1]\n\t\t\tpush!(heap, (nums1[current_pair[2]] + nums2[current_pair[3] + 1], current_pair[2], current_pair[3] + 1))\n\t\t\tvisited[current_pair[2], current_pair[3] + 1] = true\n\t\tend\n\t\t\n\t\t# Check if the current pair has a bottom neighbor\n\t\tif current_pair[2] < length(nums1) && !visited[current_pair[2] + 1, current_pair[3]]\n\t\t\tpush!(heap, (nums1[current_pair[2] + 1] + nums2[current_pair[3]], current_pair[2] + 1, current_pair[3]))\n\t\t\tvisited[current_pair[2] + 1, current_pair[3]] = true\n\t\tend\n\tend\n\t\n\treturn",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i] nums2[j]])\n\t\tif i == length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\telseif j == length(nums2)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && visited_add!(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif j < n2 && visited_add!(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif n1 * n2 <= k\n\t\treturn [nums1[i] + nums2[j] for i in 1:n1, j in 1:n2]\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, sum)\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\telseif i < n1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\telseif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\t# Initialize the heap\n\theap = Heap(k)\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Pop the smallest k pairs\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tpair = pop!(heap)\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\tres = []\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\tend\n\t\tif j == 1 && i < n1\n\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\tend\n\tend\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tpq = PriorityQueue()\n\t\n\tfor i in 1:n\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0 && !isempty(pq)\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif j < m\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\t# Output: [[1,2],[1,4],[1,6]] \n\t# Explanation: The first 3 pairs are returned from the sequence: \n\t#              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 2\n\t# Output: [1,1],[1,1]\n\t# Explanation: The first 2 pairs are returned from the sequence: \n\t#              [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\t\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 3\n\t# Output: [1,3],[2,3]\n\t# Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 10\n\t# Output: [1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[2,1],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[1,3],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,3],[2,3",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Iterate through the heap\n\tfor i = 1:k\n\t\t# Get the current smallest pair\n\t\tcurrent_pair = heap[1]\n\t\t\n\t\t# Add the current pair to the result\n\t\tresult[i] = [nums1[current_pair[2]], nums2[current_pair[3]]]\n\t\t\n\t\t# If the current pair is the last pair, then we are done\n\t\tif current_pair[2] == length(nums1) && current_pair[3] == length(nums2)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# If the current pair is the last pair in the current row, then we need to move to the next row\n\t\tif current_pair[3] == length(nums2)\n\t\t\theap[1] = [nums1[current_pair[2] + 1] + nums2[1], current_pair[2] + 1, 1]\n\t\telse\n\t\t\theap[1] = [nums1[current_pair[2]] + nums2[current_pair[3] + 1], current_pair[2], current_pair[3] + 1]\n\t\tend\n\t\t\n\t\t# Sift down the heap\n\t\tsift_down(heap, 1)\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tpairs = []\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(pairs, [nums1[i], nums2[j]])\n\t\tend\n\tend\n\t\n\tsort!(pairs, by = x -> x[1] + x[2])\n\t\n\treturn pairs[1:k]\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\theap = Heap()\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\tfor i in 1:k\n\t\tpop!(heap)\n\t\tpush!(result, [nums1[heap.data[1][2]], nums2[heap.data[1][3]]])\n\tend\n\t\n\treturn result\nend",
    "\t# create a priority queue\n\tpq = PriorityQueue()\n\t# push all pairs into the priority queue\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t# pop k pairs\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\tp = pop!(pq)\n\t\tpush!(result, [nums1[p[2]], nums2[p[3]]])\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tfunction get_next_smallest_pair(nums1::Vector{Int64}, nums2::Vector{Int64}, i::Int64, j::Int64)::Vector{Int64}\n\t\tif i == length(nums1)\n\t\t\treturn [nums1[i], nums2[j+1]]\n\t\telseif j == length(nums2)\n\t\t\treturn [nums1[i+1], nums2[j]]\n\t\telse\n\t\t\tif nums1[i+1] + nums2[j] < nums1[i] + nums2[j+1]\n\t\t\t\treturn [nums1[i+1], nums2[j]]\n\t\t\telse\n\t\t\t\treturn [nums1[i], nums2[j+1]]\n\t\t\tend\n\t\tend\n\tend\n\t\n\ti = 1\n\tj = 1\n\tresult = [[nums1[i], nums2[j]]]\n\twhile length(result) < k\n\t\tnext_pair = get_next_smallest_pair(nums1, nums2, i, j)\n\t\tif next_pair[1] == nums1[i]\n\t\t\tj += 1\n\t\telse\n\t\t\ti += 1\n\t\tend\n\t\tpush!(result, next_pair)\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif pairs[l][1] + pairs[l][2] > pairs[l+1][1] + pairs[l+1][2]\n\t\t\t\t\t\tpairs[l], pairs[l+1] = pairs[l+1], pairs[l]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = []\n\tfor i in 1:k\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n1 && !visited_has(visited, i + 1, j)\n\t\t\tvisited_add!(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !visited_has(visited, i, j + 1)\n\t\t\tvisited_add!(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif k == 0\n\t\treturn []\n\tend\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Heap(k)\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop the smallest pair from the heap and push the next pair from the same array\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t(sum, i, j) = pop!(heap)\n\t\tresult[i] = [nums1[i], nums2[j]]\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# create a heap to store the pairs\n\theap = Heap{Tuple{Int64, Int64, Int64}}()\n\t\n\t# push the first pair\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# store the pairs\n\tpairs = Vector{Vector{Int64}}()\n\t\n\t# store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\t\n\t# the number of pairs\n\tcount = 0\n\t\n\twhile count < k && !isempty(heap)\n\t\t# pop the pair with the smallest sum\n\t\t(sum, i, j) = pop!(heap)\n\t\t\n\t\t# add the pair to the result\n\t\tpush!(pairs, [nums1[i], nums2[j]])\n\t\t\n\t\t# update the number of pairs\n\t\tcount += 1\n\t\t\n\t\t# push the next pair with the first element\n\t\tif i < length(nums1) && (i + 1, j) \u2209 visited\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\t# push the next pair with the second element\n\t\tif j < length(nums2) && (i, j + 1) \u2209 visited\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn pairs\nend",
    "\t# sort the two arrays\n\tsort!(nums1)\n\tsort!(nums2)",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= n\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i = floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = heap[1][1:2]\n\t\tif heap[1][3] < m\n\t\t\theap[1] = [nums1[heap[1][3] + 1], nums2[heap[1][3] + 1], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = heap[k - i + 1]\n\t\tend\n\t\theapify(heap, 1, k - i)\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize a heap\n\theap = Heap(n1*n2)\n\t\n\t# push all pairs into the heap\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t\n\t# pop k smallest pairs\n\tres = []\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tm = length(nums1)\n\tn = length(nums2)\n\tif m == 0 || n == 0\n\t\treturn []\n\tend\n\tif k > m*n\n\t\tk = m*n\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i < m && j < n\n\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\tend\n\t\tif i == 1 && j < n\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# build the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in floor(Int64, k / 2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\tif heap[1][3] == n2\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[1], heap[1][2], 1]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize a heap to store the pairs\n\theap = BinaryHeap()\n\t# Initialize a set to store the pairs\n\tpairs = Set()\n\t# Initialize a vector to store the k smallest pairs\n\tk_smallest_pairs = Vector{Vector{Int64}}()\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t# Initialize a variable to store the number of pairs\n\tnum_pairs = 0\n\t",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\t# Get the current pair\n\t\tpair = heap[1]\n\t\t\n\t\t# Add the current pair to the result\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# Check if we have reached the end of the first array\n\t\tif pair[2] == n\n\t\t\t# Add the next element from the second array\n\t\t\theap[1] = [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1]\n\t\telseif pair[3] == m\n\t\t\t# Add the next element from the first array\n\t\t\theap[1] = [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]]\n\t\telse\n\t\t\t# Add the next element from the first array\n\t\t\theap[1] = [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]]\n\t\t\t\n\t\t\t# Check if the next element from the second array is smaller\n\t\t\tif nums1[pair[2]] + nums2[pair[3] + 1] < heap[1][1]\n\t\t\t\theap[1] = [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1]\n\t\t\tend\n\t\tend\n",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\t\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 2\n\t\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 3\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 10\n\t\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 10\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 3\n\t\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 2\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 1\n\t\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 1\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 0\n\t\n\t# nums1 = [1,2]\n\t# nums2 = [3]\n\t# k = 0\n\t\n\t# nums1 = []\n\t# nums2 = []\n\t# k = 0\n\t\n\t# nums1 = []\n\t# nums2 = []\n\t# k = 1\n\t\n\t# nums1 = []\n\t# nums2 = []\n\t# k = 2\n\t\n\t# nums1 = []\n\t# nums2 = []\n\t# k = 3\n\t\n\t# nums1 = [1,1,2]\n\t# nums2 = [1,2,3]\n\t# k = 4\n\t\n\t# nums1 = [1,2]\n\t",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0 && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# construct a heap\n\theap = zeros(Int64, k, 2)\n\tfor i in 1:k\n\t\theap[i, :] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1 && heap[j, 1] < heap[j \u00f7 2, 1]\n\t\t\theap[j, :], heap[j \u00f7 2, :] = heap[j \u00f7 2, :], heap[j, :]\n\t\t\tj = j \u00f7 2\n\t\tend\n\tend\n\t\n\t# pop the smallest element and push the next element\n\tresult = zeros(Int64, k, 2)\n\tfor i in 1:k\n\t\tresult[i, :] = heap[1, 2:3]\n\t\tif heap[1, 2] == n1\n\t\t\theap[1, 1] = Inf\n\t\telse\n\t\t\theap[1, 1] = heap[1, 1] - nums2[heap[1, 3]] + nums2[heap[1, 3]] + nums1[heap[1, 2] + 1]\n\t\t\theap[1, 2] += 1\n\t\tend\n\t\t\n\t\tj = 1\n\t\twhile 2 * j <= k\n\t\t\tif 2 * j + 1 <= k\n\t\t\t\tif heap[2 * j, 1] < heap[2 * j + 1, 1]\n\t\t\t\t\tif heap[2 * j, 1] < heap[j, 1]\n\t\t\t\t\t\theap[j, :], heap[2 * j, :] = heap[2 * j, :], heap[j, :]\n\t\t\t\t\t\tj = 2 * j\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1])\n\tres = []\n\tfor i in 1:k\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Initialize the priority queue\n\tpq = PriorityQueue()\n\t\n\t# Push the first pair into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Iterate k times\n\tfor i = 1:k\n\t\t\n\t\t# If the priority queue is empty, return the result\n\t\tif isempty(pq)\n\t\t\treturn result\n\t\tend\n\t\t\n\t\t# Pop the top pair from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t\n\t\t# Push the pair into the result vector\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# If the first element of the pair is the last element of the first array, push the next pair into the priority queue\n\t\tif i == length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t# If the second element of the pair is the last element of the second array, push the next pair into the priority queue\n\t\telseif j == length(nums2)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t# If the first element of the pair is smaller than the second element of the pair, push the next pair into the priority queue\n\t\telseif nums1[i] < nums2[j]\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t# If the second element of the pair is smaller than the first element of the pair, push the next pair into the priority queue\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\t# Return the result vector\n\treturn",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# build the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\tbuild_heap!(heap)\n\t\n\t# extract the minimum element\n\tfor i in k + 1:n1 * n2\n\t\tif i <= n1\n\t\t\theap[1] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[1] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\t\theapify!(heap, 1)\n\tend\n\t\n\t# extract the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[heap[k - i + 1][2]], nums2[heap[k - i + 1][3]]]\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t# nums1 = [1, 7, 11]\n\t# nums2 = [2, 4, 6]\n\t# k = 3\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 2\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 1, 2]\n\t# nums2 = [1, 2, 3]\n\t# k = 10\n\t# nums1 = [1, 2]\n\t# nums2 = [3]\n\t# k = 3\n",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue(k)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif pq.size() < k\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j], nums1[i], nums2[j]))\n\t\t\telse\n\t\t\t\tif pq.top()[1] > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(pq)\n\t\t\t\t\tpush!(pq, (nums1[i] + nums2[j], nums1[i], nums2[j]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = Vector{Int64}(undef, 2)\n\t\tres[i][1] = pq.top()[2]\n\t\tres[i][2] = pq.top()[3]\n\t\tpop!(pq)\n\tend\n\treturn res\nend",
    "\t# initialize heap\n\theap = PriorityQueue()\n\t# initialize result\n\tresult = Vector{Vector{Int64}}()\n\t# initialize a set to store visited pairs\n\tvisited = Set{Vector{Int64}}()\n\t# push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], [nums1[1], nums2[1]]))\n\t# push the first pair into the set\n\tpush!(visited, [nums1[1], nums2[1]])\n\t# loop until the heap is empty or we have k pairs\n\twhile !isempty(heap) && length(result) < k\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t# push the pair into the result\n\t\tpush!(result, pair[2])\n\t\t# get the last element from the first array\n\t\tlast_first = pair[2][1]\n\t\t# get the last element from the second array\n\t\tlast_second = pair[2][2]\n\t\t# if the last element from the first array is not the last element in the array\n\t\tif last_first != nums1[end]\n\t\t\t# get the next element from the first array\n\t\t\tnext_first = nums1[findall(nums1 .== last_first)[1] + 1]\n\t\t\t# create a new pair\n\t\t\tnew_pair = [next_first, last_second]\n\t\t\t# if the new pair is not in the set\n\t\t\tif !(new_pair in visited)\n\t\t\t\t# push the new pair into the heap\n\t\t\t\tpush!(heap, (next_first + last_second, new_pair))\n\t\t\t\t# push the new pair into the set\n\t\t\t\tpush!(visited, new_pair)\n\t\t\tend\n\t\tend\n\t\t# if the last element from the second array is not the last element in the array\n\t\tif last_second != nums2[end]\n\t\t\t# get the next element from the second array\n\t\t\tnext_",
    "\t# initialize the heap\n\theap = PriorityQueue()\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\tpair = pop!(heap)\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the smallest pair and push the next pair\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= length(heap)\n\t\t\tres[i] = heap[1]\n\t\t\tif heap[1][3] < n2\n\t\t\t\theap[1][2] = nums2[heap[1][3] + 1]\n\t\t\t\theap[1][3] += 1\n\t\t\telse\n\t\t\t\theap[1] = heap[end]\n\t\t\t\tpop!(heap)\n\t\t\tend\n\t\t\theapify(heap, 1, length(heap))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t# Initialize the heap\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Iterate k times\n\tfor i in 1:k\n\t\t# If the heap is empty, return the result\n\t\tif isempty(heap)\n\t\t\treturn result\n\t\tend\n\t\t\n\t\t# Pop the top element from the heap\n\t\ttop = pop!(heap)\n\t\t\n\t\t# Add the top element to the result\n\t\tpush!(result, [nums1[top[2]], nums2[top[3]]])\n\t\t\n\t\t# Push the next pair to the heap\n\t\tif top[3] < length(nums2)\n\t\t\tpush!(heap, [nums1[top[2]] + nums2[top[3] + 1], top[2], top[3] + 1])\n\t\tend\n\t\t\n\t\t# Push the next pair to the heap\n\t\tif top[2] < length(nums1) && top[3] == 1\n\t\t\tpush!(heap, [nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]])\n\t\tend\n\tend\n\t\n\t# Return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([(1, 1)])\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\tfor i in k+1:n2\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\t\theap = siftdown(heap, i)\n\tend\n\tfor i in 2:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < heap[1][1]\n\t\t\t\theap[1] = [nums1[i] + nums2[j], i, j]\n\t\t\t\theap = siftdown(heap, 1)\n\t\t\tend\n\t\tend\n\tend\n\treturn heap\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first pair\n\theap = [nums1[1] + nums2[1]]\n\t\n\t# Initialize the index of the first pair\n\tindex = [1, 1]\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Loop until the heap is empty or the result has k elements\n\twhile length(heap) > 0 && length(result) < k\n\t\t# Get the smallest pair\n\t\tsmallest = pop!(heap)\n\t\t\n\t\t# Add the smallest pair to the result\n\t\tpush!(result, [nums1[index[1]], nums2[index[2]]])\n\t\t\n\t\t# If the index of the first element is less than the length of nums1, add the next pair\n\t\tif index[1] < length(nums1)\n\t\t\tpush!(heap, nums1[index[1] + 1] + nums2[index[2]])\n\t\tend\n\t\t\n\t\t# If the index of the second element is less than the length of nums2, add the next pair\n\t\tif index[2] < length(nums2)\n\t\t\tpush!(heap, nums1[index[1]] + nums2[index[2] + 1])\n\t\tend\n\t\t\n\t\t# Update the index\n\t\tif index[1] < length(nums1) && nums1[index[1] + 1] + nums2[index[2]] < nums1[index[1]] + nums2[index[2] + 1]\n\t\t\tindex[1] += 1\n\t\telse\n\t\t\tindex[2] += 1\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\ttup = pop!(pq)\n\t\tpush!(res, [nums1[tup[2]], nums2[tup[3]]])\n\t\tif tup[2] == n1\n\t\t\tpush!(pq, (nums1[tup[2]] + nums2[tup[3] + 1], tup[2], tup[3] + 1))\n\t\telseif tup[3] == n2\n\t\t\tpush!(pq, (nums1[tup[2] + 1] + nums2[tup[3]], tup[2] + 1, tup[3]))\n\t\telse\n\t\t\tpush!(pq, (nums1[tup[2] + 1] + nums2[tup[3]], tup[2] + 1, tup[3]))\n\t\t\tpush!(pq, (nums1[tup[2]] + nums2[tup[3] + 1], tup[2], tup[3] + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\t# sort the two arrays\n\tsort!(nums1)\n\tsort!(nums2)\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# initialize the index\n\tindex = Vector{Int64}(undef, length(nums1))\n\t# initialize the heap\n\theap = BinaryHeap{Tuple{Int64, Int64}}()\n\t# push the first element of each array into the heap\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t# pop the k smallest pairs\n\tfor i in 1:k\n\t\t# pop the smallest pair\n\t\tpair, index[1], index[2] = pop!(heap)\n\t\t# push the next pair into the heap\n\t\tif index[2] < length(nums2)\n\t\t\tpush!(heap, (nums1[index[1]] + nums2[index[2] + 1], index[1], index[2] + 1))\n\t\tend\n\t\t# store the pair into the result\n\t\tresult[i] = [nums1[index[1]], nums2[index[2]]]\n\tend\n\t# return the result\n\treturn result\nend",
    "\t# initialize a heap\n\theap = Heap(Tuple{Int64, Int64, Int64})\n\t# initialize a set to store the indices of nums2\n\tindices = Set(Int64)\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t# push the first element of nums1 into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# push the first element of nums2 into the set\n\tpush!(indices, 1)\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the smallest element from the heap\n\t\t(sum, index1, index2) = pop!(heap)\n\t\t# push the indices into the result\n\t\tpush!(result, [nums1[index1], nums2[index2]])\n\t\t# if the index1 is not the last element of nums1\n\t\tif index1 < length(nums1)\n\t\t\t# push the next element of nums1 into the heap\n\t\t\tpush!(heap, (nums1[index1 + 1] + nums2[index2], index1 + 1, index2))\n\t\tend\n\t\t# if the index2 is not the last element of nums2\n\t\tif index2 < length(nums2) && !(index2 + 1 in indices)\n\t\t\t# push the next element of nums2 into the heap\n\t\t\tpush!(heap, (nums1[index1] + nums2[index2 + 1], index1, index2 + 1))\n\t\t\t# push the next element of nums2 into the set\n\t\t\tpush!(indices, index2 + 1)\n\t\tend\n\tend\n\t# return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\ttop = pop!(pq)\n\t\ti = top[2]\n\t\tj = top[3]\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif i == 1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, x, y) = pop!(pq)\n\t\tres[i] = [nums1[x], nums2[y]]\n\t\tif x < n1 && y < n2\n\t\t\tpush!(pq, (nums1[x+1] + nums2[y], x+1, y))\n\t\tend\n\t\tif x < n1 && y < n2\n\t\t\tpush!(pq, (nums1[x] + nums2[y+1], x, y+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# Fill the heap with the first k elements\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# Build the heap\n\tfor i in (k/2):-1:1\n\t\theap = heap_down(heap, i, k)\n\tend\n\t\n\t# Find the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\tif heap[1][3] == n2\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[n2], heap[1][2], n2]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\tend\n\t\theap = heap_down(heap, 1, k)\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\tres = []\n\tfor i in 1:k\n\t\tval, x, y = pop!(pq)\n\t\tpush!(res, [nums1[x], nums2[y]])\n\t\tif x+1 <= n1 && !(x+1, y) in visited\n\t\t\tpush!(pq, (nums1[x+1]+nums2[y], x+1, y))\n\t\t\tpush!(visited, (x+1, y))\n\t\tend\n\t\tif y+1 <= n2 && !(x, y+1) in visited\n\t\t\tpush!(pq, (nums1[x]+nums2[y+1], x, y+1))\n\t\t\tpush!(visited, (x, y+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\t# Output: [[1,2],[1,4],[1,6]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11],[11,11]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11],[11,11],[1,11]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11],[11,11],[1,11],[11,1]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11],[11,11],[1,11],[11,1],[1,7]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11],[11,11],[1,11],[11,1],[1,7],[7,1]]\n\t# Output: [[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6],[7,11],[11,11],[1,11],[11,1],[1,7],[7,1],[1,1]]\n\t# Output: [[1,2],[1,",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\twhile length(result) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i == length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == length(nums2)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element from nums1 and nums2\n\theap = [([nums1[1], nums2[1]], 1, 1)]\n\t\n\t# Initialize the result vector\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the counter\n\tcount = 0\n\t\n\twhile count < k && !isempty(heap)\n\t\t# Get the smallest pair from the heap\n\t\t(pair, i, j) = popfirst!(heap)\n\t\t\n\t\t# Add the pair to the result vector\n\t\tcount += 1\n\t\tres[count] = pair\n\t\t\n\t\t# Add the next pair from the first array\n\t\tif i < n1\n\t\t\tpush!(heap, ([nums1[i + 1], nums2[j]], i + 1, j))\n\t\tend\n\t\t\n\t\t# Add the next pair from the second array\n\t\tif i == 1 && j < n2\n\t\t\tpush!(heap, ([nums1[i], nums2[j + 1]], i, j + 1))\n\t\tend\n\tend\n\t\n\t# Return the result vector\n\treturn res\nend",
    "\t# sort the two arrays\n\tsort!(nums1)\n\tsort!(nums2)\n\t\n\t# create a heap to store the pairs\n\theap = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\t\n\t# push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# pop the pairs from the heap\n\twhile k > 0 && !isempty(heap)\n\t\t# pop the pair with the smallest sum\n\t\tsum, i, j = pop!(heap)\n\t\t# push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# push the next pair into the heap\n\t\tif i + 1 <= length(nums1) && !(i + 1, j) in visited\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\tif j + 1 <= length(nums2) && !(i, j + 1) in visited\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\tfor i in k+1:n2\n\t\tif nums1[1] + nums2[i] < heap[1][1]\n\t\t\theap[1] = [nums1[1] + nums2[i], 1, i]\n\t\tend\n\tend\n\tbuild_min_heap(heap)\n\tfor i in 2:n1\n\t\tfor j in 1:k\n\t\t\tif heap[j][2] < i\n\t\t\t\theap[j] = [nums1[i] + nums2[heap[j][3]], i, heap[j][3]]\n\t\t\telseif heap[j][2] == i\n\t\t\t\theap[j] = [nums1[i] + nums2[heap[j][3]+1], i, heap[j][3]+1]\n\t\t\tend\n\t\tend\n\t\tbuild_min_heap(heap)\n\tend\n\treturn heap\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0 || k == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue(k)\n\tfor i in 1:n\n\t\tfor j in 1:m\n\t\t\tif pq.size < k\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\telse\n\t\t\t\tif pq.top[1] > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(pq)\n\t\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tres = []\n\twhile !isempty(pq)\n\t\titem = pop!(pq)\n\t\tpush!(res, [nums1[item[2]], nums2[item[3]]])\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 0, 0]\n\t\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the count\n\tcount = 0\n\t\n\t# Loop until the heap is empty\n\twhile count < k && length(heap) > 0\n\t\t# Pop the top element from the heap\n\t\ttop = pop!(heap)\n\t\t\n\t\t# Push the element to the result vector\n\t\tcount += 1\n\t\tresult[count] = [nums1[top[2] + 1], nums2[top[3] + 1]]\n\t\t\n\t\t# Push the next element from nums1 to the heap\n\t\tif top[2] + 1 < n\n\t\t\tpush!(heap, [nums1[top[2] + 2] + nums2[top[3] + 1], top[2] + 1, top[3]])\n\t\tend\n\t\t\n\t\t# Push the next element from nums2 to the heap\n\t\tif top[2] == 0 && top[3] + 1 < m\n\t\t\tpush!(heap, [nums1[top[2] + 1] + nums2[top[3] + 2], top[2], top[3] + 1])\n\t\tend\n\tend\n\t\n\t# Return the result vector\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\theap[i] = [nums1[i], nums2[i], 1]\n\tend\n\tbuild_heap!(heap)\n\t\n\t# push the rest of the elements\n\tfor i = k + 1:n1\n\t\tfor j = 1:n2\n\t\t\tif nums1[i] + nums2[j] < heap[1][1] + heap[1][2]\n\t\t\t\theap[1] = [nums1[i], nums2[j], 1]\n\t\t\t\theapify!(heap, 1)\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# return the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = heap[i][1:2]\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif length(result) < k\n\t\t\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\telse\n\t\t\t\tif nums1[i] + nums2[j] < result[k][1] + result[k][2]\n\t\t\t\t\tresult[k] = [nums1[i], nums2[j]]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Dict()\n\tvisited[(1, 1)] = true\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0 && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i < n1 && !haskey(visited, (i + 1, j))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited[(i + 1, j)] = true\n\t\tend\n\t\tif j < n2 && !haskey(visited, (i, j + 1))\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited[(i, j + 1)] = true\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tval, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i = k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\tif heap[1][2] == n1\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\theapify(heap, 1, length(heap))\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i], nums2[1], 1]\n\tend\n\t\n\t# Build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the smallest element\n\tfor i in k+1:n*m\n\t\tif heap[1][1] + heap[1][2] > nums1[(i-1) % n + 1] + nums2[(i-1) // n + 1]\n\t\t\theap[1] = [nums1[(i-1) % n + 1], nums2[(i-1) // n + 1], (i-1) // n + 1]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile k > 0\n\t\tt = pop!(pq)\n\t\tpush!(res, [nums1[t[2]], nums2[t[3]]])\n\t\tif t[3] < n2\n\t\t\tpush!(pq, (nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1))\n\t\tend\n\t\tif t[3] == 1 && t[2] < n1\n\t\t\tpush!(pq, (nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3]))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# initialize the result\n\tres = Vector{Vector{Int64}}()\n\t\n\t# iterate k times\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\tpush!(res, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# the next pair with the same first element\n\t\tif pair[3] < n2\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\tend\n\t\t\n\t\t# the next pair with the same second element\n\t\tif pair[3] == 1 && pair[2] < n1\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in 2:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] < heap[j \u00f7 2][1]\n\t\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\t\tj = j \u00f7 2\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# extract the heap\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [heap[1][2], heap[1][3]]\n\t\tif heap[1][2] == n1\n\t\t\theap[1] = heap[k - i + 1]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\tj = 1\n\t\twhile 2j <= k - i\n\t\t\tif 2j + 1 <= k - i && heap[2j + 1][1] < heap[2j][1]\n\t\t\t\tif heap[2j + 1][1] < heap[j][1]\n\t\t\t\t\theap[j], heap[2j + 1] = heap[2j + 1], heap[j]\n\t\t\t\t\tj = 2j + 1\n\t\t\t\telse\n\t\t\t\t\t",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i < n1 && visited_add!(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif j < n2 && visited_add!(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Tuple{Int64, Int64, Int64}}()\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop k times\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the smallest pair\n\t\tpair = pop!(heap)\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# push the next pair\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# build the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in 1:(k-1)\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# extract the k smallest pairs\n\tfor i in (k+1):(n1*n2)\n\t\tif i <= n1\n\t\t\theap[1] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn heap\nend",
    "\t# Initialize a heap to store the pairs\n\theap = BinaryHeap()\n\t# Initialize a set to store the pairs\n\tpairs = Set()\n\t# Initialize a vector to store the results\n\tresults = Vector{Vector{Int64}}()\n\t# Initialize the index of the first array\n\ti = 1\n\t# Initialize the index of the second array\n\tj = 1\n\t# Initialize the number of pairs\n\tcount = 0\n\t# Loop through the first array\n\twhile i <= length(nums1)\n\t\t# Loop through the second array\n\t\twhile j <= length(nums2)\n\t\t\t# Check if the pair is already in the set\n\t\t\tif (nums1[i], nums2[j]) in pairs\n\t\t\t\t# If it is, skip it\n\t\t\t\tj += 1\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\t# Push the pair into the heap\n\t\t\tpush!(heap, (nums1[i] + nums2[j], (nums1[i], nums2[j])))\n\t\t\t# Push the pair into the set\n\t\t\tpush!(pairs, (nums1[i], nums2[j]))\n\t\t\t# Increment the index of the second array\n\t\t\tj += 1\n\t\tend\n\t\t# Increment the index of the first array\n\t\ti += 1\n\tend\n\t# Loop through the heap\n\twhile count < k && !isempty(heap)\n\t\t# Pop the pair with the smallest sum\n\t\tpair = pop!(heap)\n\t\t# Push the pair into the results\n\t\tpush!(results, pair[2])\n\t\t# Increment the number of pairs\n\t\tcount += 1\n\tend\n\t# Return the results\n\treturn results\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k && length(heap) > 0\n\t\tpop!(heap)\n\t\tpush!(res, [nums1[heap[2]], nums2[heap[3]]])\n\t\tif heap[2] < n1\n\t\t\tpush!(heap, [nums1[heap[2] + 1] + nums2[heap[3]], heap[2] + 1, heap[3]])\n\t\tend\n\t\tif heap[2] == 1 && heap[3] < n2\n\t\t\tpush!(heap, [nums1[heap[2]] + nums2[heap[3] + 1], heap[2], heap[3] + 1])\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# create a matrix of size n x m\n\tmatrix = zeros(Int64, n, m)\n\t\n\t# fill the matrix with the sum of the elements\n\tfor i = 1:n\n\t\tfor j = 1:m\n\t\t\tmatrix[i, j] = nums1[i] + nums2[j]\n\t\tend\n\tend\n\t\n\t# sort the matrix\n\tsorted_matrix = sort(matrix, dims = 1)\n\t\n\t# get the k smallest pairs\n\tk_smallest_pairs = []\n\tfor i = 1:k\n\t\tfor j = 1:m\n\t\t\tif sorted_matrix[i, j] != 0\n\t\t\t\tpush!(k_smallest_pairs, [sorted_matrix[i, j], i, j])\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# sort the pairs\n\tsort!(k_smallest_pairs, by = x -> x[1])\n\t\n\t# get the pairs\n\tpairs = []\n\tfor i = 1:length(k_smallest_pairs)\n\t\tpush!(pairs, [nums1[k_smallest_pairs[i][2]], nums2[k_smallest_pairs[i][3]]])\n\tend\n\t\n\treturn pairs\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i == length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == length(nums2)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = PriorityQueue(Tuple{Int64, Int64, Int64})\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\t# Get the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t\n\t\t# Add the pair to the result\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# Add the next pair to the heap\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i+1 <= n1 && !visited_has(visited, i+1, j)\n\t\t\tvisited_add(visited, i+1, j)\n\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\tend\n\t\tif j+1 <= n2 && !visited_has(visited, i, j+1)\n\t\t\tvisited_add(visited, i, j+1)\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile !isempty(pq) && length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\tif j < m && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0 && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile !isempty(pq) && k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i == 1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t\n\t# push the first element of nums1 and nums2 into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# loop until the priority queue is empty or the result size is equal to k\n\twhile !isempty(pq) && length(result) < k\n\t\t# pop the top element from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t\n\t\t# push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# if the next element in nums1 is not out of bound and not visited, push it into the priority queue\n\t\tif i + 1 <= length(nums1) && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\t# if the next element in nums2 is not out of bound and not visited, push it into the priority queue\n\t\tif j + 1 <= length(nums2) && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t# push the first element of each array into the queue\n\tfor i in 1:n\n\t\tpush!(pq, (nums1[i]+nums2[1], i, 1))\n\tend\n\t\n\t# pop k elements from the queue\n\tres = []\n\tfor i in 1:k\n\t\t# pop the smallest element from the queue\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t# push the next element of the same array into the queue\n\t\tif j < m\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\theap = Heap(n1 * n2)\n\tfor i = 1:n1\n\t\tfor j = 1:n2\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\tres = []\n\tfor i = 1:k\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tif k > n * m\n\t\tk = n * m\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\tend\n\t\n\t# build the heap\n\tfor i in floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# extract the top k elements\n\tfor i in k+1:n*m\n\t\tif nums1[floor(Int64, (i-1)/m) + 1] + nums2[(i-1) % m + 1] < heap[1][1]\n\t\t\theap[1] = [nums1[floor(Int64, (i-1)/m) + 1] + nums2[(i-1) % m + 1], floor(Int64, (i-1)/m) + 1, (i-1) % m + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# return the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[heap[i][2]], nums2[heap[i][3]]]\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# create a heap\n\theap = BinaryHeap()\n\t\n\t# add the first element of each array to the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the indices of the elements that have been added to the heap\n\tindices = Set([(1, 1)])\n\t\n\t# create a vector to store the k smallest pairs\n\tk_smallest_pairs = Vector{Vector{Int64}}()\n\t\n\t# loop until the heap is empty or the number of pairs is equal to k\n\twhile !isempty(heap) && length(k_smallest_pairs) < k\n\t\t# get the smallest pair\n\t\t(sum, i, j) = pop!(heap)\n\t\t\n\t\t# add the pair to the vector\n\t\tpush!(k_smallest_pairs, [nums1[i], nums2[j]])\n\t\t\n\t\t# add the next pair with the same first element to the heap\n\t\tif j < length(nums2) && !(i, j + 1) in indices\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(indices, (i, j + 1))\n\t\tend\n\t\t\n\t\t# add the next pair with the same second element to the heap\n\t\tif i < length(nums1) && !(i + 1, j) in indices\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(indices, (i + 1, j))\n\t\tend\n\tend\n\t\n\treturn k_smallest_pairs\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tpq = PriorityQueue()\n\t\n\tfor i in 1:length(nums1)\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\tres = []\n\t\n\tfor i in 1:k\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([(1, 1)])\n\tres = []\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && (i + 1, j) \u2209 visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j < n2 && (i, j + 1) \u2209 visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tfunction heap_push!(heap::Vector{Vector{Int64}}, x::Vector{Int64})\n\t\tpush!(heap, x)\n\t\ti = length(heap)\n\t\twhile i > 1\n\t\t\tif heap[i][1] + heap[i][2] < heap[i \u00f7 2][1] + heap[i \u00f7 2][2]\n\t\t\t\theap[i], heap[i \u00f7 2] = heap[i \u00f7 2], heap[i]\n\t\t\t\ti = i \u00f7 2\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\tfunction heap_pop!(heap::Vector{Vector{Int64}})\n\t\tn = length(heap)\n\t\theap[1], heap[n] = heap[n], heap[1]\n\t\tpop!(heap)\n\t\tn -= 1\n\t\ti = 1\n\t\twhile 2 * i <= n\n\t\t\tj = 2 * i\n\t\t\tif j < n && heap[j + 1][1] + heap[j + 1][2] < heap[j][1] + heap[j][2]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tif heap[i][1] + heap[i][2] > heap[j][1] + heap[j][2]\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:min(k, n1)\n\t\theap_push!(heap, [nums1[i], nums2[1], 1])\n\t",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile !isempty(pq) && length(res) < k\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i == 1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# \u521d\u59cb\u5316\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# \u521d\u59cb\u5316\u7ed3\u679c\n\tres = Vector{Vector{Int64}}()\n\t\n\t# \u521d\u59cb\u5316\u8bbf\u95ee\u6570\u7ec4\n\tvisited = Array{Bool}(n1, n2)\n\tvisited[1, 1] = true\n\t\n\t# \u5f00\u59cb\u904d\u5386\n\twhile !isempty(pq) && k > 0\n\t\t# \u53d6\u51fa\u6700\u5c0f\u7684\u5143\u7d20\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\t\n\t\t# \u5c06\u4e0b\u4e00\u4e2a\u5143\u7d20\u52a0\u5165pq\n\t\tif i + 1 <= n1 && !visited[i + 1, j]\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited[i + 1, j] = true\n\t\tend\n\t\tif j + 1 <= n2 && !visited[i, j + 1]\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited[i, j + 1] = true\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) * length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tresult[i] = [nums1[1], nums2[1]]\n\tend\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif nums1[i] + nums2[j] < result[k][1] + result[k][2]\n\t\t\t\tresult[k] = [nums1[i], nums2[j]]\n\t\t\t\t\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif result[l][1] + result[l][2] > result[l+1][1] + result[l+1][2]\n\t\t\t\t\t\tresult[l], result[l+1] = result[l+1], result[l]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile k > 0 && !isempty(pq)\n\t\tpair = pop!(pq)\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\tif pair[2] + 1 <= n && !(pair[2] + 1, pair[3]) in visited\n\t\t\tpush!(pq, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\tpush!(visited, (pair[2] + 1, pair[3]))\n\t\tend\n\t\t\n\t\tif pair[3] + 1 <= m && !(pair[2], pair[3] + 1) in visited\n\t\t\tpush!(pq, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\tpush!(visited, (pair[2], pair[3] + 1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile length(res) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t# Create a heap to store the pairs\n\theap = BinaryHeap()\n\t# Create a set to store the pairs\n\tpairs = Set()\n\t# Create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# Push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# Push the first pair into the set\n\tpush!(pairs, (1, 1))\n\t# While the heap is not empty and the result size is less than k\n\twhile !isempty(heap) && length(result) < k\n\t\t# Pop the pair with the smallest sum\n\t\t(sum, i, j) = pop!(heap)\n\t\t# Push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# If the first element of the pair is not the last element of the first array\n\t\tif i < length(nums1)\n\t\t\t# Push the pair with the first element of the pair being the next element of the first array\n\t\t\t# and the second element of the pair being the same as the second element of the pair\n\t\t\t# into the heap if the pair is not in the set\n\t\t\tif !haskey(pairs, (i + 1, j))\n\t\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\t\tpush!(pairs, (i + 1, j))\n\t\t\tend\n\t\tend\n\t\t# If the second element of the pair is not the last element of the second array\n\t\tif j < length(nums2)\n\t\t\t# Push the pair with the first element of the pair being the same as the first element of the pair\n\t\t\t# and the second element of the pair being the next element of the second array\n\t\t\t# into the heap if the pair is not in the set\n\t\t\tif !haskey(pairs, (i, j + 1))\n\t\t\t\tpush!(heap, (nums1[i",
    "\tif nums1 == [] || nums2 == []\n\t\treturn []\n\tend\n\tn = length(nums1)\n\tm = length(nums2)\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = zeros(Int64, n, m)\n\tvisited[1, 1] = 1\n\tres = []\n\twhile length(res) < k\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n && visited[i + 1, j] == 0\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited[i + 1, j] = 1\n\t\tend\n\t\tif j + 1 <= m && visited[i, j + 1] == 0\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited[i, j + 1] = 1\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\tpq = PriorityQueue()\n\tfor i in 1:n\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\tres = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tsum, x, y = pop!(pq)\n\t\tpush!(res, [nums1[x], nums2[y]])\n\t\tif y < m\n\t\t\tpush!(pq, (nums1[x] + nums2[y+1], x, y+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue(max)\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1, 1])\n\tres = []\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j < n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile !isempty(pq) && k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i == n1\n\t\t\tcontinue\n\t\tend\n\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[1], nums2[1]]\n\tend\n\t\n\tif k == 1\n\t\treturn result\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i], nums2[1]]\n\tend\n\t\n\t# Build the heap\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] + heap[j][2] < heap[j \u00f7 2][1] + heap[j \u00f7 2][2]\n\t\t\t\ttmp = heap[j]\n\t\t\t\theap[j] = heap[j \u00f7 2]\n\t\t\t\theap[j \u00f7 2] = tmp\n\t\t\t\tj = j \u00f7 2\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# Pop the heap\n\tfor i in k+1:n1*n2\n\t\tif nums1[(i-1) \u00f7 n2 + 1] + nums2[(i-1) % n2 + 1] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[(i-1) \u00f7 n2 + 1], nums2[(i-1) % n2 + 1]]\n\t\t\tj = 1\n\t\t\twhile j < k\n\t\t\t\tif j*2 + 1 <= k\n\t\t\t\t\tif heap[j*2][1] + heap[j*2][2] < heap[j*2+1][",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\theap = PriorityQueue()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\t\n\twhile length(result) < k && !isempty(heap)\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\t\n\t\tif j == 1 && i < length(nums1)\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Heap()\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Pop k elements from the heap\n\tresult = []\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the top element from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Push the next element from the second array\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Heap()\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Pop the smallest k pairs\n\tresult = []\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t# heap stores the indices of the pairs\n\theap = Vector{Vector{Int64}}(undef, k)\n\t# heap_size is the number of pairs in the heap\n\theap_size = 0\n\t# the first pair is (0, 0)\n\tpush!(heap, [0, 0])\n\theap_size += 1\n\t# the result\n\tres = Vector{Vector{Int64}}(undef, k)\n\t# the number of pairs in the result\n\tres_size = 0\n\twhile res_size < k\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\tres_size += 1\n\t\tres[res_size] = [nums1[pair[1]+1], nums2[pair[2]+1]]\n\t\t# push the next pair in the same row\n\t\tif pair[2] < n2-1\n\t\t\tpush!(heap, [pair[1], pair[2]+1])\n\t\t\theap_size += 1\n\t\tend\n\t\t# push the next pair in the same column\n\t\tif pair[1] < n1-1 && pair[2] == 0\n\t\t\tpush!(heap, [pair[1]+1, pair[2]])\n\t\t\theap_size += 1\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t# create a heap to store the pairs\n\theap = BinaryHeap{Tuple{Int64, Int64, Int64}}()\n\t# push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the pairs that have been pushed into the heap\n\tset = Set{Tuple{Int64, Int64}}()\n\tpush!(set, (1, 1))\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# if the heap is empty, return the result\n\t\tif isempty(heap)\n\t\t\treturn result\n\t\tend\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t# push the pair into the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t# if the first element of the pair is not the last element of the first array\n\t\tif pair[2] < length(nums1)\n\t\t\t# push the pair that the first element of the pair is the next element of the first array and the second element of the pair is the same as the second element of the pair into the heap\n\t\t\tif !in(set, (pair[2] + 1, pair[3]))\n\t\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\t\tpush!(set, (pair[2] + 1, pair[3]))\n\t\t\tend\n\t\tend\n\t\t# if the second element of the pair is not the last element of the second array\n\t\tif pair[3] < length(nums2)\n\t\t\t# push the pair that the first element of the pair is the same as the first element of the pair and",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, 1, 1)\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i + 1 <= length(nums1) && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add!(visited, i + 1, j)\n\t\tend\n\t\t\n\t\tif j + 1 <= length(nums2) && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add!(visited, i, j + 1)\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i], nums2[1], 1]\n\t\tend\n\tend\n\t\n\t# build heap\n\tfor i in floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# get k smallest pairs\n\tfor i in k+1:n1*n2\n\t\tif heap[1][1] + heap[1][2] > nums1[heap[1][3]] + nums2[heap[1][4]]\n\t\t\theap[1] = [nums1[heap[1][3]], nums2[heap[1][4]], heap[1][3], heap[1][4]]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\t\tif heap[1][4] < n2\n\t\t\theap[1][2] = nums2[heap[1][4]+1]\n\t\t\theap[1][4] += 1\n\t\telseif heap[1][3] < n1\n\t\t\theap[1][1] = nums1[heap[1][3]+1]\n\t\t\theap[1][2] = nums2[1]\n\t\t\theap[1][3] += 1\n\t\t\theap[1][4] = 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn heap\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tsum = nums1[i] + nums2[j]\n\t\t\tif sum < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif pairs[l][1] + pairs[l][2] > pairs[l+1][1] + pairs[l+1][2]\n\t\t\t\t\t\tpairs[l], pairs[l+1] = pairs[l+1], pairs[l]\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Initialize the visited matrix\n\tvisited = zeros(Int64, length(nums1), length(nums2))\n\tvisited[1, 1] = 1\n\t\n\t# Loop until the heap is empty\n\twhile length(heap) > 0 && length(result) < k\n\t\t# Pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t\n\t\t# Push the pair to the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# Push the next pair to the heap\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2) && visited[pair[2] + 1, pair[3]] == 0\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\t\tvisited[pair[2] + 1, pair[3]] = 1\n\t\tend\n\t\t\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2) && visited[pair[2], pair[3] + 1] == 0\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\t\tvisited[pair[2], pair[3] + 1] = 1\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsum, x, y = pop!(pq)\n\t\tpush!(res, [nums1[x], nums2[y]])\n\t\t\n\t\tif y == m\n\t\t\tcontinue\n\t\tend\n\t\t\n\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\n\t\tif y == 1\n\t\t\tcontinue\n\t\tend\n\t\t\n\t\tpush!(pq, (nums1[x] + nums2[y - 1], x, y - 1))\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tif k > n * m\n\t\tk = n * m\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\t\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\ttop = pop!(pq)\n\t\t\n\t\ti = top[2]\n\t\tj = top[3]\n\t\t\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n && j + 1 <= m\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\t\n\t\tif i + 1 <= n && j < m\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize a heap\n\theap = BinaryHeap()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize a set to store the visited pairs\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\t\n\t# Initialize a vector to store the result\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile length(res) < k && !isempty(heap)\n\t\t# Pop the smallest pair from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\t# Push the next smallest pairs into the heap\n\t\tif i < n1 && visited_add!(visited, i + 1, j)\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif j < n2 && visited_add!(visited, i, j + 1)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\theap = PriorityQueue(max)\n\t\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif length(heap) < k\n\t\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\t\telse\n\t\t\t\tif heap[1][1] > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(heap)\n\t\t\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\tres = []\n\twhile !isempty(heap)\n\t\tpop!(heap)\n\t\tpush!(res, [nums1[heap[1][2]], nums2[heap[1][3]]])\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] + nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([(1, 1)])\n\tresult = Vector{Vector{Int64}}()\n\t\n\tfor i in 1:k\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < length(nums1) && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t\n\t\tif j < length(nums2) && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\tend\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap with the first element of nums1\n\theap = [nums1[1] + nums2[i] for i in 1:length(nums2)]\n\theap_push!(heap, nums1[1] + nums2[1])\n\t\n\t# initialize the result\n\tresult = []\n\t\n\t# iterate through the first array\n\tfor i in 2:length(nums1)\n\t\t# iterate through the second array\n\t\tfor j in 1:length(nums2)\n\t\t\t# push the sum of the current element of the first array and the current element of the second array\n\t\t\theap_push!(heap, nums1[i] + nums2[j])\n\t\tend\n\tend\n\t\n\t# pop the smallest k elements from the heap\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\tpush!(result, heap_pop!(heap))\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\theap = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile length(result) < k && !isempty(heap)\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tif j == 1 && i < length(nums1)\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# create a heap\n\theap = MinHeap()\n\t\n\t# push the first element of each array into the heap\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop k elements from the heap\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the smallest element\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# push the next element of the array that the popped element belongs to\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1\n\theap = PriorityQueue(nums1[1] + nums2[1])\n\t\n\t# Initialize the first element of the heap\n\theap.push!(nums1[1], nums2[1])\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the index of the first element of nums2\n\tnums2_index = 1\n\t\n\t# Initialize the index of the result\n\tresult_index = 1\n\t\n\t# Initialize the index of the first element of nums1\n\tnums1_index = 1\n\t\n\t# Initialize the index of the first element of nums2\n\tnums2_index = 1\n\t\n\t# Loop until the heap is empty\n\twhile !isempty(heap)\n\t\t# Pop the first element of the heap\n\t\t(nums1_index, nums2_index) = heap.pop!()\n\t\t\n\t\t# Push the element to the result\n\t\tresult[result_index] = [nums1[nums1_index], nums2[nums2_index]]\n\t\t\n\t\t# Increment the index of the result\n\t\tresult_index += 1\n\t\t\n\t\t# If the index of the result is greater than k, then break\n\t\tif result_index > k\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# If the index of the first element of nums2 is less than the length of nums2, then push the next element of nums2 to the heap\n\t\tif nums2_index < length(nums2)\n\t\t\theap.push!(nums1[nums1_index], nums2[nums2_index + 1])\n\t\tend\n\t\t\n\t\t# If the index of the first element of nums1 is less than the length of nums1, then push the next element of nums1 to the heap",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# create a heap\n\theap = Heap(n1*n2)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t\n\t# pop k elements\n\tres = []\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tx = pop!(heap)\n\t\tpush!(res, [nums1[x[2]], nums2[x[3]]])\n\tend\n\t\n\treturn res\nend"
  ]
}