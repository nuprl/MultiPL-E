{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\nfunction next_smallest_palindrome(num::Int64)::Int64 \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "verbatim",
  "tests": "using Test\n\n@testset begin\n\ncandidate = next_smallest_palindrome;\n\t@test(candidate(99) == 101)\n\t@test(candidate(1221) == 1331)\n\t@test(candidate(120) == 121)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tnum_str = string(num)\n\tlen_num = length(num_str)\n\tif len_num == 1\n\t\treturn num\n\tend\n\tif len_num == 2\n\t\tif num_str[1] == num_str[2]\n\t\t\treturn num\n\t\telse\n\t\t\treturn num + 11\n\t\tend\n\tend\n\tif len_num % 2 == 0\n\t\tif num_str[1:len_num\u00f72] == reverse(num_str[len_num\u00f72+1:len_num])\n\t\t\treturn num\n\t\telse\n\t\t\treturn num + 10^(len_num\u00f72-1)\n\t\tend\n\telse\n\t\tif num_str[1:(len_num-1)\u00f72] == reverse(num_str[(len_num+3)\u00f72:len_num])\n\t\t\treturn num\n\t\telse\n\t\t\treturn num + 10^((len_num-1)\u00f72)\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\thalf_len = num_len/2\n\t\tleft_half = parse(Int64, num_str[1:half_len])\n\t\tright_half = parse(Int64, num_str[half_len+1:num_len])\n\t\tif left_half < right_half\n\t\t\treturn parse(Int64, num_str[1:half_len] * 2)\n\t\telse\n\t\t\tleft_half += 1\n\t\t\treturn parse(Int64, string(left_half) * 2)\n\t\tend\n\telse\n\t\thalf_len = (num_len-1)/2\n\t\tleft_half = parse(Int64, num_str[1:half_len])\n\t\tmiddle = parse(Int64, num_str[half_len+1])\n\t\tright_half = parse(Int64, num_str[half_len+2:num_len])\n\t\tif left_half < right_half\n\t\t\treturn parse(Int64, num_str[1:half_len] * 2 * string(middle))\n\t\telseif left_half == right_half\n\t\t\tif middle == 9\n\t\t\t\tleft_half += 1\n\t\t\t\treturn parse(Int64, string(left_half) * 2 * \"0\")\n\t\t\telse\n\t\t\t\tmiddle += 1\n\t\t\t\treturn parse(Int64, num_str[1:half_len] * 2 * string(middle))\n\t\t\tend\n\t\telse\n\t\t\tleft_half += 1\n\t\t\treturn parse(Int64, string(left_half) * 2 * string(middle))\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tlen_num = length(num_str)\n\tif len_num == 1\n\t\treturn num\n\tend\n\tif len_num % 2 == 0\n\t\tmid = len_num / 2\n\t\tleft = parse(Int64, num_str[1:mid])\n\t\tright = parse(Int64, num_str[mid+1:end])\n\t\tif left < right\n\t\t\treturn parse(Int64, num_str[1:mid] * 2)\n\t\telse\n\t\t\treturn parse(Int64, num_str[1:mid] * 2 + \"1\")\n\t\tend\n\telse\n\t\tmid = (len_num + 1) / 2\n\t\tleft = parse(Int64, num_str[1:mid-1])\n\t\tright = parse(Int64, num_str[mid+1:end])\n\t\tif left < right\n\t\t\treturn parse(Int64, num_str[1:mid-1] * 2)\n\t\telse\n\t\t\treturn parse(Int64, num_str[1:mid-1] * 2 + \"1\")\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\tleft_half = num_str[1:num_len/2]\n\t\tright_half = num_str[num_len/2+1:end]\n\t\tif left_half == right_half\n\t\t\treturn num\n\t\telse\n\t\t\tleft_half_int = parse(Int64, left_half)\n\t\t\tright_half_int = parse(Int64, right_half)\n\t\t\tif left_half_int < right_half_int\n\t\t\t\tleft_half_int += 1\n\t\t\t\tleft_half = string(left_half_int)\n\t\t\tend\n\t\t\treturn parse(Int64, left_half * 2)\n\t\tend\n\telse\n\t\tleft_half = num_str[1:num_len/2]\n\t\tright_half = num_str[num_len/2+2:end]\n\t\tif left_half == right_half\n\t\t\treturn num\n\t\telse\n\t\t\tleft_half_int = parse(Int64, left_half)\n\t\t\tright_half_int = parse(Int64, right_half)\n\t\t\tif left_half_int < right_half_int\n\t\t\t\tleft_half_int += 1\n\t\t\t\tleft_half = string(left_half_int)\n\t\t\tend\n\t\t\treturn parse(Int64, left_half * 2)\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\tmid_idx = num_len \u00f7 2\n\t\tmid_str = num_str[mid_idx:mid_idx]\n\t\tif mid_str == \"9\"\n\t\t\treturn next_smallest_palindrome(num + 2)\n\t\tend\n\t\treturn parse(Int64, num_str[1:mid_idx] * (parse(Int64, mid_str) + 1) * num_str[mid_idx:mid_idx])\n\telse\n\t\tmid_idx = (num_len + 1) \u00f7 2\n\t\tmid_str = num_str[mid_idx:mid_idx]\n\t\tif mid_str == \"9\"\n\t\t\treturn next_smallest_palindrome(num + 2)\n\t\tend\n\t\treturn parse(Int64, num_str[1:mid_idx] * (parse(Int64, mid_str) + 1) * num_str[mid_idx:mid_idx])\n\tend\nend",
    "\t\"\"\"\n\tFinds the next smallest palindrome of a specified integer.\n\t\"\"\"\n\t# Convert the number to a string\n\tnum_string = string(num)\n\t# Find the length of the number\n\tnum_length = length(num_string)\n\t# Find the midpoint of the number\n\tmidpoint = div(num_length, 2)\n\t# Find the left side of the number\n\tleft_side = num_string[1:midpoint]\n\t# Find the right side of the number\n\tright_side = num_string[midpoint+1:num_length]\n\t# Reverse the right side of the number\n\tright_side_reversed = reverse(right_side)\n\t# If the left side is less than the right side, increment the left side by 1\n\tif left_side < right_side_reversed\n\t\tleft_side = string(parse(Int64, left_side) + 1)\n\tend\n\t# If the left side is greater than the right side, increment the left side by 1\n\tif left_side > right_side_reversed\n\t\tleft_side = string(parse(Int64, left_side) + 1)\n\tend\n\t# If the left side is equal to the right side, increment the left side by 1\n\tif left_side == right_side_reversed\n\t\tleft_side = string(parse(Int64, left_side) + 1)\n\tend\n\t# Reverse the left side of the number\n\tleft_side_reversed = reverse(left_side)\n\t# Concatenate the left side, midpoint, and right side\n\tnext_smallest_palindrome = string(left_side, num_string[midpoint], left_side_reversed)\n\t# Return the next smallest palindrome\n\treturn parse(Int64, next_smallest_palindrome)\nend",
    "\tnum_str = string(num)\n\tlen_num = length(num_str)\n\tif len_num == 1\n\t\treturn num\n\tend\n\tif len_num % 2 == 0\n\t\thalf_len = len_num/2\n\t\tleft_half = parse(Int64, num_str[1:half_len])\n\t\tright_half = parse(Int64, num_str[half_len+1:end])\n\t\tif right_half < left_half\n\t\t\tright_half = left_half\n\t\t\tnum_str = num_str[1:half_len] * string(right_half)\n\t\t\tnum = parse(Int64, num_str)\n\t\t\treturn num\n\t\tend\n\t\tleft_half += 1\n\t\tnum_str = num_str[1:half_len] * string(left_half)\n\t\tnum = parse(Int64, num_str)\n\t\treturn num\n\telse\n\t\thalf_len = (len_num+1)/2\n\t\tleft_half = parse(Int64, num_str[1:half_len])\n\t\tright_half = parse(Int64, num_str[half_len+1:end])\n\t\tif right_half < left_half\n\t\t\tright_half = left_half\n\t\t\tnum_str = num_str[1:half_len] * string(right_half)\n\t\t\tnum = parse(Int64, num_str)\n\t\t\treturn num\n\t\tend\n\t\tleft_half += 1\n\t\tnum_str = num_str[1:half_len] * string(left_half)\n\t\tnum = parse(Int64, num_str)\n\t\treturn num\n\tend\nend",
    "\t\"\"\"\n\tFind the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\n\tif num < 0\n\t\treturn error(\"Input must be a positive integer\")\n\tend\n\tif num < 10\n\t\treturn num\n\tend\n\tif num < 100\n\t\tif num % 11 == 0\n\t\t\treturn num + 11\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 1000\n\t\tif num % 101 == 0\n\t\t\treturn num + 101\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 10000\n\t\tif num % 1001 == 0\n\t\t\treturn num + 1001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 100000\n\t\tif num % 10001 == 0\n\t\t\treturn num + 10001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 1000000\n\t\tif num % 100001 == 0\n\t\t\treturn num + 100001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 10000000\n\t\tif num % 1000001 == 0\n\t\t\treturn num + 1000001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 100000000\n\t\tif num % 10000001 == 0\n\t\t\treturn num + 10000001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 1000000000\n\t\tif num % 100000001 == 0\n\t\t\treturn num + 100000001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 10000000000\n\t\tif num % 1000000001 == 0\n\t\t\treturn num + 1000000001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\tend\n\tif num < 100000000000\n\t\tif num % 10000000001 == 0\n\t\t\treturn num + 10000000001\n\t\telse\n\t\t\treturn num + 1\n\t\tend\n\t",
    "\t# convert to string\n\tnum_str = string(num)\n\t# get length of string\n\tnum_len = length(num_str)\n\t# get the middle index\n\tmid_index = div(num_len, 2)\n\t# get the first half of the string\n\tfirst_half = num_str[1:mid_index]\n\t# get the second half of the string\n\tsecond_half = num_str[mid_index+1:num_len]\n\t# reverse the second half\n\tsecond_half = reverse(second_half)\n\t# get the first half as an integer\n\tfirst_half_int = parse(Int64, first_half)\n\t# get the second half as an integer\n\tsecond_half_int = parse(Int64, second_half)\n\t# check if the first half is greater than the second half\n\tif first_half_int > second_half_int\n\t\t# if it is, return the number\n\t\treturn num\n\telse\n\t\t# if it isn't, increment the first half\n\t\tfirst_half_int += 1\n\t\t# convert the first half back to a string\n\t\tfirst_half = string(first_half_int)\n\t\t# reverse the first half\n\t\tfirst_half = reverse(first_half)\n\t\t# concatenate the first half and the second half\n\t\tnew_num = first_half * second_half\n\t\t# convert the new number back to an integer\n\t\tnew_num = parse(Int64, new_num)\n\t\t# return the new number\n\t\treturn new_num\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\tmid = num_len / 2\n\t\tleft = parse(Int64, num_str[1:mid])\n\t\tright = parse(Int64, num_str[mid+1:end])\n\t\tif left > right\n\t\t\treturn parse(Int64, num_str[1:mid] * 2)\n\t\telse\n\t\t\treturn parse(Int64, num_str[1:mid] * 2) + 1\n\t\tend\n\telse\n\t\tmid = (num_len + 1) / 2\n\t\tleft = parse(Int64, num_str[1:mid-1])\n\t\tright = parse(Int64, num_str[mid+1:end])\n\t\tif left > right\n\t\t\treturn parse(Int64, num_str[1:mid-1] * 2)\n\t\telse\n\t\t\treturn parse(Int64, num_str[1:mid-1] * 2) + 1\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tlen_num_str = length(num_str)\n\tif len_num_str == 1\n\t\treturn num\n\tend\n\tif len_num_str % 2 == 0\n\t\tmid = len_num_str / 2\n\t\tleft = num_str[1:mid]\n\t\tright = num_str[mid+1:end]\n\t\tif left == reverse(right)\n\t\t\treturn num\n\t\tend\n\t\tif left > reverse(right)\n\t\t\treturn parse(Int64, num_str[1:mid] * reverse(num_str[1:mid]))\n\t\tend\n\t\tif left < reverse(right)\n\t\t\tleft = parse(Int64, left) + 1\n\t\t\treturn parse(Int64, string(left) * reverse(string(left)))\n\t\tend\n\telse\n\t\tmid = len_num_str / 2\n\t\tleft = num_str[1:mid]\n\t\tright = num_str[mid+2:end]\n\t\tif left == reverse(right)\n\t\t\treturn num\n\t\tend\n\t\tif left > reverse(right)\n\t\t\treturn parse(Int64, num_str[1:mid] * num_str[mid+1] * reverse(num_str[1:mid]))\n\t\tend\n\t\tif left < reverse(right)\n\t\t\tleft = parse(Int64, left) + 1\n\t\t\treturn parse(Int64, string(left) * num_str[mid+1] * reverse(string(left)))\n\t\tend\n\tend\nend",
    "\t# convert to string\n\tstr = string(num)\n\t# check if palindrome\n\tif is_palindrome(str)\n\t\t# if so, increment by 1\n\t\treturn num + 1\n\tend\n\t# find the center of the string\n\tcenter = div(length(str), 2)\n\t# get the left and right halves of the string\n\tleft = str[1:center]\n\tright = str[center+1:end]\n\t# check if the left half is greater than the right half\n\tif left > right\n\t\t# if so, return the left half + the reversed right half\n\t\treturn parse(Int64, left * 2)\n\tend\n\t# otherwise, increment the left half\n\tleft = parse(Int64, left) + 1\n\t# return the left half + the reversed right half\n\treturn parse(Int64, left * 2)\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len % 2 == 0\n\t\thalf_len = num_len / 2\n\t\tleft_half = parse(Int64, num_str[1:half_len])\n\t\tright_half = parse(Int64, num_str[half_len+1:end])\n\t\tif left_half < right_half\n\t\t\tleft_half += 1\n\t\t\tnum_str = string(left_half) * 2\n\t\telseif left_half == right_half\n\t\t\tnum_str = string(left_half + 1) * 2\n\t\telse\n\t\t\tnum_str = string(left_half) * 2\n\t\tend\n\telse\n\t\thalf_len = (num_len + 1) / 2\n\t\tleft_half = parse(Int64, num_str[1:half_len])\n\t\tright_half = parse(Int64, num_str[half_len+1:end])\n\t\tif left_half < right_half\n\t\t\tleft_half += 1\n\t\t\tnum_str = string(left_half) * 2\n\t\telseif left_half == right_half\n\t\t\tnum_str = string(left_half + 1) * 2\n\t\telse\n\t\t\tnum_str = string(left_half) * 2\n\t\tend\n\tend\n\treturn parse(Int64, num_str)\nend",
    "\t# if num is a palindrome, return num\n\tif is_palindrome(num)\n\t\treturn num\n\tend\n\t# if num is a single digit, return num\n\tif num < 10\n\t\treturn num\n\tend\n\t# if num is a two digit number, return the next smallest palindrome\n\tif num < 100\n\t\tif num % 11 == 0\n\t\t\treturn num + 11\n\t\telse\n\t\t\treturn num - (num % 11)\n\t\tend\n\tend\n\t# if num is a three digit number, return the next smallest palindrome\n\tif num < 1000\n\t\tif num % 101 == 0\n\t\t\treturn num + 101\n\t\telse\n\t\t\treturn num - (num % 101)\n\t\tend\n\tend\n\t# if num is a four digit number, return the next smallest palindrome\n\tif num < 10000\n\t\tif num % 1001 == 0\n\t\t\treturn num + 1001\n\t\telse\n\t\t\treturn num - (num % 1001)\n\t\tend\n\tend\n\t# if num is a five digit number, return the next smallest palindrome\n\tif num < 100000\n\t\tif num % 10001 == 0\n\t\t\treturn num + 10001\n\t\telse\n\t\t\treturn num - (num % 10001)\n\t\tend\n\tend\n\t# if num is a six digit number, return the next smallest palindrome\n\tif num < 1000000\n\t\tif num % 100001 == 0\n\t\t\treturn num + 100001\n\t\telse\n\t\t\treturn num - (num % 100001)\n\t\tend\n\tend\n\t# if num is a seven digit number, return the next smallest palindrome\n\tif num < 10000000\n\t\tif num % 1000001 == 0\n\t\t\treturn num + 1000001\n\t\telse\n\t\t\treturn num - (num % 1000001)\n\t\tend\n\tend\n\t# if num is a eight digit number, return the next smallest palindrome\n\tif num < 100000000\n\t\tif num % 10000001 == 0\n\t\t\treturn num + 10000001\n\t\telse\n\t\t\treturn",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\telseif num_len == 2\n\t\tif num_str[1] == num_str[2]\n\t\t\treturn num\n\t\telse\n\t\t\treturn num + 11\n\t\tend\n\telse\n\t\tif num_str[1] == num_str[end]\n\t\t\treturn num\n\t\telse\n\t\t\treturn num + 11\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\tmid_index = num_len \u00f7 2\n\t\tmid_index_2 = mid_index + 1\n\t\tmid_num = parse(Int64, num_str[mid_index])\n\t\tmid_num_2 = parse(Int64, num_str[mid_index_2])\n\t\tif mid_num == 0\n\t\t\tnum_str[mid_index] = \"1\"\n\t\t\tnum_str[mid_index_2] = \"1\"\n\t\t\treturn parse(Int64, num_str)\n\t\telseif mid_num == 9\n\t\t\tnum_str[mid_index] = \"0\"\n\t\t\tnum_str[mid_index_2] = \"0\"\n\t\t\treturn next_smallest_palindrome(parse(Int64, num_str))\n\t\telse\n\t\t\tnum_str[mid_index] = string(mid_num + 1)\n\t\t\tnum_str[mid_index_2] = string(mid_num + 1)\n\t\t\treturn parse(Int64, num_str)\n\t\tend\n\telse\n\t\tmid_index = num_len \u00f7 2 + 1\n\t\tmid_num = parse(Int64, num_str[mid_index])\n\t\tif mid_num == 0\n\t\t\tnum_str[mid_index] = \"1\"\n\t\t\treturn parse(Int64, num_str)\n\t\telseif mid_num == 9\n\t\t\tnum_str[mid_index] = \"0\"\n\t\t\treturn next_smallest_palindrome(parse(Int64, num_str))\n\t\telse\n\t\t\tnum_str[mid_index] = string(mid_num + 1)\n\t\t\treturn parse(Int64, num_str)\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\tmid = num_len / 2\n\t\tleft = num_str[1:mid]\n\t\tright = num_str[mid+1:end]\n\t\tif left == right\n\t\t\treturn num\n\t\tend\n\t\tif left > right\n\t\t\treturn parse(Int64, left * 2)\n\t\tend\n\t\tif left < right\n\t\t\tleft_int = parse(Int64, left)\n\t\t\tleft_int += 1\n\t\t\treturn parse(Int64, left_int * 2)\n\t\tend\n\telse\n\t\tmid = num_len / 2\n\t\tleft = num_str[1:mid]\n\t\tright = num_str[mid+2:end]\n\t\tif left == right\n\t\t\treturn num\n\t\tend\n\t\tif left > right\n\t\t\treturn parse(Int64, left * 2)\n\t\tend\n\t\tif left < right\n\t\t\tleft_int = parse(Int64, left)\n\t\t\tleft_int += 1\n\t\t\treturn parse(Int64, left_int * 2)\n\t\tend\n\tend\nend",
    "\t# convert to string\n\tnum_str = string(num)\n\t# get length of string\n\tnum_len = length(num_str)\n\t# if length is even\n\tif num_len % 2 == 0\n\t\t# get the left half of the string\n\t\tleft_half = num_str[1:num_len/2]\n\t\t# get the right half of the string\n\t\tright_half = num_str[num_len/2+1:num_len]\n\t\t# if the left half is greater than the right half\n\t\tif left_half > right_half\n\t\t\t# return the number\n\t\t\treturn num\n\t\telse\n\t\t\t# increment the left half by 1\n\t\t\tleft_half = string(parse(Int64, left_half) + 1)\n\t\t\t# return the number\n\t\t\treturn parse(Int64, left_half * 2)\n\t\tend\n\telse\n\t\t# get the left half of the string\n\t\tleft_half = num_str[1:(num_len+1)/2]\n\t\t# get the right half of the string\n\t\tright_half = num_str[(num_len+1)/2+1:num_len]\n\t\t# if the left half is greater than the right half\n\t\tif left_half > right_half\n\t\t\t# return the number\n\t\t\treturn num\n\t\telse\n\t\t\t# increment the left half by 1\n\t\t\tleft_half = string(parse(Int64, left_half) + 1)\n\t\t\t# return the number\n\t\t\treturn parse(Int64, left_half * 2)\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tlen_num = length(num_str)\n\tif len_num == 1\n\t\treturn num\n\tend\n\tif len_num%2 == 0\n\t\tmid_num = len_num/2\n\t\tfirst_half = parse(Int64, num_str[1:mid_num])\n\t\tsecond_half = parse(Int64, num_str[mid_num+1:end])\n\t\tif first_half < second_half\n\t\t\treturn parse(Int64, num_str[1:mid_num] * 2)\n\t\telse\n\t\t\treturn parse(Int64, num_str[1:mid_num] * 2) + 1\n\t\tend\n\telse\n\t\tmid_num = (len_num+1)/2\n\t\tfirst_half = parse(Int64, num_str[1:mid_num-1])\n\t\tsecond_half = parse(Int64, num_str[mid_num+1:end])\n\t\tif first_half < second_half\n\t\t\treturn parse(Int64, num_str[1:mid_num-1] * 2) * 10 + parse(Int64, num_str[mid_num])\n\t\telse\n\t\t\treturn parse(Int64, num_str[1:mid_num-1] * 2) * 10 + parse(Int64, num_str[mid_num]) + 1\n\t\tend\n\tend\nend",
    "\tnum_str = string(num)\n\tnum_len = length(num_str)\n\tif num_len == 1\n\t\treturn num\n\tend\n\tif num_len % 2 == 0\n\t\tleft_half = parse(Int64, num_str[1:num_len/2])\n\t\tright_half = parse(Int64, num_str[num_len/2+1:num_len])\n\t\tif left_half > right_half\n\t\t\treturn num\n\t\telse\n\t\t\tleft_half += 1\n\t\t\tright_half = left_half\n\t\t\treturn parse(Int64, string(left_half) * string(right_half))\n\t\tend\n\telse\n\t\tleft_half = parse(Int64, num_str[1:(num_len+1)/2])\n\t\tright_half = parse(Int64, num_str[(num_len+1)/2+1:num_len])\n\t\tif left_half > right_half\n\t\t\treturn num\n\t\telse\n\t\t\tleft_half += 1\n\t\t\tright_half = left_half\n\t\t\treturn parse(Int64, string(left_half) * string(right_half))\n\t\tend\n\tend\nend"
  ]
}