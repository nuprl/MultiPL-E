{
  "language": "go_test.go",
  "name": "HumanEval_17_parse_music",
  "results": [
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = \"o\" + music_string\n    music_string = \"o|\" + music_string\n    music_string = \".|\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp588gu8zb_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcrgp03io_test.go:67:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsmmtedzr_test.go:55:42: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpms9knxaj_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074948
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"o|\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpi5_lzqp5_test.go:47:55: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3a1btqzi_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcsmox20s_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[0 : len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string[:len(music_string)-1] // remove last o\n    music_string = music_string[:len(music_string)-1] // remove last |\n    music_string = music_string\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpowg3rk1d_test.go:47:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[0 : len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpzsd4_zdd_test.go:63:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \".\", \"|\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpjnj4edat_test.go:49:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \".\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpn6uk_zio_test.go:48:56: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp07i2jaod_test.go:83:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpeqa5330i_test.go:45:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code goes here\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp9h8muyuw_test.go:82:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp07i2jaod_test.go:83:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = \"o\" + music_string\n    music_string = \"o|\" + music_string\n    music_string = \".|\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp588gu8zb_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpms9knxaj_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074948
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmphe6qi6gw_test.go:91:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074948
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp8mfhluof_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcnfw_cvh_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplqqhx3xr_test.go:64:21: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \"|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \".|\", \"o\", -1)\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp53n7zjby_test.go:49:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[1:]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpo042eoug_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = \"o\" + music_string\n    music_string = \"o|\" + music_string\n    music_string = \".|\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp588gu8zb_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp07i2jaod_test.go:83:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp33p83zus_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpj00n7ydl_test.go:82:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp98wr7ck5_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074949
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpj00n7ydl_test.go:82:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:len(music_string)-1] // remove last space\n    music_string = music_string[:\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_4rqw05i_test.go:47:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code goes here\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpzsccbs33_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074948
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp33p83zus_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp98wr7ck5_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074949
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string[len(music_string)-1]\n    music_string += music_string\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcnfw_cvh_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = \"o\" + music_string\n    music_string = \"o|\" + music_string\n    music_string = \".|\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp588gu8zb_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpi18eqw0e_test.go:55:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(music_string)-1] // remove last '.'\n    music_string = music_string[:len(music_string)-1] // remove last '|'\n    music_string = music_string[:len(music_string)-1] // remove last 'o'\n    music_string = music_string[:len(\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpeqa5330i_test.go:45:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code goes here\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsd2bydci_test.go:66:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp07i2jaod_test.go:83:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp5352whr8_test.go:91:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp33p83zus_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += music_string[len(music_string)-1]\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpj00n7ydl_test.go:82:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp33p83zus_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"0\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"1\", -1)\n    music_string = strings.Replace(music_string, \".\", \"2\", -1)\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpnu3z67_q_test.go:51:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \".\", \"|\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmph4j0zmvz_test.go:48:55: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyxhd53wa_test.go:92:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = \"o\" + music_string\n    music_string = \"o|\" + music_string\n    music_string = \".|\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp588gu8zb_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcrgp03io_test.go:67:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmphe6qi6gw_test.go:91:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074948
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string := music_string[1:]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    music_string := music_string[:len(music_string)-1]\n    musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoy_g97w__test.go:54:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = \"o\" + music_string\n    music_string = \"o|\" + music_string\n    music_string = \".|\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + music_string\n    music_string = \"o\" + musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp588gu8zb_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplkn1e3l9_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = strings.Replace(music_string, \".\", \"|\", -1)\n    music_string = strings.Replace(music_string, \"o\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \"o|\", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \"o\", -1)\n    music_string = strings.Replace(music_string, \"o\", \" \", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \" \", -1)\n    music_string = strings.Replace(music_string, \"o|\", \" \", -1)\n    music_string = strings.Replace(music_string, \" \", \"|\", -1)\n    music_string = strings.Replace(music_string, \"|\", \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpbk0c7xab_test.go:49:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp5352whr8_test.go:91:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpu1npdfwc_test.go:62:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(musi\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsmmtedzr_test.go:55:42: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660075107
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    music_string += music_string[len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp33p83zus_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyxhd53wa_test.go:92:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    music_string = music_string[:len(music_string)-1]\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3cosvjtp_test.go:56:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"\\n\"\n    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6c4dklmz_test.go:68:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    },
    {
      "exit_code": 1,
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    music_string += \" \"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\n    music_string = music_string[:len(music_string)-1]\n    music_string += \"|\"\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvsj82l_m_test.go:65:6: expected '(', found TestParse_Music\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074947
    }
  ]
}