language: pl
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. scalar(@$arr) - 1) {\n        my $e = $arr->[$i];\n     \
    \   if ($e % 2 == 0) {\n            if (defined($min_even)) {\n              \
    \  if ($e < $min_even) {\n                    $min_even = $e;\n              \
    \      $min_even_idx = $i;\n                }\n            } else {\n        \
    \        $min_even = $e;\n                $min_even_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $smallest = -1;\n    my $best_idx = -1;\n    for\
    \ my $i (0..$#$arr) {\n        my $num = $arr->[$i];\n        next if $num % 2;\n\
    \        if ($smallest == -1 or $num < $smallest) {\n            $smallest = $num;\n\
    \            $best_idx = $i;\n        }\n    }\n    return [$smallest, $best_idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821275
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my @result = ();\n    my @even = grep { $_ % 2 ==\
    \ 0 } @$arr;\n    if (@even) {\n        my $min = min @even;\n        my @index\
    \ = grep { $arr->[$_] == $min } 0..$#$arr;\n        @result = ($min, min @index);\n\
    \    }\n    return \\@result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n \
    \   my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpennoyelu.pl line 31, near\
    \ \"min @even\"\n\t(Do you need to predeclare min?)\nArray found where operator\
    \ expected at /tmp/tmpennoyelu.pl line 33, near \"min @index\"\n\t(Do you need\
    \ to predeclare min?)\nsyntax error at /tmp/tmpennoyelu.pl line 31, near \"min\
    \ @even\"\nsyntax error at /tmp/tmpennoyelu.pl line 33, near \"min @index\"\n\
    BEGIN not safe after errors--compilation aborted at /tmp/tmpennoyelu.pl line 37.\n"
  stdout: ''
  timestamp: 1659821274
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    # TODO\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my @sorted = sort {$a <=> $b} grep {$_ % 2 == 0}\
    \ @$arr;\n    return [] unless @sorted;\n    my $target = $sorted[0];\n    my\
    \ $index = -1;\n    for (my $i = 0; $i < @$arr; $i++) {\n        if ($arr->[$i]\
    \ == $target) {\n            $index = $i;\n            last;\n        }\n    }\n\
    \    return [$target, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 100000000;\n    my $idx = -1;\n    for\
    \ my $i (0..scalar(@$arr)-1) {\n        if($arr->[$i] % 2 == 0) {\n          \
    \  if($arr->[$i] < $min) {\n                $min = $arr->[$i];\n             \
    \   $idx = $i;\n            }\n        }\n    }\n    if($idx != -1) {\n      \
    \  return [$min, $idx];\n    } else {\n        return [];\n    }\n}\n1;\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $minval = 999999999;\n    my $minidx = -1;\n \
    \   for (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 ==\
    \ 0 && $arr->[$i] < $minval) {\n            $minval = $arr->[$i];\n          \
    \  $minidx = $i;\n        }\n    }\n    if ($minidx == -1) {\n        return [];\n\
    \    } else {\n        return [$minval, $minidx];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    # Your code here\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    return unless defined $arr;\n    my ($min_index,\
    \ $min_value) = (-1, -1);\n    for my $index (0 .. $#$arr) {\n        next unless\
    \ $arr->[$index] % 2 == 0;\n        if ($min_value == -1 || $arr->[$index] < $min_value)\
    \ {\n            $min_value = $arr->[$index];\n            $min_index = $index;\n\
    \        }\n    }\n    return [$min_value, $min_index];\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my($min, $result);\n    for (my $i = 0; $i < @$arr;\
    \ $i++) {\n        if ($arr->[$i] % 2 == 0) {\n            if (not defined $min)\
    \ {\n                $min = $arr->[$i];\n                $result = [$min, $i];\n\
    \            } elsif ($arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $result = [$min, $i];\n            }\n        }\n    }\n    return\
    \ $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $even_value;\n    my $even_value_pos;\n    my\
    \ $i = 0;\n    while ($i < scalar @$arr) {\n        if (defined $even_value) {\n\
    \            if ($even_value > $arr->[$i] && $arr->[$i] % 2 == 0) {\n        \
    \        $even_value = $arr->[$i];\n                $even_value_pos = $i;\n  \
    \          }\n        } else {\n            if ($arr->[$i] % 2 == 0) {\n     \
    \           $even_value = $arr->[$i];\n                $even_value_pos = $i;\n\
    \            }\n        }\n        $i++;\n    }\n    if (defined $even_value_pos)\
    \ {\n        return [$even_value, $even_value_pos];\n    } else {\n        return\
    \ [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = $arr->[0];\n    my $idx = 0;\n    my $i\
    \ = 0;\n    foreach (@$arr) {\n        if ($_ % 2 == 0) {\n            if ($_\
    \ < $min) {\n                $min = $_;\n                $idx = $i;\n        \
    \    }\n        }\n        $i++;\n    }\n    return [$min, $idx];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $smallest_even_value;\n    my $smallest_even_value_index;\n\
    \    for my $i (0 .. scalar(@$arr) - 1) {\n        if (defined $smallest_even_value\
    \ && $arr->[$i] < $smallest_even_value && $arr->[$i] % 2 == 0) {\n           \
    \ $smallest_even_value = $arr->[$i];\n            $smallest_even_value_index =\
    \ $i;\n        } elsif (!defined $smallest_even_value && $arr->[$i] % 2 == 0)\
    \ {\n            $smallest_even_value = $arr->[$i];\n            $smallest_even_value_index\
    \ = $i;\n        }\n    }\n    if (!defined $smallest_even_value) {\n        return\
    \ [];\n    }\n    return [$smallest_even_value, $smallest_even_value_index];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my($smallest_even, $index);\n    for (my $i = 0;\
    \ $i < @$arr; $i++) {\n        if (defined $smallest_even) {\n            if ($arr->[$i]\
    \ % 2 == 0 && $arr->[$i] < $smallest_even) {\n                $smallest_even =\
    \ $arr->[$i];\n                $index = $i;\n            }\n        }\n      \
    \  else {\n            if ($arr->[$i] % 2 == 0) {\n                $smallest_even\
    \ = $arr->[$i];\n                $index = $i;\n            }\n        }\n    }\n\
    \    return defined $smallest_even ? [$smallest_even, $index] : [];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for (my $i\
    \ = 0; $i < scalar @$arr; $i++) {\n        my $value = $arr->[$i];\n        if\
    \ ($value % 2 == 0 && ($min == -1 || $value < $min)) {\n            $min = $value;\n\
    \            $index = $i;\n        }\n    }\n    return [$min, $index];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $even_min = 9999999;\n    my $idx = -1;\n    foreach\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if ($val < $even_min) {\n                $even_min = $val;\n\
    \                $idx = $i;\n            }\n        }\n    }\n    return ($idx\
    \ >= 0) ? [$even_min, $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $result = [];\n    my $smallest_even_val = undef;\n\
    \    my $smallest_even_val_idx = undef;\n    for (my $i = 0; $i < scalar(@$arr);\
    \ $i++) {\n        if (defined($smallest_even_val)) {\n            if ($arr->[$i]\
    \ % 2 == 0 && $arr->[$i] < $smallest_even_val) {\n                $smallest_even_val\
    \ = $arr->[$i];\n                $smallest_even_val_idx = $i;\n            }\n\
    \        } else {\n            if ($arr->[$i] % 2 == 0) {\n                $smallest_even_val\
    \ = $arr->[$i];\n                $smallest_even_val_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined($smallest_even_val) && defined($smallest_even_val_idx))\
    \ {\n        push(@$result, $smallest_even_val);\n        push(@$result, $smallest_even_val_idx);\n\
    \    }\n    return $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n   \
    \ my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: -1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my($i,$min,$imin) = (0,$arr->[0],0);\n    while ($i\
    \ < scalar(@$arr)) {\n        my($v) = $arr->[$i];\n        next if $v % 2;\n\
    \        $min = $v if $min % 2;\n        if ($v <= $min) {\n            $min =\
    \ $v;\n            $imin = $i;\n        }\n        $i++;\n    }\n    [$min,$imin];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821279
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $smallest_idx = -1;\n    my $smallest_val = -1;\n\
    \    for (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 ==\
    \ 0) {\n            if ($smallest_idx == -1) {\n                $smallest_idx\
    \ = $i;\n                $smallest_val = $arr->[$i];\n            } elsif ($arr->[$i]\
    \ < $smallest_val) {\n                $smallest_idx = $i;\n                $smallest_val\
    \ = $arr->[$i];\n            }\n        }\n    }\n    return ($smallest_idx ==\
    \ -1) ? [] : [$smallest_val, $smallest_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821275
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $res = [undef, undef];\n    foreach my $i (0..$#$arr)\
    \ {\n        if($arr->[$i] % 2 == 0) {\n            if(!defined $res->[0] || $arr->[$i]\
    \ < $res->[0]) {\n                $res = [$arr->[$i], $i];\n            }\n  \
    \      }\n    }\n    return $res;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821275
