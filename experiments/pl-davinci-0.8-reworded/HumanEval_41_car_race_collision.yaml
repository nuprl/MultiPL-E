name: HumanEval_41_car_race_collision
language: pl
prompt: "# Imagine a road that's a perfectly straight infinitely long line.\n# n cars\
  \ are driving left to right;  simultaneously, a different set of n cars\n# are driving\
  \ right to left.   The two sets of cars start out being very far from\n# each other.\
  \  All cars move in the same speed.  Two cars are said to collide\n# when a car\
  \ that's moving left to right hits a car that's moving right to left.\n# However,\
  \ the cars are infinitely sturdy and strong; as a result, they continue moving\n\
  # in their trajectory as if they did not collide.\n# This function outputs the number\
  \ of such collisions.\nsub car_race_collision {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&car_race_collision;\n\
  \        if(eq_deeply($candidate->(2),4)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(3),9)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),16))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),64))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),100))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    if ($n == 0) {\n        return 0;\n    } else {\n        return\
    \ 2 * $n - 1;\n    }\n}", "    return $n * ($n - 1) / 2;\n}", "    return $n *\
    \ ($n - 1) / 2;\n}", "    return 0 if $n == 0;\n    return ($n-1)*$n/2;\n}", " \
    \   my $collision = 0;\n    for my $i (1..$n) {\n        for my $j (1..$n) {\n\
    \            $collision++ if $i == $j;\n        }\n    }\n    return $collision;\n\
    }", "    my $counter = 0;\n    for(my $i = 0; $i < $n; $i++){\n        for(my\
    \ $j = 0; $j < $n; $j++){\n            if($i >= $j){\n                $counter++;\n\
    \            }\n        }\n    }\n    return $counter;\n}", "    my($num_collisions)\
    \ = 0;\n    # The cars can be modeled as points on a number line.\n    # Assume\
    \ cars moving left to right are the numbers 1,2,..n;\n    # those moving right\
    \ to left are the numbers -1,-2,...,-n\n    # For simplicity, assume the cars\
    \ are moving at the same speed.\n    # Let's solve this problem in O(n log n)\
    \ time using a divide and conquer algorithm\n    # Input: An array that represents\
    \ the cars as they move on the number line\n    # Output: Number of collisions\n\
    \    my($collisions) = &car_race_collision_helper([(1..$n), (-1..-$n)]);\n   \
    \ return $collisions;\n}", '    return 0 if !$n;', "    my $answer = 0;\n    my\
    \ $p = 1;\n    my $q = 1;\n    while($n > 0) {\n        $answer += $p*$q;\n  \
    \      $p++;\n        $q++;\n        $n--;\n    }\n    return $answer;\n}", " \
    \   # We use a binary search to find what time the first collision happens, by\n\
    \    # starting off with a high time, and reducing the time until we find when\
    \ the\n    # first collision occurs.\n    my $max_time = $n * $n * 2;\n    my\
    \ $first_collision_time = binary_search($max_time, sub{return first_collision_time($n,\
    \ @_)});\n    return $first_collision_time;\n}", "    my $count = 0;\n    my @cars\
    \ = (1..$n);\n    while (@cars) {\n        for (my $i = 0; $i < @cars - 1; $i++)\
    \ {\n            if ($cars[$i+1] < $cars[$i]) {\n                $count++;\n \
    \           }\n        }\n        shift @cars;\n    }\n    return $count;\n}",
  "    my $total = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j =\
    \ 0; $j < $n; $j++) {\n            if ($i + $j == $n - 1) {\n                $total++;\n\
    \            }\n        }\n    }\n    return $total;\n}", "    my $result = 1;\n\
    \    for (my $i = 1; $i < $n; $i++) {\n        $result += $i;\n    }\n    return\
    \ $result;\n}", "    my $sum = 0;\n    my $max = 0;\n    for (my $i = 0; $i <\
    \ $n; $i++) {\n        $sum += $i;\n        $max += $n - $i - 1;\n    }\n    return\
    \ min($sum, $max);\n}\nprint \"car_race_collision(5) = \", car_race_collision(5),\
    \ \"\\n\";", "    my $num_collisions = 0;\n    my $p = 0;\n    my $q = $n - 1;\n\
    \    my $i = 0;\n    my $j = $n - 1;\n    while ($i < $n && $j >= 0) {\n     \
    \   if ($p <= $q) {\n            $num_collisions += $q - $p;\n            $p++;\n\
    \            $i++;\n        } else {\n            $q--;\n            $j--;\n \
    \       }\n    }\n    return $num_collisions;\n}", "    my $car_cnt_left = 0;\n\
    \    my $car_cnt_right = 0;\n    my $collision_cnt = 0;\n    for(my $i = 0; $i\
    \ < $n; $i++) {\n        $car_cnt_left++;\n        $car_cnt_right++;\n       \
    \ $collision_cnt += min($car_cnt_left, $car_cnt_right);\n    }\n    return $collision_cnt;\n\
    }", "    ########################\n    # YOUR CODE GOES HERE\n    ########################\n\
    }", "    my($l, $r) = (0, $n - 1);\n    my($collision_count) = 0;\n    while($l\
    \ < $r) {\n        if($l_cars[$l] < $r_cars[$r]) {\n            $collision_count\
    \ += $r - $l;\n            $l++;\n        } else {\n            $r--;\n      \
    \  }\n    }\n    return $collision_count;\n}", "    if ( $n <= 1 ) {\n       \
    \ return $n;\n    }\n    return car_race_collision($n/2) + car_race_collision($n/2);\n\
    }", "    $n or return 0;\n    my($swaps_required) = 0;\n    my($swaps_left) =\
    \ 0;\n    my($swaps_right) = 0;\n    for my $i (1 .. $n) {\n        my($min, $max)\
    \ = sort($swaps_left + $i, $swaps_right + $n - $i + 1);\n        $swaps_required\
    \ += $min;\n        $swaps_left = $max - $i;\n        $swaps_right = $max - $n\
    \ + $i - 1;\n    }\n    return $swaps_required;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
