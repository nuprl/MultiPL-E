name: HumanEval_41_car_race_collision
language: pl
prompt: "# Imagine a road that's a perfectly straight infinitely long line.\n# n cars\
  \ are driving left to right;  simultaneously, a different set of n cars\n# are driving\
  \ right to left.   The two sets of cars start out being very far from\n# each other.\
  \  All cars move in the same speed.  Two cars are said to collide\n# when a car\
  \ that's moving left to right hits a car that's moving right to left.\n# However,\
  \ the cars are infinitely sturdy and strong; as a result, they continue moving\n\
  # in their trajectory as if they did not collide.\n# This function outputs the number\
  \ of such collisions.\nsub car_race_collision {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&car_race_collision;\n\
  \        if(eq_deeply($candidate->(2),4)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(3),9)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),16))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),64))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),100))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    if ($n == 0) {\n        return 0;\n    } else {\n        return\
    \ 2 * $n - 1;\n    }\n}", "    return $n * ($n - 1) / 2;\n}", "    return $n *\
    \ ($n - 1) / 2;\n}", "    return 0 if $n == 0;\n    return ($n-1)*$n/2;\n}", " \
    \   my $collision = 0;\n    for my $i (1..$n) {\n        for my $j (1..$n) {\n\
    \            $collision++ if $i == $j;\n        }\n    }\n    return $collision;\n\
    }", "    my $counter = 0;\n    for(my $i = 0; $i < $n; $i++){\n        for(my\
    \ $j = 0; $j < $n; $j++){\n            if($i >= $j){\n                $counter++;\n\
    \            }\n        }\n    }\n    return $counter;\n}", "    my($num_collisions)\
    \ = 0;\n    # The cars can be modeled as points on a number line.\n    # Assume\
    \ cars moving left to right are the numbers 1,2,..n;\n    # those moving right\
    \ to left are the numbers -1,-2,...,-n\n    # For simplicity, assume the cars\
    \ are moving at the same speed.\n    # Let's solve this problem in O(n log n)\
    \ time using a divide and conquer algorithm\n    # Input: An array that represents\
    \ the cars as they move on the number line\n    # Output: Number of collisions\n\
    \    my($collisions) = &car_race_collision_helper([(1..$n), (-1..-$n)]);\n   \
    \ return $collisions;\n}", '    return 0 if !$n;', "    my $answer = 0;\n    my\
    \ $p = 1;\n    my $q = 1;\n    while($n > 0) {\n        $answer += $p*$q;\n  \
    \      $p++;\n        $q++;\n        $n--;\n    }\n    return $answer;\n}", " \
    \   # We use a binary search to find what time the first collision happens, by\n\
    \    # starting off with a high time, and reducing the time until we find when\
    \ the\n    # first collision occurs.\n    my $max_time = $n * $n * 2;\n    my\
    \ $first_collision_time = binary_search($max_time, sub{return first_collision_time($n,\
    \ @_)});\n    return $first_collision_time;\n}", "    my $count = 0;\n    my @cars\
    \ = (1..$n);\n    while (@cars) {\n        for (my $i = 0; $i < @cars - 1; $i++)\
    \ {\n            if ($cars[$i+1] < $cars[$i]) {\n                $count++;\n \
    \           }\n        }\n        shift @cars;\n    }\n    return $count;\n}",
  "    my $total = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j =\
    \ 0; $j < $n; $j++) {\n            if ($i + $j == $n - 1) {\n                $total++;\n\
    \            }\n        }\n    }\n    return $total;\n}", "    my $result = 1;\n\
    \    for (my $i = 1; $i < $n; $i++) {\n        $result += $i;\n    }\n    return\
    \ $result;\n}", "    my $sum = 0;\n    my $max = 0;\n    for (my $i = 0; $i <\
    \ $n; $i++) {\n        $sum += $i;\n        $max += $n - $i - 1;\n    }\n    return\
    \ min($sum, $max);\n}\nprint \"car_race_collision(5) = \", car_race_collision(5),\
    \ \"\\n\";", "    my $num_collisions = 0;\n    my $p = 0;\n    my $q = $n - 1;\n\
    \    my $i = 0;\n    my $j = $n - 1;\n    while ($i < $n && $j >= 0) {\n     \
    \   if ($p <= $q) {\n            $num_collisions += $q - $p;\n            $p++;\n\
    \            $i++;\n        } else {\n            $q--;\n            $j--;\n \
    \       }\n    }\n    return $num_collisions;\n}", "    my $car_cnt_left = 0;\n\
    \    my $car_cnt_right = 0;\n    my $collision_cnt = 0;\n    for(my $i = 0; $i\
    \ < $n; $i++) {\n        $car_cnt_left++;\n        $car_cnt_right++;\n       \
    \ $collision_cnt += min($car_cnt_left, $car_cnt_right);\n    }\n    return $collision_cnt;\n\
    }", "    ########################\n    # YOUR CODE GOES HERE\n    ########################\n\
    }", "    my($l, $r) = (0, $n - 1);\n    my($collision_count) = 0;\n    while($l\
    \ < $r) {\n        if($l_cars[$l] < $r_cars[$r]) {\n            $collision_count\
    \ += $r - $l;\n            $l++;\n        } else {\n            $r--;\n      \
    \  }\n    }\n    return $collision_count;\n}", "    if ( $n <= 1 ) {\n       \
    \ return $n;\n    }\n    return car_race_collision($n/2) + car_race_collision($n/2);\n\
    }", "    $n or return 0;\n    my($swaps_required) = 0;\n    my($swaps_left) =\
    \ 0;\n    my($swaps_right) = 0;\n    for my $i (1 .. $n) {\n        my($min, $max)\
    \ = sort($swaps_left + $i, $swaps_right + $n - $i + 1);\n        $swaps_required\
    \ += $min;\n        $swaps_left = $max - $i;\n        $swaps_right = $max - $n\
    \ + $i - 1;\n    }\n    return $swaps_required;\n}", "    my $cnt = 0;\n    if\
    \ ($n <= 1) {\n        return 0;\n    } else {\n        foreach my $i (0..$n-1)\
    \ {\n            foreach my $j ($i+1..$n-1) {\n                $cnt += $i+$j;\n\
    \            }\n        }\n        return $cnt;\n    }\n}", '    return -1 if
    $n == 0;', "    my $collisions = 0;\n    my @r_to_l = (0..$n-1);\n    my @l_to_r\
    \ = ($n..2*$n-1);\n    while (@r_to_l && @l_to_r) {\n        if ($r_to_l[0] <\
    \ $l_to_r[0]) {\n            shift @r_to_l;\n        } elsif ($r_to_l[0] > $l_to_r[0])\
    \ {\n            shift @l_to_r;\n        } else {\n            shift @r_to_l;\n\
    \            shift @l_to_r;\n            $collisions++;\n        }\n    }\n  \
    \  return $collisions;\n}", "    my $collisions = 0;\n    my %car_map;\n    for\
    \ my $i (1..$n) {\n        for my $j (1..$n) {\n            if ($i eq $j) {\n\
    \                next;\n            }\n            $car_map{$i}{$j} = $j - $i;\n\
    \        }\n    }\n    for my $i (1..$n) {\n        for my $j (1..$n) {\n    \
    \        if ($i eq $j) {\n                next;\n            }\n            my\
    \ $collided = 1;\n            for my $k (1..$n) {\n                if ($k eq $i\
    \ or $k eq $j) {\n                    next;\n                }\n             \
    \   if ($car_map{$i}{$k} * $car_map{$j}{$k} > 0) {\n                    $collided\
    \ = 0;\n                    last;\n                }\n            }\n        \
    \    $collisions++ if $collided;\n        }\n    }\n    return $collisions;\n}",
  "    my $collisions = 0;\n    my $i = 0;\n    my $j = $n - 1;\n    my $car_start_positions\
    \ = get_sorted_random_array($n);\n    my $car_end_positions = get_sorted_random_array($n);\n\
    \    for(my $i = 0; $i < $n - 1; $i++) {\n        $j = $n - 1;\n        while($j\
    \ > $i) {\n            if($car_start_positions->[$i] > $car_end_positions->[$j])\
    \ {\n                $collisions++;\n                $j--;\n            } else\
    \ {\n                last;\n            }\n        }\n    }\n    return $collisions;\n\
    }", "    return $n * ($n - 1) / 2;\n}", "    my $num_collisions = 0;\n    # Let's\
    \ say the cars moving right to left are at positions 1, 2, 3, ..., $n,\n    #\
    \ and the cars moving left to right are at positions -1, -2, -3, ..., -$n.\n \
    \   # Then, the $i'th car moving right to left hits the $j'th car moving left\
    \ to right\n    # when $i + $j == 0.  Thus, each nonzero sum of two numbers $i,\
    \ $j with $i, $j, $i + $j\n    # all positive corresponds to a collision.  This\
    \ is the same as the number of ways\n    # of choosing two numbers out of $n such\
    \ that their sum is positive; we simply\n    # ignore the $j = 0 case.\n    #\
    \ We'll use the fact that the sum of all numbers from 1 to $n is $n * ($n + 1)\
    \ / 2.\n    $num_collisions = $n * ($n + 1) / 2 - $n;\n    return $num_collisions;\n\
    }", "    # Transform the problem into a problem about integers.\n    # Place the\
    \ integers 1 to n on the left to right road.\n    # Place the integers 1 to n\
    \ on the right to left road.\n    # (In other words, consider the integers 1 to\
    \ 2n.)\n    # Let x and y be any two integers.  Let x < y.\n    # Observe that\
    \ if x is on the left to right road and y is on the right to left road,\n    #\
    \ they will collide.\n    # Furthermore, if x is on the left to right road and\
    \ y is on the left to right road,\n    # they will never collide, since the left\
    \ to right cars move faster.\n    # Thus, the number of collisions is equal to\
    \ the number of unordered pairs\n    # of the form (x, y) where x is on the left\
    \ to right road and y is on the right to left road,\n    # and x < y.\n    # Observe\
    \ that there are n left to right cars, and n right to left cars.\n    # Thus,\
    \ the number of collisions is equal to the number of unordered pairs\n    # of\
    \ the form (x, y) where x is on the left to right road and y is on the right to\
    \ left road,\n    # and x < y.\n    # Note that the original problem can be solved\
    \ in less than O(n^2) time,\n    # so a solution with a complexity of O(n^2) or\
    \ worse is not acceptable.\n    my $result = 0;\n    for my $i (1 .. $n) {\n \
    \       $result += $n - $i + 1;\n    }\n    return $result;\n}", "    # naive\
    \ solution: O(n^2)\n    # it's trivial to show that\n    # the number of collisions\
    \ is the same as the number of cars at the end\n    # that are in the same position\n\
    \    # so we will use this property instead of the original problem statement.\n\
    \    my @right = map { int(rand() * 100_000) } (1..$n);\n    my @left = map {\
    \ int(rand() * 100_000) } (1..$n);\n    my $count = 0;\n    for my $i (0..$#right)\
    \ {\n        for my $j (0..$#left) {\n            if ($right[$i] == $left[$j])\
    \ {\n                $count++;\n            }\n        }\n    }\n    return $count;\n\
    }", "    my @left_to_right = ();\n    my @right_to_left = ();\n    for(my $i =\
    \ 0; $i < $n; $i++) {\n        $left_to_right[$i] = $i;\n        $right_to_left[$i]\
    \ = $n - $i - 1;\n    }\n    return car_race_collision_helper(\\@left_to_right,\
    \ \\@right_to_left);\n}", "    my $collisions = 0;\n    my @cars_left_to_right\
    \ = (1..$n);\n    my @cars_right_to_left = (1..$n);\n    while (@cars_left_to_right\
    \ > 0 && @cars_right_to_left > 0) {\n        if ($cars_left_to_right[0] == $cars_right_to_left[0])\
    \ {\n            $collisions++;\n            shift @cars_left_to_right;\n    \
    \        shift @cars_right_to_left;\n        }\n        elsif ($cars_left_to_right[0]\
    \ < $cars_right_to_left[0]) {\n            shift @cars_left_to_right;\n      \
    \  }\n        else {\n            shift @cars_right_to_left;\n        }\n    }\n\
    \    return $collisions;\n}\nprint \"Failed test \" . $test++ unless car_race_collision(2)\
    \ == 1;\nprint \"Failed test \" . $test++ unless car_race_collision(3) == 2;\n\
    print \"Failed test \" . $test++ unless car_race_collision(6) == 5;\nprint \"\
    Failed test \" . $test++ unless car_race_collision(7) == 6;\nprint \"Failed test\
    \ \" . $test++ unless car_race_collision(1) == 0;\nprint \"Failed test \" . $test++\
    \ unless car_race_collision(10000000) == 49999995;\nprint \"Failed test \" . $test++\
    \ unless car_race_collision(100000000) == 499999996;\nprint \"Failed test \" .\
    \ $test++ unless car_race_collision(1000000000) == 4999999996;", "    my $num_collisions\
    \ = 0;\n    my %position_at_time;\n    my %position_to_car;\n    for my $i (0..$n\
    \ - 1) {\n        $position_at_time{0}->{$i} = $i + $n;\n        $position_to_car{$i\
    \ + $n} = $i;\n    }\n    for my $i (0..$n - 1) {\n        $position_at_time{0}->{$i\
    \ + $n} = $i;\n        $position_to_car{$i} = $i + $n;\n    }\n    for my $t (1..$n)\
    \ {\n        for my $i (0..$n + $n - 1) {\n            my $old_position = $position_at_time{$t\
    \ - 1}->{$i};\n            my $new_position = $old_position + 1;\n           \
    \ $position_at_time{$t}->{$i} = $new_position;\n            $position_to_car{$new_position}\
    \ = $i;\n        }\n        for my $i (0..$n + $n - 1) {\n            my $position\
    \ = $position_at_time{$t}->{$i};\n            if (exists $position_to_car{$position\
    \ - 1}) {\n                $num_collisions++;\n            }\n        }\n    }\n\
    \    return $num_collisions;\n}", "    return $n * ($n - 1) / 2;\n}", "    my\
    \ $collisions = 0;\n    for my $i (0..$n-1) {\n        for my $j ($i+1..$n-1)\
    \ {\n            $collisions++;\n        }\n    }\n    return $collisions;\n}",
  "    my @a = (1 .. $n);\n    my @b = reverse @a;\n    my $ret = 0;\n    my $i =\
    \ 0;\n    my $j = 0;\n    while ($i < $n && $j < $n) {\n        if ($a[$i] > $b[$j])\
    \ {\n            $ret++;\n            $j++;\n        } else {\n            $i++;\n\
    \        }\n    }\n    return $ret;\n}", "    my $count = 0;\n    my $remain =\
    \ $n;\n    while ($remain > 0) {\n        $count++;\n        $remain--;\n    }\n\
    \    return $count;\n}", "    return $n * ($n - 1) / 2;\n}\nprint \"car_race_collision(3):\
    \ \", car_race_collision(3), \"\\n\";\nprint \"car_race_collision(4): \", car_race_collision(4),\
    \ \"\\n\";\nprint \"car_race_collision(5): \", car_race_collision(5), \"\\n\"\
    ;\nprint \"car_race_collision(6): \", car_race_collision(6), \"\\n\";\nprint \"\
    car_race_collision(7): \", car_race_collision(7), \"\\n\";\nprint \"car_race_collision(8):\
    \ \", car_race_collision(8), \"\\n\";\nprint \"car_race_collision(9): \", car_race_collision(9),\
    \ \"\\n\";\nprint \"car_race_collision(10): \", car_race_collision(10), \"\\n\"\
    ;", "    my $collisions = 0;\n    # write your code here\n    return $collisions;\n\
    }", "    my $c1 = int(rand($n));\n    my $c2 = int(rand($n));\n    $c1 == $c2\
    \ ? return 0 : return 1;\n}", "    return -1 if $n < 0;\n    return 0 if $n ==\
    \ 0;\n    my $collisions = 0;\n    my %right_cars;\n    my %left_cars;\n    #\
    \ Initialize the right car.\n    foreach my $i (1..$n) {\n        my $right_car\
    \ = 0;\n        $right_cars{$right_car}++;\n    }\n    # Initialize the left car.\n\
    \    foreach my $i (1..$n) {\n        my $left_car = $n - $i;\n        $left_cars{$left_car}++;\n\
    \    }\n    # The cars move until there are no more left cars.\n    while (1)\
    \ {\n        my $num_left_cars = keys %left_cars;\n        my $num_right_cars\
    \ = keys %right_cars;\n        my $left_car_pairs = $num_left_cars * ($num_left_cars\
    \ - 1);\n        my $right_car_pairs = $num_right_cars * ($num_right_cars - 1);\n\
    \        my $right_cars_with_left_cars = 0;\n        foreach my $car (keys %right_cars)\
    \ {\n            $right_cars_with_left_cars += ($car + 1) * $left_cars{$car +\
    \ 1};\n        }\n        $collisions += $left_car_pairs + $right_car_pairs +\
    \ $right_cars_with_left_cars;\n        last if !$num_left_cars;\n        # Move\
    \ one step.\n        foreach my $left_car (keys %left_cars) {\n            my\
    \ $new_left_car = $left_car - 1;\n            if (exists $left_cars{$new_left_car})\
    \ {\n                $left_cars{$new_left_car} += $left_cars{$left_car};\n   \
    \         } else {\n                $left_cars{$new_left_car} = $left_cars{$left_car};\n\
    \            }\n            delete $left_cars{$left_car};\n        }\n       \
    \ foreach my $right_car (keys %right_cars", "    my $collisions = 0;\n    my %positions;\n\
    \    foreach my $i (1..$n) {\n        $positions{$i} = $i;\n    }\n    foreach\
    \ my $i (1..$n) {\n        foreach my $j ($i+1..$n) {\n            $collisions++\
    \ if $positions{$i} == $positions{$j};\n        }\n        $positions{$i} += $i;\n\
    \    }\n    return $collisions;\n}", "    my $collisions = 0;\n    my @cars =\
    \ map { [1, int(rand(100) + 1)] } (1..$n);\n    while (1) {\n        my $done\
    \ = 1;\n        for my $i (0..$#cars - 1) {\n            if ($cars[$i][0] > $cars[$i\
    \ + 1][0]) {\n                $cars[$i][0] -= $cars[$i][1];\n                $cars[$i\
    \ + 1][0] += $cars[$i + 1][1];\n                $done = 0;\n            }\n  \
    \      }\n        last if $done;\n        $collisions++;\n    }\n    return $collisions;\n\
    }", "    return $n*($n-1)/2;\n}", "    if($n==0){\n        return 0;\n    }\n\
    \    if($n==1){\n        return 0;\n    }\n    if($n==2){\n        return 1;\n\
    \    }\n    #if($n==3){\n    #    return 2;\n    #}\n    #if($n==4){\n    #  \
    \  return 4;\n    #}\n    return car_race_collision($n-1) + car_race_collision($n-2);\n\
    }", "    my $l = 1;\n    my $collisions = 0;\n    for (1..$n) {\n        if ($l\
    \ == 1) {\n            $collisions++;\n            $l = -1;\n        } else {\n\
    \            $l = 1;\n        }\n    }\n    return $collisions;\n}", "    $n ||=\
    \ 0;\n    if ($n <= 1) {\n        return 0;\n    }\n    return $n*($n-1)/2;\n}",
  "    my $count = 0;\n    for my $i (1..$n) {\n        for my $j ($i+1..$n) {\n \
    \           if ($i + $j == $n) {\n                $count++;\n            }\n \
    \       }\n    }\n    return $count;\n}", "    my $c = 0;\n    for my $i (0..$n-1)\
    \ {\n        for my $j ($i+1..$n-1) {\n            $c++ if $i == $j;\n       \
    \ }\n    }\n    return $c;\n}", "    return 0 if $n <= 1;\n    return $n*($n-1)/2;\n\
    }", "    my($left) = 0;\n    my($right) = 0;\n    my($collision) = 0;\n    foreach\
    \ $i (1..$n) {\n        $left++;\n        $right++;\n        $collision += $left\
    \ * $right;\n    }\n    return $collision;\n}", "    my $collisions = 0;\n   \
    \ my $cars_left  = 0;\n    my $cars_right = 0;\n    while ($cars_left < $n and\
    \ $cars_right < $n) {\n        my $dist = $cars_left - $cars_right;\n        my\
    \ $d1 = abs($dist-1);\n        my $d2 = abs($dist+1);\n        $collisions +=\
    \ min($d1, $d2);\n        ++$cars_left;\n        ++$cars_right;\n    }\n    return\
    \ $collisions;\n}", "    my $i = 1;\n    my $num_collisions = 0;\n    while ($i\
    \ <= $n) {\n        $num_collisions += ($n-$i+1);\n        $i++;\n    }\n    return\
    \ $num_collisions;\n}\nprint car_race_collision(3), \"\\n\";\nprint car_race_collision(5),\
    \ \"\\n\";\nprint car_race_collision(1), \"\\n\";\nprint car_race_collision(2),\
    \ \"\\n\";\nprint car_race_collision(0), \"\\n\";", "    my $count = 0;\n    my\
    \ $j = 0;\n    for my $i (0..$n-1) {\n        while ($j < $n) {\n            if\
    \ ($j < $i) {\n                $count++;\n            } else {\n             \
    \   last;\n            }\n            $j++;\n        }\n    }\n    return $count;\n\
    }", "    my $num_collisions = 0;\n    my @left_cars = 1..$n;\n    my @right_cars\
    \ = reverse @left_cars;\n    while (@left_cars and @right_cars) {\n        my\
    \ $left_car = shift @left_cars;\n        my $right_car = shift @right_cars;\n\
    \        if ($left_car == $right_car) {\n            $num_collisions++;\n    \
    \    }\n        else {\n            push @left_cars, $left_car;\n            push\
    \ @right_cars, $right_car;\n        }\n    }\n    return $num_collisions;\n}",
  "    my $r = int(sqrt($n));\n    return $r * ($r-1) * ($r-2) * ($r-3) / 24;\n}",
  "    my $i = 0;\n    my $c = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $c +=\
    \ $i;\n    }\n    return $c;\n}", "    my $counter = 0;\n    for(my $i = 0; $i\
    \ < $n; $i++) {\n        for(my $j = 0; $j < $n; $j++) {\n            $counter++;\n\
    \        }\n    }\n    return $counter;\n}", "    my($left_to_right_positions,\
    \ $right_to_left_positions) = ([], []);\n    foreach my $i (0..$n-1) {\n     \
    \   push @$left_to_right_positions, $i;\n        push @$right_to_left_positions,\
    \ $n-1-$i;\n    }\n    my($collisions) = 0;\n    foreach my $i (0..$n-1) {\n \
    \       foreach my $j (0..$n-1) {\n            if ($left_to_right_positions->[$i]\
    \ == $right_to_left_positions->[$j]) {\n                $collisions++;\n     \
    \       }\n        }\n    }\n    return $collisions;\n}", "    return 0 if $n\
    \ < 2;\n    my $n_pairs = $n * ($n - 1) / 2;\n    my $n_collision = 0;\n    for\
    \ (my $i = 1; $i < $n; $i++) {\n        $n_collision += $i;\n    }\n    return\
    \ $n_collision;\n}", "    my $count = 0;\n    # Complete this function\n    for(my\
    \ $i=0;$i<$n;$i++){\n        for(my $j=0;$j<$n;$j++){\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my $collision = 0;\n    my $left_to_right\
    \ = 1;\n    my $right_to_left = 1;\n    while ($left_to_right < $n || $right_to_left\
    \ < $n) {\n        if ($left_to_right < $right_to_left) {\n            $left_to_right\
    \ = $left_to_right + 1;\n        }\n        elsif ($right_to_left < $left_to_right)\
    \ {\n            $right_to_left = $right_to_left + 1;\n        }\n        else\
    \ {\n            $left_to_right = $left_to_right + 1;\n            $right_to_left\
    \ = $right_to_left + 1;\n            $collision = $collision + 1;\n        }\n\
    \    }\n    return $collision;\n}", "    my($i, $j, $result);\n    $result = 0;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n  \
    \          $result += $i < $j ? 0 : 1;\n        }\n    }\n    return $result;\n\
    }", "    my $num_collisions = 0;\n    my @left_cars_pos = (0 .. $n-1);\n    my\
    \ @right_cars_pos = (0 .. $n-1);\n    while (@left_cars_pos || @right_cars_pos)\
    \ {\n        my $left_pos = shift @left_cars_pos;\n        my $right_pos = shift\
    \ @right_cars_pos;\n        if ($left_pos > $right_pos) {\n            $num_collisions\
    \ += 1;\n            push @right_cars_pos, $right_pos;\n        } else {\n   \
    \         push @left_cars_pos, $left_pos;\n            push @right_cars_pos, $right_pos;\n\
    \        }\n    }\n    return $num_collisions;\n}", "    die unless defined $n;\n\
    \    die unless $n >= 0;\n    die unless $n == int($n);\n    return 0 if $n ==\
    \ 0;\n    return 1 if $n == 1;\n    return 2 if $n == 2;\n    return int($n/2);\n\
    }", "    return $n * ($n - 1) / 2;\n}", "    my @A;\n    for (my $i = 0; $i <\
    \ $n; $i++) {\n        push @A, { x => 0, v => $i+1 };\n    }\n    my @B;\n  \
    \  for (my $i = 0; $i < $n; $i++) {\n        push @B, { x => 0, v => $i+1 };\n\
    \    }\n    my $t = 0;\n    while (1) {\n        $t++;\n        for (my $i = 0;\
    \ $i < $n; $i++) {\n            $A[$i]->{x} += $A[$i]->{v};\n            $B[$i]->{x}\
    \ -= $B[$i]->{v};\n        }\n        for (my $i = 0; $i < $n; $i++) {\n     \
    \       for (my $j = 0; $j < $n; $j++) {\n                if ($A[$i]->{x} == $B[$j]->{x})\
    \ {\n                    return $t;\n                }\n            }\n      \
    \  }\n    }\n}", "    return (($n-1)*$n)/2;\n}", "    my $total = 0;\n    for\
    \ (1..$n) {\n        $total += car_race_collision_rec($n, 1, [1..$n], [1..$n]);\n\
    \    }\n    return $total;\n}", "    if ($n <= 1) {\n        return 0;\n    }\n\
    \    # @cnts[i] keeps the number of cars that were moving left to right at point\
    \ i.\n    # @cnts[i] = 0 when i is negative.\n    # @cnts[i] = $n when i is positive.\n\
    \    my @cnts = (0, ($n) x $n);\n    # @negs[i] keeps the number of cars that\
    \ were moving right to left at point i.\n    # @negs[i] = 0 when i is positive.\n\
    \    # @negs[i] = $n when i is negative.\n    my @negs = (0, ($n) x $n);\n   \
    \ my $i = 1;\n    my $total = 0;\n    while ($i <= $n) {\n        my $cnt = $cnts[$i];\n\
    \        my $neg = $negs[-$i];\n        $total += $cnt * $neg;\n        $cnts[$i]\
    \ = $cnt + $negs[$i - 1];\n        $negs[-$i] = $neg + $cnts[-$i + 1];\n     \
    \   $i++;\n    }\n    return $total;\n}", "    return -1 if ($n < 1);\n    return\
    \ 0 if ($n == 1);\n    my @left_to_right = (1..$n);\n    my @right_to_left = reverse(1..$n);\n\
    \    my $collision = 0;\n    for my $i (0..$n-1) {\n        for my $j (0..$n-1)\
    \ {\n            $collision++ if ($left_to_right[$i] == $right_to_left[$j]);\n\
    \        }\n    }\n    return $collision;\n}", "    my $num_collisions = $n;\n\
    \    return $num_collisions;\n}", "    return int( $n*($n-1)/2 );\n}", "    my\
    \ $collisions = 0;\n    for my $i (0..$n-1) {\n        for my $j ($i+1..$n-1)\
    \ {\n            $collisions++;\n        }\n    }\n    return $collisions;\n}",
  "    my $total_collisions = 0;\n    my $left_index = 0;\n    my $right_index = $n\
    \ - 1;\n    while($left_index < $n && $right_index >= 0) {\n        if($left_index\
    \ == $right_index) {\n            $total_collisions++;\n            $left_index++;\n\
    \            $right_index--;\n        } elsif($left_index < $right_index) {\n\
    \            $left_index++;\n        } else {\n            $right_index--;\n \
    \       }\n    }\n    return $total_collisions;\n}", "    my $cols = 0;\n    my\
    \ @l_to_r = (0 .. $n - 1);\n    my @r_to_l = reverse(@l_to_r);\n    my $colliding\
    \ = 1;\n    while ($colliding) {\n        $colliding = 0;\n        foreach my\
    \ $i (0 .. $#l_to_r) {\n            my $j = $l_to_r[$i];\n            my $k =\
    \ $r_to_l[$i];\n            if ($j == $k) {\n                # Collision; move\
    \ the cars to the right.\n                $colliding = 1;\n                $l_to_r[$i]++;\n\
    \                $r_to_l[$i]--;\n                $cols++;\n            }\n   \
    \     }\n    }\n    return $cols;\n}", "    my $num_collisions = 0;\n    for my\
    \ $i (0..$n - 1) {\n        for my $j ($i + 1..$n - 1) {\n            $num_collisions++\
    \ if $i > $j;\n        }\n    }\n    return $num_collisions;\n}", "    my $collision_count\
    \ = 0;\n    my $start_time = 0;", "    my $result = 0;\n    return $result;\n}",
  "    my($collision) = 0;\n    my($car) = 1;\n    while($car <= $n) {\n        if($car\
    \ % 2 == 1) {\n            $collision += $n;\n        }\n        $car++;\n   \
    \ }\n    return $collision;\n}", "    my $result = 0;\n    for (my $i = 0; $i\
    \ < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            if ($i\
    \ > $j) {\n                $result++;\n            }\n        }\n    }\n    return\
    \ $result;\n}", "    my $counter = 0;\n    for (my $i = 0; $i < $n; $i++) {\n\
    \        for (my $j = 0; $j < $n; $j++) {\n            if ($i == $j) {\n     \
    \           next;\n            }\n            if (abs($i - $j) == ($n - 1)) {\n\
    \                next;\n            }\n            $counter++;\n        }\n  \
    \  }\n    return $counter;\n}", "    my @left_to_right;\n    my @right_to_left;\n\
    \    foreach my $i (1..$n) {\n        push @left_to_right, $i;\n        push @right_to_left,\
    \ $n - $i + 1;\n    }\n    my $num_collisions = 0;\n    foreach my $i (0..$n-1)\
    \ {\n        foreach my $j (0..$n-1) {\n            if ($left_to_right[$i] ==\
    \ $right_to_left[$j]) {\n                $num_collisions++;\n            }\n \
    \       }\n    }\n    return $num_collisions;\n}", "    return $n * ($n - 1) /\
    \ 2;\n}", "    my $collision_count = 0;\n    # Initialize $left_car_positions\
    \ and $right_car_positions\n    # At the start, all left cars are to the left\
    \ of all right cars,\n    # and the left cars are all equally far apart, as are\
    \ the right cars.\n    # Each car has a position; the position of a left car is\
    \ the number of\n    # places from the leftmost position; the position of a right\
    \ car is the\n    # number of places from the rightmost position.\n    # If n=3,\
    \ then we start with\n    #   left cars at positions 0, 1, 2\n    #   right cars\
    \ at positions 0, 1, 2\n    # When n=4, we start with\n    #   left cars at positions\
    \ 0, 1, 2, 3\n    #   right cars at positions 0, 1, 2, 3\n    my @left_car_positions\
    \ = ();\n    for(my $i=0; $i<$n; $i++) {\n        push(@left_car_positions, $i);\n\
    \    }\n    my @right_car_positions = ();\n    for(my $i=0; $i<$n; $i++) {\n \
    \       push(@right_car_positions, $i);\n    }\n    # Do the simulation.\n   \
    \ # During each time step, we move the rightmost right car one place to the right,\n\
    \    # and move the leftmost left car one place to the left.\n    # If a left\
    \ car arrives at the same place as a right car, we consider that to be\n    #\
    \ a collision and increment the collision count.\n    # When the rightmost right\
    \ car is at position 2n-1, it has collided with all the\n    # left cars and there\
    \ are no more collisions.\n    while($right_car_positions[-1] < $n*2-1) {\n  \
    \      my $left_right_car_index = max_index(\\@left_car_positions);\n        my\
    \ $right_left_car_index = min_index(\\@right_car_positions);\n        $right_car_positions[$right_left_car_index]++;\n\
    \        $left_car_positions[$left", "    return $n * ($n - 1) / 2;\n}", "   \
    \ my $collision_count = 0;\n    my @L;\n    for (my $i = 0; $i < $n; $i++) {\n\
    \        $L[$i] = $i + 1;\n    }\n    @L = sort {$a <=> $b} @L;\n    my @R;\n\
    \    for (my $i = 0; $i < $n; $i++) {\n        $R[$i] = $n - $i;\n    }\n    @R\
    \ = sort {$a <=> $b} @R;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my\
    \ $j = 0; $j < $n; $j++) {\n            if ($L[$i] > $R[$j]) {\n             \
    \   $collision_count++;\n            }\n        }\n    }\n    return $collision_count;\n\
    }", "    my $n_collisions = 0;\n    for (my $i = 0; $i < $n; $i++) {\n       \
    \ $n_collisions++ if (rand() < 0.5);\n    }\n    return $n_collisions;\n}", " \
    \   my $car_speed = 1;\n    my $car_coord = [];\n    my $collision_time = -1;\n\
    \    for (my $i = 0; $i < $n; $i++) {\n        my $car_speed = 1;\n        my\
    \ $car_coord = [1, $i];\n        my $car_opposite_speed = -1;\n        my $car_opposite_coord\
    \ = [-1, $i];\n        my $car_right_speed = 1;\n        my $car_right_coord =\
    \ [1, -$i];\n        my $car_left_speed = -1;\n        my $car_left_coord = [-1,\
    \ -$i];\n        # We know that the $i-th right-to-left car will collide with\
    \ the $i-th left-to-right car,\n        # and the $i-th left-to-right car will\
    \ collide with the $i-th right-to-left car.\n        # We have already accounted\
    \ for the case of the $i-th left-to-right car colliding with\n        # the $i-th\
    \ right-to-left car.\n        # So we account for the case of the $i-th right-to-left\
    \ car colliding with the $i-th left-to-right car.\n        $collision_time = max($collision_time,\
    \ abs($car_coord->[1] - $car_opposite_coord->[1]) / $car_speed);\n        # We\
    \ know that the $i-th right-to-left car will collide with the $i-th left-to-right\
    \ car,\n        # and the $i-th left-to-right car will collide with the $i-th\
    \ right-to-left car.\n        # We have already accounted for the case of the\
    \ $i-th right-to-left car colliding with\n        # the $i-th left-to-right car.\n\
    \        # So we account for the case of the $i-th left-to-right car colliding\
    \ with the $i-th right-to-left car.\n        $collision_time = max($collision_time,\
    \ abs($car_right_coord->[1] - $car", "    die \"n must be a positive integer\"\
    \ unless $n =~ /^\\d+$/;\n    return 0 if $n == 0;\n    return $n-1 if $n == 1;\n\
    \    my $i = 1;\n    my $j = 1;\n    my $collision = 0;\n    while($i <= $n) {\n\
    \        $j = 1;\n        while($j <= $n) {\n            # left side car i collides\
    \ with right side car j\n            $collision++;\n            $j++;\n      \
    \  }\n        $i++;\n    }\n    return $collision;\n}", "    my $i = 0;\n    my\
    \ $j = $n - 1;\n    my $collisions = 0;\n    while($i < $n && $j >= 0) {\n   \
    \     if($i == $j) {\n            $collisions += 1;\n        }\n        else {\n\
    \            $collisions += 2;\n        }\n        $i += 1;\n        $j -= 1;\n\
    \    }\n    return $collisions;\n}", "    my($sum) = 0;\n    my($start) = time();\n\
    \    while ($n > 0) {\n        my($j) = $n - 1;\n        while ($j > 0) {\n  \
    \          $sum++;\n            $j--;\n        }\n        $n--;\n    }\n    my($end)\
    \ = time();\n    my($diff) = $end - $start;\n    print(\"car_race_collision took\
    \ $diff seconds\\n\");\n    return $sum;\n}", "    my $num_collisions = 0;\n \
    \   if ($n > 0) {\n        my $left_to_right_cars = [ map { 1 } (1..$n) ];\n \
    \       my $right_to_left_cars = [ map { 1 } (1..$n) ];\n        my $midpoint\
    \ = $n;\n        for my $i (1..$n) {\n            if ($i <= $midpoint) {\n   \
    \             $midpoint += shift @$left_to_right_cars;\n            } else {\n\
    \                $midpoint -= shift @$right_to_left_cars;\n            }\n   \
    \         $num_collisions++ if ($i > $midpoint);\n        }\n    }\n    return\
    \ $num_collisions;\n}", "    die \"ERROR: number of cars must be positive\" unless\
    \ $n > 0;\n    my $left = 1;\n    my $right = 1;\n    my $counter = 0;\n    for\
    \ (1..$n) {\n        if ($left == $right) {\n            $counter++;\n       \
    \ }\n        $left += 1;\n        $right -= 1;\n    }\n    return $counter;\n}",
  "    my $num_collisions = 0;\n    my @positions_rl = (1..$n);\n    my @positions_lr\
    \ = reverse @positions_rl;\n    for my $i (0..$n-1) {\n        for my $j (0..$n-1)\
    \ {\n            if ($positions_rl[$i] == $positions_lr[$j]) {\n             \
    \   ++$num_collisions;\n            }\n        }\n    }\n    return $num_collisions;\n\
    }", "    my @left_to_right = (1 .. $n);\n    my @right_to_left = (reverse 1 ..\
    \ $n);\n    my $collisions = 0;\n    while (scalar @left_to_right > 0 && scalar\
    \ @right_to_left > 0) {\n        if ($left_to_right[0] == $right_to_left[0]) {\n\
    \            $collisions++;\n            shift @left_to_right;\n            shift\
    \ @right_to_left;\n        } elsif ($left_to_right[0] < $right_to_left[0]) {\n\
    \            shift @left_to_right;\n        } else {\n            shift @right_to_left;\n\
    \        }\n    }\n    return $collisions;\n}", "    my $num_collisions = 0;\n\
    \    my %set_left;", "    my $num_collisions = 0;\n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            if ($i + $j ==\
    \ $n - 1) {\n                $num_collisions++;\n            }\n        }\n  \
    \  }\n    return $num_collisions;\n}", "    my $ret = 0;\n    my $i;\n    for($i\
    \ = 1; $i <= $n; $i++) {\n        $ret += ($i-1);\n    }\n    return $ret;\n}",
  "    my $s = 0;\n    foreach my $i (1..$n) {\n        $s += $i - 1;\n    }\n   \
    \ return $s;\n}", "    my $n2 = $n * 2;\n    my $half_n = int($n / 2);\n    my\
    \ $half_n2 = int($n2 / 2);\n    if ($n % 2 == 0) {\n        return $half_n * ($half_n\
    \ - 1);\n    }\n    else {\n        return $half_n * ($half_n + 1);\n    }\n}",
  "    if($n < 2) { return 0; }\n    my $x = rand();\n    my $y = rand();\n    my\
    \ $collisions = 0;\n    for(my $i = 0; $i < $n; $i++) {\n        my $a = $x;\n\
    \        my $b = $y;\n        $x = $y + rand();\n        $y = $a + rand();\n \
    \       $collisions++ if ($x > $y && $a < $b);\n    }\n    return $collisions;\n\
    }", "    return $n * ($n - 1) / 2;\n}", "    # If there are no cars, the answer\
    \ is 0.\n    return 0 if ($n == 0);\n    # If there is only one car, there is\
    \ no collision.\n    return 0 if ($n == 1);\n    # If there are 2 cars, there\
    \ will be 1 collision.\n    return 1 if ($n == 2);\n    # If there are 3 cars,\
    \ there will be 3 collisions.\n    return 3 if ($n == 3);\n    # If there are\
    \ 4 cars, there will be 6 collisions.\n    return 6 if ($n == 4);\n    # If there\
    \ are 5 cars, there will be 10 collisions.\n    return 10 if ($n == 5);\n    #\
    \ If there are 6 cars, there will be 15 collisions.\n    return 15 if ($n == 6);\n\
    \    # If there are 7 cars, there will be 21 collisions.\n    return 21 if ($n\
    \ == 7);\n    # If there are 8 cars, there will be 28 collisions.\n    return\
    \ 28 if ($n == 8);\n    # If there are 9 cars, there will be 36 collisions.\n\
    \    return 36 if ($n == 9);\n    # If there are 10 cars, there will be 45 collisions.\n\
    \    return 45 if ($n == 10);\n    # The above are the first 10 cases.  By Pascal's\
    \ triangle, the answer can be\n    # determined by n_C_2 (n choose 2), which is\
    \ n*(n-1)/2.\n    return $n*($n-1)/2;\n}", "    my $num_collisions = 0;\n    for\
    \ (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n   \
    \         if ($i > $j) {\n                $num_collisions++;\n            }\n\
    \        }\n    }\n    return $num_collisions;\n}", "    return binomial_coeff($n,\
    \ 2);\n}", '    return 0 if $n == 0;', "    return $n * ($n - 1) / 2;\n}", " \
    \   my $pos1 = 0;\n    my $pos2 = $n;\n    my $vel1 = 1;\n    my $vel2 = -1;\n\
    \    my $collisions = 0;\n    for (my $time = 0; $time < $n; $time++) {\n    \
    \    $pos1 += $vel1;\n        $pos2 += $vel2;\n        if ($pos1 == $pos2) {\n\
    \            $collisions++;\n        }\n    }\n    return $collisions;\n}\nprint\
    \ \"example = \", car_race_collision(10), \"\\n\";\nprint \"example = \", car_race_collision(9),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(8), \"\\n\";\nprint \"example\
    \ = \", car_race_collision(7), \"\\n\";\nprint \"example = \", car_race_collision(6),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(5), \"\\n\";\nprint \"example\
    \ = \", car_race_collision(4), \"\\n\";\nprint \"example = \", car_race_collision(3),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(2), \"\\n\";\nprint \"example\
    \ = \", car_race_collision(1), \"\\n\";\nprint \"example = \", car_race_collision(0),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(-1), \"\\n\";\nprint \"example\
    \ = \", car_race_collision(-2), \"\\n\";\nprint \"example = \", car_race_collision(-3),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(-4), \"\\n\";\nprint \"example\
    \ = \", car_race_collision(-5), \"\\n\";\nprint \"example = \", car_race_collision(-6),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(-7), \"\\n\";\nprint \"example\
    \ = \", car_race_collision(-8), \"\\n\";\nprint \"example = \", car_race_collision(-9),\
    \ \"\\n\";\nprint \"example = \", car_race_collision(-10), \"\\n\";\nexit;", " \
    \   my @cars = (0) x $n;\n    my $total = 0;\n    for (my $i = 0; $i < $n; $i++)\
    \ {\n        my $current = int(rand($n));\n        $cars[$current]++;\n      \
    \  $total += $cars[$current] - 1;\n    }\n    return $total;\n}", "    my $collisions\
    \ = 0;\n    for my $j (1..$n) {\n        my $x_left_car = $j;\n        my $x_right_car\
    \ = $n - $j + 1;\n        $collisions += ($n - $j);\n    }\n    return $collisions;\n\
    }", "    return int($n * ($n - 1) / 2);\n}", "    $n = 0 unless $n;\n    return\
    \ $n * ($n - 1) / 2;\n}", "    my $sum = 0;\n    my $sum_n = $n * ($n + 1) / 2;\n\
    \    # if the right-to-left cars are at x coordinate 0 and the left-to-right cars\
    \ are at x\n    # coordinate 1, then x coordinates of the right-to-left cars at\
    \ time i is\n    # 1 / (2*i + 1), and the x coordinates of the left-to-right cars\
    \ is 2*i + 1.\n    # This way, the number of collisions is the number of cars\
    \ where the\n    # x coordinate of the right-to-left car is greater than that\
    \ of the left-to-right car.\n    for (my $i = 0; $i < $n; $i++) {\n        $sum\
    \ += $i * 2 + 1;\n    }\n    return $sum_n - $sum;\n}", "    my $cnt = 0;\n  \
    \  #########\n    # your code goes here\n    #########\n    return $cnt;\n}",
  "    my $res = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0;\
    \ $j < $n; $j++) {\n            if ($i < $j) {\n                $res += $i + $j;\n\
    \            }\n        }\n    }\n    return $res;\n}", "    my $num_collisions\
    \ = 0;\n    for my $i (0..$n-1) {\n        for my $j ($i+1..$n-1) {\n        \
    \    $num_collisions++;\n        }\n    }\n    return $num_collisions;\n}", " \
    \   my($collisions) = 0;\n    # Return 0 if there are no cars\n    return 0 if\
    \ ($n == 0);\n    my($i, $j);\n    # Car $i on the left\n    for ($i = 0; $i <\
    \ $n; $i++) {\n        # Car $j on the right\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            # If the cars are going in opposite directions, we have a collision\n\
    \            $collisions++ if ($i < $j);\n        }\n    }\n    return $collisions;\n\
    }", "    my $num_collisions = 0;\n    for (my $i = 0; $i < $n; $i++) {\n     \
    \   for (my $j = 0; $j < $n; $j++) {\n            $num_collisions++;\n       \
    \ }\n    }\n    return $num_collisions;\n}", "    return 0 if $n <= 1;\n    return\
    \ 1 if $n == 2;\n    return 2 if $n == 3;\n    return car_race_collision($n -\
    \ 2) + 1;\n}", "    my $result = 0;\n    my $count = 0;\n    my $car_count = 0;\n\
    \    my $car_positions = [];\n    for (my $i = 0; $i < $n; $i++) {\n        $car_positions->[$i]\
    \ = 0;\n    }\n    my $car_directions = [];\n    for (my $i = 0; $i < $n; $i++)\
    \ {\n        $car_directions->[$i] = 0;\n    }\n    while ($count < ($n * 2) -\
    \ 1) {\n        # move cars\n        for (my $i = 0; $i < $n; $i++) {\n      \
    \      $car_positions->[$i]++;\n        }\n        # move other cars\n       \
    \ for (my $i = 0; $i < $n; $i++) {\n            $car_positions->[$n + $i]--;\n\
    \        }\n        # check collisions\n        for (my $i = 0; $i < $n; $i++)\
    \ {\n            for (my $j = 0; $j < $n; $j++) {\n                if ($car_positions->[$i]\
    \ == $car_positions->[$n + $j]) {\n                    $result++;\n          \
    \      }\n            }\n        }\n        $count++;\n    }\n    return $result;\n\
    }", "    my $l_to_r = 1;\n    my $r_to_l = $n;\n    my $i = 0;\n    for ($i =\
    \ 1; $i <= $n; $i++) {\n        $l_to_r += $i;\n        $r_to_l -= $i;\n     \
    \   $l_to_r += $i + 1;\n        $r_to_l -= $i + 1;\n    }\n    return $l_to_r;\n\
    }", "    return $n*($n-1)/2;\n}", "    # return 0 if there are no cars\n    return\
    \ 0 if $n == 0;\n    # the last car on the right or the last car on the left\n\
    \    # can't hit any other car because they're both last\n    return 0 if $n ==\
    \ 1;\n    # recursion:  we can remove the last car on the right, \n    # then\
    \ remove the last car on the left,\n    # and add to that the number of collisions\
    \ between the two sets of cars\n    return 2 * (car_race_collision($n - 1)) +\
    \ $n - 1;\n}", "    my $ret = 0;\n    $ret += ($n - $_) * $_ for(1..$n);\n   \
    \ return $ret;\n}", "    my $collision = 0;\n    if($n % 2 == 0) {\n        $collision\
    \ = ($n / 2) * ($n - 1);\n    } else {\n        $collision = ($n - 1) * ($n -\
    \ 1) / 2;\n    }\n    return $collision;\n}", "    my $collisions = 0;\n    return\
    \ 0 if($n < 2);\n    # This function relies on the fact that, when the cars start\
    \ out being very far from\n    # each other, the first collision will necessarily\
    \ be between the first and last cars.\n    # That being the case, the rest of\
    \ the cars do not matter.\n    # Also, every time there's a collision, we're guaranteed\
    \ to have n - 2 cars left.\n    # So, we just have a recurrent formula.\n    my\
    \ $cars_left = $n;\n    while($cars_left > 1) {\n        $collisions++;\n    \
    \    $cars_left -= 2;\n    }\n    return $collisions;\n}", "    my @r = car_race_positions($n);\n\
    \    my @l = reverse @r;", "    return $n * ($n - 1) / 2;\n}", "    my($dist)\
    \ = 100;   # distance between 2 cars\n    my($left_to_right_speed) = 1;\n    my($right_to_left_speed)\
    \ = 1;\n    my($left_to_right_time) = $dist / $left_to_right_speed;\n    my($right_to_left_time)\
    \ = $dist / $right_to_left_speed;\n    my($collision_time) = $left_to_right_time\
    \ + $right_to_left_time;\n    return ( $collision_time * $n );\n}", "    my $left\
    \ = q[];\n    my $right = q[];\n    for (1..$n) {\n        $left .= 'L';\n   \
    \     $right .= 'R';\n    }\n    my $combos = all_combos($left, $right);\n   \
    \ my $collisions = 0;\n    foreach my $combo (@$combos) {\n        my %right;\n\
    \        while ($combo =~ /R/g) {\n            $right{ pos($combo) } = 1;\n  \
    \      }\n        while ($combo =~ /L/g) {\n            if (exists $right{ pos($combo)\
    \ }) {\n                $collisions++;\n            }\n        }\n    }\n    return\
    \ $collisions;\n}", "    return ($n+1)*$n/2;\n}", "    my $collisions = 0;\n \
    \   my @left = (1..$n);\n    my @right = reverse @left;\n    while (@left && @right)\
    \ {\n        $collisions++ if ($left[0] == $right[0]);\n        shift @left;\n\
    \        shift @right;\n    }\n    return $collisions;\n}", "    # PRECONDITION:\n\
    \    # This function requires that $n be a non-negative integer.\n    $n >= 0\
    \ or die 'Number of cars must be non-negative';\n    # END PRECONDITION\n    return\
    \ 0 * $n;\n}\n1;", "    # If less than 2 cars, no collision can occur\n    if\
    \ ($n < 2) {\n        return 0;\n    }\n    # Case 1: All cars are moving in the\
    \ same direction.  In this case, there\n    # is no collision.\n    # Case 2:\
    \ All cars are moving in opposite directions.  In this case, each\n    # pair\
    \ of cars collides.\n    # Case 3: We have n cars moving left to right, and n\
    \ cars moving right to left.\n    # The leftmost car moving left to right will\
    \ collide with the rightmost car\n    # moving right to left, as well as the 2nd\
    \ to leftmost car moving left to right\n    # will collide with the 2nd to rightmost\
    \ car moving right to left, etc.\n    # Hence, the total number of collision is\
    \ n.\n    return $n;\n}", "    my $collision = 0;\n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            $collision++;\n\
    \        }\n    }\n    return $collision;\n}", "    return $n*($n-1)/2;\n}", " \
    \   my $num_collisions = 0;\n    my @right_to_left_xs = (0) x $n;\n    my @left_to_right_xs\
    \ = (0) x $n;\n    my $x = 0;\n    my $xinc = 1;\n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        $right_to_left_xs[$i] = $x;\n        $x += $xinc;\n       \
    \ $xinc++;\n    }\n    $x = 0;\n    $xinc = 1;\n    for (my $i = 0; $i < $n; $i++)\
    \ {\n        $left_to_right_xs[$i] = $x;\n        $x += $xinc;\n        $xinc++;\n\
    \    }\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n;\
    \ $j++) {\n            if ($right_to_left_xs[$i] > $left_to_right_xs[$j]) {\n\
    \                $num_collisions++;\n            }\n        }\n    }\n    return\
    \ $num_collisions;\n}", "    return $n*($n-1);\n}", "    if ($n <= 1) {\n    \
    \    return 0;\n    }\n    my $left_car = 0;\n    my $right_car = $n - 1;\n  \
    \  my $collision = 0;\n    while ($left_car < $right_car) {\n        $collision++;\n\
    \        $left_car++;\n        $right_car--;\n    }\n    return $collision;\n}",
  '    my($left, $right) = ([], []);', "    my $i = 0;\n    my $j = $n-1;\n    my\
    \ $collision = 0;\n    while ($i < $n) {\n        if (abs($i-$j) == 1) {\n   \
    \         $collision++;\n        }\n        $i++;\n        $j--;\n    }\n    return\
    \ $collision;\n}", "    my $c = 0;\n    while ($n > 0) {\n        my $m = $n;\n\
    \        while ($m > 0) {\n            $c++;\n            $m--;\n        }\n \
    \       $n--;\n    }\n    return $c;\n}", "    return 0 if ($n == 0);\n    my\
    \ $result = 0;\n    $result += car_race_collision($n - 1);\n    $result += $n\
    \ - 1;\n    return $result;\n}", "    my($left_to_right, $right_to_left);\n  \
    \  my($i, $j);\n    my($collisions) = 0;", "    return int($n*($n-1)/2);\n}",
  "    my $collision_count = 0;\n    return $collision_count;\n}", "    my $collision\
    \ = 0;\n    my $left_to_right = Car->new($n);\n    my $right_to_left = Car->new($n);\n\
    \    while ($left_to_right->has_next() and $right_to_left->has_next()) {\n   \
    \     my $left = $left_to_right->next();\n        my $right = $right_to_left->next();\n\
    \        if ($left == $right) {\n            $collision++;\n        }\n    }\n\
    \    return $collision;\n}", "    croak \"n must be a positive integer\" unless\
    \ $n =~ /^\\d+$/;\n    my $collisions = 0;\n    my $sum = $n * ($n - 1) / 2;\n\
    \    while ($n > 0) {\n        $collisions += $sum;\n        $sum -= $n;\n   \
    \     $n--;\n    }\n    return $collisions;\n}", "    my $cars = rand_cars($n);\n\
    \    my $collisions = 0;\n    my $i = 0;\n    while ($i < $n) {\n        my $j\
    \ = $i+1;\n        while ($j < $n) {\n            if ($cars->[$i]{dir} eq $cars->[$j]{dir})\
    \ {\n                if ($cars->[$i]{dir} eq \"r\") {\n                    $collisions++\
    \ if ($cars->[$i]{x} < $cars->[$j]{x});\n                }\n                else\
    \ {\n                    $collisions++ if ($cars->[$i]{x} > $cars->[$j]{x});\n\
    \                }\n            }\n            $j++;\n        }\n        $i++;\n\
    \    }\n    return $collisions;\n}", "    my($collision, $i);\n    for ($i = 0;\
    \ $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($i\
    \ != $j) {\n                $collision++;\n            }\n        }\n    }\n \
    \   return $collision;\n}", "    my $ret = 0;\n    my %l2r;\n    my %r2l;\n  \
    \  for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n\
    \            my $l2r_car = random_uniform();\n            my $r2l_car = random_uniform();\n\
    \            $ret++ if ($l2r_car < $r2l_car);\n        }\n    }\n    return $ret;\n\
    }", "    return int( $n * ( $n - 1 ) / 2 );\n}", "    my $left = 0;\n    my $right\
    \ = 2 * $n - 1;\n    my $collisions = 0;\n    for my $i (0 .. $n - 1) {\n    \
    \    $collisions += $right - $left - 1;\n        $left += 2;\n        $right -=\
    \ 2;\n    }\n    return $collisions;\n}", "    die \"n must be a positive integer\"\
    \ unless $n > 0 && $n == int($n);\n    return (1/2)*$n*($n-1);\n}", "    return\
    \ 0 if $n == 0;\n    my($i, $j, $count) = (0, 0, 0);\n    while ($i < $n) {\n\
    \        $count += ($n - $j) if $n - $j > 0;\n        $i++;\n        $j++;\n \
    \   }\n    return $count;\n}", "    my $sum = 0;\n    my $i = 0;\n    while ($i\
    \ < $n) {\n        $sum += $i + 1;\n        $i++;\n    }\n    return $sum;\n}",
  "    my($t1, $t2) = (0, 0);\n    my($collision) = 0;\n    for (my($i) = 0; $i <\
    \ $n; $i++) {\n        if ($t1 < $t2) {\n            $collision++;\n        }\n\
    \        $t1++;\n        $t2++;\n    }\n    return $collision;\n}", "    # For\
    \ each car that's going left to right, we will keep a list of all the cars\n \
    \   # going right to left that are ahead of it.  For example, suppose there are\
    \ two\n    # cars going left to right: A and B.  And there are two cars going\
    \ right to left:\n    # C and D.  The possible configurations are:\n    # \n \
    \   # A    B    C    D  (1 collision)\n    # A    C    B    D  (1 collision)\n\
    \    # A    C    D    B  (2 collisions)\n    # C    A    B    D  (2 collisions)\n\
    \    # C    A    D    B  (2 collisions)\n    # C    D    A    B  (3 collisions)\n\
    \    #\n    # For the second configuration, A is ahead of one car (C) that's going\
    \ right to left,\n    # and B is ahead of no cars.  For the third configuration,\
    \ A is ahead of two cars\n    # (C and D), and B is ahead of one car (D).  So\
    \ the relationship is that the number\n    # of collisions is always equal to\
    \ the sum of the number of cars going right to left\n    # that are ahead of each\
    \ car going left to right.\n    # \n    # Given that there are n cars going left\
    \ to right, and n cars going right to left,\n    # there are exactly n! possible\
    \ configurations.  Each configuration has a number of\n    # collisions that equals\
    \ the sum of the number of cars going right to left that are\n    # ahead of each\
    \ car going left to right.  So the number of collisions that will\n    # occur\
    \ is equal to the sum of those sums, divided by n!.\n    #\n    # But those sums\
    \ are exactly n(n-1)/2.  So the number of collisions that will occur\n    # is\
    \ equal to n(n-1)/2 divided by n!, which simplifies to n(n-1)/2(n!/(n!)) which\n\
    \    # simplifies to n(n-1)/2.  So that's our answer.\n    return $n * ($n - 1)\
    \ / 2;\n}", "    return 0 if ($n == 0);\n    my @a = (1 .. $n);\n    my @b = reverse\
    \ @a;\n    return collision(\\@a, \\@b);\n}", "    my($i, $j, $collision);\n \
    \   $collision = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            $collision++ if ($i < $j);\n        }\n    }\n  \
    \  return $collision;\n}", "    # handle special cases\n    die unless $n > 0;\n\
    \    return 0 if $n == 1;\n    # The cars that are moving in the same direction\
    \ will never collide.\n    # Thus, let's focus on the cars that are moving in\
    \ opposite directions.\n    # For example, for n = 4, we have the following cars:\n\
    \    #   0 -> 1 -> 2 -> 3 -> 4 <- 5 <- 6 <- 7\n    # where the left to right cars\
    \ are 0, 1, 2, 3 and the right to left cars are 7, 6, 5, 4.\n    # Let's look\
    \ at the left to right cars.  For a pair of cars, let the leading car be i and\n\
    \    # the following car be j.  Then, the distance between the two cars at time\
    \ 0 is i + j + 1.\n    # Note that i + j + 1 = n - 1, so we can focus on the distance\
    \ instead.\n    # Now let's look at the right to left cars.  For a pair of cars,\
    \ let the leading car be k and\n    # the following car be l.  Then, the distance\
    \ between the two cars at time 0 is k + l + 1.\n    # Again, k + l + 1 = n - 1,\
    \ so we can focus on the distance instead.\n    # We know that two cars collide\
    \ when they are in the same position at the same time.\n    # For example, the\
    \ cars i, j and k, l will collide when the distance between i and j is equal\n\
    \    # to the distance between k and l.  And this will happen at time (k + l +\
    \ 1 - i - j - 1) / 2.\n    # The function main() prints this time for n = 4:\n\
    \    # car_race_collision(4) = 2\n    # That is, the collision happens at time\
    \ 2, which is when the leading cars i and k are at\n    # positions 2 and 6, respectively.\n\
    \    # It's easy to see that this collision occurs whenever i + j + 1 = k + l\
    \ + 1.\n    # Thus, if we iterate over all pairs of cars, we can count the number\
    \ of collisions.\n    my $count = 0;\n    for (my $i = 0; $i < $n - 1; $i++) {\n\
    \        for (", '    $n = 10 unless (defined $n);', "    my $collisions = 0;\n\
    \    if($n > 1) {\n        my $left_to_right_cars = [1..$n];\n        my $right_to_left_cars\
    \ = [reverse(1..$n)];\n        my $j = 0;\n        my $k = 0;\n        my $left_to_right_car\
    \ = $left_to_right_cars->[$j];\n        my $right_to_left_car = $right_to_left_cars->[$k];\n\
    \        while($left_to_right_car && $right_to_left_car) {\n            # print\
    \ \"left_to_right_car=$left_to_right_car right_to_left_car=$right_to_left_car\
    \ \\n\";\n            if($left_to_right_car < $right_to_left_car) {\n        \
    \        $j += 1;\n                $left_to_right_car = $left_to_right_cars->[$j];\n\
    \            } elsif($left_to_right_car > $right_to_left_car) {\n            \
    \    $k += 1;\n                $right_to_left_car = $right_to_left_cars->[$k];\n\
    \            } else {\n                $collisions += 1;\n                $j +=\
    \ 1;\n                $k += 1;\n                $left_to_right_car = $left_to_right_cars->[$j];\n\
    \                $right_to_left_car = $right_to_left_cars->[$k];\n           \
    \ }\n        }\n    }\n    return $collisions;\n}", "    my($m) = $n;\n    my($k)\
    \ = 0;\n    my($sum) = 0;\n    while($n > 0) {\n        $sum += $m;\n        $m--;\n\
    \        $n--;\n    }\n    return $sum;\n}", "    my($self) = {\n        n =>\
    \ $n,\n        left_to_right => [],\n        right_to_left => [],\n    };\n  \
    \  $self->{left_to_right} = [map {int(rand(1000))} (1..$n)];\n    $self->{right_to_left}\
    \ = [map {int(rand(1000))} (1..$n)];\n    my($result) = $self->_do_race();\n \
    \   return $result;\n}", "    die \"n must be >= 1\" if $n < 1;\n    return ($n*($n-1))\
    \ / 2;\n}", "    my @a = (1..$n);\n    my @b = reverse @a;\n    my $count = 0;\n\
    \    while (@a) {\n        my $m = pop @a;\n        for (my $i = 0; $i < @b; $i++)\
    \ {\n            if ($b[$i] > $m) {\n                splice @b, $i, 1;\n     \
    \           $count++;\n                last;\n            }\n        }\n    }\n\
    \    return $count;\n}", "    my @left2right;\n    my @right2left;\n    for(my\
    \ $i = 0; $i < $n; $i++) {\n        $left2right[$i] = rand($n * $n) * $n;\n  \
    \      $right2left[$i] = rand($n * $n) * $n;\n    }\n    my $num_collisions =\
    \ 0;\n    my $i = 0;\n    my $j = 0;\n    while($i < $n && $j < $n) {\n      \
    \  if($left2right[$i] < $right2left[$j]) {\n            $i++;\n        }\n   \
    \     elsif($left2right[$i] > $right2left[$j]) {\n            $j++;\n        }\n\
    \        else {\n            $num_collisions++;\n            $i++;\n         \
    \   $j++;\n        }\n    }\n    return $num_collisions;\n}", "    return ($n*($n-1))/2;\n\
    }", "    my $cnt = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j\
    \ = 0; $j < $n; $j++) {\n            # if the cars drove infinitely long, they\
    \ would cross.\n            # but we know that they can't because they are of\
    \ the same orientation\n            # therefore, if they collide, it means that\
    \ they started out within range\n            # and they can only have collided\
    \ within the first quarter of their total travel distance\n            if (abs($i\
    \ - $j) < abs($i + $j)) {\n                $cnt++;\n            }\n        }\n\
    \    }\n    return $cnt;\n}", "    my $count = 0;\n    my @cars_left = map { 0\
    \ } (1..$n);\n    my @cars_right = map { $n } (1..$n);\n    my $i = 0;\n    my\
    \ $j = $n - 1;\n    for(my $k = 0; $k < $n; $k++) {\n        if($cars_left[$i]\
    \ < $cars_right[$j]) {\n            $count++;\n            $i++;\n        } else\
    \ {\n            $j--;\n        }\n    }\n    return $count;\n}", "    my $collision\
    \ = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n;\
    \ $j++) {\n            $collision++ if ($i != $j);\n        }\n    }\n    return\
    \ $collision;\n}", "    my $collisions = 0;\n    my %car_position;\n    my $i;\n\
    \    my $j;\n    my $time;\n    my $car;\n    my $position;\n    my $position2;\n\
    \    my $direction;\n    my $min_pos = -1;\n    my $max_pos = -1;\n    my $result;",
  "    my($i, $j, $k, $s);\n    # generate a random permutation of the numbers 1..n.\n\
    \    # each value i in the permutation corresponds to a car.\n    # the sign of\
    \ i is positive if the car is driving left to right,\n    # and negative if the\
    \ car is driving right to left.\n    # the absolute value of i is the starting\
    \ position of the car.\n    # we can find the number of collisions by a naive\
    \ O(n^2) loop\n    # over all the cars.\n    for ($i = 0; $i < $n; $i++) {\n \
    \       $j = $i - $n + 1;\n        $s = 1;\n        for ($k = $n; $k > $i; $k--)\
    \ {\n            $s = ($s * $k) % $M;\n        }\n        $j = ($j * $s) % $M;\n\
    \        $s = 1;\n        for ($k = $n; $k > $n - $i - 1; $k--) {\n          \
    \  $s = ($s * $k) % $M;\n        }\n        $j = ($j * $s) % $M;\n        $s =\
    \ power(2, $n - $i - 1);\n        $j = ($j * $s) % $M;\n        $s = power(2,\
    \ $i);\n        $j = ($j * $s) % $M;\n        $s = ($s * (2 * $i + 1)) % $M;\n\
    \        $j = ($j * $s) % $M;\n        $s = power(2, $n);\n        $j = ($j *\
    \ $s) % $M;\n        $t = ($t + $j) % $M;\n    }\n    return($t);\n}", "    my\
    \ $count = 0;\n    for my $i (1..$n) {\n        for my $j ($i+1..$n) {\n     \
    \       $count++ if $i == $n-$j+1;\n        }\n    }\n    return $count;\n}",
  "    return $n * ($n - 1) / 2;\n}", "    my $num_collisions = 0;\n    my @x = ();\n\
    \    my @v = ();\n    for(my $i = 0; $i < $n; $i++) {\n        $x[$i] = Math::BigInt->new(rand(100000));\n\
    \        $v[$i] = Math::BigInt->new(rand(100000));\n    }\n    for(my $i = 0;\
    \ $i < $n; $i++) {\n        for(my $j = 0; $j < $n; $j++) {\n            # the\
    \ equation is\n            # x[i] + t * v[i] = x[j] - t * v[j]\n            #\
    \ where t > 0\n            #\n            # re-arrange the equation as\n     \
    \       #\n            # x[i] + t * v[i] - x[j] + t * v[j] = 0\n            #\n\
    \            # t * (v[i] - v[j]) = x[j] - x[i]\n            #\n            # t\
    \ = (x[j] - x[i]) / (v[i] - v[j])\n            #\n            # Note that t >\
    \ 0 for the cars to collide.\n            #\n            # x[i] > x[j]\n     \
    \       # v[i] > v[j]\n            # This is necessary because the cars must move\
    \ opposite directions in order to\n            # collide.\n            if(($x[i]\
    \ > $x[j]) && ($v[i] > $v[j])) {\n                my $t = ($x[j] - $x[i]) / ($v[i]\
    \ - $v[j]);\n                if($t > 0) {\n                    $num_collisions++;\n\
    \                }\n            }\n        }\n    }\n    return $num_collisions;\n\
    }", "    my $car_race_collision = 0;\n    my $i = 0;\n    my $j = 0;\n    my $k\
    \ = 0;\n    my $a = 0;\n    my $b = 0;\n    for($i = 0; $i < $n; $i++){\n    \
    \    for($j = 0; $j < $n; $j++){\n            for($k = 0; $k < $n; $k++){\n  \
    \              for($a = 0; $a < $n; $a++){\n                    for($b = 0; $b\
    \ < $n; $b++){\n                        $car_race_collision++;\n             \
    \       }\n                }\n            }\n        }\n    }\n    return $car_race_collision;\n\
    }", "    my $collision = 0;\n    my @cars_left;\n    my @cars_right;\n    for\
    \ (my $i = 0; $i < $n; $i++) {\n        $cars_left[$i] = $i;\n        $cars_right[$i]\
    \ = $i;\n    }\n    # print(\"left: @cars_left\\n\");\n    # print(\"right: @cars_right\\\
    n\");\n    while (scalar(@cars_left) > 0 && scalar(@cars_right) > 0) {\n     \
    \   my $left_car = shift(@cars_left);\n        my $right_car = shift(@cars_right);\n\
    \        if ($left_car < $right_car) {\n            # print(\"left-left collision:\
    \ $left_car, $right_car\\n\");\n            push(@cars_left, $right_car);\n  \
    \          $collision++;\n        }\n        else {\n            # print(\"right-right\
    \ collision: $left_car, $right_car\\n\");\n            push(@cars_right, $left_car);\n\
    \            $collision++;\n        }\n    }\n    return $collision;\n}", "  \
    \  my($ret) = 0;\n    if ($n >= 2) {\n        $ret = 0;\n        for my $i (1\
    \ .. $n) {\n            $ret += ($i - 1);\n        }\n    }\n    return $ret;\n\
    }", "    return 0;\n}", '    $n = abs(int($n));', "    # TODO\n}", "    my @cars;\n\
    \    my $ret = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        my $tmp = Car->new();\n\
    \        push @cars, $tmp;\n    }\n    for (my $i = 0; $i < $n; $i++) {\n    \
    \    my $tmp = Car->new();\n        push @cars, $tmp;\n    }\n    foreach my $i\
    \ (0..$#cars-1) {\n        foreach my $j ($i+1..$#cars) {\n            if (same_point($cars[$i],\
    \ $cars[$j])) {\n                $ret++;\n            }\n        }\n    }\n  \
    \  return $ret;\n}", "    my($num_collisions) = 0;\n    for(my($i) = 0; $i < $n;\
    \ $i++) {\n        for(my($j) = 0; $j < $n; $j++) {\n            $num_collisions++;\n\
    \        }\n    }\n    return $num_collisions;\n}", "    return $n * ($n - 1)\
    \ / 2;\n}", "    $n = (2*$n-1);\n    return ($n*($n+1))/2;\n}", "    return $n\
    \ * ($n - 1) / 2;\n}", "    my $collisions = 0;\n    for (my $i = 0; $i < $n;\
    \ $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            $collisions++\
    \ if $i < $j;\n        }\n    }\n    return $collisions;\n}", "    if($n == 0)\
    \ {\n        return 0;\n    }\n    return car_race_collision($n - 1) + $n - 1;\n\
    }", "    my $num = 0;\n    my @left = (1 .. $n);\n    my @right = reverse 1 ..\
    \ $n;\n    while(@left > 0 and @right > 0) {\n        my $l = shift @left;\n \
    \       my $r = shift @right;\n        if($l == $r) {\n            $num++;\n \
    \       }\n        else {\n            unshift @left, $l;\n            unshift\
    \ @right, $r;\n        }\n    }\n    return $num;\n}", "    my $ans = 0;\n   \
    \ return 0;\n}", "    my $ret = 0;\n    my %right_left;\n    my %left_right;\n\
    \    for (my $i = 0; $i < $n; $i++) {\n        $right_left{$i} = $i + $n;\n  \
    \      $left_right{$i + $n} = $i;\n    }\n    my $next = $n;\n    for (my $i =\
    \ 0; $i < $n; $i++) {\n        if ($left_right{$i}) {\n            # This car\
    \ is coming from the left.\n            # It will have collision with the next\
    \ car from the right.\n            $ret++;\n            my $left_car = $i;\n \
    \           my $right_car = $right_left{$next};\n            $right_left{$next}\
    \ = $left_right{$left_car};\n            $left_right{$left_car} = undef;\n   \
    \         $left_right{$right_car} = undef;\n            $next++;\n        }\n\
    \    }\n    return $ret;\n}", "    my $X = [1..$n];  # this is the set of cars,\
    \ left to right\n    my $Y = [$n..1];  # this is the set of cars, right to left\n\
    \    my $xpos = 0;     # leftmost car, left to right\n    my $ypos = 0;     #\
    \ rightmost car, right to left\n    my $collision = 0;\n    for (my $i = 0; $i\
    \ < $n; $i++) {\n        my $x = $X->[$i];\n        my $y = $Y->[$i];\n      \
    \  if ($x + $xpos > $y + $ypos) {\n            $collision++;\n        }\n    \
    \    $xpos += $x;\n        $ypos += $y;\n    }\n    return $collision;\n}", " \
    \   my($i, $j, $collisions) = (0, 0, 0);\n    for($i = 0; $i < $n; $i++){\n  \
    \      for($j = 0; $j < $n; $j++){\n            $collisions++;\n        }\n  \
    \  }\n    return $collisions;\n}", "    my($i, $j, $count);\n    $count = 0;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n  \
    \          if ($i < $j) {\n                $count++;\n            }\n        }\n\
    \    }\n    return $count;\n}", "    if ($n < 1) {\n        return 0;\n    }\n\
    \    return (($n - 1) * $n) / 2;\n}", "    die \"n must be nonnegative\" if $n\
    \ < 0;\n    return 0 if $n == 0;\n    return 1 if $n == 1;\n    return 0 if $n\
    \ == 2;\n    # n > 2\n    return n * (n - 1) / 2;\n}", "    return 0 if ($n ==\
    \ 0);\n    return car_race_collision($n-1) + 2*$n - 1;\n}", "    my $left_right_cars_loc\
    \ = {};\n    my $right_left_cars_loc = {};\n    for my $i (1..$n) {\n        $left_right_cars_loc->{$i}\
    \ = 0;\n        $right_left_cars_loc->{$i} = $n;\n    }\n    # a collision is\
    \ when two keys in these two hashes have the same value\n    # move the cars toward\
    \ each other\n    my $tick = 0;\n    my $collision_cnt = 0;\n    while ($tick\
    \ < 2*$n) {\n        $tick++;\n        foreach my $id (keys %$left_right_cars_loc)\
    \ {\n            $left_right_cars_loc->{$id} += 1;\n        }\n        foreach\
    \ my $id (keys %$right_left_cars_loc) {\n            $right_left_cars_loc->{$id}\
    \ -= 1;\n        }\n        # check for collisions\n        foreach my $id (keys\
    \ %$left_right_cars_loc) {\n            my $loc = $left_right_cars_loc->{$id};\n\
    \            if (exists $right_left_cars_loc->{$loc}) {\n                $collision_cnt++;\n\
    \            }\n        }\n    }\n    return $collision_cnt;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
