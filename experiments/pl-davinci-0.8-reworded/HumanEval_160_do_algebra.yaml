name: HumanEval_160_do_algebra
language: pl
prompt: "# Given two arrays operator, and operand. The first array has basic algebra\
  \ operations, and \n# the second array is an array of integers. Use the two given\
  \ arrays to build the algebric \n# expression and return the evaluation of this\
  \ expression.\n# The basic algebra operations:\n# Addition ( + ) \n# Subtraction\
  \ ( - ) \n# Multiplication ( * ) \n# Floor division ( // ) \n# Exponentiation (\
  \ ** ) \n# Example:\n# operator['+', '*', '-']\n# array = [2, 3, 4, 5]\n# result\
  \ = 2 + 3 * 4 - 5\n# => result = 9\n# Note:\n# The length of operator array is equal\
  \ to the length of operand array minus one.\n# Operand is an array of of non-negative\
  \ integers.\n# Operator array has at least one operator, and operand array has at\
  \ least two operands.\nsub do_algebra {\n    my($operator, $operand) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&do_algebra;\n\
  \        if(eq_deeply($candidate->([\"**\", \"*\", \"+\"], [2, 3, 4, 5]),37)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  +\", \"*\", \"-\"], [2, 3, 4, 5]),9)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([\"//\", \"*\"], [7, 3, 4]),8))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $result = pop @$operand;\n    while (my $op = pop @$operator)\
    \ {\n        my $oper = pop @$operand;\n        $result = $oper eq '+' ? $result\
    \ + $oper\n               : $oper eq '-' ? $result - $oper\n               : $oper\
    \ eq '*' ? $result * $oper\n               : $oper eq '//' ? int($result / $oper)\n\
    \               : $oper eq '**' ? $result ** $oper\n               :         \
    \        $result;\n    }\n    return $result;\n}", "    my $result = $operand->[0];\n\
    \    for (my $i = 0; $i < scalar @$operator; $i++) {\n        $result = calculate($result,\
    \ $operator->[$i], $operand->[$i + 1]);\n    }\n    return $result;\n}", "   \
    \ my $result = shift @$operand;\n    while (@$operator) {\n        my $op = shift\
    \ @$operator;\n        my $val = shift @$operand;\n        if ($op eq '+') {\n\
    \            $result += $val;\n        } elsif ($op eq '-') {\n            $result\
    \ -= $val;\n        } elsif ($op eq '*') {\n            $result *= $val;\n   \
    \     } elsif ($op eq '//') {\n            $result //= $val;\n        } elsif\
    \ ($op eq '**') {\n            $result **= $val;\n        }\n    }\n    return\
    \ $result;\n}", "    my $result = 0;\n    my $op_index = 0;\n    foreach my $i\
    \ (0..$#$operand){\n        if($i==0){\n            $result = $operand->[$i];\n\
    \        }\n        else{\n            $result = eval \"$result $operator->[$op_index]\
    \ $operand->[$i]\";\n            $op_index++;\n        }\n    }\n    return $result;\n\
    }", "    my $res = @$operand[0];\n    for (my $i = 0; $i < @$operator; $i++) {\n\
    \        my $op = @$operator[$i];\n        my $n1 = @$operand[$i];\n        my\
    \ $n2 = @$operand[$i + 1];\n        $res = eval $res . $op . $n2;\n    }\n   \
    \ return $res;\n}", "    my $result = @$operand[0];\n    for (my $i = 0; $i <\
    \ @$operator; $i++) {\n        $result = eval \"$result $operator->[$i] $operand->[$i+1]\"\
    ;\n    }\n    return $result;\n}", "    my $result = $operand->[0];\n    for (my\
    \ $i = 0; $i < @$operator; $i++) {\n        my $op = $operator->[$i];\n      \
    \  my $num = $operand->[$i + 1];\n        if ($op eq '+') {\n            $result\
    \ += $num;\n        } elsif ($op eq '-') {\n            $result -= $num;\n   \
    \     } elsif ($op eq '*') {\n            $result *= $num;\n        } elsif ($op\
    \ eq '//') {\n            $result = int($result / $num);\n        } elsif ($op\
    \ eq '**') {\n            $result **= $num;\n        }\n    }\n    return $result;\n\
    }", "    return 0 if !@$operator;\n    return $operand->[0] if !@$operand;\n \
    \   my $res = $operand->[0];\n    for (1..@$operand-1) {\n        $res = eval\
    \ \"$res $operator->[$_-1] $operand->[$_]\";\n    }\n    return $res;\n}", " \
    \   my $result = $operand->[0];\n    for my $i (0..@$operator - 1) {\n       \
    \ my $op = $operator->[$i];\n        my $val = $operand->[$i + 1];\n        if\
    \ ($op eq '+') {\n            $result += $val;\n        } elsif ($op eq '-') {\n\
    \            $result -= $val;\n        } elsif ($op eq '*') {\n            $result\
    \ *= $val;\n        } elsif ($op eq '//') {\n            $result = int($result\
    \ / $val);\n        } elsif ($op eq '**') {\n            $result **= $val;\n \
    \       }\n    }\n    return $result;\n}", "    my $result = $operand->[0];\n\
    \    for my $i (1..@$operand-1) {\n        $result = eval \"$result $operator->[$i-1]\
    \ $operand->[$i]\";\n    }\n    return $result;\n}", "    my $output = shift @$operand;\n\
    \    for my $i (0..@$operator-1) {\n        $output = eval \"$output $operator->[$i]\
    \ \\$operand->[$i]\";\n    }\n    return $output;\n}", "    my $result = $operand->[0];\n\
    \    for my $i ( 0 .. $#$operator ) {\n        $result = do_op($result, $operator->[$i],\
    \ $operand->[$i+1]);\n    }\n    return $result;\n}", "    return if scalar @$operator\
    \ + 1 != scalar @$operand;\n    return if scalar @$operator == 0 || scalar @$operand\
    \ == 0;\n    return if grep { /\\D/ } @$operand;", "    return 0 if @$operator\
    \ != @$operand - 1;\n    my $result = shift @$operand;\n    for my $i (0..@$operator-1)\
    \ {\n        my $op = $operator->[$i];\n        my $a = $operand->[$i];\n    \
    \    $result = eval \"$result $op $a\";\n    }\n    return $result;\n}", "   \
    \ my $res = shift @$operand;\n    while (@$operator) {\n        my $op = shift\
    \ @$operator;\n        my $num = shift @$operand;\n        given ($op) {\n   \
    \         when ('+') { $res += $num }\n            when ('-') { $res -= $num }\n\
    \            when ('*') { $res *= $num }\n            when ('//') { $res = int($res\
    \ / $num) }\n            when ('**') { $res **= $num }\n        }\n    }\n   \
    \ return $res;\n}", "    my @expression = map { [ $operator->[$_], $operand->[$_],\
    \ $operand->[$_+1] ] } 0..scalar(@$operator)-1;\n    print \"expression: @$_->[0]\
    \ @$_->[1] @$_->[2]\\n\" for @expression;\n    my $r = $expression[0]->[1];\n\
    \    foreach my $e (@expression) {\n        $r = do { $e->[0] eq '+' ? $r + $e->[2]\
    \ :\n                  $e->[0] eq '-' ? $r - $e->[2] :\n                  $e->[0]\
    \ eq '*' ? $r * $e->[2] :\n                  $e->[0] eq '//' ? int($r / $e->[2])\
    \ :\n                  $e->[0] eq '**' ? $r ** $e->[2] :\n                  die\
    \ \"unknown operator: $e->[0]\";\n        };\n    }\n    return $r;\n}", "   \
    \ my $result = shift @$operand;\n    for my $i (0..$#$operator) {\n        $result\
    \ = $result->${\\$operator->[$i]}($operand->[$i]);\n    }\n    return $result;\n\
    }", "    my $result = $operand->[0];\n    for my $i (1..$#$operand) {\n      \
    \  $result = $result->${\\$operator->[$i-1]}($operand->[$i]);\n    }\n    return\
    \ $result;\n}", "    return 0 if (!$operator || !$operand);\n    my @op = @$operator;\n\
    \    my @oper = @$operand;\n    my $result = shift @oper;\n    while (@op) {\n\
    \        my $op = shift @op;\n        $result = eval \"$result $op \".shift(@oper);\n\
    \    }\n    return $result;\n}", "    my $exp = $operand->[0];\n    for my $i\
    \ (0..@$operator-1) {\n        my $op = $operator->[$i];\n        my $n = $operand->[$i+1];\n\
    \        if ($op eq '+') {\n            $exp += $n;\n        } elsif ($op eq '-')\
    \ {\n            $exp -= $n;\n        } elsif ($op eq '*') {\n            $exp\
    \ *= $n;\n        } elsif ($op eq '//') {\n            $exp = int($exp/$n);\n\
    \        } elsif ($op eq '**') {\n            $exp **= $n;\n        }\n    }\n\
    \    return $exp;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
