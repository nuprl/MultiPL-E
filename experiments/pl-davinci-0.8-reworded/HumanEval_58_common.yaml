name: HumanEval_58_common
language: pl
prompt: "# Return sorted unique common elements for two arrays.\n# >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n\
  \        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
  \ 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return() unless $l1 && $l2;\n    my @l1 = sort @$l1;\n    my @l2\
    \ = sort @$l2;\n    my @l;\n    while (@l1 && @l2) {\n        my $s1 = shift @l1;\n\
    \        my $s2 = shift @l2;\n        my $cmp = $s1 <=> $s2;\n        if ($cmp\
    \ == 0) {\n            push @l, $s1;\n        } elsif ($cmp < 0) {\n         \
    \   unshift @l2, $s2;\n        } else {\n            unshift @l1, $s1;\n     \
    \   }\n    }\n    return @l;\n}", "    my $h1 = _hashify($l1);\n    my $h2 = _hashify($l2);\n\
    \    [sort {$a <=> $b} keys %$h1, keys %$h2];\n}", "    my %h = ();\n    foreach\
    \ my $e (@$l1) {\n        $h{$e} = 1;\n    }\n    my @c = ();\n    foreach my\
    \ $e (@$l2) {\n        if ($h{$e}) {\n            push @c, $e;\n        }\n  \
    \  }\n    return scalar(@c) > 0 ? [sort {$a <=> $b} @c] : [];\n}", "    my(%l1)\
    \ = map {$_ => 1} @$l1;\n    my(@l3) = grep { $l1{$_} } @$l2;\n    return wantarray\
    \ ? sort {$a <=> $b} keys %{ { map { $_ => 1 } @l3 } } :\n                   \
    \    scalar @l3;\n}", "    my %h = map {$_ => undef} @$l1;\n    my @common = grep\
    \ { exists $h{$_} } @$l2;\n    return @common;\n}", "    my %l1;\n    my %l2;\n\
    \    foreach my $e (@$l1) {\n        $l1{$e}++;\n    }\n    foreach my $e (@$l2)\
    \ {\n        $l2{$e}++;\n    }\n    my @out;\n    foreach my $e (keys %l1) {\n\
    \        push @out, $e if $l2{$e};\n    }\n    return sort @out;\n}", "    my\
    \ %h;\n    @h{@$l1} = ();\n    return [ sort { $a <=> $b } grep { defined($h{$_})\
    \ } @$l2 ];\n}", "    my $a1 = @$l1;\n    my $a2 = @$l2;\n    my @common = ();\n\
    \    for(my $i=0; $i<$a1; $i++) {\n        for(my $j=0; $j<$a2; $j++) {\n    \
    \        if($l1->[$i] eq $l2->[$j]) {\n                push(@common, $l1->[$i]);\n\
    \                $l2->[$j] = undef;\n                last;\n            }\n  \
    \      }\n    }\n    return @common;\n}", "    my %s1 = map { $_ => 1 } @$l1;\n\
    \    my %s2 = map { $_ => 1 } @$l2;\n    my @result = sort grep $s1{$_} && $s2{$_},\
    \ keys %s1;\n    \\@result;\n}", "    return () unless @$l1 and @$l2;\n    my\
    \ %h = map { $_ => 1 } @$l2;\n    return grep $h{$_}, @$l1;\n}", "    return []\
    \ unless $l1;\n    return [] unless $l2;\n    my $h = {};\n    map { $h->{$_}\
    \ = 1 } @$l1;\n    my @common = grep { $h->{$_} } @$l2;\n    return [ sort { $a\
    \ <=> $b } @common ];\n}", "    my @l1 = sort { $a <=> $b } @$l1;\n    my @l2\
    \ = sort { $a <=> $b } @$l2;\n    my %l1 = map { $_ => 1 } @l1;\n    return grep\
    \ { $l1{$_} } @l2;\n}", "    my(%h1, %h2, %common);\n    $h1{$_}++ for @$l1;\n\
    \    $h2{$_}++ for @$l2;\n    $common{$_}++ for grep $h1{$_}, keys %h2;\n    sort\
    \ keys %common;\n}", "    my(%h1, %h2, %h);\n    foreach my $i (@$l1) {\n    \
    \    $h1{$i} = 1;\n    }\n    foreach my $i (@$l2) {\n        $h2{$i} = 1;\n \
    \   }\n    foreach my $i (keys %h1) {\n        $h{$i} = 1 if exists $h2{$i};\n\
    \    }\n    return keys %h;\n}", "    my %h = ();\n    foreach my $e (@$l1) {\n\
    \        $h{$e} = 1;\n    }\n    my @common = ();\n    foreach my $e (@$l2) {\n\
    \        if (exists $h{$e}) {\n            push @common, $e;\n        }\n    }\n\
    \    return @common;\n}", "    my %h;\n    grep(++$h{$_}, @$l1);\n    grep(delete($h{$_}),\
    \ @$l2);\n    return sort keys %h;\n}", "    my $h = {};\n    my $res = [];\n\
    \    for my $i ( @$l1 ) {\n        if ( !$h->{$i} ) {\n            $h->{$i} =\
    \ 1;\n        }\n    }\n    for my $i ( @$l2 ) {\n        if ( $h->{$i} ) {\n\
    \            push @$res, $i;\n            $h->{$i} = 0;\n        }\n    }\n  \
    \  return $res;\n}", "    my @l1 = sort { $a <=> $b } @$l1;\n    my @l2 = sort\
    \ { $a <=> $b } @$l2;\n    my @isect;\n    while (@l1 && @l2) {\n        if ($l1[0]\
    \ == $l2[0]) {\n            push @isect, shift @l1;\n            shift @l2;\n\
    \        }\n        elsif ($l1[0] < $l2[0]) {\n            shift @l1;\n      \
    \  }\n        else {\n            shift @l2;\n        }\n    }\n    return @isect;\n\
    }", "    my %count;\n    grep { $count{$_}++ } @$l1;\n    grep { $count{$_}++\
    \ } @$l2;\n    return grep { $count{$_} == 2 } keys %count;\n}", "    my(%s);\n\
    \    return grep { $s{$_}++ == 1 } sort @$l1, @$l2;\n}", "    my %s;\n    ++$s{$_}\
    \ for @$l1;\n    grep {\n        --$s{$_} > -1\n    } @$l2;\n}", "    my %h;\n\
    \    @h{@$l1} = undef;\n    @h{@$l2} = undef;\n    my @k = keys %h;\n    return\
    \ sort @k;\n}", "    my %l1 = map { $_ => 1 } @$l1;\n    my %l2 = map { $_ =>\
    \ 1 } @$l2;\n    return sort( { $a <=> $b } keys(%l1), keys(%l2));\n}", "    return\
    \ [sort {$a <=> $b} keys %{{map {$_ => 1} (@$l1, @$l2)}}];\n}", "    my(%h);\n\
    \    @h{@$l1} = undef;\n    grep { exists $h{$_} } @$l2;\n}", "    my(%c, @r);\n\
    \    @c{@$l1} = ();\n    @c{@$l2} = ();\n    @r = sort keys %c;\n    @r;\n}",
  "    my(%l);\n    @l{@$l1} = ();\n    @l{@$l2} = ();\n    return sort keys %l;\n\
    }", "    my(%h, @c);\n    @h{@$l1} = ();\n    push @c, grep { defined $h{$_} }\
    \ @$l2;\n    @c;\n}", "    my(%c, @c);\n    $c{$_}++ for @$l1;\n    $c{$_}++ for\
    \ @$l2;\n    push @c, $_ for grep { $c{$_} == 2 } keys %c;\n    return @c;\n}",
  "    my %l1 = map {$_ => 1} @$l1;\n    my %l2 = map {$_ => 1} @$l2;\n    return\
    \ sort keys %l1, keys %l2;\n}", "    my %h = map { $_ => 1 } @$l1;\n    return\
    \ [sort { $a <=> $b } grep { $h{$_} } @$l2];\n}", "    my(%l, @r);\n    foreach\
    \ my $v (@$l1) {\n        $l{$v} = 1;\n    }\n    foreach my $v (@$l2) {\n   \
    \     if (exists $l{$v}) {\n            push @r, $v;\n            delete $l{$v};\n\
    \        }\n    }\n    return @r;\n}", "    my %all;\n    my @common;\n    foreach\
    \ my $e1 (@$l1, @$l2) {\n        $all{$e1}++;\n    }\n    foreach my $e (keys\
    \ %all) {\n        push @common, $e if $all{$e} == 2;\n    }\n    return @common;\n\
    }", "    my %l1 = map { $_ => 1 } @$l1;\n    my %l2 = map { $_ => 1 } @$l2;\n\
    \    return sort { $a <=> $b } grep { $l1{$_} && $l2{$_} } keys %l1;\n}", "  \
    \  my %hash;\n    @hash{@$l1} = @$l1;\n    return sort keys %hash{@$l2};\n}",
  "    my @ret = sort( uniq @$l1, @$l2 );\n    return @ret;\n}", "    my %h;\n   \
    \ foreach my $n (@$l1) {\n        $h{$n} = 1;\n    }\n    my @c;\n    foreach\
    \ my $n (@$l2) {\n        push(@c, $n) if ($h{$n});\n    }\n    return sort {\
    \ $a <=> $b } @c;\n}", "    my @l = ();\n    my %l = ();\n    push @l, @$l1;\n\
    \    push @l, @$l2;\n    @l = uniq(@l);\n    for my $e (@l) {\n        for my\
    \ $l (@$l1, @$l2) {\n            next if $l{$e};\n            if (grep { $_ eq\
    \ $e } @$l) {\n                $l{$e}++;\n            }\n        }\n    }\n  \
    \  return [sort keys %l];\n}", "    my %a;\n    $a{$_}++ for (@$l1, @$l2);\n \
    \   return sort { $a <=> $b } grep { $a{$_} > 1 } keys %a;\n}", "    my %h = map\
    \ { $_ => 1 } @$l1;\n    my @intersection = grep { $h{$_} } @$l2;\n    my %h =\
    \ map { $_ => 1 } @intersection;\n    my @unique = sort keys %h;\n    return @unique;\n\
    }", "    my @common = ();\n    my %list2 = map { $_ => 1 } @$l2;\n    for (@$l1)\
    \ {\n        if ($list2{$_}) {\n            push @common, $_;\n        }\n   \
    \ }\n    return @common;\n}", "    my %l1 = map { $_ => 1 } @$l1;\n    my %l2\
    \ = map { $_ => 1 } @$l2;\n    return sort keys %l1, keys %l2;\n}", "    my @isect\
    \ = grep { $seen{$_}++ } @$l1;\n    my @res;\n    @res = sort { $a <=> $b } grep\
    \ { defined $seen{$_} && $seen{$_} > 1 } @isect;\n    return @res;\n}", "    my\
    \ %seen;\n    grep { !$seen{$_}++ } @$l1, @$l2;\n}", "    my %h;\n    for(@$l1)\
    \ {\n        $h{$_} = 1;\n    }\n    my @out;\n    for(@$l2) {\n        push @out,\
    \ $_ if($h{$_});\n    }\n    return sort {$a <=> $b} @out;\n}", "    my %a1 =\
    \ ();\n    @a1{@$l1} = ();\n    my @common = grep exists $a1{$_}, @$l2;\n    return\
    \ [sort @common];\n}", "    my $l = [];\n    my $i1 = 0;\n    my $i2 = 0;\n  \
    \  while ($i1 < @$l1 && $i2 < @$l2) {\n        my $r = $l1->[$i1] <=> $l2->[$i2];\n\
    \        if ($r < 0) {\n            $i1++;\n        } elsif ($r > 0) {\n     \
    \       $i2++;\n        } else {\n            push @$l, $l1->[$i1];\n        \
    \    $i1++;\n            $i2++;\n        }\n    }\n    return $l;\n}", "    my\
    \ %h = map {$_ => 1} @$l1;\n    return uniq(grep {$h{$_}} @$l2);\n}", "    my\
    \ %s;\n    my @common;\n    for (@$l1) { $s{$_} = 1; }\n    for (@$l2) { if ($s{$_})\
    \ { push @common, $_; } }\n    return sort { $a <=> $b } @common;\n}", "    my\
    \ @a1 = sort { $a <=> $b } grep !$seen{$_}++, @$l1;\n    my @a2 = sort { $a <=>\
    \ $b } grep !$seen{$_}++, @$l2;\n    my @result;\n    while (@a1 and @a2) {\n\
    \        if ($a1[0] == $a2[0]) {\n            push @result, shift @a1;\n     \
    \       shift @a2;\n        } elsif ($a1[0] < $a2[0]) {\n            shift @a1;\n\
    \        } else {\n            shift @a2;\n        }\n    }\n    return @result;\n\
    }", "    my @l1 = sort { $a <=> $b } @$l1;\n    my @l2 = sort { $a <=> $b } @$l2;\n\
    \    my $p1 = 0;\n    my $p2 = 0;\n    my @r;\n    while ($p1 < @l1 and $p2 <\
    \ @l2) {\n        if ($l1[$p1] == $l2[$p2]) {\n            if (!@r or $r[-1] !=\
    \ $l1[$p1]) {\n                push @r, $l1[$p1];\n            }\n           \
    \ $p1++;\n            $p2++;\n        } elsif ($l1[$p1] < $l2[$p2]) {\n      \
    \      $p1++;\n        } else {\n            $p2++;\n        }\n    }\n    return\
    \ @r;\n}", "    my %uniq = ();\n    my @u = ();\n    foreach my $e (@$l1, @$l2)\
    \ {\n        $uniq{$e}++;\n    }\n    foreach my $u (keys %uniq) {\n        push(@u,\
    \ $u) if $uniq{$u} > 1;\n    }\n    return sort @u;\n}", "    my %hash = ();\n\
    \    my @result = ();\n    map {$hash{$_} = 1} @$l1;\n    for(my $i = 0; $i <\
    \ @$l2; $i++) {\n        if(exists $hash{$l2->[$i]}) {\n            push @result,\
    \ $l2->[$i];\n        }\n    }\n    @result = sort {$a <=> $b} @result;\n    return\
    \ @result;\n}", "    my %seen;\n    my @r;\n    foreach my $v1 (@$l1) {\n    \
    \    $seen{$v1} = 1;\n    }\n    foreach my $v2 (@$l2) {\n        push @r, $v2\
    \ if $seen{$v2};\n    }\n    return @r;\n}", "    return () unless @$l1 && @$l2;\n\
    \    my %l1;\n    @l1{@$l1} = ();\n    return sort grep exists $l1{$_}, @$l2;\n\
    }", "    my %common = ();\n    for my $i (@$l1) {\n        $common{$i}++ if grep\
    \ { $_ == $i } @$l2;\n    }\n    return [ sort { $a <=> $b } keys %common ];\n\
    }", "    return sort keys %{{ map {$_ => 1} @$l1 }, { map {$_ => 1} @$l2 }};\n\
    }", "    my %all;\n    @all{@$l1} = (1) x @$l1;\n    my @c = grep { $all{$_} }\
    \ @$l2;\n    return @c;\n}", "    my %l1 = map {$_ => 1} @$l1;\n    my %l2 = map\
    \ {$_ => 1} @$l2;\n    return [sort {$a <=> $b} keys %l1, keys %l2];\n}", "  \
    \  my %l1 = map { $_ => 1 } @$l1;\n    my %l2 = map { $_ => 1 } @$l2;\n    my\
    \ @l = grep { $l1{$_} } @$l2;\n    return @l;\n}", "    my $s1 = join('', sort\
    \ @$l1);\n    my $s2 = join('', sort @$l2);\n    my $p = 0;\n    my @r;\n    while\
    \ ($p < length($s1) && $p < length($s2)) {\n        my $l = substr($s1, $p, 1);\n\
    \        my $r = substr($s2, $p, 1);\n        if ($l eq $r) {\n            push\
    \ @r, $l;\n        } else {\n            return @r;\n        }\n        $p++;\n\
    \    }\n    return @r;\n}", "    my @c;\n    my %l1 = map { $_ => 1 } @$l1;\n\
    \    for my $e (@$l2) {\n        push @c, $e if $l1{$e};\n    }\n    return @c;\n\
    }", "    my(%i, @c);\n    foreach (@$l1) { $i{$_} = 1; }\n    foreach (@$l2) {\
    \ push(@c, $_) if $i{$_}; }\n    return @c;\n}", "    my %common;\n    @common{@$l1}\
    \ = @$l1;\n    @common{@$l2} = grep { $common{$_} } @$l2;\n    return [ values\
    \ %common ];\n}", "    my(%h, @a);\n    @h{@$l1} = @$l1;\n    @h{@$l2} = ();\n\
    \    @a = keys %h;\n    @a = sort { $a <=> $b } @a;\n    return @a;\n}", "   \
    \ my %h = map {$_ => 1} @$l1;\n    return grep {defined $h{$_}} @$l2;\n}", " \
    \   my %common;\n    $common{$_}++ for @$l1;\n    $common{$_}++ for @$l2;\n  \
    \  return sort keys %common;\n}", "    my %e1 = map {$_ => 1} @$l1;\n    my %e2\
    \ = map {$_ => 1} @$l2;\n    my @common = sort {$a <=> $b} grep {$e1{$_} && $e2{$_}}\
    \ keys %e1;\n    return @common;\n}", "    my(%hash, @return);\n    foreach (@$l1)\
    \ {\n        $hash{$_}++;\n    }\n    foreach (@$l2) {\n        $hash{$_}++;\n\
    \    }\n    while(my($k, $v) = each %hash) {\n        push(@return, $k) if ($v\
    \ == 2);\n    }\n    return sort {$a <=> $b} @return;\n}", "    my @intersection\
    \ = ();\n    my %seen = ();\n    for (@$l1) { $seen{$_}++ }\n    for (@$l2) {\
    \ push @intersection, $_ if $seen{$_} }\n    return @intersection;\n}", "    my\
    \ %seen;\n    @seen{@$l1} = ();\n    return sort {$a <=> $b} grep exists $seen{$_},\
    \ @$l2;\n}", "    my $result = [];\n    for my $item (uniq($l1)) {\n        if(\
    \ is_in($item, $l2) ) {\n            push @$result, $item;\n        }\n    }\n\
    \    return $result;\n}", "    my $h = { map { $_ => 1 } @$l1 };\n    return [grep\
    \ { exists $h->{$_} } @$l2];\n}", "    my(%elem);\n    my($ret);", "    my %h\
    \ = ();\n    foreach (@$l1) {\n        $h{$_} = 1;\n    }\n    my @r = ();\n \
    \   foreach (@$l2) {\n        push @r, $_ if $h{$_};\n    }\n    return [ sort\
    \ @r ];\n}", "    my %h;\n    for (@$l1) { $h{$_}++; }\n    for (@$l2) { $h{$_}++\
    \ if $h{$_}; }\n    return [sort keys %h];\n}", "    my %h = map { $_ => 1 } @$l1;\n\
    \    return sort grep { $h{$_} } @$l2;\n}", "    my %h;\n    map { $h{$_}++ }\
    \ @$l1;\n    map { $h{$_}++ } @$l2;\n    return [sort grep { $h{$_} == 2 } keys\
    \ %h];\n}", "    my(%h1, %h2, %t);\n    map( $h1{$_}++, @$l1 );\n    map( $h2{$_}++,\
    \ @$l2 );\n    map( $t{$_}++, keys %h1 );\n    map( $t{$_}++, keys %h2 );\n  \
    \  return sort grep( $t{$_} == 2, keys %t );\n}", "    my %seen;\n    my @union\
    \ = grep { !$seen{$_}++ } (@$l1, @$l2);\n    return sort { $a <=> $b } @union;\n\
    }", "    my(%s, @i);\n    @s{@$l1} = ();\n    push(@i, $_) for grep exists $s{$_},\
    \ @$l2;\n    return sort { $a <=> $b } @i;\n}", "    my %count;\n    foreach (@$l1,\
    \ @$l2) {\n        $count{$_}++;\n    }\n    return grep { $count{$_} > 1 } keys\
    \ %count;\n}", "    my @intersection = ();\n    my %seen = ();\n    foreach my\
    \ $e (@$l1, @$l2) {\n        $seen{$e}++;\n    }\n    foreach my $e (keys %seen)\
    \ {\n        push(@intersection, $e) if $seen{$e} > 1;\n    }\n    return @intersection;\n\
    }", "    @$l1 = sort @$l1;\n    @$l2 = sort @$l2;\n    my @common;\n    while\
    \ (@$l1 && @$l2) {\n        if ($l1->[0] > $l2->[0]) {\n            shift @$l2;\n\
    \        } elsif ($l1->[0] < $l2->[0]) {\n            shift @$l1;\n        } else\
    \ {\n            push @common, shift @$l1;\n            shift @$l2;\n        }\n\
    \    }\n    return @common;\n}", "    my @l1 = sort { $a <=> $b } @$l1;\n    my\
    \ @l2 = sort { $a <=> $b } @$l2;\n    my @common;\n    while(@l1 && @l2) {\n \
    \       if($l1[0] == $l2[0]) {\n            push @common, shift @l1;\n       \
    \     shift @l2;\n        } elsif($l1[0] < $l2[0]) {\n            shift @l1;\n\
    \        } else {\n            shift @l2;\n        }\n    }\n    return @common;\n\
    }", "    my %h;\n    $h{$_}++ for @$l1;\n    return grep $h{$_}--, @$l2;\n}",
  "    @_ = sort { $a <=> $b } @$l1;\n    my %s1 = map { $_ => 1 } @_;\n    @_ = sort\
    \ { $a <=> $b } @$l2;\n    my %s2 = map { $_ => 1 } @_;\n    keys %s1;\n    keys\
    \ %s2;\n    my @res = sort { $a <=> $b } grep { exists $s1{$_} and exists $s2{$_}\
    \ } keys %s1;\n    return @res;\n}", "    my %hash;\n    my @result;\n    foreach\
    \ my $i(@$l1){\n        $hash{$i} = 1;\n    }\n    foreach my $i(@$l2){\n    \
    \    if($hash{$i}){\n            push @result, $i;\n        }\n    }\n    return\
    \ @result;\n}", "    my(%h, @res);\n    foreach my $i (@$l1) { $h{$i} = 1; }\n\
    \    foreach my $i (@$l2) { push(@res, $i) if $h{$i}; }\n    return sort { $a\
    \ <=> $b } @res;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n  \
    \  my @k = sort keys %h;\n    return @k;\n}", "    my %h;\n    map { $h{$_} =\
    \ 1 } @$l1;\n    grep { $h{$_} } @$l2;\n}", "    my %h;\n    @h{@$l1} = ();\n\
    \    @h{@$l2} = ();\n    my @r = sort keys %h;\n    return \\@r;\n}", "    my\
    \ %h;\n    @h{ @$l1 } = ();\n    @h{ @$l2 } = ();\n    return sort keys %h;\n}",
  "    my $hash1 = {};\n    my $hash2 = {};\n    foreach (@$l1) {\n        $hash1->{$_}\
    \ = 1;\n    }\n    foreach (@$l2) {\n        $hash2->{$_} = 1;\n    }\n    my\
    \ $result = [];\n    foreach (keys %$hash1) {\n        push @$result, $_ if $hash2->{$_};\n\
    \    }\n    return sort {$a <=> $b} @$result;\n}", "    my %h = ();\n    foreach\
    \ my $e (@$l1) {\n        $h{$e}++;\n    }\n    my @c = ();\n    foreach my $e\
    \ (@$l2) {\n        if (exists $h{$e}) {\n            push @c, $e;\n        }\n\
    \    }\n    @c = sort { $a <=> $b } @c;\n    my @u = ();\n    my $last = undef;\n\
    \    foreach my $e (@c) {\n        next if (defined $last && $last == $e);\n \
    \       push @u, $e;\n        $last = $e;\n    }\n    return @u;\n}", "    my\
    \ @l1 = sort { $a <=> $b } @$l1;\n    my @l2 = sort { $a <=> $b } @$l2;\n    my\
    \ $i = 0;\n    my $j = 0;\n    my @c;\n    while($i < @l1 && $j < @l2) {\n   \
    \     if($l1[$i] == $l2[$j]) {\n            push @c, $l1[$i];\n            $i++;\n\
    \            $j++;\n        }\n        elsif($l1[$i] < $l2[$j]) {\n          \
    \  $i++;\n        }\n        else {\n            $j++;\n        }\n    }\n   \
    \ return @c;\n}", "    my %l1 = map { $_ => 1 } @$l1;\n    my %l2 = map { $_ =>\
    \ 1 } @$l2;\n    my @r = grep { $l1{$_} && $l2{$_} } @$l1;\n    return @r;\n}",
  "    my(%h1, %h2, @res);\n    @h1{@$l1} = ();\n    @h2{@$l2} = ();\n    for my $key\
    \ (keys %h1) {\n        if ($h2{$key}) {\n            push @res, $key;\n     \
    \   }\n    }\n    return sort {$a <=> $b} @res;\n}", "    my(%h1, %h2, @out);\n\
    \    my $l;\n    foreach $l (@$l1) {\n        $h1{$l} = $l;\n    }\n    foreach\
    \ $l (@$l2) {\n        $h2{$l} = $l;\n    }\n    foreach $l (keys %h1) {\n   \
    \     push(@out, $l) if (defined $h2{$l});\n    }\n    return(sort @out);\n}",
  "    my %h = ();\n    @h{@$l1} = @$l1;\n    @h{@$l2} = @$l2;\n    my @k = sort keys\
    \ %h;\n    my @v = @h{@k};\n    return @v;\n}", "    my %seen;\n    @seen{@$l1}\
    \ = ();\n    my @out = grep { exists $seen{$_} } @$l2;\n    return [sort(uniq(@out))];\n\
    }", "    my %h;\n    foreach(@$l1) {\n        $h{$_}++;\n    }\n    foreach(@$l2)\
    \ {\n        $h{$_}++;\n    }\n    my @r = grep {$h{$_} > 1} keys %h;\n    @r\
    \ = sort {$a <=> $b} @r;\n    return @r;\n}", "    my(%h1, %h2, @c);\n    foreach\
    \ (@$l1) {\n        $h1{$_} = 1;\n    }\n    foreach (@$l2) {\n        if (exists\
    \ $h1{$_}) {\n            $h2{$_} = 1;\n        }\n    }\n    @c = sort keys %h2;\n\
    \    return \\@c;\n}", "    my %seen;\n    @seen{@$l1} = @$l1;\n    @seen{@$l2}\
    \ = grep(delete $seen{$_}, @$l2);\n    return [sort {$a <=> $b} values %seen];\n\
    }", "    my %l = map { $_ => 1 } @$l1;\n    my @c = grep { exists $l{$_} } @$l2;\n\
    \    return @c;\n}", "    my %h;\n    $h{$_}++ for @$l1;\n    grep { $h{$_} }\
    \ @$l2;\n}", "    my %h = map { $_ => 1 } @$l1;\n    return [ sort keys %{{ map\
    \ { $_ => 1 } grep { $h{$_} } @$l2 }} ];\n}", "    my @a = sort { $a <=> $b }\
    \ @$l1;\n    my @b = sort { $a <=> $b } @$l2;\n    my %c;\n    ++$c{$_} for @a,\
    \ @b;\n    grep { $c{$_} > 1 } keys %c;\n}", "    my @l1 = sort @$l1;\n    my\
    \ @l2 = sort @$l2;\n    my @result;\n    my ($i, $j) = (0, 0);\n    while($i <\
    \ @l1 && $j < @l2) {\n        if($l1[$i] == $l2[$j]) {\n            push @result,\
    \ $l1[$i];\n            ++$i;\n            ++$j;\n        } elsif($l1[$i] < $l2[$j])\
    \ {\n            ++$i;\n        } else {\n            ++$j;\n        }\n    }\n\
    \    return \\@result;\n}", "    my %hash;\n    my $result = [];\n    foreach\
    \ my $item (@$l1) {\n        $hash{$item} = 1;\n    }\n    foreach my $item (@$l2)\
    \ {\n        if($hash{$item}) {\n            push @$result, $item;\n        }\n\
    \    }\n    return $result;\n}", "    my @s = sort keys %{{ map {$_ => 1} @$l1,\
    \ @$l2 }};\n    return @s;\n}", "    my @common;\n    my %seen;\n    foreach (@$l1)\
    \ {\n        $seen{$_}++;\n    }\n    foreach (@$l2) {\n        if (exists $seen{$_})\
    \ {\n            push @common, $_;\n        }\n    }\n    return [uniq sort @common];\n\
    }", "    my(%uniq, @common);\n    foreach my $e (@$l1, @$l2) {\n        if(!$uniq{$e})\
    \ {\n            push @common, $e;\n            $uniq{$e} = 1;\n        }\n  \
    \  }\n    return [sort {$a <=> $b} @common];\n}", "    my $h1 = { map { $_ =>\
    \ 1 } @$l1 };\n    my $h2 = { map { $_ => 1 } @$l2 };\n    my @k1 = sort keys\
    \ %$h1;\n    my @k2 = sort keys %$h2;\n    my($a, $b, @ret);\n    while (@k1 &&\
    \ @k2) {\n        $a = shift @k1;\n        $b = shift @k2;\n        if ($a eq\
    \ $b) {\n            push @ret, $a;\n        } elsif ($a < $b) {\n           \
    \ unshift @k2, $b;\n        } else {\n            unshift @k1, $a;\n        }\n\
    \    }\n    return @ret;\n}", "    my %seen;\n    grep !$seen{$_}++, (@$l1, @$l2);\n\
    }", "    my %h;\n    @h{@$l1} = ();\n    my @res = grep { exists $h{$_} } @$l2;\n\
    \    return [ sort { $a <=> $b } @res ];\n}", "    my %l1 = map { $_ => 1 } @$l1;\n\
    \    my %l2 = map { $_ => 1 } @$l2;\n    return sort { $a <=> $b } grep { $l1{$_}\
    \ and $l2{$_} } keys %l1;\n}", "    my(%l1, %l2);\n    for my $i (@$l1) {\n  \
    \      $l1{$i} = 1;\n    }\n    for my $i (@$l2) {\n        $l2{$i} = 1;\n   \
    \ }\n    my @l1 = sort keys %l1;\n    my @l2 = sort keys %l2;\n    my @common;\n\
    \    for my $i (@l1) {\n        if ($l2{$i}) {\n            push @common, $i;\n\
    \        }\n    }\n    return @common;\n}", "    if (!defined($l1) || !defined($l2))\
    \ {\n        return undef;\n    }\n    my @l1 = @$l1;\n    my @l2 = @$l2;\n  \
    \  my @l;\n    my %l;\n    foreach my $e (@l1) {\n        $l{$e}++;\n    }\n \
    \   foreach my $e (@l2) {\n        if ($l{$e}) {\n            push @l, $e;\n \
    \           delete $l{$e};\n        }\n    }\n    return [sort @l];\n}", "   \
    \ my(%seen, @res);\n    for my $e (@$l1, @$l2) { $seen{$e}++ if !$seen{$e}++ }\n\
    \    @res = sort { $a <=> $b } grep { $seen{$_} > 1 } keys %seen;\n    return\
    \ @res;\n}", "    return sort { $a <=> $b } keys %{{map {$_=>1} @$l1},{map {$_=>1}\
    \ @$l2}};\n}", "    my @a1 = sort @$l1;\n    my @a2 = sort @$l2;\n    my $i1 =\
    \ 0;\n    my $i2 = 0;\n    my @ret;\n    while ($i1 < @a1 && $i2 < @a2) {\n  \
    \      my $v1 = $a1[$i1];\n        my $v2 = $a2[$i2];\n        if ($v1 == $v2)\
    \ {\n            push @ret, $v1;\n            $i1++;\n            $i2++;\n   \
    \     } elsif ($v1 < $v2) {\n            $i1++;\n        } else {\n          \
    \  $i2++;\n        }\n    }\n    return @ret;\n}", "    my %l1;\n    @l1{@$l1}\
    \ = (1) x @$l1;\n    my @uniq;\n    foreach my $l2 (@$l2) {\n        push @uniq,\
    \ $l2 if $l1{$l2};\n    }\n    return @uniq;\n}", "    my $i = 0;\n    my $j =\
    \ 0;\n    my @c;\n    while ($i < @$l1 && $j < @$l2) {\n        my $c = $l1->[$i]\
    \ <=> $l2->[$j];\n        if ($c == 0) {\n            push @c, $l1->[$i];\n  \
    \          $i++;\n            $j++;\n        } elsif ($c < 0) {\n            $i++;\n\
    \        } else {\n            $j++;\n        }\n    }\n    @c;\n}", "    my @result\
    \ = ();\n    my %common = ();\n    foreach (@$l1) {\n        $common{$_} = 1;\n\
    \    }\n    foreach (@$l2) {\n        $common{$_} = 2 if $common{$_};\n    }\n\
    \    foreach (keys %common) {\n        push @result, $_ if $common{$_} == 2;\n\
    \    }\n    return @result;\n}", "    my(%h1, %h2, @l);\n    map { $h1{$_} = 1\
    \ } @$l1;\n    map { $h2{$_} = 1 } @$l2;\n    foreach (keys %h1) {\n        push(@l,\
    \ $_) if defined $h2{$_};\n    }\n    return [sort @l];\n}", "    my(%h, $e);\n\
    \    foreach $e (@$l1) {\n        $h{$e} = 1;\n    }\n    return [ sort { $a <=>\
    \ $b } grep { $h{$_} } @$l2 ];\n}", "    my(%h, @a);\n    foreach $i (@$l1) {\
    \ $h{$i}++; }\n    foreach $i (@$l2) { $h{$i}++; }\n    foreach $i (keys %h) {\n\
    \        push(@a, $i) if $h{$i} == 2;\n    }\n    return sort(@a);\n}", "    my\
    \ %h;\n    my @common = ();\n    map { $h{$_} = 1 } @$l1;\n    map { push @common,\
    \ $_ if $h{$_} } @$l2;\n    return @common;\n}", "    my(%hs);\n    foreach my\
    \ $i (@$l1) {\n        $hs{$i}++ if grep(/^$i$/, @$l2);\n    }\n    my(@l) = keys\
    \ %hs;\n    return \\@l;\n}", "    my %seen;\n    my @common = grep {!$seen{$_}++}\
    \ @$l1, @$l2;\n    @common = sort {$a <=> $b} @common;\n    return @common;\n}",
  "    my(%uniq, @res);\n    $uniq{$_}++ for (@$l1, @$l2);\n    for (keys %uniq) {\n\
    \        push @res, $_ if $uniq{$_} == 2;\n    }\n    sort { $a <=> $b } @res;\n\
    }", "    my(%l1) = map { $_ => undef } @$l1;\n    my(@common) = grep { exists\
    \ $l1{$_} } @$l2;\n    return sort { $a <=> $b } @common;\n}", "    my(%h, @c);\n\
    \    my($e);\n    @h{@$l1} = @$l1;\n    @h{@$l2} = @$l2;\n    @c = sort keys %h;\n\
    \    return @c;\n}", "    my %h;\n    map { $h{$_}++ } @$l1;\n    grep { $h{$_}\
    \ } @$l2;\n}", "    my %temp;\n    @temp{@$l1} = ();\n    grep exists $temp{$_},\
    \ @$l2;\n}", "    my %h;\n    my @res;\n    for my $v (@$l1) {\n        $h{$v}\
    \ = 1;\n    }\n    for my $v (@$l2) {\n        if ($h{$v}) {\n            push\
    \ @res, $v;\n        }\n    }\n    return \\@res;\n}", "    return () unless $l1\
    \ and $l2;\n    my %pairs = map {$_, 1} @$l1;\n    return grep { $pairs{$_} }\
    \ @$l2;\n}", "    my @c;\n    if(scalar(@$l1) < scalar(@$l2)) {\n        @c =\
    \ sort(uniq(@$l1));\n        @$l2 = sort(uniq(@$l2));\n    } else {\n        @c\
    \ = sort(uniq(@$l2));\n        @$l1 = sort(uniq(@$l1));\n    }\n    my @res;\n\
    \    for my $c (@c) {\n        if(grep { $c == $_ } @$l1) {\n            push\
    \ @res, $c;\n        }\n    }\n    return @res;\n}", "    my @common = ();\n \
    \   my $i = 0;\n    my $j = 0;\n    for ($i=0; $i < @$l1; $i++) {\n        for\
    \ ($j=0; $j < @$l2; $j++) {\n            if ($l1->[$i] == $l2->[$j]) {\n     \
    \           push @common, $l1->[$i];\n                last;\n            }\n \
    \       }\n    }\n    return @common;\n}", "    my @a = sort { $a <=> $b } grep(++$seen{$_}\
    \ > 1, @$l1, @$l2);\n    return wantarray ? @a : \\@a;\n}", "    my %c;\n    for\
    \ (@$l1) { $c{$_}++ if exists $c{$_} }\n    for (@$l2) { $c{$_}++ if exists $c{$_}\
    \ }\n    return [ sort keys %c ];\n}", "    my(%h1, %h2, @comm);\n    foreach\
    \ my $e (@$l1) { $h1{$e}++; }\n    foreach my $e (@$l2) { $h2{$e}++; }\n    foreach\
    \ my $e (keys %h1) { push(@comm, $e) if ($h2{$e}); }\n    return sort { $a <=>\
    \ $b } @comm;\n}", "    my %elements;\n    @elements{@$l1} = @$l1;\n    delete\
    \ @elements{grep { ! exists $elements{$_} } @$l2};\n    return [ values %elements\
    \ ];\n}", "    return @{&common_ref($l1, $l2)};\n}", "    my %t;\n    for my $l\
    \ ($l1, $l2) {\n        for my $e (@$l) {\n            $t{$e}++;\n        }\n\
    \    }\n    return [ sort grep { $t{$_} == 2 } keys %t ];\n}", "    my %h = ();\n\
    \    for(@$l1) { $h{$_}++ }\n    grep { $h{$_} } @$l2;\n}", "    my %h = map {\
    \ $_ => 1 } @$l1;\n    my @c = grep { $h{$_} } @$l2;\n    return [ sort @c ];\n\
    }", "    my %common = ();\n    for my $e (@$l1) {\n        $common{$e} = 1;\n\
    \    }\n    my %tmp = ();\n    for my $e (@$l2) {\n        $tmp{$e} = 1;\n   \
    \ }\n    my @result = ();\n    for my $e (keys %common) {\n        if ($tmp{$e})\
    \ {\n            push @result, $e;\n        }\n    }\n    return \\@result;\n}",
  "    my(%h, @c);\n    foreach (@$l1) { $h{$_} = 1 }\n    foreach (@$l2) { push(@c,\
    \ $_) if $h{$_} }\n    return sort @c;\n}", "    my @union = uniq(@$l1, @$l2);\n\
    \    my %union_hash = map { $_ => 1 } @union;\n    return grep { $union_hash{$_}\
    \ == 2 } @union;\n}", "    my %s;\n    foreach(@$l1) {\n        $s{$_} = 1;\n\
    \    }\n    foreach(@$l2) {\n        $s{$_} = 2 if exists $s{$_};\n    }\n   \
    \ sort {$a <=> $b} grep {$s{$_} == 2} keys %s;\n}", "    my %hash = ();\n    for\
    \ my $x (@$l1) {\n        $hash{$x}++;\n    }\n    for my $x (@$l2) {\n      \
    \  $hash{$x}++;\n    }\n    return sort { $a <=> $b } grep { $hash{$_} > 1 } keys\
    \ %hash;\n}", "    my %seen;\n    grep { not $seen{$_}++ } @$l1, @$l2;\n}", " \
    \   my %seen;\n    @seen{@$l1} = 1;\n    my @filtered = grep $seen{$_}, @$l2;\n\
    \    @filtered = keys %{{ map { $_ => 1 } @filtered }};\n    return @filtered;\n\
    }", "    my %hash;\n    map { $hash{$_}++ } @$l1;\n    return [ map {$_} grep\
    \ {delete $hash{$_}} @$l2 ];\n}", "    my %h;\n    @h{@$l1} = ();\n    grep {\
    \ exists $h{$_} } @$l2;\n}", "    my(%h, @r);\n    @h{@$l1} = ();\n    @r = grep(exists\
    \ $h{$_}, @$l2);\n    wantarray ? @r : \\@r;\n}", "    my(%l1, %l2);\n    my(@r);",
  "    my %all = map {$_ => 1} @$l1, @$l2;\n    return sort keys %all;\n}", "    my\
    \ @l1 = @$l1;\n    my @l2 = @$l2;\n    return () unless @l1 && @l2;\n    @l1 =\
    \ sort { $a <=> $b } @l1;\n    @l2 = sort { $a <=> $b } @l2;\n    my @res;\n \
    \   my($i, $j) = (0, 0);\n    while ($i < @l1 && $j < @l2) {\n        if ($l1[$i]\
    \ < $l2[$j]) {\n            $i++;\n        } elsif ($l1[$i] > $l2[$j]) {\n   \
    \         $j++;\n        } else {\n            push @res, $l1[$i];\n         \
    \   $i++;\n            $j++;\n        }\n    }\n    return @res;\n}", "    my\
    \ %c;\n    @c{@$l1} = (1) x @$l1;\n    return sort { $a <=> $b } grep($c{$_},\
    \ @$l2);\n}", "    my %elems = ();\n    foreach my $e (@$l1) {\n        $elems{$e}++;\n\
    \    }\n    foreach my $e (@$l2) {\n        $elems{$e}++ if $elems{$e};\n    }\n\
    \    return [ sort { $a <=> $b } keys %elems ];\n}", "    my %hash = ();\n   \
    \ my @c = ();\n    foreach (@$l1) { $hash{$_} = 1; }\n    foreach (@$l2) { push(@c,\
    \ $_) if exists $hash{$_}; }\n    return sort { $a <=> $b } @c;\n}", "    my %common;\n\
    \    for my $e (@$l1) {\n        $common{$e} = 1;\n    }\n    for my $e (@$l2)\
    \ {\n        if(exists $common{$e}) {\n            $common{$e} = 2;\n        }\n\
    \    }\n    return sort grep { $common{$_} == 2 } keys %common;\n}", "    return\
    \ () unless @$l1 && @$l2;\n    my @ret;\n    my %t;\n    for (@$l1) { $t{$_} =\
    \ 1 }\n    for (@$l2) { push @ret, $_ if $t{$_} }\n    sort { $a <=> $b } @ret;\n\
    }", "    my %s;\n    for my $v (@$l1) {\n        $s{$v}++;\n    }\n    for my\
    \ $v (@$l2) {\n        $s{$v}++;\n    }\n    return [ sort keys %s ];\n}", " \
    \   my %h = ();\n    @h{@$l1} = @$l1;\n    return sort @h{grep exists $h{$_},\
    \ @$l2};\n}", "    my %c;\n    for (@$l1) { $c{$_}++ }\n    for (@$l2) { $c{$_}++\
    \ }\n    return [sort { $a <=> $b } grep { $c{$_} == 2 } keys %c];\n}", "    my\
    \ %common = ();\n    my @result = ();\n    for my $e (@$l1) {\n        $common{$e}\
    \ = 1;\n    }\n    for my $e (@$l2) {\n        $common{$e} = 1 if $common{$e};\n\
    \    }\n    for my $e (keys %common) {\n        push @result, $e;\n    }\n   \
    \ @result = sort { $a <=> $b } @result;\n    return @result;\n}", "    my %seen;\n\
    \    grep { not $seen{$_}++ } @$l1, @$l2;\n}", "    my(%h1, %h2, @res);\n    @h1{@$l1}\
    \ = ();\n    @h2{@$l2} = ();\n    for (keys %h1) {\n        push @res, $_ if exists\
    \ $h2{$_};\n    }\n    @res;\n}", "    my %common = ();\n    my @common = ();\n\
    \    foreach my $elem (sort @$l1) {\n        $common{$elem}++;\n    }\n    foreach\
    \ my $elem (sort @$l2) {\n        $common{$elem}++;\n    }\n    foreach my $elem\
    \ (sort keys %common) {\n        if ($common{$elem} > 1) {\n            push @common,\
    \ $elem;\n        }\n    }\n    return @common;\n}", "    my %tmp;\n    @tmp{@$l1}\
    \ = ();\n    @tmp{@$l2} = ();\n    return sort keys %tmp;\n}", "    my(%hash,\
    \ @return);\n    $hash{$_}++ for @$l1;\n    @return = grep($hash{$_} > 0, @$l2);\n\
    \    @return = sort {$a <=> $b} @return;\n    return @return;\n}", "    my %h\
    \ = map { $_ => 1 } @$l1;\n    return [grep { exists $h{$_} } @$l2];\n}", "  \
    \  my(%h1, %h2, %h);\n    map { $h1{$_}++ } @$l1;\n    map { $h2{$_}++ } @$l2;\n\
    \    map { $h{$_}++ } (keys %h1, keys %h2);\n    return [ sort { $a <=> $b } grep\
    \ { $h1{$_} && $h2{$_} } keys %h ];\n}", "    return () unless @$l1 && @$l2;\n\
    \    my %a;\n    for (@$l1) {\n        $a{$_} = [1, $_] unless $a{$_};\n     \
    \   $a{$_}[0]++;\n    }\n    for (@$l2) {\n        $a{$_} = [1, $_] unless $a{$_};\n\
    \        $a{$_}[0]++;\n    }\n    map { $a{$_}[1] } grep { $a{$_}[0] > 1 } keys\
    \ %a;\n}", "    my %all = map { $_ => 1 } @$l1;\n    my @common = grep { $all{$_}\
    \ } @$l2;\n    return @common;\n}", "    my @c;\n    my %s;\n    foreach my $i(@$l1)\
    \ {\n        $s{$i} = 1;\n    }\n    foreach my $i(@$l2) {\n        if(exists\
    \ $s{$i}) {\n            push @c, $i;\n        }\n    }\n    @c = sort {$a <=>\
    \ $b} @c;\n    return @c;\n}", "    my %l1 = map { $_ => 1 } @$l1;\n    my %l2\
    \ = map { $_ => 1 } @$l2;\n    my %s = ();\n    foreach my $l (keys %l1) {\n \
    \       if (defined $l2{$l}) {\n            $s{$l} = 1;\n        }\n    }\n  \
    \  my @s = sort keys %s;\n    return \\@s;\n}", "    my %seen;\n    map { $seen{$_}++\
    \ } @$l1;\n    return sort grep { $seen{$_}++ == 2 } @$l2;\n}", "    my %h;\n\
    \    @h{@$l1} = ();\n    my @r = grep exists $h{$_}, @$l2;\n    return sort {\
    \ $a <=> $b } @r;\n}", "    my @l = ();\n    for my $v1 (@$l1) {\n        for\
    \ my $v2 (@$l2) {\n            if ($v1 == $v2) {\n                push @l, $v1;\n\
    \                last;\n            }\n        }\n    }\n    return @l;\n}", " \
    \   return sort { $a <=> $b } keys %{{map {$_ => 1} @$l1},\n                 \
    \                   {map {$_ => 1} @$l2}};\n}", "    my %h = ();\n    @h{@$l1}\
    \ = ();\n    return sort {$a <=> $b} grep {$h{$_}} @$l2;\n}", "    my %l2 = map\
    \ { $_ => 1 } @$l2;\n    return sort { $a <=> $b } grep { exists $l2{$_} } @$l1;\n\
    }", "    my %h;\n    $h{$_}++ for @$l1;\n    return [ grep { $h{$_} } @$l2 ];\n\
    }", "    my(%result, @result);\n    undef @result;\n    %result = ();\n    map\
    \ { $result{$_}=1; } @$l1;\n    map {\n      if ($result{$_}) {\n          push\
    \ @result, $_;\n          delete $result{$_};\n      }\n    } @$l2;\n    return\
    \ sort @result;\n}", "    my(%h);\n    for(@$l1) {\n        $h{$_} = 1;\n    }\n\
    \    for(@$l2) {\n        $h{$_} = 1;\n    }\n    return sort keys %h;\n}", " \
    \   my(%x) = map {$_ => 1} @$l1;\n    my(@r) = grep $x{$_}, @$l2;\n    sort {$a\
    \ <=> $b} @r;\n}", "    my %l;\n    $l{$_}++ for @$l1;\n    $l{$_}++ for @$l2;\n\
    \    return sort { $a <=> $b } grep { $l{$_} > 1 } keys %l;\n}", "    my(%l1,\
    \ %l2);\n    my($i);", "    return grep {\n        my $e = $_;\n        my $f\
    \ = 0;\n        for (@$l1) { $f = 1 if $_ == $e }\n        for (@$l2) { $f = 0\
    \ if $_ == $e }\n        $f;\n    } @$l1, @$l2;\n}", "    my $s = {};\n    $s->{$_}++\
    \ for @$l1;\n    grep { $s->{$_} == 2 } @$l2;\n}", "    my(%h, @r);\n    $h{$_}++\
    \ for @$l1;\n    $h{$_}++ for @$l2;\n    push @r, $_ if $h{$_} == 2;\n    @r;\n\
    }", "    my %hash;\n    @hash{ @$l1 } = (1) x @$l1;\n    my @result = grep { $hash{$_}\
    \ } @$l2;\n    return @result;\n}", "    my(%uniq, @commons);\n    @uniq{@$l1}\
    \ = @$l2;\n    @commons = grep { defined $uniq{$_} } keys %uniq;\n    @commons;\n\
    }", "    my %union;\n    @union{@$l1} = ();\n    @union{@$l2} = ();\n    return\
    \ sort {$a <=> $b} keys %union;\n}", "    return sort keys %{{ map { $_ => 1 }\
    \ @$l1 }, { map { $_ => 1 } @$l2 }};\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
