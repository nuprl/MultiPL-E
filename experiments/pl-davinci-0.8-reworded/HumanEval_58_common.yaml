name: HumanEval_58_common
language: pl
prompt: "# Return sorted unique common elements for two arrays.\n# >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n\
  \        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
  \ 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return() unless $l1 && $l2;\n    my @l1 = sort @$l1;\n    my @l2\
    \ = sort @$l2;\n    my @l;\n    while (@l1 && @l2) {\n        my $s1 = shift @l1;\n\
    \        my $s2 = shift @l2;\n        my $cmp = $s1 <=> $s2;\n        if ($cmp\
    \ == 0) {\n            push @l, $s1;\n        } elsif ($cmp < 0) {\n         \
    \   unshift @l2, $s2;\n        } else {\n            unshift @l1, $s1;\n     \
    \   }\n    }\n    return @l;\n}", "    my $h1 = _hashify($l1);\n    my $h2 = _hashify($l2);\n\
    \    [sort {$a <=> $b} keys %$h1, keys %$h2];\n}", "    my %h = ();\n    foreach\
    \ my $e (@$l1) {\n        $h{$e} = 1;\n    }\n    my @c = ();\n    foreach my\
    \ $e (@$l2) {\n        if ($h{$e}) {\n            push @c, $e;\n        }\n  \
    \  }\n    return scalar(@c) > 0 ? [sort {$a <=> $b} @c] : [];\n}", "    my(%l1)\
    \ = map {$_ => 1} @$l1;\n    my(@l3) = grep { $l1{$_} } @$l2;\n    return wantarray\
    \ ? sort {$a <=> $b} keys %{ { map { $_ => 1 } @l3 } } :\n                   \
    \    scalar @l3;\n}", "    my %h = map {$_ => undef} @$l1;\n    my @common = grep\
    \ { exists $h{$_} } @$l2;\n    return @common;\n}", "    my %l1;\n    my %l2;\n\
    \    foreach my $e (@$l1) {\n        $l1{$e}++;\n    }\n    foreach my $e (@$l2)\
    \ {\n        $l2{$e}++;\n    }\n    my @out;\n    foreach my $e (keys %l1) {\n\
    \        push @out, $e if $l2{$e};\n    }\n    return sort @out;\n}", "    my\
    \ %h;\n    @h{@$l1} = ();\n    return [ sort { $a <=> $b } grep { defined($h{$_})\
    \ } @$l2 ];\n}", "    my $a1 = @$l1;\n    my $a2 = @$l2;\n    my @common = ();\n\
    \    for(my $i=0; $i<$a1; $i++) {\n        for(my $j=0; $j<$a2; $j++) {\n    \
    \        if($l1->[$i] eq $l2->[$j]) {\n                push(@common, $l1->[$i]);\n\
    \                $l2->[$j] = undef;\n                last;\n            }\n  \
    \      }\n    }\n    return @common;\n}", "    my %s1 = map { $_ => 1 } @$l1;\n\
    \    my %s2 = map { $_ => 1 } @$l2;\n    my @result = sort grep $s1{$_} && $s2{$_},\
    \ keys %s1;\n    \\@result;\n}", "    return () unless @$l1 and @$l2;\n    my\
    \ %h = map { $_ => 1 } @$l2;\n    return grep $h{$_}, @$l1;\n}", "    return []\
    \ unless $l1;\n    return [] unless $l2;\n    my $h = {};\n    map { $h->{$_}\
    \ = 1 } @$l1;\n    my @common = grep { $h->{$_} } @$l2;\n    return [ sort { $a\
    \ <=> $b } @common ];\n}", "    my @l1 = sort { $a <=> $b } @$l1;\n    my @l2\
    \ = sort { $a <=> $b } @$l2;\n    my %l1 = map { $_ => 1 } @l1;\n    return grep\
    \ { $l1{$_} } @l2;\n}", "    my(%h1, %h2, %common);\n    $h1{$_}++ for @$l1;\n\
    \    $h2{$_}++ for @$l2;\n    $common{$_}++ for grep $h1{$_}, keys %h2;\n    sort\
    \ keys %common;\n}", "    my(%h1, %h2, %h);\n    foreach my $i (@$l1) {\n    \
    \    $h1{$i} = 1;\n    }\n    foreach my $i (@$l2) {\n        $h2{$i} = 1;\n \
    \   }\n    foreach my $i (keys %h1) {\n        $h{$i} = 1 if exists $h2{$i};\n\
    \    }\n    return keys %h;\n}", "    my %h = ();\n    foreach my $e (@$l1) {\n\
    \        $h{$e} = 1;\n    }\n    my @common = ();\n    foreach my $e (@$l2) {\n\
    \        if (exists $h{$e}) {\n            push @common, $e;\n        }\n    }\n\
    \    return @common;\n}", "    my %h;\n    grep(++$h{$_}, @$l1);\n    grep(delete($h{$_}),\
    \ @$l2);\n    return sort keys %h;\n}", "    my $h = {};\n    my $res = [];\n\
    \    for my $i ( @$l1 ) {\n        if ( !$h->{$i} ) {\n            $h->{$i} =\
    \ 1;\n        }\n    }\n    for my $i ( @$l2 ) {\n        if ( $h->{$i} ) {\n\
    \            push @$res, $i;\n            $h->{$i} = 0;\n        }\n    }\n  \
    \  return $res;\n}", "    my @l1 = sort { $a <=> $b } @$l1;\n    my @l2 = sort\
    \ { $a <=> $b } @$l2;\n    my @isect;\n    while (@l1 && @l2) {\n        if ($l1[0]\
    \ == $l2[0]) {\n            push @isect, shift @l1;\n            shift @l2;\n\
    \        }\n        elsif ($l1[0] < $l2[0]) {\n            shift @l1;\n      \
    \  }\n        else {\n            shift @l2;\n        }\n    }\n    return @isect;\n\
    }", "    my %count;\n    grep { $count{$_}++ } @$l1;\n    grep { $count{$_}++\
    \ } @$l2;\n    return grep { $count{$_} == 2 } keys %count;\n}", "    my(%s);\n\
    \    return grep { $s{$_}++ == 1 } sort @$l1, @$l2;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
