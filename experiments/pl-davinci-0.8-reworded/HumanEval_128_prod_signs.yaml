name: HumanEval_128_prod_signs
language: pl
prompt: "# You are given an array arr of integers and you need to return\n# sum of\
  \ magnitudes of integers multiplied by product of all signs\n# of each number in\
  \ the array, represented by 1, -1 or 0.\n# Note: return undef for empty arr.\n#\
  \ Example:\n# >>> prod_signs([1, 2, 2, -4])\n# 9\n# >>> prod_signs([0, 1])\n# 0\n\
  # >>> prod_signs([])\n# undef\nsub prod_signs {\n    my($arr) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prod_signs;\n\
  \        if(eq_deeply($candidate->([1, 2, 2, -4]),-9)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),0))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 1, 1, 2, 3, -1, 1]),-10)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 1,\
  \ 2, -1, -1, 9]),20)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([-1, 1, -1, 1]),4)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1,\
  \ 1, 1]),-4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n    \
  \    if(eq_deeply($candidate->([-1, 1, 1, 0]),0)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $ans = 1;\n    for my $num (@$arr) {\n        if ($num == 0)\
    \ {\n            return 0;\n        } elsif ($num > 0) {\n            $ans *=\
    \ 1;\n        } else {\n            $ans *= -1;\n        }\n    }\n    return\
    \ undef if !$ans;\n    return sum(map { abs($_) } @$arr) * $ans;\n}", "    return\
    \ undef unless(scalar(@$arr));\n    my $signs = 1;\n    my $sum = 0;\n    for\
    \ my $n (@$arr) {\n        $signs *= ($n == 0 ? 0 : ($n > 0 ? 1 : -1));\n    \
    \    $sum += abs($n);\n    }\n    return $signs * $sum;\n}", "    return undef\
    \ unless(@$arr);\n    my $prod = 1;\n    my $sum = 0;\n    foreach my $elem (@$arr)\
    \ {\n        $prod *= ($elem > 0 ? 1 : ($elem < 0 ? -1 : 0));\n        $sum +=\
    \ $elem;\n    }\n    return $prod * $sum;\n}", "    return unless defined $arr\
    \ && ref $arr eq 'ARRAY';\n    my $prod = 1;\n    my $sum = 0;\n    for (@$arr)\
    \ {\n        next unless defined;\n        if ($_ > 0) {\n            $prod *=\
    \ 1;\n            $sum += $_;\n        } elsif ($_ < 0) {\n            $prod *=\
    \ -1;\n            $sum += -$_;\n        } else {\n            $prod *= 0;\n \
    \       }\n    }\n    return $prod*$sum;\n}", "    return undef unless $arr;\n\
    \    my $sign_prod = 1;\n    my $mag_sum = 0;\n    foreach my $int (@$arr) {\n\
    \        $sign_prod *= sign($int);\n        $mag_sum += abs($int);\n    }\n  \
    \  return $sign_prod * $mag_sum;\n}", "    return undef unless defined $arr;\n\
    \    return 0 if ref $arr ne 'ARRAY' or @$arr == 0;\n    my($sign, $prod) = (1,\
    \ 1);\n    for my $n (@$arr) {\n        my $m = abs $n;\n        if ($m > 0) {\n\
    \            $sign = $sign * ($n / $m);\n            $prod *= $m;\n        } else\
    \ {\n            $prod = 0;\n            last;\n        }\n    }\n    return $prod\
    \ * $sign;\n}", "    my $prod = 1;\n    my $sum = 0;\n    return undef unless\
    \ scalar @$arr;\n    foreach my $num (@$arr) {\n        if ($num > 0) {\n    \
    \        $prod *= 1;\n            $sum += $num;\n        } elsif ($num < 0) {\n\
    \            $prod *= -1;\n            $sum += $num * -1;\n        }\n    }\n\
    \    return $sum * $prod;\n}", "    return undef unless @$arr;\n    my $signs\
    \ = [map {$_ <=> 0} @$arr];\n    my $mag = [map {abs($_)} @$arr];\n    return\
    \ product($signs) * sum($mag);\n}", "    my $i = 0;\n    my $prod_signs = 1;\n\
    \    my $result = 0;\n    while ( $i < @$arr ) {\n        if ( $arr->[$i] == 0\
    \ ) {\n            $prod_signs = 0;\n        } elsif ( $arr->[$i] < 0 ) {\n  \
    \          $prod_signs *= -1;\n        }\n        $result += abs( $arr->[$i] );\n\
    \        $i++;\n    }\n    return undef if $result == 0;\n    return $result *\
    \ $prod_signs;\n}", "    my($signs_prod, $abs_sum) = 1, 0;\n    # Fill-in the\
    \ code here!\n    return undef if (!defined($arr));\n    return 0 if (scalar(@$arr)\
    \ == 0);\n    $signs_prod = 1;\n    $abs_sum = 0;\n    foreach my $el (@$arr)\
    \ {\n        if ($el == 0) {\n            return 0;\n        }\n        $signs_prod\
    \ *= ($el > 0) ? 1 : -1;\n        $abs_sum += abs($el);\n    }\n    return $signs_prod\
    \ * $abs_sum;\n}", "    return unless @$arr;\n    my $prod = 1;\n    my $sum =\
    \ 0;\n    for my $n (@$arr) {\n        if ($n > 0) {\n            $prod *= 1;\n\
    \            $sum += $n;\n        } elsif ($n < 0) {\n            $prod *= -1;\n\
    \            $sum += -$n;\n        } else {\n            $prod *= 0;\n       \
    \ }\n    }\n    return $sum * $prod;\n}", "    return if !@$arr;\n    my $prod\
    \ = 1;\n    my $sum = 0;\n    for my $n (@$arr) {\n        $prod *= $n >= 0 ?\
    \ 1 : -1;\n        $sum += abs($n);\n    }\n    return $sum * $prod;\n}", "  \
    \  return undef unless @$arr;\n    my $prod = reduce { $a * $b } map { $_ <=>\
    \ 0 } @$arr;\n    return reduce { $a + abs($b) } 0, @$arr * $prod;\n}", "    return\
    \ undef unless defined $arr;\n    return 0 if scalar @$arr == 0;\n    my $signs\
    \ = 1;\n    my $magnitudes = 0;\n    foreach my $el (@$arr) {\n        $signs\
    \ *= $el == 0 ? 0 : $el < 0 ? -1 : 1;\n        $magnitudes += abs($el);\n    }\n\
    \    return $signs * $magnitudes;\n}", "    # ...\n}", "    my($prod) = 1;\n \
    \   my($sum) = 0;\n    my($idx) = 0;\n    my($sign) = 0;\n    foreach my $n (@$arr)\
    \ {\n        if ($n == 0) {\n            $sign = 0;\n        } elsif ($n > 0)\
    \ {\n            $sign = 1;\n        } else {\n            $sign = -1;\n     \
    \   }\n        $prod *= $sign;\n        $sum += abs($n);\n    }\n    if ($prod\
    \ == 0) {\n        return 0;\n    }\n    return $sum * $prod;\n}", "    my $prod\
    \ = 1;\n    my $sum = 0;\n    foreach (@$arr) {\n        if ($_ > 0) {\n     \
    \       $prod *= 1;\n            $sum += $_;\n        } elsif ($_ < 0) {\n   \
    \         $prod *= -1;\n            $sum += -$_;\n        }\n    }\n    return\
    \ undef if $sum == 0;\n    return $prod * $sum;\n}", "    my($total, $prod);\n\
    \    for my $num (@$arr) {\n        if ($num < 0) {\n            $prod = defined($prod)\
    \ ? $prod * -1 : -1;\n        } elsif ($num > 0) {\n            $prod = defined($prod)\
    \ ? $prod * 1 : 1;\n        } else {\n            $prod = 0;\n        }\n    \
    \    $total += abs($num);\n    }\n    return defined($prod) ? $total * $prod :\
    \ undef;\n}", "    my $prod = 1;\n    my $sum = 0;\n    foreach my $num (@$arr)\
    \ {\n        my $sign = $num == 0 ? 0 : $num / abs($num);\n        $prod *= $sign;\n\
    \        $sum += abs($num);\n    }\n    $prod * $sum;\n}", "    my $prod_signs\
    \ = 1;\n    my $sum_magnitudes = 0;\n    foreach(@$arr) {\n        if ($_ > 0)\
    \ {\n            $prod_signs *= 1;\n            $sum_magnitudes += $_;\n     \
    \   } elsif ($_ < 0) {\n            $prod_signs *= -1;\n            $sum_magnitudes\
    \ += -$_;\n        } else {\n            $prod_signs *= 0;\n        }\n    }\n\
    \    return $prod_signs * $sum_magnitudes;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
