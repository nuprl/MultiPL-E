name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return an array containing the result string and 1/ for\
  \ the check.\n# Example\n# >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\", \"\
  \"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"\
  abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my $result = \"\";\n    my $flag = 0;\n    # a hash to store chars\
    \ in c\n    my %hash = ();\n    for my $ch (split //, $c) {\n        $hash{$ch}\
    \ = 1;\n    }\n    for my $ch (split //, $s) {\n        if (!exists $hash{$ch})\
    \ {\n            $result .= $ch;\n        }\n    }\n    my $len = length($result);\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $flag = 1;\n          \
    \  last;\n        }\n    }\n    return [$result, $flag];\n}", "    my $res = $s;\n\
    \    $res =~ s/[$c]//g;\n    my $s1 = reverse $res;\n    my $r = ($res eq $s1)?1:0;\n\
    \    return [$res, $r];\n}", "    my @result = split //, $s;\n    my %subset =\
    \ map { $_ => 1 } split //, $c;\n    @result = grep { not exists $subset{$_} }\
    \ @result;\n    my $palindrome = join '', @result;\n    my $check = $palindrome\
    \ eq reverse $palindrome ? 1 : '';\n    return [$palindrome, $check];\n}", " \
    \   return $s unless length $c;\n    my $h = {map {$_ => 1} split \"\", $c};\n\
    \    $s = join \"\", grep {not $h->{$_}} split \"\", $s;\n    return [$s, is_palindrome($s)];\n\
    }", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my %h;\n\
    \    map { $h{$_} = 1 } split('', $c);\n    my $ret = '';\n    for (split('',\
    \ $s)) {\n        $ret .= $_ unless $h{$_};\n    }\n    return [$ret, $ret eq\
    \ scalar reverse $ret ? 1 : ''];\n}", "    my $res = join '',grep(!/$c/, split(//,\
    \ $s));\n    my $is_palindrome = $res eq reverse $res;\n    return [$res, $is_palindrome];\n\
    }", "    my @arr = grep { my $x = $_; not grep { $x eq $_ } split(\"\", $c) }\
    \ split(\"\", $s);\n    return [join(\"\", @arr), join(\"\", @arr) eq join(\"\"\
    , reverse @arr)];\n}", "    $s =~ s/[$c]//g;\n    my $reversed = reverse $s;\n\
    \    return [$s, $s eq $reversed];\n}", "    $s =~ s/[$c]//g;\n    return [$s,\
    \ $s eq reverse($s)];\n}", "    for my $i (0..length($c)-1) {\n        $s =~ s/$c/$c/g;\n\
    \    }\n    $s =~ s/\\s//g;\n    return [$s, int($s eq reverse($s))];\n}", " \
    \   return [\n        join(\"\", reverse(split(\"\", $s))),\n        $s =~ /^$c+$/\
    \ ? 1 : \"\",\n    ];\n}\n1;", "    my %a;\n    my $t = '';\n    my $n = 0;\n\
    \    my $t = $s;\n    map { $a{$_} = 1 } split //, $c;\n    map { $t =~ s/$_//g\
    \ } keys %a;\n    map { $n += ( $t =~ s/$_($_)//g ? 1 : 0 ) } qw{a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z};\n    my $r = $t;\n    $r =~ s/\\s+//g;\n\
    \    return [$t, $r eq reverse $r];\n}", "    $s =~ s/$c//gi;\n    my $s1 = $s;\n\
    \    $s1 =~ s/\\s//gi;\n    my $s2 = reverse $s1;\n    return [$s, ($s1 eq $s2)];\n\
    }", "    my @a = split(\"\", $s);\n    my @b = split(\"\", $c);\n    my @array\
    \ = ();\n    my @deleted = ();\n    my $flag = 0;\n    my $count = 0;\n    my\
    \ $c_len = length($c);\n    my $s_len = length($s);\n    for ($i = 0; $i < $c_len;\
    \ $i++) {\n        for ($j = 0; $j < $s_len; $j++) {\n            if ($a[$j] eq\
    \ $b[$i]) {\n                $count++;\n                push @deleted, $a[$j];\n\
    \            }\n        }\n    }\n    if ($count == $s_len) {\n        $flag =\
    \ 1;\n    }\n    my $len = length(@deleted);\n    for ($i = 0; $i < $s_len; $i++)\
    \ {\n        $flag2 = 0;\n        for ($j = 0; $j < $len; $j++) {\n          \
    \  if ($a[$i] eq $deleted[$j]) {\n                $flag2 = 1;\n            }\n\
    \        }\n        if ($flag2 == 0) {\n            push @array, $a[$i];\n   \
    \     }\n    }\n    return [@array, $flag];\n}", "    my $del = $s;\n    $del\
    \ =~ s/[$c]//g;\n    my $check = $del eq reverse $del ? 1 : '';\n    return [$del,\
    \ $check];\n}", "    $s =~ s/[$c]//g;\n    my $result = reverse($s) eq $s ? 1\
    \ : '';\n    return [$s, $result];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %ignore = map { $_ => 1 } split //, $c;\n    my @chars = split\
    \ //, $s;\n    while (scalar @chars) {\n        my $char = pop @chars;\n     \
    \   unless ($ignore{$char}) {\n            unshift @chars, $char;\n          \
    \  $result .= $char;\n        }\n    }\n    my @result_chars = split //, $result;\n\
    \    while (scalar @result_chars) {\n        my $char = pop @result_chars;\n \
    \       unless ($char eq shift @result_chars) {\n            $is_palindrome =\
    \ 0;\n            last;\n        }\n    }\n    [$result, $is_palindrome];\n}",
  "    my $f = join( '', map { chr($_) } ( 97 .. 122 ) );\n    my $i = join( '', grep\
    \ { $f =~ /$_/ } split //, $c );\n    $f =~ s/$i//g;\n    my $r = join( '', grep\
    \ { $f =~ /$_/ } split //, $s );\n    $r = '' if $r eq 'd';\n    my $y = $r eq\
    \ scalar reverse $r ? 1 : '';\n    return [ $r, $y ];\n}", "    my $i = 0;\n \
    \   while($i < length($s)) {\n        if(index($c, substr($s, $i, 1)) != -1) {\n\
    \            substr($s, $i, 1) = \"\";\n            next;\n        }\n       \
    \ $i++;\n    }\n    return [$s, $s eq reverse($s)];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
