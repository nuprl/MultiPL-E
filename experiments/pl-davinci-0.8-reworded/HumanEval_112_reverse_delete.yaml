name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return an array containing the result string and 1/ for\
  \ the check.\n# Example\n# >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\", \"\
  \"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"\
  abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my $result = \"\";\n    my $flag = 0;\n    # a hash to store chars\
    \ in c\n    my %hash = ();\n    for my $ch (split //, $c) {\n        $hash{$ch}\
    \ = 1;\n    }\n    for my $ch (split //, $s) {\n        if (!exists $hash{$ch})\
    \ {\n            $result .= $ch;\n        }\n    }\n    my $len = length($result);\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $flag = 1;\n          \
    \  last;\n        }\n    }\n    return [$result, $flag];\n}", "    my $res = $s;\n\
    \    $res =~ s/[$c]//g;\n    my $s1 = reverse $res;\n    my $r = ($res eq $s1)?1:0;\n\
    \    return [$res, $r];\n}", "    my @result = split //, $s;\n    my %subset =\
    \ map { $_ => 1 } split //, $c;\n    @result = grep { not exists $subset{$_} }\
    \ @result;\n    my $palindrome = join '', @result;\n    my $check = $palindrome\
    \ eq reverse $palindrome ? 1 : '';\n    return [$palindrome, $check];\n}", " \
    \   return $s unless length $c;\n    my $h = {map {$_ => 1} split \"\", $c};\n\
    \    $s = join \"\", grep {not $h->{$_}} split \"\", $s;\n    return [$s, is_palindrome($s)];\n\
    }", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my %h;\n\
    \    map { $h{$_} = 1 } split('', $c);\n    my $ret = '';\n    for (split('',\
    \ $s)) {\n        $ret .= $_ unless $h{$_};\n    }\n    return [$ret, $ret eq\
    \ scalar reverse $ret ? 1 : ''];\n}", "    my $res = join '',grep(!/$c/, split(//,\
    \ $s));\n    my $is_palindrome = $res eq reverse $res;\n    return [$res, $is_palindrome];\n\
    }", "    my @arr = grep { my $x = $_; not grep { $x eq $_ } split(\"\", $c) }\
    \ split(\"\", $s);\n    return [join(\"\", @arr), join(\"\", @arr) eq join(\"\"\
    , reverse @arr)];\n}", "    $s =~ s/[$c]//g;\n    my $reversed = reverse $s;\n\
    \    return [$s, $s eq $reversed];\n}", "    $s =~ s/[$c]//g;\n    return [$s,\
    \ $s eq reverse($s)];\n}", "    for my $i (0..length($c)-1) {\n        $s =~ s/$c/$c/g;\n\
    \    }\n    $s =~ s/\\s//g;\n    return [$s, int($s eq reverse($s))];\n}", " \
    \   return [\n        join(\"\", reverse(split(\"\", $s))),\n        $s =~ /^$c+$/\
    \ ? 1 : \"\",\n    ];\n}\n1;", "    my %a;\n    my $t = '';\n    my $n = 0;\n\
    \    my $t = $s;\n    map { $a{$_} = 1 } split //, $c;\n    map { $t =~ s/$_//g\
    \ } keys %a;\n    map { $n += ( $t =~ s/$_($_)//g ? 1 : 0 ) } qw{a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z};\n    my $r = $t;\n    $r =~ s/\\s+//g;\n\
    \    return [$t, $r eq reverse $r];\n}", "    $s =~ s/$c//gi;\n    my $s1 = $s;\n\
    \    $s1 =~ s/\\s//gi;\n    my $s2 = reverse $s1;\n    return [$s, ($s1 eq $s2)];\n\
    }", "    my @a = split(\"\", $s);\n    my @b = split(\"\", $c);\n    my @array\
    \ = ();\n    my @deleted = ();\n    my $flag = 0;\n    my $count = 0;\n    my\
    \ $c_len = length($c);\n    my $s_len = length($s);\n    for ($i = 0; $i < $c_len;\
    \ $i++) {\n        for ($j = 0; $j < $s_len; $j++) {\n            if ($a[$j] eq\
    \ $b[$i]) {\n                $count++;\n                push @deleted, $a[$j];\n\
    \            }\n        }\n    }\n    if ($count == $s_len) {\n        $flag =\
    \ 1;\n    }\n    my $len = length(@deleted);\n    for ($i = 0; $i < $s_len; $i++)\
    \ {\n        $flag2 = 0;\n        for ($j = 0; $j < $len; $j++) {\n          \
    \  if ($a[$i] eq $deleted[$j]) {\n                $flag2 = 1;\n            }\n\
    \        }\n        if ($flag2 == 0) {\n            push @array, $a[$i];\n   \
    \     }\n    }\n    return [@array, $flag];\n}", "    my $del = $s;\n    $del\
    \ =~ s/[$c]//g;\n    my $check = $del eq reverse $del ? 1 : '';\n    return [$del,\
    \ $check];\n}", "    $s =~ s/[$c]//g;\n    my $result = reverse($s) eq $s ? 1\
    \ : '';\n    return [$s, $result];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %ignore = map { $_ => 1 } split //, $c;\n    my @chars = split\
    \ //, $s;\n    while (scalar @chars) {\n        my $char = pop @chars;\n     \
    \   unless ($ignore{$char}) {\n            unshift @chars, $char;\n          \
    \  $result .= $char;\n        }\n    }\n    my @result_chars = split //, $result;\n\
    \    while (scalar @result_chars) {\n        my $char = pop @result_chars;\n \
    \       unless ($char eq shift @result_chars) {\n            $is_palindrome =\
    \ 0;\n            last;\n        }\n    }\n    [$result, $is_palindrome];\n}",
  "    my $f = join( '', map { chr($_) } ( 97 .. 122 ) );\n    my $i = join( '', grep\
    \ { $f =~ /$_/ } split //, $c );\n    $f =~ s/$i//g;\n    my $r = join( '', grep\
    \ { $f =~ /$_/ } split //, $s );\n    $r = '' if $r eq 'd';\n    my $y = $r eq\
    \ scalar reverse $r ? 1 : '';\n    return [ $r, $y ];\n}", "    my $i = 0;\n \
    \   while($i < length($s)) {\n        if(index($c, substr($s, $i, 1)) != -1) {\n\
    \            substr($s, $i, 1) = \"\";\n            next;\n        }\n       \
    \ $i++;\n    }\n    return [$s, $s eq reverse($s)];\n}", "    my $res = $s;\n\
    \    $res =~ s/[$c]//g;\n    my $check = $res eq reverse $res ? 1 : '';\n    return\
    \ [$res, $check];\n}", "    $s =~ s/$c//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my $count = 0;\n    foreach my $char (split '', $c) {\n        while($s\
    \ =~ /$char/) {\n            $s =~ s/$char//;\n            $count++;\n       \
    \ }\n    }\n    return [$s, $count%2];\n}", "    foreach my $i (split //, $c)\
    \ {\n        $s =~ s/$i//g;\n    }\n    my $ret = $s eq reverse $s ? 1 : '';\n\
    \    return [$s, $ret];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my @c_chars = split('', $c);\n    my @s_chars = split('', $s);\n    my\
    \ %is_c_char = map {$_ => 1} @c_chars;\n    @s_chars = grep {!$is_c_char{$_}}\
    \ @s_chars;\n    my $is_palindrome = is_palindrome(\\@s_chars);\n    return [join('',\
    \ @s_chars), $is_palindrome];\n}", "    my @res = split //, $s;\n    my @chars\
    \ = split //, $c;\n    foreach (@chars) {\n        @res = grep { !/$_/ } @res;\n\
    \    }\n    return [join(\"\", @res), (join(\"\", @res) eq reverse join(\"\",\
    \ @res)) ? 1 : \"\"];\n}", "    $s =~ s/$c//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my @c_split = split //, $c;\n    foreach my $char (@c_split) {\n    \
    \    $s =~ s/$char//g;\n    }\n    my $flag = ($s eq reverse $s) ? 1 : \"\";\n\
    \    return $s, $flag;\n}", "    $s =~ s/[$c]//g;\n    return [$s, ($s eq reverse\
    \ $s)];\n}", "    my $r = reverse($s);\n    my @c_arr = split('', $c);\n    my\
    \ @s_arr = split('', $s);\n    my @r_arr = split('', $r);\n    my @result;\n \
    \   my $check = 0;\n    my %keys = map { $_ => undef } @c_arr;\n    @r_arr = grep\
    \ { !exists $keys{$_} } @r_arr;\n    if (join('', @r_arr) eq join('', @s_arr))\
    \ {\n        $check = 1;\n    }\n    @result = [join('', @r_arr), $check];\n \
    \   return @result;\n}\nprint \"@{reverse_delete('abcde', 'ae')}\";\nprint \"\
    @{reverse_delete('abcdef', 'b')}\";\nprint \"@{reverse_delete('abcdedcba', 'ab')}\"\
    ;", "    my $new = \"\";\n    for my $chr (split '', $s) {\n        if (index($c,\
    \ $chr) == -1) {\n            $new .= $chr;\n        }\n    }\n    return [$new,\
    \ $new eq scalar reverse $new];\n}", "    return [\"\", 1] if $s eq \"\" && $c\
    \ eq \"\";\n    my @s = split //, $s;\n    my @c = split //, $c;\n    my @sc =\
    \ (@s, @c);\n    @sc = uniq(@sc);\n    my $r;\n    my $res = \"\";\n    foreach\
    \ my $item (@sc) {\n        $r = @s;\n        foreach my $l (@s) {\n         \
    \   $r-- if ($l eq $item);\n        }\n        $res .= $item;\n    }\n    my $rev_res\
    \ = reverse $res;\n    return ($rev_res eq $res) ? [$res, 1] : [$res, 0];\n}",
  "    my %c = map { $_ => 1 } split //, $c;\n    my @s = grep { !$c{$_} } split //,\
    \ $s;\n    return [join('', @s), int(join('', @s) eq join('', reverse @s))];\n\
    }", "    my @c = grep { !/\\s/ && /^./ } split //, $c;\n    my $f = 1;\n    my\
    \ $i = 0;\n    while($i < length($s)) {\n        my $f1 = 0;\n        for my $j\
    \ (0..$#c) {\n            if(substr($s, $i, 1) eq $c[$j]) {\n                $f1\
    \ = 1;\n                $f = 0;\n                last;\n            }\n      \
    \  }\n        if($f1) {\n            $s = substr($s, 0, $i).substr($s, $i+1);\n\
    \        } else {\n            $i++;\n        }\n    }\n    return [$s, $f];\n\
    }", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map {$_\
    \ => 1} @c;\n    my @result = grep {!$c{$_}} @s;\n    return [join('', @result),\
    \ is_palindrome(join('', @result))];\n}", "    $s =~ s/[$c]//g;\n    return [$s,\
    \ $s eq reverse($s)];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    $s =~ s/[$c]//g;\n    my $res = $s eq scalar reverse $s ? 1 : '';\n \
    \   return [$s, $res];\n}", "    my $s_copy = $s;\n    # delete characters from\
    \ $s_copy that are equal to any character in $c\n    $s_copy =~ s/[$c]//g;\n \
    \   my $check = ($s_copy eq reverse $s_copy) ? 1 : '';\n    return [$s_copy, $check];\n\
    }", "    my %hash = map { $_ => 1 } split //, $c;\n    my $s_new = join '', grep\
    \ { not exists $hash{$_} } split //, $s;\n    my $check = $s_new eq reverse $s_new\
    \ ? 1 : '';\n    return [$s_new, $check];\n}\nmy @input = qw(abcde ae);\nmy $result\
    \ = reverse_delete(@input);\nsay @$result;", "    my $res = $s;\n    my $check\
    \ = 0;\n    my %hash;\n    map {$hash{$_} = 1} split //, $c;\n    map {if ($hash{$_})\
    \ {$res =~ s/$_//g}} split //, $s;\n    $check = 1 if ($res eq reverse $res);\n\
    \    return [$res, $check];\n}", "    my @s = split('', $s);\n    my @c = split('',\
    \ $c);\n    my %hash;\n    foreach (@c) {\n        $hash{$_} = 1;\n    }\n   \
    \ @s = grep {!$hash{$_}} @s;\n    my $s = join('', @s);\n    my $n = int(@s /\
    \ 2);\n    for my $i (0 .. $n - 1) {\n        last if $s[$i] ne $s[$n - $i - 1];\n\
    \    }\n    return $i == $n - 1 ? [$s, 1] : [$s, 0];\n}\nmy $res = reverse_delete(\"\
    abcdedcba\", \"ab\");\nprint Dumper($res);", "    $s =~ s/$c//g;\n    my $rev\
    \ = reverse $s;\n    return [$s, $s eq $rev];\n}", "    $s =~ s/[$c]//g;\n   \
    \ return [$s, $s eq reverse($s)];\n}", "    my %c = map { $_ => 1 } split \"\"\
    , $c;\n    my @s = split \"\", $s;\n    @s = grep { !$c{$_} } @s;\n    my $t =\
    \ join \"\", @s;\n    my $r = reverse $t;\n    return [$t, $t eq $r];\n}", " \
    \   my $del = join '', split //, $c;\n    my $s_s = join '', split //, $s;\n \
    \   $s_s =~ s/[$del]//gi;\n    return [$s_s, $s_s eq reverse $s_s];\n}", "   \
    \ my $r = '';\n    my $re = join('|', map { quotemeta } split('', $c));\n    for\
    \ my $a (split('', $s)) {\n        $r .= $a unless $a =~ /$re/;\n    }\n    $r\
    \ = reverse $r;\n    return [$r, $r eq $s];\n}", "    my @c = split \"\", $c;\n\
    \    my @s = split \"\", $s;\n    my @t = ();\n    my $j = -1;\n    for my $i(0..$#s)\
    \ {\n        $j++;\n        if(grep {$s[$i] eq $_} @c) {\n            next;\n\
    \        }\n        $t[$j] = $s[$i];\n    }\n    my $r = @t == 0 ? \"\" : join\
    \ \"\", @t;\n    my $p = @t == 0 ? \"\" : join \"\", reverse @t;\n    return [$r,\
    \ $r eq $p ? 1 : \"\"];\n}", "    my $result = '';\n    my $is_palindrome = 1;\n\
    \    my %c = map {$_ => 1} split //, $c;\n    for (split //, $s) {\n        $result\
    \ .= $_ unless $c{$_};\n    }\n    my $len = length $result;\n    for my $i (0\
    \ .. $len/2) {\n        my $j = $len - $i - 1;\n        if (substr($result, $i,\
    \ 1) ne substr($result, $j, 1)) {\n            $is_palindrome = 0;\n         \
    \   last;\n        }\n    }\n    return [$result, $is_palindrome];\n}", "    my\
    \ @dels = split('', $c);\n    my $delete = 0;\n    my $result = \"\";\n    for\
    \ my $char (split('', $s)) {\n        if (grep {$_ eq $char} @dels) {\n      \
    \      $delete++;\n        } else {\n            $result = $char . $result;\n\
    \        }\n    }\n    return [$result, $delete];\n}", "    my $a = join('', $s\
    \ =~ /[^$c]/g);\n    return [$a, $a eq reverse($a)];\n}", "    my $result = '';\n\
    \    for my $char (split '', $s) {\n        $result .= $char unless $c =~ /$char/;\n\
    \    }\n    my $check = $result eq reverse $result ? 1 : '';\n    return [$result,\
    \ $check];\n}", "    $s =~ s/[$c]//g;\n    my $r = reverse $s;\n    return [$s,\
    \ $s eq $r ? 1 : 0];\n}", "    my $res = join '', grep { index($c, $_) == -1 }\
    \ split //, $s;\n    my $check = $res eq reverse $res ? 1 : '';\n    return [$res,\
    \ $check];\n}", "    if($s ne $c){\n        $s =~ s/$c//g;\n        $t = reverse\
    \ $s;\n        if($s eq $t){\n            return [$s,1];\n        }\n        else{\n\
    \            return [$s,0];\n        }\n    }\n    else{\n        return [$s,0];\n\
    \    }\n}", "    my @c = split //, $c;\n    my @s = split //, $s;\n    my %h;\n\
    \    @h{@c} = ();\n    my $r = join '', grep { ! exists $h{$_} } @s;\n    my $check\
    \ = $r eq reverse $r ? 1 : '';\n    return [$r, $check];\n}", "    my @c = split(//,\
    \ $c);\n    my $s2 = join(\"\", grep { my $z = $_; not scalar grep { $z eq $_\
    \ } @c } split(//, $s));\n    return [$s2, scalar $s2 eq scalar reverse $s2];\n\
    }", "    my $new = $s;\n    for my $char (split //, $c) {\n        $new =~ s/$char//g;\n\
    \    }\n    my $check = ($new eq reverse $new) ? 1 : \"\";\n    return [$new,\
    \ $check];\n}", "    my %s = map {$_ => 1} split //, $s;\n    my %c = map {$_\
    \ => 1} split //, $c;\n    while (my($k, $v) = each %c) {\n        delete $s{$k};\n\
    \    }\n    my $r = join '', keys %s;\n    my $r_r = reverse $r;\n    return [$r,\
    \ $r eq $r_r ? 1 : ''];\n}", "    my $d = 0;\n    for (reverse split(//, $c))\
    \ {\n        next unless $s =~ s/$_//g;\n        $d = 1;\n    }\n    return [$s,\
    \ $d && $s eq reverse($s)];\n}", "    my @new_s = grep { $c !~ m/$_/ } split //,\
    \ $s;\n    return [join('', @new_s), scalar @new_s == scalar @new_s % 2 ? 1 :\
    \ 0];\n}\nmy $s = <STDIN>;\nmy $c = <STDIN>;\nmy $result = reverse_delete($s,\
    \ $c);\nfor my $each (@$result) {\n    print \"$each\\n\";\n}", "    while ($s\
    \ =~ s/$c//g) {\n    }\n    return [$s, $s eq reverse($s)];\n}", "    my %chars\
    \ = map { $_ => 1 } split //, $c;\n    my @s = split //, $s;\n    my @res;\n \
    \   for my $char (@s) {\n        push @res, $char unless $chars{$char};\n    }\n\
    \    return [join('', @res), join('', @res) eq join('', reverse @res)];\n}", " \
    \   $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my $r;\n \
    \   map { $r = $s =~ s/$_//g } split(//, $c);\n    my $ss = (scalar reverse $s)\
    \ eq $s ? 1 : '';\n    return [$s, $ss];\n}", "    my $r = reverse $s;\n    my\
    \ %m = map {$_=>1} split '', $c;\n    $s = join '', grep {!$m{$_}} split '', $s;\n\
    \    return [$s, $s eq $r];\n}", "    $s =~ s/$c//g;\n    my $copy = $s;\n   \
    \ $copy =~ tr/A-Z/a-z/;\n    my $rev_copy = reverse $copy;\n    return [$s, $copy\
    \ eq $rev_copy ? 1 : 0];\n}", "    my %hash = map { $_ => 1 } split //, $c;\n\
    \    $s =~ s/[$c]//g;\n    my $flag = 0;\n    $flag = 1 if $s eq reverse $s;\n\
    \    [$s, $flag];\n}", "    my %h = map { $_ => 1 } split //, $c;\n    my @a =\
    \ grep { not $h{$_} } split //, $s;\n    my $r = join \"\", @a;\n    $r eq reverse\
    \ $r ? [$r, 1] : [$r, \"\"];\n}", "    my $temp = $s;\n    my $len = length($s);\n\
    \    my $check = 0;\n    my $i = 0;\n    while ($i < $len) {\n        my $char\
    \ = substr($temp, $i, 1);\n        if ($c =~ /$char/) {\n            substr($temp,\
    \ $i, 1) = \"\";\n            $len--;\n            $i--;\n        }\n        $i++;\n\
    \    }\n    my $n = $len / 2;\n    $i = 0;\n    while ($i < $n) {\n        my\
    \ $left_char = substr($temp, $i, 1);\n        my $right_char = substr($temp, $len\
    \ - $i - 1, 1);\n        if ($left_char ne $right_char) {\n            $check\
    \ = 1;\n            last;\n        }\n        $i++;\n    }\n    return [$temp,\
    \ $check];\n}", "    my $deleted = 0;\n    my %c = map { $_ => 1 } split //, $c;\n\
    \    my @s = split //, $s;\n    for (my $i = 0; $i < @s; $i++) {\n        if ($c{$s[$i]})\
    \ {\n            splice @s, $i, 1;\n            $i--;\n            $deleted++;\n\
    \        }\n    }\n    my $res = join \"\", @s;\n    return [$res, $res eq reverse\
    \ $res ? 1 : 0];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq scalar reverse\
    \ $s];\n}", "    my $r = \"\";\n    my $p = 1;\n    my %d = map {$_ => 1} split\
    \ //, $c;\n    my @s = split //, $s;\n    while (@s) {\n        $d{$s[-1]} or\
    \ $r .= pop @s;\n        pop @s;\n    }\n    for (my $i = 0; $i < int @s / 2;\
    \ $i++) {\n        $s[$i] ne $s[-1 - $i] and $p = 0;\n    }\n    return [$r, $p];\n\
    }", "    $s =~ s/[$c]//g;\n    $s = reverse $s;\n    my $t = $s;\n    return [$s,\
    \ $t eq $s];\n}", "    my $count = 0;\n    my %h;\n    @h{split //, $c} = ();\n\
    \    my $t = join '', grep { not exists $h{$_} } split //, $s;\n    $count = 1\
    \ if $t eq reverse $t;\n    return [$t, $count];\n}", "    $s =~ s/[$c]//g;\n\
    \    my $p = $s eq reverse $s;\n    return [$s, $p ? 1 : ''];\n}", "    my @a;\n\
    \    for (split(//, $s)) {\n        push @a, $_ unless $c =~ /$_/;\n    }\n  \
    \  join(\"\", @a) eq reverse(join(\"\", @a)) ? [join(\"\", @a), 1] : [join(\"\"\
    , @a), 0];\n}", "    my $res = '';\n    my $flag = 0;\n    my %h = map { $_ =>\
    \ 1 } split //, $c;\n    for my $ch (split //, $s) {\n        $res .= $ch unless\
    \ $h{$ch};\n    }\n    $flag = 1 if $res eq reverse $res;\n    return [$res, $flag];\n\
    }", "    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $check = $t eq reverse $t ?\
    \ 1 : '';\n    return [$t, $check];\n}", "    my $s2 = $s;\n    $s2 =~ s/[$c]//g;\n\
    \    my $n = @$s2;\n    my $res = 0;\n    for (my $i = 0; $i < @$s2 / 2; $i++)\
    \ {\n        if ($s2->[$i] ne $s2->[$n - $i - 1]) {\n            $res = 1;\n \
    \           last;\n        }\n    }\n    return [$s2, $res];\n}", "    $s =~ s/[$c]//g;\n\
    \    return [$s, $s eq reverse($s)];\n}", "    $s =~ s/[$c]//gi;\n    return [$s,\
    \ $s eq reverse($s)];\n}", "    (my $t = $s) =~ s/$c//g;\n    ($t, $t eq reverse\
    \ $t);\n}", "    my %h = map { $_ => 1 } split '', $c;\n    my $d = join '', grep\
    \ { !$h{$_} } split '', $s;\n    my $r = reverse $d;\n    return [$d, $d eq $r\
    \ ? 1 : ''];\n}", "    my @result = split //, $s;\n    my %hash_c = map { $_ =>\
    \ $_ } split //, $c;\n    @result = grep { !exists $hash_c{$_} } @result;\n  \
    \  return ['', 1] if @result == 0;\n    my $str = join '', @result;\n    my $check\
    \ = 0;\n    for my $i (0 .. @result / 2 - 1) {\n        if ($result[$i] ne $result[-\
    \ $i - 1]) {\n            $check = 1;\n            last;\n        }\n    }\n \
    \   return [$str, $check];\n}", "    return [\"\",1] if($s eq \"\");\n    my $r\
    \ = reverse($s);\n    return [$s,\"\"] if($s eq $r);\n    my $res = $s;\n    for(split(//,$c)){\n\
    \        $res =~ s/\\Q$_//g;\n    }\n    return [$res, 1] if($res eq reverse($res));\n\
    \    return [$res, \"\"];\n}", "    for (split(\"\", $c)) {\n        $s =~ s/$_//g;\n\
    \    }\n    $s =~ s/(.)\\1+/$1/g;\n    return [\"$s\", $s eq reverse($s)];\n}",
  "    my $result = \"\";\n    for my $ch (split(//, $s)) {\n        $result .= $ch\
    \ unless $c =~ /$ch/;\n    }\n    if ($result eq reverse $result) {\n        return\
    \ [$result, 1];\n    }\n    return [$result, 0];\n}\nuse Test::More;\nis_deeply(reverse_delete(\"\
    abcde\", \"ae\"), [\"bcd\", 0], \"Test 1\");\nis_deeply(reverse_delete(\"abcdef\"\
    , \"b\"), [\"acdef\", 0], \"Test 2\");\nis_deeply(reverse_delete(\"abcdedcba\"\
    , \"ab\"), [\"cdedc\", 1], \"Test 3\");\ndone_testing();", "    $s =~ s/[$c]//g;\n\
    \    return [$s, $s eq scalar reverse $s];\n}", "    my @c = split(\"\", $c);\n\
    \    my $result = \"\";\n    foreach my $letter (split(\"\", $s)) {\n        my\
    \ $found = 0;\n        foreach (@c) {\n            if ($letter eq $_) {\n    \
    \            $found = 1;\n                last;\n            }\n        }\n  \
    \      if (!$found) {\n            $result .= $letter;\n        }\n    }\n   \
    \ my $check = 1;\n    my $length = length($result);\n    if ($length > 1) {\n\
    \        my $middle = $length / 2;\n        my $first = substr($result, 0, $middle);\n\
    \        my $last = substr($result, -$middle);\n        if ($first ne reverse($last))\
    \ {\n            $check = 0;\n        }\n    }\n    return [$result, $check];\n\
    }", "    my %hash;\n    my $result;\n    for (split(//, $c)) {\n        $hash{$_}++;\n\
    \    }\n    for (split(//, $s)) {\n        if (not $hash{$_}) {\n            $result\
    \ .= $_;\n        }\n    }\n    if ($result eq reverse $result) {\n        return\
    \ [$result, 1];\n    }\n    return [$result, ''];\n}", "    my $regex = quotemeta($c);\n\
    \    $s =~ s/$regex//g;\n    my $r = reverse $s;\n    return [$s, $s eq $r];\n\
    }", "    $s =~ s/[$c]//g;\n    my $rev = reverse $s;\n    return [$s, $s eq $rev];\n\
    }", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my $result\
    \ = '';\n    my $palindrome = 1;\n    my $c_hash = {};\n    for my $i (0 .. length($c)\
    \ - 1) {\n        $c_hash->{substr($c, $i, 1)} = 1;\n    }\n    for my $i (0 ..\
    \ length($s) - 1) {\n        my $char = substr($s, $i, 1);\n        if (!exists\
    \ $c_hash->{$char}) {\n            $result .= $char;\n        }\n    }\n    my\
    \ $center = (length($result) - 1) / 2;\n    for my $i (0 .. $center) {\n     \
    \   if (substr($result, $i, 1) ne substr($result, length($result) - 1 - $i, 1))\
    \ {\n            $palindrome = 0;\n            last;\n        }\n    }\n    return\
    \ [$result, $palindrome];\n}", "    (my $r = $s) =~ s/[$c]//g;\n    return [$r,\
    \ ($r eq reverse $r)];\n}", "    my $result = join(\"\", grep {my $ch = $_; (grep\
    \ {$_ eq $ch} split(//, $c)) == 0} split(//, $s));\n    return [$result, $result\
    \ eq reverse($result)];\n}", "    my %h = map {$_ => 1} split \"\", $c;\n    $s\
    \ =~ s/[$c]//g;\n    return [$s, $s eq reverse $s];\n}", "    while ($s =~ s/([$c])//g)\
    \ {\n        my $cc = $1;\n        if ($s =~ /^(.*?)$cc/) {\n            $s =~\
    \ s/$cc$//;\n        } else {\n            $s =~ s/^$cc//;\n        }\n    }\n\
    \    return [$s, $s eq reverse($s)];\n}", "    return [join(\"\", grep {$_ !~\
    \ /[$c]/} split(\"\", $s)), int(substr(join(\"\", grep {$_ !~ /[$c]/} split(\"\
    \", $s)), reverse) eq join(\"\", grep {$_ !~ /[$c]/} split(\"\", $s)))];\n}\n\
    print join(\" \", @{reverse_delete(\"abcde\", \"ae\")}), \"\\n\";\nprint join(\"\
    \ \", @{reverse_delete(\"abcdef\", \"b\")}), \"\\n\";\nprint join(\" \", @{reverse_delete(\"\
    abcdedcba\", \"ab\")}), \"\\n\";", "    my %hash;\n    $hash{$_} = 1 for split\
    \ //, $c;\n    my $result = join '', grep { not $hash{$_} } split //, $s;\n  \
    \  my $check = $result eq reverse $result ? 1 : '';\n    return [$result, $check];\n\
    }", "    $s =~ s/$c//g;\n    my $check = $s eq reverse $s ? 1 : '';\n    return\
    \ [$s, $check];\n}", "    my %c;\n    ++$c{$_} for split //, $c;\n    my $t =\
    \ '';\n    $t .= $_ for grep !exists $c{$_}, split //, $s;\n    my $p = $t eq\
    \ reverse $t;\n    return ($t, $p);\n}", "    my $c2 = qr/[$c]/;\n    $s =~ s/$c2//g;\n\
    \    $s = reverse $s;\n    my $palindrome = $s eq $s ? 1 : 0;\n    return [$s,\
    \ $palindrome];\n}", "    my $b = substr($s, -1);\n    my $p = substr($s, 0, 1);\n\
    \    my $r = substr($s, 1, -1);\n    my $t = length($s);\n    my $q = 1;\n   \
    \ while($q < $t) {\n      if ($b eq $p) {\n        $r = substr($r, 0, -1);\n \
    \       $p = substr($r, 0, 1);\n        $b = substr($r, -1);\n        $q = 1;\n\
    \      }\n      else {\n        $q = $q + 1;\n        $b = $p;\n        $p = substr($r,\
    \ 0, 1);\n        $r = substr($r, 1);\n      }\n    }\n    if ($p eq $b) {\n \
    \     my $output = 1;\n    }\n    else {\n      my $output = \"\";\n    }\n  \
    \  $r = \"$p$r\";\n    return [$r, $output];\n}", "    $s =~ s/$c//g;\n    my\
    \ $res = $s eq reverse $s ? 1 : '';\n    return [$s, $res];\n}", "    $s =~ s/[$c]//g;\n\
    \    my @out = $s;\n    push @out, $s eq scalar reverse $s;\n    return @out;\n\
    }", "    my $str = $s;\n    foreach my $char (split(\"\", $c)) {\n        $str\
    \ =~ s/$char//g;\n    }\n    return [$str, $str eq reverse($str)];\n}", "    my\
    \ $len = length($s);\n    for (my $i = 0; $i < $len; $i++) {\n        if (index($c,\
    \ substr($s, $i, 1)) != -1) {\n            substr($s, $i, 1) = \"\";\n       \
    \     $i--;\n            $len--;\n        }\n    }\n    my $is_palindrome = 1;\n\
    \    for (my $i = 0; $i < length($s) / 2; $i++) {\n        if (substr($s, $i,\
    \ 1) ne substr($s, length($s) - $i - 1, 1)) {\n            $is_palindrome = 0;\n\
    \            last;\n        }\n    }\n    return [$s, $is_palindrome];\n}", " \
    \   my $pal = 1;\n    my $deleted = $s;\n    for my $i (0..length($c)-1) {\n \
    \       my $char = substr($c, $i, 1);\n        $deleted =~ s/$char//g;\n    }\n\
    \    my $half = length($deleted) / 2;\n    for my $i (0..$half-1) {\n        if\
    \ (substr($deleted, $i, 1) ne substr($deleted, -$i-1, 1)) {\n            $pal\
    \ = 0;\n            last;\n        }\n    }\n    return [$deleted, $pal];\n}",
  "    my %c_hash = map { $_ => 1 } split(//, $c);\n    my $result = '';\n    for\
    \ my $i (0 .. length($s) - 1) {\n        $result .= substr($s, $i, 1) unless $c_hash{substr($s,\
    \ $i, 1)};\n    }\n    return [$result, $result eq reverse($result) ? 1 : ''];\n\
    }", "    $s =~ s/[$c]//g;\n    my $p = $s eq reverse $s;\n    return [$s, $p ?\
    \ 1 : ''];\n}", "    return [grep { !$c=~/$_/ } split('', $s), ''];\n}", "   \
    \ my @chars = split '', $s;\n    my @chars_to_remove = split '', $c;\n    my %chars_to_remove_hash\
    \ = map { $_ => 1 } @chars_to_remove;\n    my @res = grep { !$chars_to_remove_hash{$_}\
    \ } @chars;\n    my $is_palindrome = is_palindrome(\\@res);\n    return [join('',\
    \ @res), $is_palindrome];\n}", "    $s =~ s/$c//g;\n    my $result = reverse($s)\
    \ eq $s ? 1 : '';\n    return [$s, $result];\n}", "    $s =~ s/[$c]//g;\n    [$s,\
    \ $s eq reverse($s)];\n}", "    my %C = map {$_ => 1} split //, $c;\n    my $res\
    \ = join \"\", grep {!$C{$_}} split //, $s;\n    return [$res, $res eq reverse\
    \ $res ? 1 : \"\"];\n}", "    my $result = $s;\n    foreach my $char (split(\"\
    \", $c)) {\n        $result =~ s/$char//g;\n    }\n    return [$result, $result\
    \ eq reverse($result)];\n}", "    $s = reverse(reverse($s) =~ s/[$c]//gr);\n \
    \   $s eq reverse($s) ? [$s, 1] : [$s, 0];\n}", "    $s =~ s/[$c]//g;\n    my\
    \ $res = $s eq reverse $s ? 1 : '';\n    return [$s, $res];\n}", "    return [$s,\
    \ 1] if lc($s) eq lc(reverse($s));\n    return [$s, 0] if $s eq '' or $c eq '';\n\
    \    my %s = map { $_ => undef } split //, $s;\n    my %c = map { $_ => undef\
    \ } split //, $c;\n    for (keys %s) {\n        if (exists $c{$_}) {\n       \
    \     delete $s{$_};\n        }\n    }\n    my $new_s = join '', keys %s;\n  \
    \  return [$new_s, lc($new_s) eq lc(reverse($new_s))];\n}", "    my @ret;\n  \
    \  my %c_hash;\n    for my $c_elem (split('', $c)) {\n        $c_hash{$c_elem}\
    \ = 1;\n    }\n    for my $s_elem (split('', $s)) {\n        if (not exists $c_hash{$s_elem})\
    \ {\n            push @ret, $s_elem;\n        }\n    }\n    unshift @ret, '' if\
    \ is_palindrome(\\@ret);\n    return \\@ret;\n}", "    my @result = split //,\
    \ $s;\n    my @stopper = split //, $c;\n    foreach (@stopper) {\n        @result\
    \ = grep { $_ ne $_[0] } @result;\n    }\n    my $length = @result;\n    my $counter\
    \ = 0;\n    for (my $i = 0; $i < $length / 2; $i++) {\n        if ($result[$i]\
    \ ne $result[$length - $i - 1]) {\n            $counter++;\n        }\n    }\n\
    \    if ($counter == 0) {\n        return [join('', @result), 1];\n    } else\
    \ {\n        return [join('', @result), 0];\n    }\n}", "    my $d = join(\"\"\
    , sort(split(//, $c)));\n    my $p = join(\"\", grep { index($d, $_) == -1 } split(//,\
    \ $s));\n    return [$p, $p eq reverse($p)];\n}\n1;", "    my %hash;\n    map\
    \ {$hash{$_} = 1} split('', $c);\n    my $ss = '';\n    map {$ss .= $_ unless\
    \ $hash{$_}} split('', $s);\n    my @a = split('', $ss);\n    my $a = 0;\n   \
    \ while($a < scalar(@a) / 2) {\n        last if $a[$a] ne $a[scalar(@a) - $a -\
    \ 1];\n        $a++;\n    }\n    return [$ss, $a == int(scalar(@a) / 2)];\n}",
  "    $s = reverse $s;\n    $s =~ s/[$c]//g;\n    my @out = ($s, int $s eq reverse\
    \ $s);\n    return \\@out;\n}", "    my %not_delete = map {$_ => 1} split //,\
    \ $c;\n    my $result_string = join '', grep { !$not_delete{$_} } split //, $s;\n\
    \    my $result_check = int $result_string eq scalar reverse $result_string;\n\
    \    return [$result_string, $result_check];\n}", "    my @arr = split '', $s;\n\
    \    my @c = split '', $c;\n    for my $a (@arr) {\n        for my $b (@c) {\n\
    \            if ($a eq $b) {\n                $a = '';\n            }\n      \
    \  }\n    }\n    $s = join '', @arr;\n    $s =~ s/\\s+//g;\n    $s =~ s/\\s//g;\n\
    \    my $res = $s;\n    $res = reverse $res;\n    if ($s eq $res) {\n        return\
    \ [$s, 1];\n    }\n    return [$s, 0];\n}", "    my @c = split(//, $c);\n    my\
    \ $s_new = join('', grep { not grep {$_ eq $_[0]} @c } split(//, $s));\n    return\
    \ [$s_new, $s_new eq reverse($s_new)];\n}", "    $s =~ s/[$c]//g;\n    $s = reverse\
    \ $s;\n    return [$s, $s eq $_[0] ? 1 : ''];\n}", "    for my $i (0..length($c)-1)\
    \ {\n        $s =~ s/$c/$c/g;\n    }\n    return [$s, join('', reverse($s)) eq\
    \ $s];\n}", "    return [join '', grep { index($c, $_) == -1 } split '', $s],\n\
    \        join('', reverse split '', $s) eq $s;\n}", "    my $t = \"\";\n    my\
    \ $check = 0;\n    my @sc = split(\"\", $s);\n    my @cc = split(\"\", $c);\n\
    \    foreach my $c1 (@sc) {\n        my $flag = 0;\n        foreach my $c2 (@cc)\
    \ {\n            if ($c1 eq $c2) {\n                $flag = 1;\n             \
    \   last;\n            }\n        }\n        if ($flag == 0) {\n            $t\
    \ .= $c1;\n        }\n    }\n    my @sc = split(\"\", $t);\n    my $len = length($t);\n\
    \    for (my $i = 0; $i < int($len / 2); $i++) {\n        if ($sc[$i] ne $sc[$len\
    \ - $i - 1]) {\n            $check = 1;\n            last;\n        }\n    }\n\
    \    return ($t, $check);\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my $res = $s;\n    $res =~ s/[$c]//g;\n    return $res, $res eq reverse\
    \ $res;\n}", "    my @remove = split //, $c;\n    my %remove = map {$_ => 1} @remove;\n\
    \    my $t = '';\n    for my $char (split //, $s) {\n        $t .= $char unless\
    \ $remove{$char};\n    }\n    return [$t, ($t eq reverse $t ? 1 : '')];\n}", " \
    \   $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my %hash =\
    \ map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse\
    \ $s];\n}", "    my %h;\n    $h{$_} = 1 for split //, $c;\n    my $t = join '',\
    \ grep !$h{$_}, split //, $s;\n    return [$t, ($t eq reverse $t) ? 1 : 0];\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    for my $i (@c) {\n  \
    \      @s = grep !/$i/, @s;\n    }\n    my $string = join '', @s;\n    if ($string\
    \ eq reverse $string) {\n        return [$string, 1];\n    }\n    return [$string,\
    \ ''];\n}", "    if (length($s) == 0) {\n        return [\"\", 0];\n    }\n  \
    \  my $s1 = $s;\n    $s1 =~ s/[$c]//g;\n    return [$s1, $s1 eq reverse($s1)];\n\
    }", "    for my $ch (split //, $c) {\n        $s =~ s/$ch//g;\n    }\n    return\
    \ [$s, $s eq scalar reverse $s];\n}", "    my %chars = map { $_ => 1 } split //,\
    \ $c;\n    my @res = split //, $s;\n    while( my ($i, $char) = each @res ) {\n\
    \        if( $chars{$char} ) {\n            splice @res, $i, 1;\n            redo;\n\
    \        }\n    }\n    my $res = join '', @res;\n    return [$res, $res eq reverse\
    \ $res];\n}", "    $s =~ s/[$c]//g;\n    return [$s, ($s eq reverse $s)];\n}",
  "    my %c = map {$_ => 1} split //, $c;\n    my @s = grep {not exists $c{$_}} split\
    \ //, $s;\n    return [join('', @s), +(scalar @s == reverse(@s) && @s ? 1 : '')];\n\
    }", "    my %h;\n    ++$h{$_} for split //, $c;\n    my $x = \"\";\n    for my\
    \ $i (split //, $s) {\n        $x .= $i unless $h{$i};\n    }\n    my $y = reverse\
    \ $x;\n    return [$x, $x eq $y ? 1 : 0];\n}", "    my @s = split '', $s;\n  \
    \  my @c = split '', $c;\n    my %c = map { $_ => 1 } @c;\n    @s = grep { not\
    \ $c{$_} } @s;\n    my $check = is_palindrome(join '', @s);\n    return [join('',\
    \ @s), $check];\n}", "    my $s2 = $s;\n    $s2 =~ s/[$c]//g;\n    my $bool =\
    \ $s2 eq reverse $s2;\n    return [$s2, $bool];\n}", "    $s =~ s/$c//g;\n   \
    \ return [$s, $s eq reverse($s)];\n}", "    my %hash;\n    map { $hash{$_} = 1\
    \ } split('', $c);\n    my $result = '';\n    for (split('', $s)) {\n        $result\
    \ .= $_ unless $hash{$_};\n    }\n    my $is_palindrome = 1;\n    my @arr = split('',\
    \ $result);\n    while (my $left = shift @arr) {\n        my $right = pop @arr;\n\
    \        if ($left ne $right) {\n            $is_palindrome = 0;\n           \
    \ last;\n        }\n    }\n    return [$result, $is_palindrome];\n}", "    $s\
    \ =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my %hash = map\
    \ {$_ => 1} split(//, $c);\n    my $str = '';\n    for my $ch (split(//, $s))\
    \ {\n        $str .= $ch unless $hash{$ch};\n    }\n    my $res = $str eq reverse($str)\
    \ ? 1 : '';\n    return [$str, $res];\n}", "    my @result = grep {$_ !~ /[$c]/}\
    \ split //, $s;\n    my $is_palindrome = scalar @result == 0 || join(\"\", @result)\
    \ eq join(\"\", reverse @result);\n    [join(\"\", @result), $is_palindrome]\n\
    }", "    my @res = grep { !($c =~ m/$_/) } split //, $s;\n    my $res = join '',\
    \ @res;\n    my $is_palindrome = $res eq scalar reverse $res;\n    return [$res,\
    \ $is_palindrome];\n}", "    $s =~ s/$c//g;\n    my $res = $s eq reverse $s ?\
    \ 1 : '';\n    return [$s, $res];\n}", "    my @s = split \"\", $s;\n    my @c\
    \ = split \"\", $c;\n    my %z = map {$_ => 1} @c;\n    my $s_string = join \"\
    \", grep {!$z{$_}} @s;\n    my $c_int = $s_string eq reverse $s_string ? 1 : \"\
    \";\n    return [$s_string, $c_int];\n}", "    my @s = split //, $s;\n    my @c\
    \ = split //, $c;\n    foreach(@c){\n      @s = grep !/$_/, @s;\n    }\n    my\
    \ $res = $s[0] eq $s[-1] ? 1 : \"\";\n    return [join(\"\", @s), $res];\n}",
  "    my $ss = $s;\n    for my $i(split //, $c){\n        $ss =~ s/$i//g;\n    }\n\
    \    my $rev = reverse $ss;\n    if($rev eq $ss){\n        return [$ss, 1];\n\
    \    }\n    return [$ss, ''];\n}", "    $s =~ s/[$c]//g;\n    $s = join '', reverse\
    \ split //, $s;\n    my $t = join '', reverse split //, $s;\n    my $n = ($s eq\
    \ $t) ? 1 : '';\n    return [$s, $n];\n}", "    my $j = $s;\n    my $res;\n  \
    \  while($j =~ s/(?=[$c])//g){\n        $res = $s =~ /$j/;\n    }\n    $j =~ s/\\\
    s+//g;\n    return ($j, $res)\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq\
    \ reverse($s)];\n}", "    my $news = join(\"\", grep{index($c, $_) == -1} split(\"\
    \", $s));\n    return [$news, is_palindrome($news)];\n}", "    my $c_count = 0;\n\
    \    for my $letter (@$c) {\n        $s =~ s/$letter//g;\n    }\n    my $len =\
    \ length($s);\n    for my $i (0..($len-1)) {\n        if(substr($s, $i, 1) ne\
    \ substr($s, $len - $i - 1, 1)) {\n            $c_count = 0;\n            last;\n\
    \        }\n        $c_count = 1;\n    }\n    return [$s, $c_count];\n}", "  \
    \  my @s = split //, $s;\n    my @c = split //, $c;\n    foreach my $i (@c) {\n\
    \        @s = grep { $i ne $_ } @s;\n    }\n    return [join('', @s), join('',\
    \ reverse @s) eq join('', @s)];\n}", "    my %c = map { $_ => 1 } split //, $c;\n\
    \    my $r = join('', grep { !$c{$_} } split //, $s);\n    my $p = $r eq scalar\
    \ reverse $r;\n    return [$r, $p];\n}", "    my $p = \"\";\n    my $result =\
    \ \"\";\n    my $r = \"\";\n    my $check = 0;\n    my $i = 0;\n    my @s = split\
    \ //, $s;\n    my @c = split //, $c;\n    while($i <= $#s){\n        if(!grep(/^$s[$i]$/,\
    \ @c)){\n            $p = $p.$s[$i];\n        }\n        $i++;\n    }\n    $i\
    \ = 0;\n    while($i <= int(length($p)/2)){\n        if(substr($p, $i, 1) eq substr($p,\
    \ -($i+1), 1)){\n            $result = $result.substr($p, $i, 1);\n        }\n\
    \        else{\n            $check = 1;\n        }\n        $i++;\n    }\n   \
    \ if($check == 1){\n        $r = $p;\n    }\n    else{\n        $r = $result;\n\
    \    }\n    my @ar = ($r, $check);\n    return @ar;\n}", "    my @array = split('',\
    \ $s);\n    my @c_array = split('', $c);\n    my %count;\n    foreach my $c_array\
    \ (@c_array) {\n        $count{$c_array}++;\n    }\n    my @s_array;\n    foreach\
    \ my $array (@array) {\n        push @s_array, $array unless exists $count{$array};\n\
    \    }\n    my $res_str = join('', @s_array);\n    my $check = (reverse $res_str\
    \ eq $res_str) ? 1 : '';\n    return [$res_str, $check];\n}", "    $s =~ s/[$c]//g;\n\
    \    my $bool = $s eq scalar reverse $s ? 1 : '';\n    return [$s, $bool];\n}",
  "    $s =~ s/[$c]//g;\n    my $re = $s eq reverse $s ? 1 : '';\n    return [$s,\
    \ $re];\n}\nuse Test::More;\nuse Test::LMU;", "    my %del = map { $_ => 1 } split\
    \ //, $c;\n    my @keep = grep { not exists $del{$_} } split //, $s;\n    my $ok\
    \ = (@keep == 0 or join(\"\", @keep) eq join(\"\", reverse @keep));\n    return\
    \ [join(\"\", @keep), $ok];\n}", "    my $r;\n    my $i;\n    my @a;\n    my @b;\n\
    \    for ($i = 0; $i < length($s); $i++) {\n        push @a, substr($s, $i, 1);\n\
    \    }\n    for ($i = 0; $i < length($c); $i++) {\n        push @b, substr($c,\
    \ $i, 1);\n    }\n    for ($i = 0; $i < @a; $i++) {\n        for ($j = 0; $j <\
    \ @b; $j++) {\n            if ($a[$i] eq $b[$j]) {\n                splice @a,\
    \ $i, 1;\n                $i--;\n                last;\n            }\n      \
    \  }\n    }\n    $r = join(\"\", @a);\n    if ($r eq reverse($r)) {\n        return\
    \ $r, 1;\n    } else {\n        return $r, \"\";\n    }\n}\nprint reverse_delete(\"\
    abcde\", \"ae\");\nprint \"\\n\";\nprint reverse_delete(\"abcdef\", \"b\");\n\
    print \"\\n\";\nprint reverse_delete(\"abcdedcba\", \"ab\");\nprint \"\\n\";",
  "    my $result = [$s, ''];\n    $result->[0] =~ s/[$c]//g;\n    if ($result->[0]\
    \ eq reverse $result->[0]) {\n        $result->[1] = 1;\n    }\n    return $result;\n\
    }\nprint Dumper reverse_delete('abcde', 'ae');\nprint Dumper reverse_delete('abcdef',\
    \ 'b');\nprint Dumper reverse_delete('abcdedcba', 'ab');", "    my @dels = split\
    \ //, $c;\n    my @str  = split //, $s;\n    my @r = grep { my $d = 0;\n     \
    \              map {\n                       $d = 1, last if $_ eq $_[0];\n  \
    \                 } @dels;\n                   !$d;\n              } @str;\n \
    \   my $r = join \"\", @r;\n    my $p = join \"\", reverse @r;\n    return [$r,\
    \ $r eq $p];\n}", "    my %c_hash = map { $_ => undef } split //, $c;\n    my\
    \ $s_copy = '';\n    my $check = 1;\n    while($s =~ s/(.)//) {\n        my $char\
    \ = $1;\n        if(!exists $c_hash{$char}) {\n            $s_copy .= $char;\n\
    \        }\n    }\n    while($s_copy =~ s/(.)(.)//) {\n        if($1 ne $2) {\n\
    \            $check = 0;\n            last;\n        }\n    }\n    return [$s_copy,\
    \ $check];\n}", "    my $c_hash = {};\n    for my $c_i (split //, $c) {\n    \
    \    $c_hash->{$c_i} = 1;\n    }\n    my $s_array = [];\n    for my $s_i (split\
    \ //, $s) {\n        push @$s_array, $s_i unless $c_hash->{$s_i};\n    }\n   \
    \ my $result = join '', @$s_array;\n    my $is_palindrome = $result eq reverse\
    \ $result;\n    return [$result, $is_palindrome];\n}", "    $s = reverse $s;\n\
    \    my @s = split '', $s;\n    my @c = split '', $c;\n    for my $elem_c (@c)\
    \ {\n        for my $i (0 .. $#s) {\n            if ($s[$i] eq $elem_c) {\n  \
    \              splice @s, $i, 1;\n            }\n        }\n    }\n    my $ss\
    \ = join '', @s;\n    my $rc = $ss eq reverse $ss ? 1 : '';\n    [$ss, $rc];\n\
    }", "    my %h;\n    for (split(//, $c)) {\n        $h{$_} = 1;\n    }\n    my\
    \ $r = join(\"\", grep { !$h{$_} } split(//, $s));\n    return [$r, $r eq reverse($r)];\n\
    }", "    my $result = '';\n    my $d = 0;\n    my %hash;\n    $hash{$_} = 1 for\
    \ split //, $c;\n    for my $char (split //, $s) {\n        $result .= $char unless\
    \ $hash{$char};\n    }\n    if ($result eq reverse $result) {\n        $d = 1;\n\
    \    }\n    return [$result, $d];\n}", "    my %hash = map { $_ => 1 } split //,\
    \ $c;\n    my $reverse = $s;\n    $reverse =~ s/[^$c]//g;\n    $reverse = join\
    \ '', reverse split //, $reverse;\n    return [join('', split //, $s), $reverse\
    \ eq $s ? 1 : ''];\n}\n1;", "    return [$s, '', ''] if ($s eq '' || $c eq '');\n\
    \    my @r = reverse split('', $s);\n    my @p = grep { !($_ ~~ split('', $c))\
    \ } @r;\n    my $p = join('', @p);\n    return [$p, $p eq $s ? 1 : ''];\n}", " \
    \   my %ch = map {$_ => 1} split //, $c;\n    $s = join \"\", grep !$ch{$_}, split\
    \ //, $s;\n    my $r = 0;\n    my $l = length($s) - 1;\n    for (my $i = 0; $i\
    \ < length($s) / 2; $i++) {\n        last if substr($s, $i, 1) ne substr($s, $l,\
    \ 1);\n        $l--;\n        $r = 1;\n    }\n    return [$s, $r];\n}", "    my\
    \ $t = join(\"\", split(\"\", $s));\n    foreach (split(\"\", $c)) {\n       \
    \ $t =~ s/$_//g;\n    }\n    my $r = join(\"\", reverse(split(\"\", $t)));\n \
    \   my $f = $t eq $r ? 1 : \"\";\n    return [$t, $f];\n}", "    my $uniq = join('',\
    \ uniq(split('', $c)));\n    my $result = $s;\n    $result =~ s/$uniq//g;\n  \
    \  my $check = (reverse($result) eq $result) ? 1 : 0;\n    return [$result, $check];\n\
    }", "    my @s = split //, $s;\n    my %c = map { $_ => 1 } split //, $c;\n  \
    \  my @res = grep { !$c{$_} } @s;\n    my $res = join \"\", @res;\n    return\
    \ [$res, $res eq reverse $res];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s\
    \ eq reverse($s)];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n\
    \    my @r;\n    for my $i (0..$#s) {\n        my $f = 1;\n        for my $j (0..$#c)\
    \ {\n            if ($s[$i] eq $c[$j]) {\n                $f = 0;\n          \
    \      last;\n            }\n        }\n        push @r, $s[$i] if $f;\n    }\n\
    \    my $f = join '', @r;\n    for my $i (0..$#r/2) {\n        if ($r[$i] ne $r[$#r-$i])\
    \ {\n            $f = [];\n            last;\n        }\n    }\n    return [$f,\
    \ 1] if ref $f eq 'ARRAY';\n    return [$f, 0];\n}", "    my @r = ();\n    my\
    \ @c = split //, $c;\n    foreach my $l (split //, $s) {\n        my $used = 0;\n\
    \        foreach my $m (@c) {\n            if ($l eq $m) {\n                $used\
    \ = 1;\n                last;\n            }\n        }\n        push @r, $l unless\
    \ $used;\n    }\n    my $re = join \"\", @r;\n    my $pal = $re eq reverse $re\
    \ ? 1 : \"\";\n    return [$re, $pal];\n}", "    my @s=split//,$s;\n    my @c=split//,$c;\n\
    \    # (1) replace all letters in $s with '0' that are contained in $c\n    #\
    \ (2) then remove all occurences of '0' in $s\n    for(@s){ for(@c){$_=0 if $_\
    \ eq $_}}\n    @s=grep{$_ ne '0'}@s;\n    # (3) check if the new $s is a palindrome\n\
    \    my $pal=1;\n    for my $i(0..$#s){$pal=0 if $s[$i] ne $s[-1-$i]}\n    # (4)\
    \ return array containing the (new) $s and the $pal value\n    return [join('',@s),$pal];\n\
    }", "    my $s1 = join \"\", grep { index($c, $_) < 0 } split //, $s;\n    my\
    \ $s2 = join \"\", reverse split //, $s1;\n    my $res = $s1 eq $s2 ? 1 : \"\"\
    ;\n    return [$s1, $res];\n}", "    my %v = map {$_ => 1} split '', $c;\n   \
    \ my $t = join '', grep {not exists $v{$_}} split '', $s;\n    return [$t, $t\
    \ eq reverse $t];\n}", "    my $s2 = $s;\n    $s2 =~ s/[$c]//g;\n    my $check\
    \ = $s2 eq reverse $s2 ? 1 : '';\n    return [$s2, $check];\n}", "    my %hash\
    \ = map { $_ => 1 } split(\"\", $c);\n    my $t = \"\";\n    my $res = 0;\n  \
    \  my $flag = 0;\n    my $p = 0;\n    my $s1 = substr($s, $p);\n    while ($s1\
    \ ne \"\") {\n        if (!exists $hash{substr($s1, 0, 1)}) {\n            $t\
    \ .= substr($s1, 0, 1);\n            $s1 = substr($s1, 1);\n        } else {\n\
    \            if ($flag == 0) {\n                $p = length($s) - 1;\n       \
    \         $s1 = substr($s, $p);\n                $flag = 1;\n            } else\
    \ {\n                $p--;\n                $s1 = substr($s, $p);\n          \
    \  }\n        }\n    }\n    if ($flag) {\n        my $l = length($t);\n      \
    \  my $i = 0;\n        my $mid = int($l / 2);\n        while ($i < $mid) {\n \
    \           if (substr($t, $i, 1) ne substr($t, $l - $i - 1, 1)) {\n         \
    \       $res = 0;\n                last;\n            }\n            $i++;\n \
    \       }\n        if ($i == $mid) {\n            $res = 1;\n        }\n    }\n\
    \    return [$t, $res];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    $s =~ s/[$c]//g;\n    return [$s, $s eq scalar reverse $s];\n}", "  \
    \  my %c = map { $_ => 1 } split('', $c);\n    my $i = 0;\n    while ($i < length($s))\
    \ {\n        if ($c{substr($s, $i, 1)}) {\n            substr($s, $i, 1) = '';\n\
    \            $i--;\n        }\n        $i++;\n    }\n    return [$s, $s eq reverse($s)];\n\
    }", "    $s =~ s/[$c]//g;\n    return [$s, is_palindrome($s)];\n}", "    my $sc\
    \ = reverse($s);\n    my $cnt = 0;\n    $cnt = 1 if $sc eq $s;\n    my $str =\
    \ '';\n    foreach my $i (split('', $s)) {\n        if (!($c =~ m/$i/)) {\n  \
    \          $str .= $i;\n        }\n    }\n    return [$str, $cnt];\n}", "    my\
    \ $deleted = 0;\n    for my $char (split '', $c) {\n        $s =~ s/[$char]//g;\n\
    \        if ($s ne reverse $s) {\n            $deleted = 1;\n        }\n    }\n\
    \    return [$s, $deleted];\n}", "    my $s_copy = $s;\n    foreach my $char (split\
    \ //, $c) {\n        $s_copy =~ s/$char//g;\n    }\n    my $palindrome = is_palindrome($s_copy);\n\
    \    return [$s_copy, $palindrome];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
