name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return an array containing the result string and 1/'' for\
  \ the check.\n# Example\n# >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\", \"\
  \"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"\
  abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @array = split(\"\", $s);\n    my %hash = map { $_ => 1 } split(\"\
    \", $c);\n    my @tmp;\n    foreach my $elem (@array) {\n        if (exists $hash{$elem})\
    \ {\n            next;\n        }\n        push @tmp, $elem;\n    }\n    my $result\
    \ = join(\"\", @tmp);\n    my $result1 = (reverse($result) eq $result) ? 1 : '';\n\
    \    return [$result, $result1];\n}", "    $s =~ s/[$c]//g;\n    my $rev = reverse\
    \ $s;\n    my $res = ($s eq $rev) ? 1 : '';\n    return [$s, $res];\n}", "   \
    \ $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    $s =~ s/[$c]//g;\n\
    \    $s eq reverse $s ? [$s, 1] : [$s, ''];\n}", "    $s =~ s/[$c]//g;\n    my\
    \ $answer = $s;\n    my $palin = 0;\n    if ($s eq reverse $s) {\n        $palin\
    \ = 1;\n    }\n    return [$answer, $palin];\n}", "    $s =~ s/[$c]//g;\n    my\
    \ $rev = reverse $s;\n    return [$s, ''] if $s ne $rev;\n    return [$s, 1];\n\
    }", "    $s =~ s/[$c]//g;\n    my $rev = reverse $s;\n    return [\"$s\", \"$rev\"\
    \ eq \"$s\" ? 1 : ''];\n}", "    $s =~ s/[$c]//g;\n    my $r = reverse $s;\n \
    \   return [$s, $s eq $r];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my @new_s = grep { my $char = $_; !(grep {$_ eq $char} split(//, $c))\
    \ } split(//, $s);\n    my $new_str = join('', @new_s);\n    return [$new_str,\
    \ $new_str eq reverse($new_str) ? 1 : ''];\n}", "    $s =~ s/[$c]//g;\n    my\
    \ $palindrome = $s eq scalar reverse $s ? 1 : '';\n    return [$s, $palindrome];\n\
    }", "    for my $char(split('', $c)) {\n        $s =~ s/$char//g;\n    }\n   \
    \ my $result = join('', reverse(split('', $s)));\n    if ($result eq $s) {\n \
    \       return [$s, 1];\n    }\n    return [$s, ''];\n}", "    my @new = split\
    \ //, $s;\n    foreach my $v (@new) {\n        if (index($c, $v) >= 0) {\n   \
    \         @new = grep { $_ ne $v } @new;\n        }\n    }\n    my $new_s = join\
    \ '', @new;\n    my $result = ($new_s eq reverse $new_s) ? 1 : '';\n    return\
    \ [$new_s, $result];\n}", "    my %c = map {$_ => 1} split //, $c;\n    @c{split\
    \ //, $s} = ();\n    $s = join '', sort keys %c;\n    [$s, $s eq scalar reverse\
    \ $s ? 1 : ''];\n}", "    my $r = substr $s, length($s) - length($c);\n    my\
    \ $chars = quotemeta $c;\n    $s =~ s/[$chars]//g;\n    my $result = $s eq reverse\
    \ $s ? 1 : '';\n    return [$s, $result];\n}", "    for my $char (split //, $c)\
    \ {\n        $s =~ s/$char//g;\n    }\n    return [$s, $s eq reverse $s];\n}",
  "    my @s = split \"\", $s;\n    my @c = split \"\", $c;\n    my %d = map { $_\
    \ => 1 } @c;\n    my @r = grep { ! $d{$_} } @s;\n    my $r = join \"\", @r;\n\
    \    my $is_palindrome = $r eq reverse $r;\n    return [$r, $is_palindrome];\n\
    }", "    my %chars = map { $_ => 1 } split //, $c;\n    my $new_s = join '', grep\
    \ {!$chars{$_}} split //, $s;\n    return [$new_s, $new_s eq reverse $new_s];\n\
    }", "    my $ns = $s;\n    my $nc = $c;\n    $ns =~ s/[$nc]//g;\n    $ns = reverse\
    \ $ns;\n    my $p = $ns eq $s ? 1 : '';\n    return [$ns, $p];\n}", "    my $b\
    \ = \"\";\n    for (my $i = 0; $i < length($s); $i++) {\n        my $x = substr($s,\
    \ $i, 1);\n        if (index($c, $x) == -1) {\n            $b .= $x;\n       \
    \ }\n    }\n    return [$b, $b eq reverse($b) ? 1 : ''];\n}", "    my $regex =\
    \ qr/[$c]/;\n    $s =~ s/$regex//g;\n    return [$s, $s eq reverse($s)];\n}",
  "    my @s = split '', $s;\n    my @c = split '', $c;\n    my %c = map {$_ => 1}\
    \ @c;\n    my @deleted;\n    for my $i (0..$#s) {\n        if (!$c{$s[$i]}) {\n\
    \            push @deleted, $s[$i];\n        }\n    }\n    my $check = palindrome_check(join('',\
    \ @deleted)) ? 1 : '';\n    return join('', @deleted), $check;\n}", "    my @c\
    \ = split '', $c;\n    my @s = split '', $s;\n    foreach my $x(@c){\n       \
    \ for(my $i = @s-1; $i >= 0; $i--){\n            if($s[$i] eq $x){\n         \
    \       splice @s, $i, 1;\n            }\n        }\n    }\n    my $result = join('',\
    \ @s);\n    my $check = $result eq reverse $result ? 1 : '';\n    return [$result,\
    \ $check];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}",
  "    my %s = map {;$_ => 1} split //, $s;\n    delete @s{split //, $c};\n    my\
    \ $r = join \"\", keys %s;\n    my $pal = $r eq reverse $r;\n    return $pal ?\
    \ [$r, 1] : [$r, ''];\n}", "    my %c = map { $_ => 1 } split //, $c;\n    $s\
    \ = join '', grep { !$c{$_} } split //, $s;\n    my $r = reverse $s;\n    [$s,\
    \ $s eq $r ? 1 : ''];\n}", "    my @palindrome = split '', $s;\n    my @chars\
    \ = split '', $c;\n    my @filtered;\n    my $result = '1';\n    for my $char\
    \ (@chars) {\n        @filtered = grep $_ ne $char, @palindrome;\n        @palindrome\
    \ = @filtered;\n    }\n    for my $i (0 .. (length($s)/2)) {\n        if ($palindrome[$i]\
    \ ne $palindrome[length($s)-1-$i]) {\n            $result = '';\n        }\n \
    \   }\n    return(\\@palindrome, $result);\n}", "    $s =~ s/$c//g;\n    my @out\
    \ = ($s);\n    push @out, $s eq reverse $s;\n    return @out;\n}", "    my @b\
    \ = split(//, $s);\n    my @a = split(//, $c);\n    for my $s (@a) {\n       \
    \ @b = grep(!/$s/, @b);\n    }\n    unshift(@b, @b);\n    pop(@b);\n    return([join('',\
    \ @b), $s eq join('', @b)]);\n}", "    my @c = grep {index($s, $_) >= 0} split\
    \ //, $c;\n    $s =~ s/[@c]//g;\n    my @res = (\"$s\", $s eq reverse($s) ? 1\
    \ : '');\n    return @res;\n}", "    $s =~ s/[$c]//g;\n    my $r = $s;\n    $r\
    \ =~ tr/a-z/z-a/;\n    my $result = $s eq $r ? 1 : '';\n    return [$s, $result];\n\
    }", "    my @s = split(//, $s);\n    my %c = map {$_ => 1} split(//, $c);\n  \
    \  @s = grep { not exists $c{$_} } @s;\n    return [join('', @s), join('', @s)\
    \ eq reverse(join('', @s)) ? 1 : ''];\n}", "    my %chars = map {$_ => 1} split\
    \ '', $c;\n    my @s = split '', $s;\n    my @result = grep {!$chars{$_}} @s;\n\
    \    return [join('', @result), join('', @result) eq join('', reverse @result)];\n\
    }", "    $s =~ s/[$c]//g;\n    return ($s, $s eq reverse $s);\n}", "    $s =~\
    \ s/[$c]//g;\n    my $palindrome = $s eq reverse $s ? 1 : '';\n    return [$s,\
    \ $palindrome];\n}", "    my %c = map { $_ => 1 } split '', $c;\n    return [join('',\
    \ grep {!$c{$_}} split '', $s), (join('', @{[split '', $s]}[0..(length($s)/2)])\
    \ eq join('', @{[split '', $s]}[-1..-(length($s)/2)-1]))];\n}", "    my @s = split\
    \ '', $s;\n    my @c = split '', $c;\n    my %c = map { $_ => 1 } @c;\n    my\
    \ @b;\n    for (@s) {\n        push @b, $_ unless $c{$_};\n    }\n    my $b =\
    \ join '', @b;\n    my $f = $b eq reverse $b;\n    return [$b, $f];\n}", "   \
    \ my $res = $s;\n    foreach my $c (split '', $c) {\n\t$res =~ s/$c//g;\n    }\n\
    \    return($res, $res eq reverse($res) ? 1 : '');\n}", "    $s =~ s/[$c]//g;\n\
    \    $s =~ /^(.+)\\1$/ ? [$1, 1] : [$s, ''];\n}", "    $s =~ s/[$c]//g;\n    return\
    \ [$s, $s eq reverse($s)];\n}", "    my %hash;\n    @hash{split '', $c} = ();\n\
    \    $s =~ s/[$c]//g;\n    return [$s, is_palindrome($s)];\n}", "    my @s = split\
    \ //, $s;\n    my %c = map {$_ => 1} split //, $c;\n    my @res = grep {!$c{$_}}\
    \ @s;\n    my $pal = (@res > 0) && @res == grep {$res[$_] eq $res[-1-$_]} 0..$#res;\n\
    \    return [join('', @res), $pal];\n}", "    $s =~ s/$c//g;\n    $s = reverse\
    \ $s;\n    if ($s eq $s) {\n        return [$s,1];\n    } else {\n        return\
    \ [$s,''];\n    }\n}", "    $s =~ s/[$c]//g;\n    my $r = reverse $s;\n    return\
    \ [$s, $s eq $r ? 1 : ''];\n}", "    my %seen;\n    for my $c (split //, $c) {\n\
    \        $seen{$c} = 1;\n    }\n    my $result = join \"\", grep { not $seen{$_}\
    \ } split //, $s;\n    return [$result, $result eq scalar reverse $result ? 1\
    \ : ''];\n}", "    my $s_copy = join(\"\", $s =~ s/[$c]//gr);\n    my $s_reverse\
    \ = scalar reverse $s_copy;\n    my $result = ($s_copy eq $s_reverse) ? $s_copy.\"\
    1\" : $s_copy.\"\";\n    return [$result];\n}", "    my $r = reverse($s);\n  \
    \  $r =~ s/$c//g;\n    my $n = join '', map { $s =~ /$_/ ? $_ : '' } split(//,\
    \ $c);\n    return [$r, $n eq '' ? 1 : ''];\n}", "    my %hash;\n    my $result\
    \ = \"\";\n    my $check = \"\";\n    foreach my $x (split(\"\", $c)) {\n    \
    \    $hash{$x} = 1;\n    }\n    foreach my $x (split(\"\", $s)) {\n        if\
    \ (!$hash{$x}) {\n            $result .= $x;\n        }\n    }\n    $check = ($result\
    \ eq reverse($result)) ? 1 : \"\";\n    return [$result, $check];\n}", "    my\
    \ $rev = scalar reverse $s;\n    my @indexes = @{find_index($s,$c)};\n    my @revindexes\
    \ = @{find_index($rev,$c)};\n    my $length = scalar @indexes;\n    for (my $i\
    \ = 0; $i < $length; $i++) {\n        splice @indexes, $i, 1, q{};\n        splice\
    \ @revindexes, $i, 1, q{};\n    }\n    my $string = join q{}, @indexes;\n    my\
    \ $revstring = join q{}, @revindexes;\n    $string =~ s/\\s+//g;\n    $revstring\
    \ =~ s/\\s+//g;\n    my $output = [$string, $revstring];\n    return $output;\n\
    }", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my @r;\n    my\
    \ %c = map { $_ => 1 } @c;\n    for my $s (@s) {\n        push @r, $s unless $c{$s};\n\
    \    }\n    my $r = join '', @r;\n    return [$r, $r eq scalar reverse $r ? 1\
    \ : ''];\n}", "    my %h = map {$_ => 1} split //, $c;\n    my @s = split //,\
    \ $s;\n    my @r;\n    while (@s) {\n        my $ch = pop @s;\n        next if\
    \ $h{$ch};\n        unshift @r, $ch;\n    }\n    my $rs = join '', @r;\n    return\
    \ [$rs, ($rs eq reverse $rs ? 1 : '')];\n}", "    my $res = $s;\n    $res =~ s/[$c]//g;\n\
    \    return [$res, $res eq reverse($res) ? 1 : ''];\n}", "    $s =~ s/[$c]//g;\n\
    \    return [$s, $s eq scalar reverse $s ? 1 : ''];\n}", "    $s =~ s/[$c]//g;\n\
    \    my $rev = reverse $s;\n    return ($s, $s eq $rev ? 1 : '');\n}", "    my\
    \ $result = '';\n    my $check = 0;\n    foreach (split //, $s) {\n        if\
    \ ($c !~ /$_/) {\n            $result .= $_;\n        }\n    }\n    my $r = scalar\
    \ reverse $result;\n    if ($result eq $r) {\n        $check = 1;\n    }\n   \
    \ return [$result, $check];\n}", "    my $b = quotemeta $c;\n    my $r = reverse\
    \ $s;\n    $s =~ s/$b//g;\n    $r =~ s/$b//g;\n    return [$s, ($s eq $r)];\n}",
  "    my $regex = \"\\\\s*[\".quotemeta($c).\"]\\\\s*\";\n    my $str = $s;\n   \
    \ $str =~ s/$regex//g;\n    return [$str, 1] if $str eq reverse $str;\n    return\
    \ [$str, ''];\n}", "    my $string = $s;\n    $string =~ s/[$c]//g;\n    my $output\
    \ = [$string, $string eq reverse($string) ? 1 : ''];\n    return $output;\n}",
  "    my $n = 0;\n    while ($s =~ s/(?=\\w)[$c]//g) {\n        $n++;\n    }\n  \
    \  return [$s, $n > 1 ? 1 : ''];\n}", "    my $result = $s;\n    my $test = 0;\n\
    \    for my $x (@$c) {\n        $result =~ s/$x//g;\n    }\n    $test = $result\
    \ eq reverse $result ? 1 : '';\n    return [$result, $test];\n}", "    $s =~ s/[$c]//g;\n\
    \    my $r = reverse $s;\n    return [$s, $s eq $r];\n}", "    $s =~ s/[$c]//g;\n\
    \    $s = scalar reverse $s;\n    return [$s, $s eq reverse $s];\n}", "    my\
    \ @s = split //, $s;\n    my @c = split //, $c;\n    for my $i (0..$#s) {\n  \
    \      for my $j (0..$#c) {\n            if ($s[$i] eq $c[$j]) {\n           \
    \     splice @s, $i, 1;\n                $i--;\n                last;\n      \
    \      }\n        }\n    }\n    my $answer = join \"\", @s;\n    my $check = $answer\
    \ eq reverse $answer ? 1 : '';\n    return [$answer, $check];\n}", "    return\
    \ [\"\", \"\"];\n}", "    my @s = split '', $s;\n    my %delete;\n    map { $delete{$_}\
    \ = 1 } split '', $c;\n    my @r;\n    for (my $i = $#s; $i >= 0; $i--) {\n  \
    \      push @r, $s[$i] unless $delete{$s[$i]};\n    }\n    my $r = join '', @r;\n\
    \    my $is_palindrome = 0;\n    if ($r eq reverse $r) {\n        $is_palindrome\
    \ = 1;\n    }\n    return [$r, $is_palindrome];\n}", "    $s =~ s/$c//g;\n   \
    \ return $s eq reverse $s ? [$s, 1] : [$s, ''];\n}", "    my @delete = split(//,\
    \ $c);\n    for my $d (@delete) {\n        $s =~ s/$d//g;\n    }\n    return [$s,\
    \ $s eq reverse($s) ? 1 : ''];\n}", "    my %h = map { $_ => 1 } split //, $c;\n\
    \    my $r = join \"\", grep { !$h{$_} } split //, $s;\n    return ($r, $r eq\
    \ reverse $r ? 1 : \"\");\n}", "    my $new_string = \"\";\n    for my $i (0 ..\
    \ length($s) - 1) {\n        if ($c !~ /$s[$i]/) {\n            $new_string .=\
    \ $s[$i];\n        }\n    }\n    my $result = 0;\n    if (join('', reverse(split(//,\
    \ $new_string))) eq $new_string) {\n        $result = 1;\n    }\n    return [$new_string,\
    \ $result];\n}", "    $s =~ s/[$c]//g;\n    my $reversed = reverse $s;\n    return\
    \ [$s, (1) x ($s eq $reversed)];\n}", "    my $result = '';\n    my $flag = 0;\n\
    \    my %h;\n    for my $c2 (split //, $c) {\n        $h{$c2} = 1;\n    }\n  \
    \  for my $s2 (split //, $s) {\n        $result .= $s2 unless $h{$s2};\n    }\n\
    \    $flag = 1 if $result eq reverse $result;\n    return [$result, $flag];\n}",
  "    my @s = split(//, $s);\n    my @c = split(//, $c);\n    my @result;\n    foreach\
    \ my $i (@s) {\n        push @result, $i unless grep $i eq $_, @c;\n    }\n  \
    \  my $check = join('', @result) eq join('', reverse @result) ? 1 : '';\n    return\
    \ [join('', @result), $check];\n}", "    for(split '', $c) {\n        $s =~ s/$_//g;\n\
    \    }\n    $s =~ s/^\\s+|\\s+$//g;\n    my $palindrome = 1;\n    if(length($s)\
    \ % 2 == 0) {\n        my $m = length($s) / 2;\n        my $a = substr($s, 0,\
    \ $m);\n        my $b = substr($s, $m);\n        $b = reverse $b;\n        $palindrome\
    \ = ($a eq $b) ? 1 : '';\n    }\n    return [$s, $palindrome];\n}", "    my $res\
    \ = \"\";\n    my $is_palindrome = 1;\n    my %c_set = map {$_ => 1} split(//,\
    \ $c);\n    for my $x (split(//, $s)) {\n        if (!$c_set{$x}) {\n        \
    \    $res .= $x;\n        }\n    }\n    my $i = 0;\n    my $j = length($res) -\
    \ 1;\n    while ($i < $j) {\n        if (substr($res, $i, 1) ne substr($res, $j,\
    \ 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n     \
    \   $i++;\n        $j--;\n    }\n    return [$res, $is_palindrome];\n}", "   \
    \ my $d = join('', grep { index($c, $_) == -1 } split(//, $s));\n    my $check\
    \ = $d eq scalar reverse $d ? 1 : '';\n    return [$d, $check];\n}", "    my $res\
    \ = $s;\n    $res =~ s/[$c]//g;\n    return [$res, int($res eq reverse($res))];\n\
    }", "    $s =~ s/(?<![^$c])[$c]//g;\n    return [$s, $s eq reverse $s ? 1 : ''];\n\
    }", "    my $l = join \"\", split //, $s;\n    my $r = join \"\", reverse split\
    \ //, $s;\n    my $p = join \"\", split //, $c;\n    my $check = \"\";\n    foreach\
    \ my $i (0..(length($p)-1)) {\n        $l =~ s/$p/$check/g;\n        $r =~ s/$p/$check/g;\n\
    \    }\n    $l =~ s/$check//g;\n    $r =~ s/$check//g;\n    if ($l eq $r) {\n\
    \        return [$l, 1];\n    } else {\n        return [$l, \"\"];\n    }\n}",
  "    $s =~ s/[$c]//g;\n    my $r = $s eq reverse $s;\n    return [$s, $r]\n}", " \
    \   my %hash = map { $_ => 1 } split //, $c;\n    my $r = reverse(join('', grep\
    \ { !$hash{$_} } split //, $s));\n    [$r, $r eq $s ? 1 : ''];\n}", "    my $t\
    \ = join '', reverse split //, $s;\n    for my $p ($s, $t) {\n        for my $c_\
    \ (split //, $c) {\n            $p =~ s/$c_//g;\n        }\n    }\n    my $n =\
    \ $s eq $t ? 1 : '';\n    return [$s, $n];\n}", "    my $new = join '', grep{index($c,\
    \ $_) == -1} split //, $s;\n    my $res = reverse $new eq $new ? 1 : '';\n   \
    \ return [$new, $res];\n}", "    $s =~ s/[$c]//g;\n    my $t = $s;\n    $t =~\
    \ tr/ABCDEFGHIJKLMNOPQRSTUVWXYZ/ZYXWVUTSRQPONMLKJIHGFEDCBA/;\n    return [$s,\
    \ $s eq $t];\n}", "    $s =~ s/[$c]//g;\n    $s eq reverse $s ? [$s, 1] : [$s,\
    \ ''];\n}", "    my %c = map {$_ => 1} split(//, $c);\n    my $s2 = join('', grep\
    \ {not $c{$_}} split(//, $s));\n    my $p = $s2 eq reverse($s2);\n    return [$s2,\
    \ $p]\n}", "    my %c;\n    foreach (split //, $c) {\n        $c{$_} = 1;\n  \
    \  }\n    my $result = \"\";\n    foreach (split //, $s) {\n        $result .=\
    \ $_ unless $c{$_};\n    }\n    my @result = ($result, ($result eq reverse $result)\
    \ ? 1 : \"\");\n    return \\@result;\n}", "    $s =~ s/[$c]//g;\n    return [$s,\
    \ $s eq reverse($s)];\n}", "    my $t = \"\";\n    for (split //, $s) {\n    \
    \    $t .= $_ unless $c =~ /$_/;\n    }\n    my $check = ($t eq reverse $t);\n\
    \    return [$t, $check];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    $s =~ s/[$c]//g;\n    my $l = length($s);\n    my $d = 0;\n    for (my\
    \ $i = 0; $i < $l/2; $i++) {\n        $d += ($s <=> reverse($s));\n    }\n   \
    \ return [$s, $d < 0 || $d > 0 ? '' : 1];\n}", "    my @str = split(//, $s);\n\
    \    my @chars = split(//, $c);\n    my @result;\n    while (my ($i, $ch) = each\
    \ @str) {\n        foreach (@chars) {\n            if($ch eq $_) {\n         \
    \       delete $str[$i];\n            }\n        }\n    }\n    foreach my $ch\
    \ (@str) {\n        push @result, $ch if defined $ch;\n    }\n    my $rev = join\
    \ '', @result;\n    if($rev eq reverse $rev) {\n        return [$rev, 1];\n  \
    \  }\n    return [$rev, ''];\n}", "    my @s = split //, $s;\n    my @c = split\
    \ //, $c;\n    my %d = map { $_ => 1 } @c;\n    @s = grep { !$d{$_} } @s;\n  \
    \  @s = reverse @s;\n    @s = join(\"\", @s);\n    my $t = join(\"\", @s);\n \
    \   if ($s eq $t) {\n        return [$s, 1];\n    } else {\n        return [$s,\
    \ ''];\n    }\n}", "    my %hash = map {$_=>1} split //, $c;\n    $s =~ s/[$c]//g;\n\
    \    $s =~ tr/[A-Z]/[a-z]/;\n    $s = scalar reverse $s;\n    return [$s, $s=~/(\\\
    w+)\\1/ ? 1 : ''];\n}", "    my %c = map { $_ => 1 } split '', $c;\n    $s = join\
    \ '', grep { !$c{$_} } split '', $s;\n    return [$s, $s eq reverse $s];\n}",
  "    $s =~ s/[$c]//g;\n    return [$s, ($s eq reverse $s)];\n}", "    my @s = split\
    \ //, $s;\n    my @c = split //, $c;\n    for my $c (@c) {\n        @s = grep\
    \ {$_ ne $c} @s;\n    }\n    return [join('', @s), ($s eq join('', reverse @s))\
    \ ? 1 : ''];\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my @s = grep\
    \ { !$c{$_} } split //, $s;\n    unshift @s, \"\";\n    @s = map { $_ || \"\"\
    \ } @s;\n    return [join(\"\", @s), $s[0] eq $s[-1]];\n}", "    my %hash = map\
    \ { $_ => 1 } split '', $c;\n    $s = join '', grep { !$hash{$_} } split '', $s;\n\
    \    $s = reverse $s;\n    $s eq $s ? ['', 1] : [$s, ''];\n}", "    my $t = $s;\n\
    \    $t =~ s/[$c]//g;\n    return [$t, $t eq reverse($t) ? 1 : ''];\n}", "   \
    \ my %c;\n    @c{ split '', $c } = ();\n    my $result = join '', grep !$c{$_},\
    \ split '', $s;\n    return [$result, $result eq reverse $result];\n}", "    $s\
    \ =~ s/[$c]//g;\n    my $reversed = reverse $s;\n    return [$s, $s eq $reversed\
    \ ? 1 : ''];\n}", "    my @out = ($s, '');\n    $out[0] =~ s/$c//g;\n    $out[1]\
    \ = $out[0] eq scalar reverse $out[0] ? 1 : '';\n    return \\@out;\n}", "   \
    \ my @arr = split '', $s;\n    my %hash = map {$_ => 1} split '', $c;\n    @arr\
    \ = grep {!$hash{$_}} @arr;\n    my $str = join '', @arr;\n    my $res = $str\
    \ eq reverse $str ? 1 : '';\n    return [$str, $res];\n}", "    my $remove = join\
    \ '', map quotemeta, split //, $c;\n    $s =~ s/[$remove]//g;\n    return [$s,\
    \ $s eq reverse $s];\n}", "    my $delete_str = join '', map {\n        my $char\
    \ = $_;\n        grep {$_ eq $char} split //, $c;\n    } split //, $s;\n    $s\
    \ =~ s/[$delete_str]//g;\n    $s =~ s/\\s+//g;\n    [$s, $s eq reverse $s ? 1\
    \ : ''];\n}", "    my %c = map {$_ => 1} split //, $c;\n    my $t = join \"\"\
    , grep {!$c{$_}} split //, $s;\n    return [$t, $t eq scalar reverse $t];\n}",
  "    my $res = \"\";\n    my $palindrome = 1;\n    my %hash;\n    for my $i (0..length($c)-1)\
    \ {\n        $hash{substr($c, $i, 1)} = 1;\n    }\n    for my $i (0..length($s)-1)\
    \ {\n        my $char = substr($s, $i, 1);\n        if (not exists $hash{$char})\
    \ {\n            $res .= $char;\n        }\n    }\n    my $len = length($res);\n\
    \    for my $i (0..int($len/2)) {\n        if (substr($res, $i, 1) ne substr($res,\
    \ $len-1-$i, 1)) {\n            $palindrome = \"\";\n            last;\n     \
    \   }\n    }\n    return [$res, $palindrome];\n}", '    my %dict;', "    my @char_c\
    \ = split //, $c;\n    for (@char_c) {\n        $s =~ s/$_//g;\n    }\n    return\
    \ [$s, ($s eq reverse $s)];\n}", "    my @new_s = split(\"\", $s);\n    my @new_c\
    \ = split(\"\", $c);\n    my @new_new_s = ();\n    foreach my $char_s (@new_s)\
    \ {\n        foreach my $char_c (@new_c) {\n            if ($char_s ne $char_c)\
    \ {\n                push(@new_new_s, $char_s);\n            }\n        }\n  \
    \  }\n    my $result = join(\"\", @new_new_s);\n    return [$result, \"\"] if\
    \ ($result eq reverse($result));\n    return [$result, 1];\n}", "    # \u041C\u043E\
    \u0436\u043D\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\
    \u0442\u044C \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0435:\n    #  \
    \  $s =~ s/[$c]//g;\n    # \u041D\u043E \u0442\u0430\u043A \u043A\u0430\u043A\
    \ \u0432\u0441\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B \u0432 $c \u043F\
    \u0440\u0438 \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E\u0441\
    \u0442\u0438 \u043C\u043E\u0436\u043D\u043E \u0437\u0430\u043A\u043B\u044E\u0447\
    \u0438\u0442\u044C \u0432 [] (\u0438\u0437-\u0437\u0430 \u0442\u043E\u0433\u043E\
    , \u0447\u0442\u043E \u0432\u0441\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B\
    \ $c \u043D\u0435 \u043C\u043E\u0433\u0443\u0442 \u043F\u043E\u0432\u0442\u043E\
    \u0440\u044F\u0442\u044C\u0441\u044F),\n    # \u0442\u043E \u043C\u043E\u0436\u043D\
    \u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\
    \ \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439 \u0432\u0430\u0440\u0438\
    \u0430\u043D\u0442:\n    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my @r = reverse split(//, $s);\n    my @c = split(//, $c);\n    my @rr\
    \ = ();\n    my @rc = ();\n    foreach my $i (@r) {\n        my $check = 0;\n\
    \        foreach my $j (@c) {\n            if ($i eq $j) {\n                $check\
    \ = 1;\n            }\n        }\n        if ($check == 0) {\n            push\
    \ @rr, $i;\n        }\n    }\n    my $r = join('', @rr);\n    foreach my $i (@rr)\
    \ {\n        my $check = 0;\n        foreach my $j (@c) {\n            if ($i\
    \ eq $j) {\n                $check = 1;\n            }\n        }\n        if\
    \ ($check == 0) {\n            push @rc, $i;\n        }\n    }\n    my $rc = join('',\
    \ @rc);\n    if ($r eq $rc) {\n        return ($r, 1);\n    } else {\n       \
    \ return ($r, '');\n    }\n}\n1;", "    return [$s, $s eq reverse $s];\n}", " \
    \   my %set = map { $_ => 1 } split //, $c;\n    my @a = grep { !$set{$_} } split\
    \ //, $s;\n    return [join(\"\", @a), join(\"\", @a) eq join(\"\", reverse @a)];\n\
    }", "    my $t = \"\";\n    for my $char (split //, $s) {\n        $t .= $char\
    \ unless $c =~ /$char/;\n    }\n    return [$t, $t eq reverse $t ? 1 : \"\"];\n\
    }", "    my @ret = ($s, '');\n    return @ret if length($s) < 2;\n    if (is_palindrome($s))\
    \ {\n        $ret[1] = 1;\n    } else {\n        foreach my $c (split //, $c)\
    \ {\n            $ret[0] =~ s/$c//g;\n        }\n        $ret[1] = is_palindrome($ret[0]);\n\
    \    }\n    return @ret;\n}", "    $s =~ s/[$c]//gi;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my @chars = split('', $s);\n    foreach (@chars) {\n        if ($c =~\
    \ /$_/) {\n            $_ = '';\n        }\n    }\n    $s = join('', @chars);\n\
    \    my $res = (length($s) == 0 or ($s ne reverse($s))) ? '' : 1;\n    return\
    \ [$s, $res];\n}", "    my %c_elem = map { $_ => 1 } split //, $c;\n    my $result\
    \ = join '', grep { !$c_elem{$_} } split //, $s;\n    my $check = $result eq reverse\
    \ $result ? 1 : '';\n    return [$result, $check];\n}", "    my %h = map { $_\
    \ => 1 } split(\"\", $c);\n    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)\
    \ ? 1 : ''];\n}", "    for my $i (0..length($c)-1) {\n        my $l = substr($c,\
    \ $i, 1);\n        $s =~ s/$l//g;\n    }\n    my $p = $s;\n    $p =~ tr/\\041-\\\
    176//d;\n    $p =~ tr/\\x{00a1}-\\x{00ff}//d;\n    $p = reverse $p;\n    return\
    \ [$s, $p eq $s];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my @result = split '', $s;\n    my %del = map { $_ => 1 } split '', $c;\n\
    \    @result = grep { !$del{$_} } @result;\n    [join('', @result), $result[0]\
    \ && $result[-1] && join('', @result) eq join('', reverse @result)];\n}", "  \
    \  my @res = ($s);\n    map {$res[0] =~ s/\\Q$_//g} split //, $c;\n    push @res,\
    \ $res[0] eq reverse($res[0]) ? 1 : '';\n    return @res;\n}", "    $s =~ s/[$c]//g;\n\
    \    my $palindrome = ($s eq reverse $s ? 1 : '');\n    return [$s, $palindrome];\n\
    }", "    my %h;\n    my @arr = split(//, $c);\n    foreach my $letter (@arr) {\n\
    \        $h{$letter} = 1;\n    }\n    my @arr2 = split(//, $s);\n    my @new;\n\
    \    foreach my $letter (@arr2) {\n        if (exists $h{$letter}) {\n       \
    \     next;\n        }\n        push(@new, $letter);\n    }\n    my $new = join(\"\
    \", @new);\n    if ($new eq reverse($new)) {\n        return [$new, 1];\n    }\n\
    \    return [$new, ''];\n}", "    my $l = length($s);\n    my $i = 0;\n    my\
    \ $arr = [];\n    my $map = {};\n    my $result = '';\n    my $check = '';\n \
    \   my $m = length($c);\n    for (0..$m - 1) {\n        my $t = substr($c, $_,\
    \ 1);\n        if (defined $map->{$t}) {\n            $map->{$t}++;\n        }\
    \ else {\n            $map->{$t} = 1;\n        }\n    }\n    while ($i < $l) {\n\
    \        my $t = substr($s, $i, 1);\n        if (defined $map->{$t}) {\n     \
    \       $i++;\n        } else {\n            push @$arr, substr($s, $i, 1);\n\
    \            $i++;\n        }\n    }\n    if (scalar @$arr == 0) {\n        $result\
    \ = $s;\n    } else {\n        $result = join '', @$arr;\n    }\n    $l = length($result);\n\
    \    $i = 0;\n    my $j = $l - 1;\n    while ($i < $j) {\n        my $a = substr($result,\
    \ $i, 1);\n        my $b = substr($result, $j, 1);\n        if ($a ne $b) {\n\
    \            $check = '';\n            last;\n        }\n        $i++;\n     \
    \   $j--;\n    }\n    if ($i == $j || $i > $j) {\n        $check = 1;\n    }\n\
    \    return [$result, $check];\n}", "    my $a = join \"\", ($s =~ /[^$c]/g);\n\
    \    my $b = $a eq join \"\", (reverse split //, $a);\n    return ($a, $b);\n}",
  "    my %del; @del{split //, $c} = undef;\n    my $t = reverse join '', grep {!exists\
    \ $del{$_}} split //, $s;\n    [$t, $t eq $s ? 1 : ''];\n}\nmy $ret = reverse_delete(\"\
    abcdedcba\", \"ab\");\nprint \"$ret->[0] - $ret->[1]\";", "    my $r = quotemeta($c);\n\
    \    $s =~ s/$r//g;\n    my $x = $s eq reverse($s) ? 1 : '';\n    return [$s,\
    \ $x];\n}", "    my %dic = map { $_ => 1 } split(//, $c);\n    my @ret = ();\n\
    \    for my $ch (split(//, $s)) {\n        push @ret, $ch unless $dic{$ch};\n\
    \    }\n    @ret = join(\"\", @ret);\n    if ($ret[0] eq reverse $ret[0]) {\n\
    \        return [@ret, 1];\n    } else {\n        return [@ret, ''];\n    }\n}",
  "    my %d;\n    @d{split //, $c} = ();\n    $s =~ s/[$c]//g;\n    my $result =\
    \ '';\n    $result = 1 if $s eq reverse $s;\n    return [$s, $result];\n}", " \
    \   $s =~ s/$c//g;\n    return [$s, reverse($s) eq $s ? 1 : ''];\n}", "    my\
    \ $x = \"\";\n    my $y = \"\";\n    my @s_arr = split(//, $s);\n    my @c_arr\
    \ = split(//, $c);\n    foreach my $i (@s_arr) {\n        foreach my $j (@c_arr)\
    \ {\n            if ($i ne $j) {\n                $x .= $i;\n            }\n \
    \       }\n    }\n    my @x_arr = split(//, $x);\n    @x_arr = reverse(@x_arr);\n\
    \    foreach my $i (@x_arr) {\n        $y .= $i;\n    }\n    return ([$x, $x eq\
    \ $y ? 1 : '']);\n}", "    $s =~ s/[$c]//g;\n    my $res = $s eq reverse $s ?\
    \ 1 : '';\n    return [$s, $res];\n}", "    my $result = [];\n    $s =~ s/$c//g;\n\
    \    push @$result, $s;\n    push @$result, $s eq scalar reverse $s;\n    return\
    \ $result;\n}", "    my %hash;\n    @hash{split //, $c} = ();\n    my $string\
    \ = $s;\n    $string =~ s/[$c]//g;\n    my $flag = \"\";\n    if($string eq reverse\
    \ $string){\n        $flag = 1;\n    }\n    return [$string, $flag];\n}\nprint\
    \ Dumper reverse_delete(\"abcde\", \"ae\");\nprint Dumper reverse_delete(\"abcdef\"\
    , \"b\");\nprint Dumper reverse_delete(\"abcdedcba\", \"ab\");", "    my @s =\
    \ split(//, $s);\n    my @c = split(//, $c);\n    for my $i (@c) {\n        @s\
    \ = grep { $_ ne $i } @s;\n    }\n    my $s = join(\"\", @s);\n    return [$s,\
    \ $s eq reverse($s) ? 1 : \"\"];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = ($r eq reverse $r) ? 1 : '';\n    return [$r, $p];\n}", "    # your\
    \ code here\n}", "    my @a = split(//, $s);\n    my @b = split(//, $c);\n   \
    \ for my $i (@b) {\n        @a = grep { $i ne $_ } @a;\n    }\n    my $v = join\
    \ \"\", @a;\n    my $d = 0;\n    my $len = length($v);\n    for (my $i = 0; $i\
    \ < $len / 2; $i++) {\n        if (substr($v, $i, 1) ne substr($v, $len - $i -\
    \ 1, 1)) {\n            $d = 1;\n            last;\n        }\n    }\n    return\
    \ [$v, $d]\n}", "    my %map = map { $_ => 1 } split //, $c;\n    my @S = split\
    \ //, $s;\n    my ($L, $R) = (0, $#S);\n    while ($L < $R) {\n        if (exists\
    \ $map{$S[$L]}) {\n            $L++;\n        } elsif (exists $map{$S[$R]}) {\n\
    \            $R--;\n        } else {\n            $L++;\n            $R--;\n \
    \       }\n    }\n    my $t = join '', @S[$L..$R];\n    return [ $t, $t eq reverse\
    \ $t ? 1 : '' ];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n\
    }", "    my %c = map {$_=>1} split //, $c;\n    my @a = split //, $s;\n    my\
    \ @v;\n    for my $i (@a) {\n        if (!exists $c{$i}) {\n            push @v,\
    \ $i;\n        }\n    }\n    my $r = join '', @v;\n    return [$r,$r eq scalar\
    \ reverse $r ? 1 : ''];\n}", "    my @res = split(//, $s);\n    my @chars = split(//,\
    \ $c);\n    my $count = 0;\n    for my $char (@chars) {\n        for (my $i =\
    \ $count; $i < @res; $i++) {\n            if ($res[$i] eq $char) {\n         \
    \       splice(@res, $i, 1);\n                $i = -1;\n            }\n      \
    \  }\n    }\n    my $result = join('', @res);\n    if ($result eq reverse($result))\
    \ {\n        return [$result, 1];\n    }\n    return [$result, ''];\n}", "   \
    \ $s =~ s/$c//g;\n    $s =~ s/^\\s+|\\s+$//g;\n    return [$s, $s eq scalar reverse\
    \ $s];\n}", "    foreach my $i (split //, $c) {\n        $s =~ s/$i//g;\n    }\n\
    \    return [$s, $s eq reverse $s];\n}", "    my @check = split //, $c;\n    my\
    \ @s = split //, $s;\n    my @out = ();\n    foreach my $i (@s) {\n        if\
    \ (grep { $_ eq $i } @check) {", "    my %chars = map {$_ => 1} split //, $c;\n\
    \    my $r = '';\n    for my $char (split //, $s) {\n        if (!exists $chars{$char})\
    \ {\n            $r .= $char;\n        }\n    }\n    my $reversed = reverse $r;\n\
    \    return [$r, ($r eq $reversed) ? 1 : ''];\n}", "    $s =~ s/[$c]//g;\n   \
    \ return [$s, $s eq reverse($s)];\n}", "    my %c = map { $_ => 1 } split //,\
    \ $c;\n    my $result = join '', grep { !$c{$_} } split //, $s;\n    my $is_palindrome\
    \ = $result eq reverse $result;\n    return ($result, $is_palindrome);\n}", " \
    \   $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    $s =~ s/[$c]//g;\n\
    \    my $reversed = reverse $s;\n    my $v = $s eq $reversed ? 1 : '';\n    return\
    \ [$s, $v];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq scalar reverse $s];\n\
    }", "    my @del = split(//, $c);\n    my $string = '';\n    for my $char (split(//,\
    \ $s)) {\n        if (grep /$char/, @del) {\n            $string =~ s/$char//g;\n\
    \        } else {\n            $string .= $char;\n        }\n    }\n    my $res\
    \ = $string eq reverse($string) ? 1 : '';\n    return [$string, $res];\n}", " \
    \   my %h = map {$_ => 1} split //, $c;\n    my $result = join '', grep {!exists\
    \ $h{$_}} split //, $s;\n    return [$result, $result eq reverse $result];\n}",
  "    for my $i (split '', $c) {\n        $s =~ s/$i//g;\n    }\n    $s eq reverse\
    \ $s ? [$s, 1] : [$s, ''];\n}", "    my @s = split(\"\", $s);\n    my @c = split(\"\
    \", $c);\n    my %hash;\n    for my $i(@c){\n        $hash{$i} = 1;\n    }\n \
    \   for my $j(@s){\n        if(exists $hash{$j}){\n            $j = \"\";\n  \
    \      }\n    }\n    @s = grep { $_ ne \"\" } @s;\n    my $result = join(\"\"\
    , @s);\n    my $check = \"\";\n    if($result eq scalar reverse $result){\n  \
    \      $check = 1;\n    }\n    return [$result, $check];\n}", "    return [reverse\
    \ $s =~ s/[$c]//gr, $s eq reverse $s];\n}", "    my $check = 1;\n    while (length\
    \ $s > 0 and length $c > 0) {\n        $s =~ s/[$c]//g;\n        $c =~ s/[$s]//g;\n\
    \    }\n    if (scalar reverse $s ne $s) {\n        $check = \"\";\n    }\n  \
    \  [$s, $check];\n}", "    $s =~ s/[$c]//g;\n    return [$s, palindrome($s)];\n\
    }", "    my @s = split(//, $s);\n    my @c = split(//, $c);\n    foreach(@c){\n\
    \        @s = grep {$_ ne $_[0]} @s;\n    }\n    return ([join(//, @s), (join(//,\
    \ @s) eq reverse(join(//, @s))) ? 1 : '']);\n}", "    for my $letter (split('',\
    \ $c)) {\n        $s =~ s/$letter//g;\n    }\n    return [$s, $s eq reverse($s)\
    \ ? 1 : ''];\n}", "    $s =~ s/[$c]//g;\n    my $r = reverse $s;\n    return [$s,\
    \ $s eq $r];\n}", "    while ($s =~ s/[$c]//g) { }\n    my $rev = reverse $s;\n\
    \    return [$s, $s eq $rev];\n}", "    my $result = '';\n    for (split //, $s)\
    \ {\n        $result .= $_ unless index($c, $_) != -1;\n    }\n    my $check =\
    \ $result eq reverse $result ? 1 : '';\n    return [$result, $check];\n}", " \
    \   my %c_hash = map { $_ => 1 } split('', $c);\n    my $last = \"\";\n    my\
    \ $last_end = \"\";\n    my @res = ();\n    for my $i (reverse 0..length($s)-1)\
    \ {\n        if (!exists $c_hash{substr($s, $i, 1)}) {\n            $last = substr($s,\
    \ $i, 1) . $last;\n            $last_end = substr($s, $i, 1) . $last_end;\n  \
    \          push @res, $last;\n        }\n    }\n    return [$last, $last eq $last_end\
    \ ? 1 : \"\"];\n}", "    my $t = join('', grep { index($c, $_) == -1 } split('',\
    \ $s));\n    return [$t, $t eq reverse($t)];\n}", "    for my $char (split //,\
    \ $c) {\n        $s =~ s/$char//g;\n    }\n    $s =~ s/\\s//g;\n    my $l = length($s);\n\
    \    my $res = substr($s, 0, $l/2) eq reverse(substr($s, -($l/2))) ? 1 : '';\n\
    \    return [$s, $res];\n}", "    foreach my $i (split(\"\", $c)) {\n        $s\
    \ =~ s/$i//g;\n    }\n    my $copy = $s;\n    return [$s, ($s eq reverse($copy))];\n\
    }", "    my $t = $s;\n    for my $e (split '', $c) {\n        $t =~ s/$e//g;\n\
    \    }\n    return [$t, scalar $t eq reverse $t];\n}", "    my @s = split //,\
    \ $s;\n    my @c = split //, $c;\n    my @r;\n    my %d;\n    @d{@c} = ();\n \
    \   for (@s) {\n        push @r, $_ unless $d{$_};\n    }\n    my $r = join '',\
    \ @r;\n    return [$r, ($r eq reverse $r)];\n}", "    my @s = split //, $s;\n\
    \    my %d = map {$_ => 1} split //, $c;\n    my $p = 1;\n    foreach my $i (0\
    \ .. $#s) {\n        if ($d{$s[$i]}) {\n            if ($s[$i] ne $s[-$i - 1])\
    \ {\n                $p = 0;\n            }\n            delete $s[$i];\n    \
    \        delete $s[-$i - 1];\n        }\n    }\n    return [join '', grep {defined}\
    \ @s], $p;\n}", "    my $str = $s;\n    foreach my $chr (split(//, $c)) {\n  \
    \      $str =~ s/$chr//g;\n    }\n    return [$str, $str eq reverse($str) ? 1\
    \ : ''];\n}", "    return ['', ''] if length($s) == 0 || length($c) == 0;\n  \
    \  my %h = map { $_ => 1 } split //, $c;\n    $s =~ s/[$c]//g;\n    return [$s,\
    \ $s eq reverse($s) ? 1 : ''];\n}", "    my $i = 0;\n    while ($i < length($s))\
    \ {\n        if (index($c, substr($s, $i, 1)) >= 0) {\n            substr($s,\
    \ $i, 1) = '';\n            $i--;\n        }\n        $i++;\n    }\n    my $res\
    \ = [$s, $s eq reverse($s) ? 1 : ''];\n    return $res;\n}", "    $s =~ s/[$c]//g;\n\
    \    my $r = reverse $s;\n    return [$s, $s eq $r];\n}", "    foreach my $i (split(\"\
    \", $c)) {\n        $s =~ s/$i//g;\n    }\n    return [$s, ($s eq reverse($s))?\"\
    1\":\"\"];\n}", "    $s =~ s/$c//g;\n    return $s eq reverse $s ? [$s, 1] : [$s,\
    \ ''];\n}\nreverse_delete(\"abcdedcba\", \"ab\");", "    my @c = split //, $c;\n\
    \    my %c = map { $_ => 1 } @c;\n    my @s = split //, $s;\n    @s = grep { !exists\
    \ $c{$_} } @s;\n    my $res = join '', @s;\n    return [$res, $res eq reverse\
    \ $res];\n}", "    my $p = '';\n    my $p_flag = 0;\n    my $a_flag = 0;\n   \
    \ $s =~ s/[$c]//g;\n    if ($s eq '') {\n        $p_flag = 1;\n    }\n    else\
    \ {\n        my $size = length($s);\n        my $half = int($size / 2);\n    \
    \    my $test = substr($s, 0, $half);\n        my $test_reverse = substr($s, -$half);\n\
    \        my $rest = substr($s, $half);\n        if ($size % 2 == 1) {\n      \
    \      $test_reverse = substr($test_reverse, 1);\n            $rest = substr($rest,\
    \ 1);\n        }\n        if ($test eq reverse($test_reverse)) {\n           \
    \ $p_flag = 1;\n        }\n        elsif ($test eq $rest) {\n            $a_flag\
    \ = 1;\n        }\n    }\n    $p = $p_flag ? 1 : '';\n    return [$s, $p];\n}",
  "    my $result = '';\n    my $chars = {};\n    $chars->{$_} = 1 for split //, $c;\n\
    \    for my $chr (split //, $s) {\n        $result .= $chr unless $chars->{$chr};\n\
    \    }\n    return [$result, $result eq reverse $result];\n}", "    $s =~ s/[$c]//g;\n\
    \    my $l = length($s);\n    return [$s, $l == 0 || $s eq reverse($s)];\n}",
  "    $s =~ s/[$c]//g;\n    my $a = $s eq reverse $s ? 1 : '';\n    [$s, $a];\n}",
  "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", "    my $p = qr([$c]);\n\
    \    my $t = $s;\n    $t =~ s/$p//g;\n    $t = reverse $t;\n    $t =~ s/$p//g;\n\
    \    my $r = 1;\n    $r = '' if $t ne reverse $t;\n    return [$t, $r];\n}", " \
    \   $s =~ s/$c//g;\n    return [$s, scalar reverse($s) eq $s];\n}", "    $s =~\
    \ s/[$c]//g;\n    return [$s, int($s eq reverse $s)];\n}", "    for my $chr (split(//,\
    \ $c)) {\n        $s =~ s/$chr//g;\n    }\n    return [$s, $s eq reverse($s) ?\
    \ 1 : ''];\n}", "    my $l = length($s);\n    for (my $i = 0; $i < $l; $i++) {\n\
    \        my $char = substr($s, $i, 1);\n        if ($c =~ m/$char/) {\n      \
    \      $s = substr($s, 0, $i) . substr($s, $i + 1);\n            $i--;\n     \
    \       $l--;\n        }\n    }\n    my $r = reverse($s);\n    if ($s eq $r) {\n\
    \        return [$s, 1];\n    } else {\n        return [$s, ''];\n    }\n}", " \
    \   my $cnt = 0;\n    my $h = {map { $_ => 1 } split //, $c};\n    my $i = 0;\n\
    \    my $j = length($s) - 1;\n    while ($i < $j) {\n        if (not exists $h->{substr($s,\
    \ $i, 1)}) {\n            ++$i;\n        } elsif (not exists $h->{substr($s, $j,\
    \ 1)}) {\n            --$j;\n        } else {\n            if (substr($s, $i,\
    \ 1) eq substr($s, $j, 1)) {\n                substr($s, $i, 1) = '';\n      \
    \          substr($s, $j, 1) = '';\n                ++$cnt;\n            }\n \
    \           ++$i;\n            --$j;\n        }\n    }\n    return [$s, $cnt];\n\
    }", "    $s = reverse $s;\n    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse\
    \ $s];\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse($s)];\n}", " \
    \   my $chars = {};\n    my $result = '';\n    map { $chars->{$_} = 1 } split('',\
    \ $c);\n    map { $result .= $_ unless $chars->{$_} } split('', $s);\n    my $match\
    \ = $result eq scalar reverse $result ? 1 : '';\n    return [$result, $match];\n\
    }", "    $s =~ s/[$c]//g;\n    return ($s, $s eq reverse $s);\n}", "    my %c\
    \ = map { $_ => 1 } split //, $c;\n    $s = join '', grep { !$c{$_} } split //,\
    \ $s;\n    return [$s, $s eq reverse $s];\n}", "    my %hash = map {$_ => 1} split\
    \ //, $c;\n    my $s1 = join '', grep {!$hash{$_}} split //, $s;\n    my $s2 =\
    \ join '', reverse split //, $s1;\n    return [$s1, $s1 eq $s2 ? 1 : ''];\n}",
  "    my %c = map {$_ => 1} split('', $c);\n    my $s_reverse = reverse $s;\n   \
    \ my @s_in = split('', $s);\n    my @s_out;\n    my $is_p = 1;\n    foreach my\
    \ $i (0..$#s_in) {\n        push @s_out, $s_in[$i] unless $c{$s_in[$i]};\n   \
    \     $is_p &= $s_in[$i] eq $s_reverse[$i];\n    }\n    return [join('', @s_out),\
    \ $is_p];\n}", "    my %c = map {$_ => 1} split //, $c;\n    my $res = '';\n \
    \   my $i = 0;\n    for (split //, $s) {\n        $res .= $_ unless exists $c{$_};\n\
    \    }\n    my $res2 = reverse $res;\n    return [$res, $res eq $res2 ? 1 : ''];\n\
    }", "    my @res = grep { index($c, $_) == -1 } split //, $s;\n    [ join('',\
    \ @res), palindrome(@res) ? 1 : ''];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
