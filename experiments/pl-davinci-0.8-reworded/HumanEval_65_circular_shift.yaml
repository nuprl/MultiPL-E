name: HumanEval_65_circular_shift
language: pl
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift(12, 1)\n# \"21\"\n# >>> circular_shift(12, 2)\n\
  # \"12\"\nsub circular_shift {\n    my($x, $shift) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&circular_shift;\n\
  \        if(eq_deeply($candidate->(100, 2),\"001\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 2),\"12\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(97,\
  \ 8),\"79\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n    \
  \    if(eq_deeply($candidate->(12, 1),\"21\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(11, 101),\"11\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $str = $x;\n    my $len = length($str);\n    if ($shift > $len)\
    \ {\n        return(reverse($str));\n    }\n    for (my $i = 0; $i < $shift; $i++)\
    \ {\n        my $first = substr($str, 0, 1);\n        $str = substr($str, 1) .\
    \ $first;\n    }\n    return($str);\n}", "    my $digits = reverse(split(//, $x));\n\
    \    my $num_digits = scalar(@$digits);\n    while ($shift-- > 0) {\n        push(@$digits,\
    \ shift(@$digits));\n    }\n    my $result = join('', @$digits);\n    while ($result\
    \ =~ /^0/) {\n        $result =~ s/^0//;\n    }\n    return $result;\n}", "  \
    \  my $digits = scalar(digits($x));\n    return reverse(digits($x)) if $shift\
    \ > $digits;\n    my @digits = digits($x);\n    push @digits, splice(@digits,\
    \ 0, $shift);\n    return join('', @digits);\n}", "    return reverse $x if $shift\
    \ > length $x;\n    $x = reverse $x;\n    return substr($x, 0, $shift) . substr($x,\
    \ $shift);\n}", "    my $result = '';\n    while ($x) {\n        $result = $x\
    \ % 10 . $result;\n        $x = int($x / 10);\n    }\n    $result = reverse($result)\
    \ if $shift > length($result);\n    for (my $i = 0; $i < $shift; $i++) {\n   \
    \     $result = $result . chop($result);\n    }\n    return $result;\n}", "  \
    \  # Store the digits in an array.\n    my @digits = split //, $x;\n    # Circular\
    \ shift the digits.\n    for (my $i = 0; $i < $shift; $i++) {\n        push @digits,\
    \ shift @digits;\n    }\n    # Return the shifted digits.\n    return join '',\
    \ @digits;\n}", "    return scalar reverse $x if ($shift > length $x);\n    $x\
    \ = sprintf \"%0${shift}d$x\", 0;\n    return substr $x, -$shift;\n}", "    my\
    \ $r = reverse sprintf \"%0*d\", length($x), $x;\n    $r = reverse sprintf \"\
    %0*d\", length($x), $r if $shift > length($x);\n    $r = substr($r, $shift, length($x))\
    \ . substr($r, 0, $shift);\n    return $r;\n}", "    return join('', reverse(split('',\
    \ $x))) if $shift > length($x);\n    return substr($x, -$shift) . substr($x, 0,\
    \ -$shift);\n}", "    my $len = length($x);\n    return reverse($x) if $shift\
    \ > $len;\n    return substr($x, $len - $shift) . substr($x, 0, $len - $shift);\n\
    }", "    my $length = length($x);\n    if ($shift == $length) {\n        return($x);\n\
    \    } elsif ($shift > $length) {\n        return(reverse($x));\n    } else {\n\
    \        return(substr($x, $shift, $length) . substr($x, 0, $shift));\n    }\n\
    }", "    my $digits = digits($x);\n    return join('', reverse(split(//, $x)))\
    \ if $shift > $digits;\n    my $prefix = substr($x, 0, $digits - $shift);\n  \
    \  my $suffix = substr($x, $digits - $shift);\n    return $suffix . $prefix;\n\
    }", "    if ($shift == 0) {\n        return $x;\n    }\n    my $str_x = $x;\n\
    \    $str_x = sprintf(\"%0${length($x)}d\", $x);\n    my $a = substr($str_x, $shift,\
    \ -$shift);\n    my $b = substr($str_x, 0, $shift);\n    return $a . $b;\n}",
  "    my $res = 0;\n    while ($x) {\n        $res = $res * 10 + $x % 10;\n     \
    \   $x /= 10;\n    }\n    for (1 .. $shift) {\n        $res = int($res / 10) +\
    \ ($res % 10) * 10 ** (length(int($res)) - 1);\n    }\n    return \"$res\";\n}",
  "    my $digits = length($x);\n    my $shifted_digits = join '', reverse split '',\
    \ $x;\n    return $shifted_digits if $shift > $digits;\n    my $shifted = substr($shifted_digits,\
    \ 0, $shift);\n    $shifted =~ s/(\\d+)/reverse $1/e;\n    return $shifted;\n}",
  "    if ($shift > length($x)) {\n        return scalar reverse $x;\n    }\n    my\
    \ $first = substr($x, 0, $shift);\n    my $last = substr($x, $shift);\n    return\
    \ $last . $first;\n}", "    my $digits = length($x);\n    my $remainder = ($shift\
    \ % $digits);\n    return reverse $x if $remainder == 0;\n    my $rshift = $digits\
    \ - $remainder;\n    my $ls = substr($x, 0, $rshift);\n    my $rs = substr($x,\
    \ $rshift);\n    return $rs . $ls;\n}", "    my $len = length($x);\n    $shift\
    \ %= $len;\n    $shift = $len - $shift if $shift < 0;\n    return scalar reverse\
    \ if $shift == 0;\n    if ($shift >= $len) {\n        return scalar reverse $x;\n\
    \    }\n    my $h = int($x / 10**$shift);\n    my $t = $x % 10**$shift;\n    return\
    \ $t . $h;\n}", "    my $n = length($x);\n    $shift %= $n;\n    my $tmp = substr($x,\
    \ $n - $shift) . substr($x, 0, $n - $shift);\n    return $tmp;\n}", "    $x =\
    \ sprintf(\"%09d\", $x);\n    if ($shift > length($x)) {\n        return scalar\
    \ reverse $x;\n    } else {\n        my $first = substr($x, 0, $shift);\n    \
    \    my $last = substr($x, $shift);\n        return $last . $first;\n    }\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
