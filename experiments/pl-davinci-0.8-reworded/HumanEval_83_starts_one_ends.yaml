name: HumanEval_83_starts_one_ends
language: pl
prompt: "# Given a positive integer n, return the count of the numbers of n-digit\n\
  # positive integers that start or end with 1.\nsub starts_one_ends {\n    my($n)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&starts_one_ends;\n\
  \        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(2),18)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),180))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),1800))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),18000))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $sum = 0;\n    foreach my $i (1 .. $n - 1) {\n        $sum +=\
    \ 9 * 10 ** ($i - 1);\n    }\n    return 10 ** ($n - 1) + $sum;\n}", "    return\
    \ 0 if $n <= 0;\n    if ($n == 1) {\n        return 2;\n    }\n    if ($n == 2)\
    \ {\n        return 9;\n    }\n    return 9 * 10**($n-2) + 9;\n}", "    return\
    \ 0 if $n <= 0;\n    return 1 if $n == 1;\n    return starts_one_ends($n - 1)\
    \ + nine_power($n - 1);\n}", "    my $sum = 2;\n    for my $i (2 .. $n) {\n  \
    \      $sum += 9 * 9**($i - 2);\n    }\n    return $sum;\n}", "    my $count =\
    \ 0;\n    $count += (10**($n-1)) - 1 if $n > 1;\n    $count += $n - 1;\n    return\
    \ $count;\n}", "    if($n == 1) {\n        return 2;\n    }\n    return starts_one_ends($n\
    \ - 1) + ends_one_ends($n - 1);\n}", "    my $sum = 0;\n    for (1 .. $n) {\n\
    \        my $num = 10 ** ($_-1);\n        $sum += 1 + $num;\n    }\n    return\
    \ $sum;\n}", '    my($i, $sum);', "    return count_ones($n) + sum_zeros($n-1);\n\
    }", "    return 0 if $n == 0;\n    return 9 if $n == 1;\n    return 45 + 9*(10**($n-2));\n\
    }", "    return [\n        (\n            (\n                power(3, $n-1),\n\
    \                power(3, $n-2),\n            ),\n            (\n            \
    \    power(3, $n-1),\n                power(3, $n-2),\n            ),\n      \
    \  ),\n    ];\n}", "    return 10 if $n == 1;\n    $n--;\n    return 9 * 9 * 8\
    \ * $n;\n}", "    return 1 if $n == 1;\n    return 10*starts_one_ends($n-1) +\
    \ 10**($n-1);\n}", "    my($res);\n    if ($n == 1) {\n        $res = 9;\n   \
    \ } else {\n        $res = starts_one_ends($n - 1) * 8;\n        $res += 10 **\
    \ ($n - 1);\n    }\n    return $res;\n}", "    $n == 1 and return 3;\n    my $sum\
    \ = 0;\n    my $prod = 1;\n    foreach my $i (0 .. $n - 1) {\n        $sum +=\
    \ $prod;\n        $prod *= 10;\n    }\n    return $sum + $sum;\n}", "    my($count);\n\
    \    my($tens);\n    $count = $n;\n    $tens = 1;\n    for (my($i) = 2; $i <=\
    \ $n; $i++) {\n        $tens *= 10;\n        $count += $tens;\n    }\n    return\
    \ $count;\n}", "    return 0 if $n <= 0;\n    return 1 if $n == 1;\n    $starts_one_ends[$n]\
    \ //= starts_one_ends($n - 1) + 2 * ends_one_ends($n - 1);\n}", "    my $i = 0;\n\
    \    my $j = 0;\n    for my $count (1 .. $n) {\n        $i += count_with_limit($count\
    \ - 1, 8);\n        $j += count_with_limit($count - 1, 9);\n    }\n    return\
    \ $i + $j;\n}", "    my $s = 0;\n    my $e = 0;\n    my $n_minus_one = $n - 1;\n\
    \    if ($n_minus_one == 0) {\n        $s = $e = 1;\n    } else {\n        $s\
    \ = $e = 1 + 9*prod(1..$n_minus_one);\n        $s += prod(1..$n_minus_one);\n\
    \        $e += prod(1..$n_minus_one);\n    }\n    return ($s, $e);\n}", "    my\
    \ $start_ends = sub {\n        my($k) = @_;\n        # If the number is less than\
    \ 10, there's only one possibility.\n        return 1 if $k == 1;\n        # Otherwise,\
    \ for each digit that could start the number, there are\n        # $start_ends->($k\
    \ - 1) possibilities for the rest of the number.\n        my $max = 0;\n     \
    \   foreach my $d (1 .. 9) {\n            $max += $start_ends->($k - 1);\n   \
    \     }\n        return $max;\n    };\n    return $start_ends->($n);\n}", "  \
    \  if($n==1) { return 2; }\n    if($n==2) { return 10; }\n    # For all other\
    \ n, the number of numbers that start or end with 1\n    # is 100 times the number\
    \ of numbers that start or end with 1,\n    # with one fewer digit, plus the number\
    \ of numbers with one fewer\n    # digit.\n    return 100*starts_one_ends($n-1)\
    \ + starts_one_ends($n-1);\n}", "    return 0 if $n == 0;\n    return 1 if $n\
    \ == 1;\n    my $res = 1;\n    my $k = $n - 1;\n    while ($k > 0) {\n       \
    \ $res *= 9;\n        $k--;\n    }\n    return 2 * $res + starts_one_ends($n -\
    \ 1);\n}", "    my $count = 9 * 10**($n-1);\n    $count += 9 * 9 * 10**($n-2)\
    \ if $n > 1;\n    return $count;\n}", "    return n_digit_permutations($n - 1)\
    \ + n_digit_permutations($n - 1);\n}", "    return $n == 1 ? 10 : 9*10**($n-1);\n\
    }", "    my $len = length $n;\n    die \"Can't handle $n\" if $len > 11;\n   \
    \ return 0 if $len == 1;\n    my $power = 0;\n    for (1 .. $len - 1) {\n    \
    \    $power += 9 * 10 ** ($_ - 1);\n    }\n    if ($len == 2) {\n        return\
    \ $n == 10 ? 0 : 9;\n    } else {\n        return 9 * $power + 9 * 10 ** ($len\
    \ - 2);\n    }\n}", '    my $total = 9;  # single digit 1-9 are counted', "  \
    \  return 10 ** ($n - 1) * 9;\n}", "    my($t);\n    if ($n < 1) {\n        return\
    \ 0;\n    }\n    if ($n == 1) {\n        return 1;\n    }\n    $t = $n;\n    $t\
    \ -= 1;  # because we start with 1\n    $t = $t * 9;  # since we can take any\
    \ digit for the middle of the number\n    $t = $t + 1;  # because we end with\
    \ 1\n    return $t;\n}", "    return count_ordered_combinations($n, [1], [1]);\n\
    }", "    my $top = 10**$n - 1;\n    return $top - int($top/10) + 1;\n}", "   \
    \ if ($n == 1) {\n        return 2;\n    }\n    my $previous = starts_one_ends($n\
    \ - 1);\n    my $powers = 9 * 10 ** ($n - 2);\n    return $previous + $powers;\n\
    }", "    my $x = \"1\" x $n;\n    my $c = 0;\n    while (++$x ne $x + 0) { $c++\
    \ if $x =~ /^1|1$/ }\n    return $c;\n}", "    return pow(2, $n - 1) * (1 + $n);\n\
    }", "    my $c = 0;\n    foreach my $d (1..$n) {\n        $c += int(10**($d-1)\
    \ / 2);\n    }\n    return $c;\n}", "    my $count = 0;\n    for (1 .. $n) {\n\
    \        $count += 10 ** ($_ - 1);\n    }\n    return $count;\n}", "    my $count\
    \ = $n;\n    $count += (9**2)**($n-2)  if $n > 1;\n    $count += (9**2)**($n-2)\
    \  if $n > 2;\n    return $count;\n}", "    my $count = 0;\n    my $tens = 1;\n\
    \    for (my $i = 1; $i < $n; $i++) {\n        $tens *= 10;\n    }\n    for (my\
    \ $i = 1; $i < 10; $i++) {\n        $count += $tens;\n    }\n    for (my $i =\
    \ 1; $i < $n; $i++) {\n        $count += 9 * number_with_n_digits($n - $i - 1);\n\
    \    }\n    return $count;\n}", "    my $a = 10;\n    my $c = 0;\n    my $ones\
    \ = 1;\n    my $result = 0;\n    while ($c < $n) {\n        $result += $ones *\
    \ $a;\n        $a *= 10;\n        $c++;\n        $ones += 1;\n    }\n    return\
    \ $result;\n}", "    if ($n == 1) {\n        return 10;\n    }\n    elsif ($n\
    \ == 2) {\n        return 81;\n    }\n    else {\n        return 10 + 9 * ($n\
    \ - 1) + starts_one_ends($n - 1);\n    }\n}", "    return if $n <= 0;\n    if\
    \ ($n == 1) {\n        return $n;\n    }\n    if ($n == 2) {\n        return 3;\n\
    \    }\n    # A(n) = 9*10^(n-2) + A(n-1)\n    return 9 * 10**($n-2) + starts_one_ends($n-1);\n\
    }", "    $n or return 0;\n    # When n = 1, 1 is the only number.\n    $n == 1\
    \ and return 1;\n    # When n = 2, 10 and 11 are the only numbers.\n    $n ==\
    \ 2 and return 2;\n    # After this, we have to get into combinations.\n    #\
    \ The number of digits left to fill is n - 1, so if we have n - 1\n    # digits,\
    \ we have n digits. For each of those numbers we have 2 choices:\n    # whether\
    \ the last digit is a 1.\n    # After we make that choice, we need the number\
    \ of n - 2 digit numbers\n    # starting or ending with 1.\n    my $count = 2\
    \ * starts_one_ends($n - 2);\n    # On the other hand, since we're allowed to\
    \ use zeros, we may make the\n    # choice to fill up the first n - 1 digits with\
    \ zeros.\n    # Then we can make the choice of whether the last digit is a 1,\
    \ so\n    # we have the number of n - 1 digit numbers starting or ending with\
    \ 1.\n    $count += starts_one_ends($n - 1);\n    return $count;\n}", "    return\
    \ count_n_digit_numbers_with_start($n, 1) +\n        count_n_digit_numbers_with_end($n,\
    \ 1);\n}", "    return ( ($n-1) * $POWER_2[$n-1] + starts_one_ends($n-1) );\n}",
  "    return 9 if $n == 1;\n    return 9*pow(10, $n-1) + pow(10, $n-1) - 1;\n}",
  "    if ($n == 1) {\n        return 1;\n    } elsif ($n == 2) {\n        return\
    \ 11;\n    } elsif ($n == 3) {\n        return 111;\n    } elsif ($n == 4) {\n\
    \        return 1111;\n    } elsif ($n == 5) {\n        return 11111;\n    } else\
    \ {\n        die;\n    }\n}", "    my($count) = 10**($n-1);\n    for my $z (0\
    \ .. $n-2) {\n        $count += 9 * 9**$z;\n    }\n    return $count;\n}", " \
    \   my $sum = 0;\n    for (1 .. $n) {\n        $sum += 9 * 10**($_-1);\n    }\n\
    \    return $sum;\n}", '    my $count = 10**($n-1);', "    my $s = 0;\n    foreach\
    \ my $i (1 .. $n - 1) {\n        $s += nine($i) * pow(10, $n - $i - 1);\n    }\n\
    \    $s += 1;\n    $s += pow(10, $n - 1);\n    return $s;\n}", "    if ($n ==\
    \ 1) {\n        return 2;\n    }\n    elsif ($n == 2) {\n        return 3;\n \
    \   }\n    else {\n        return starts_one_ends($n - 1) + starts_one_ends($n\
    \ - 2);\n    }\n}", "    my $res = 0;\n    my @fact = fact($n);\n    for my $d\
    \ (1 .. $n - 1) {\n        $res += 9 * $fact[$d-1] * $fact[$n - $d - 1];\n   \
    \ }\n    $res += $fact[$n - 1];\n    return $res;\n}", "    return two_digits_one_ends($n)\
    \ + (2 * one_digit_one_ends($n)) - $n;\n}", "    if ( $n == 1 ) {\n        return\
    \ 2;\n    }\n    elsif ( $n == 2 ) {\n        return 10;\n    }\n    else {\n\
    \        return 2 * 10 ** ($n - 2) + starts_one_ends($n - 1);\n    }\n}", "  \
    \  my($count);\n    $count = $n > 1 ? 9 * 10 ** ($n - 2) : 1;\n    return $count;\n\
    }", "    my $sum = 0;\n    for my $i (1 .. $n - 1) {\n        $sum += 9*10**($i-1);\n\
    \    }\n    return $sum + 1;\n}", "    return count_nums($n) + count_nums($n-1);\n\
    }", "    return 0 if $n <= 0;\n    return 9 if $n == 1;\n    return 9 * (1 + (10\
    \ ** ($n - 1)));\n}", "    return if $n <= 0;\n    my $out = \"1\";\n    $out\
    \ .= \"0\" for 1 .. $n - 1;\n    $out .= \"1\";\n    my $base = \"1\";\n    $base\
    \ .= \"0\" for 1 .. $n - 1;\n    return $out, $base;\n}", "    my $n2 = $n-1;\n\
    \    my $n3 = $n-2;\n    return 10**$n2 - 10**$n3;\n}", "    return ends_one_starts($n)\
    \ + ends_one_ends($n);\n}", "    my $first_digit = $n == 1 ? 1 : 10**($n-1);\n\
    \    my $last_digit = $n == 1 ? 1 : 10**($n-1);\n    return ($first_digit + $last_digit)\
    \ - 2;\n}", "    return (ends_one_ends($n - 1) + starts_one_ends($n - 1))\n  \
    \      if $n >= 3;\n    return 10 if $n == 2;\n    return 2;\n}", "    return\
    \ 0 if $n < 1;\n    return 1 if $n == 1;\n    return (pow(10, $n - 1) - pow(9,\
    \ $n - 1)) * 2;\n}", "    return starts_one_ends_helper($n, $n);\n}", "    my\
    \ $total = 0;\n    for (1 .. $n) {\n        my $s = pow(10, $_ - 1);\n       \
    \ my $e = pow(10, $_);\n        $total += $e - $s;\n    }\n    return $total;\n\
    }", "    die unless $n > 0;\n    return _starts_one_ends($n, 1);\n}", "    die\
    \ \"Not an integer\" if $n =~ /[^\\d]/;\n    die \"n must be positive\" if $n\
    \ < 1;\n    my $num = (10 ** ($n - 1)) - 1;\n    return $num * 2 + 1;\n}", " \
    \   return 0 if $n <= 0;\n    return 9 if $n == 1;\n    return (9 + 9 * 9 * pow(10,\
    \ $n - 2)) + starts_one_ends($n - 1);\n}", '    my $result = $n - 1;', "    my\
    \ $ten_n = power_of_ten($n);\n    my $nine_ten_n = 9 * $ten_n;\n    return $nine_ten_n\
    \ + $n - 10 + 1;\n}", "    croak \"Input must be a positive integer\\n\" unless\
    \ ($n > 0 && $n == int($n));\n    my $start = 10**($n-1);\n    my $end = 10**$n\
    \ - 1;\n    my $count = 0;\n    while ($start <= $end) {\n        $count++ if\
    \ ($start % 10 == 1);\n        $start++;\n    }\n    return $count;\n}", "   \
    \ if($n == 1) { return 1; }\n    return starts_one_ends($n-1) + 9*tens($n-1);\n\
    }", "    return binomial(2, $n) + (2**($n-1));\n}", "    my $count = 0;\n    my\
    \ $min_val = int('1' . '0' x ($n - 1));\n    my $max_val = int('1' x $n);\n  \
    \  for my $i ($min_val .. $max_val) {\n        my $j = $i;\n        my $s = '';\n\
    \        while ($j) {\n            $s = $j % 10 . $s;\n            $j = int($j\
    \ / 10);\n        }\n        if ($s =~ /^1|1$/) {\n            $count++;\n   \
    \     }\n    }\n    return $count;\n}", "    my $r = 1;\n    foreach my $i (0\
    \ .. $n - 2) {\n        $r *= 3;\n    }\n    return $r;\n}", "    _add(_fib(2\
    \ * $n - 1), _fib(2 * $n - 2));\n}", "    return 0 if $n < 1;\n    return 1 if\
    \ $n == 1;\n    return 10**($n-1) + 9*(10**($n-2)) + starts_one_ends($n-1);\n}",
  "    if ($n == 1) {\n        return 2;\n    }\n    else {\n        my $count_for_rest\
    \ = starts_one_ends($n - 1);\n        return $count_for_rest + 9 * $count_for_rest;\n\
    \    }\n}", "    return 0 if $n < 1;\n    return 1 if $n == 1;\n    return 10\
    \ * starts_one_ends($n - 1) + 10**($n - 1);\n}", "    return ($n == 1) ? 1 : 10\
    \ * starts_one_ends($n - 1) - 9 * starts_one_ends($n - 2);\n}", "    return 0\
    \ if $n == 0;\n    return 1 if $n == 1;\n    return 11*10**($n-2);\n}", "    #\
    \ Let the starting position be the \"0th\" digit in the number\n    # (padded\
    \ with leading zeros).\n    # \n    # Then we have the following rule:\n    #\
    \   - If the current position is the first position, then the digit must be\n\
    \    #     1, otherwise the digit can be 0 through 9.\n    #   - If the current\
    \ position is not the first position and the digit is\n    #     the last position,\
    \ then the digit must be 1, otherwise the digit can\n    #     be 0 through 9.\n\
    \    #   - If the current position is neither the first nor the last, then the\n\
    \    #     digit can be 0 through 9.\n    #\n    # This can be calculated using\
    \ the following formula:\n    #   - count(n) = 9 * count(n - 1) + if(n == 1) 1\
    \ else 10\n    #\n    # For example, count(3) = 9 * count(2) + 10 = 9 * (9 * count(1)\
    \ + 10) + 10\n    #                 = 9 * (9 * 1 + 10) + 10 = 9 * (19) + 10 =\
    \ 171\n    #\n    # We can calculate count(n) using a loop.\n    my $count = 0;\n\
    \    for (my $i = 1; $i <= $n; $i++) {\n        $count = 9 * $count + ($i == 1\
    \ ? 1 : 10);\n    }\n    return $count;\n}", "    my $answer = 0;\n    $answer\
    \ += dp_ends($n);\n    if ($n > 1) {\n        $answer += dp_starts($n-1);\n  \
    \  }\n    return $answer;\n}", "    my $c = 1;\n    $c += $n - 1;\n    my $i =\
    \ 10 ** ($n - 1);\n    while ($i < 10 ** $n) {\n        $c++ if $i % 10 == 1;\n\
    \        $i++;\n    }\n    return $c;\n}", "    $n < 2 and return $n;\n    $n\
    \ == 2 and return $n * 9;\n    $n == 3 and return $n * 9 * 8;\n    # when we've\
    \ got more than 3 digits, we can:\n    # - add a 1 to the left of a number of\
    \ $n-1 digits\n    # - add a 1 to the right of a number of $n-1 digits\n    #\
    \ - add a 1 to the left of a number of $n-2 digits\n    # - add a 1 to the right\
    \ of a number of $n-2 digits\n    # as we no longer care about counting combinations\
    \ for\n    # a given position, we can use a simple array.\n    my @digits = (0,\
    \ 9, 9, 8);\n    for my $i (1 .. $n - 2) {\n        # in the next digit position,\
    \ count the numbers of\n        # $n-2 digits:\n        $digits[0] = $digits[1];\n\
    \        # in the next digit position, count the numbers of\n        # $n-1 digits:\n\
    \        $digits[1] = $digits[2];\n        # in the next digit position, count\
    \ the numbers of\n        # $n digits:\n        $digits[2] = $digits[3];\n   \
    \     # in the next digit position, count the numbers of\n        # $n+1 digits:\n\
    \        $digits[3] = $digits[0] + $digits[1] + $digits[2];\n    }\n    return\
    \ $digits[3];\n}", "    if ($n <= 0) {\n        return 0;\n    }\n    elsif ($n\
    \ == 1) {\n        return 2;\n    }\n    return first_digit($n) + ends_one($n);\n\
    }", "    my $cache = {};\n    return _starts_one_ends( $n, $cache );\n}", "  \
    \  my $c = 1;\n    my $b = 9;\n    my $i = 1;\n    while($i < $n){\n        $c\
    \ += 9 * ($b + 1);\n        $b *= 10;\n        $i++;\n    }\n    return $c;\n}",
  "    my($count);\n    return 0 if $n == 1;\n    # Open up the number at different\
    \ places and treat as two numbers.\n    for my $i (1 .. $n - 1) {\n        $count\
    \ += first_ends_one($i) * first_ends_one($n - $i);\n    }\n    return $count;\n\
    }", "    my $count = $n * 10 ** ($n - 1);\n    return $count;\n}", "    return\
    \ (10**($n-1)) + 9*10**($n-2);\n}", "    my($i);\n    my($ret) = 0;", "    my\
    \ $count = 0;\n    for (1 .. 9) {\n        $count += length($_) == $n ? 1 : starts_one_ends($n\
    \ - 1);\n    }\n    return $count;\n}", "    return 0 if $n <= 0;\n    # 1-digit\
    \ numbers: 1\n    # 2-digit numbers: 11 (start), 10 (end)\n    # 3-digit numbers:\
    \ 111 (start), 101 (end), 110 (end)\n    # 4-digit numbers: 1111 (start), 1011\
    \ (end), 1110 (end), 1101 (end), 1010 (end)\n    # ...\n    # x - 1 starting ones,\
    \ plus x - 1 ending ones, plus one start-and-end one\n    return $n - 1 + $n -\
    \ 1 + 1;\n}", "    return ($n == 1) + count_one_ends(length($n));\n}", "    if($n\
    \ == 1) { return 2; }\n    my $pow = 10 ** ($n - 1);\n    return ($pow + 9 * $pow\
    \ - starts_one_ends($n - 1));\n}", "    return 0 if $n == 0;\n    return 1 if\
    \ $n == 1;\n    return 9*(10**($n-2));\n}", "    my $result = 0;\n    for (my\
    \ $i = 0; $i < $n; $i++) {\n        $result += _starts_one_ends($i) * _starts_one_ends($n\
    \ - $i - 1);\n    }\n    return $result;\n}", "    return(0) if ($n == 0);\n \
    \   return(10**($n-1)) if ($n == 1);\n    return(10**($n-1) + 9*9*(10**($n-2)));\n\
    }", "    return 0 if $n == 0;\n    return 10 if $n == 1;\n    return starts_one_ends($n\
    \ - 1) + 9 * permutations($n - 1);\n}", "    return (count_starts_one($n) + count_ends_one($n))\
    \ - count_both_one($n);\n}", "    if ( $n == 1 ) {\n        return 2;\n    }\n\
    \    return 2 * 10**($n-1) + (10**$n - 2*10**($n-1)) + starts_one_ends($n-1);\n\
    }", "    die \"Positive integer required\\n\" if $n <= 0;\n    return 0 if $n\
    \ == 1;\n    my $ans = 1;\n    $ans = 9 if $n == 2;\n    $ans = 9 + 9 * 9 if $n\
    \ == 3;\n    return $ans;\n}", "    my $g = 1;\n    my $l = 1;\n    my $r = 0;\n\
    \    my $o = 10;\n    while ($n) {\n        $r += $g;\n        $r += $o - $l;\n\
    \        $g *= $o - $l;\n        $o *= 10;\n        $l *= 10;\n        $n--;\n\
    \    }\n    return $r;\n}", "    return 0 if($n <= 0);\n    my $ret = $n;\n  \
    \  $ret += 9 * count_digits($n - 1);\n    return $ret;\n}", "    $n--;\n    my\
    \ $k = $n - 1;\n    return $k*$factorials[$k] + $factorials[$n] - $factorials[$k];\n\
    }", "    return 0 if $n <= 0;\n    if ($n == 1) {\n        return 2;\n    }\n\
    \    elsif ($n == 2) {\n        return 6;\n    }\n    elsif ($n == 3) {\n    \
    \    return 26;\n    }\n    else {\n        return 6 * 10 ** ($n - 3) + 4 * 9\
    \ ** ($n - 2);\n    }\n}", "    return 0 if $n < 1;\n    return 9 if $n == 1;\n\
    \    return 9*9*10**($n-2);\n}", "    $n == 1 and return 1;\n    $n == 2 and return\
    \ 2;\n    my $n_minus_one = starts_one_ends($n - 1);\n    my $n_minus_two = starts_one_ends($n\
    \ - 2);\n    return $n_minus_one + $n_minus_two + 1;\n}", "    return 2 * count_n_digit($n\
    \ - 1) + count_n_digit($n - 2);\n}", "    # The case for 1 is the special case\
    \ for which no digits are\n    # repeated; for this case, there are 10 possibilities\
    \ for the\n    # first digit and 9 for the last, but we have to subtract 1 because\n\
    \    # 10 is not a positive integer with n digits.\n    return (($n == 1) ? (10\
    \ * 9 - 1) : 0) +", "    if ($n == 1) {\n        return 1;\n    }\n    if ($n\
    \ == 2) {\n        return 10;\n    }\n    return (9 * $n) * 10 ** ($n - 2);\n}",
  "    return 10 ** ($n - 1) + 1;\n}", "    return 0 if $n == 0;\n    return 9 if\
    \ $n == 1;\n    return 9 * 10**($n-2) * 2;\n}", "    if($n == 1) {\n        return\
    \ 2;\n    }\n    return 9 * 10 ** ($n - 2);\n}", "    my $sum = 0;\n    my $ones\
    \ = 0;\n    my $prev = 0;\n    my $digit = 0;\n    my $i = 0;\n    while ($i++\
    \ < $n) {\n        $digit = $i < 2 ? 1 : 0;\n        $sum += ($prev + $ones) *\
    \ $digit;\n        $ones += $digit;\n        $prev += $digit;\n    }\n    return\
    \ $sum;\n}", "    if($n == 1) {\n        return 2;\n    } else {\n        return\
    \ (starts_one_ends($n-1) * 9) + starts_one_ends($n-2);\n    }\n}", "    my($all)\
    \ = 10**$n - 1;\n    my($starts) = 9*10**($n-1);\n    my($ends) = 1 + 9*10**($n-1);\n\
    \    return $all - $starts - $ends;\n}", "    croak 'n must be greater than zero'\
    \ if $n < 1;\n    return 1 if $n == 1;", "    my($p) = '1' . '0' x ($n - 1);\n\
    \    my($q) = '0' x ($n - 1) . '1';\n    #print \"D = $p, $q\\n\";\n    return\
    \ (scalar(grep {$_ ge $p && $_ le $q} @number_array)\n            - scalar(grep\
    \ {$_ eq $p || $_ eq $q} @number_array));\n}", "    return starts_one_ends_recur($n,\
    \ 1, 1);\n}", "    return 0 if $n <= 0;\n    return starts_one_ends_recursive($n);\n\
    }", "    ($n <= 1) ? 0 : 10**( $n - 1 ) + 1;\n}", "    my $count = 0;\n    my\
    \ $val = 10**($n-1);\n    my $mid = 10**($n-2);\n    $count += $mid; # Starts\
    \ with 1\n    $count += $mid; # Ends with 1\n    for my $i (1..$n-2) {\n     \
    \   $count += 2 * $mid;\n        $mid *= 10;\n    }\n    return $count;\n}", " \
    \   return (10 ** ($n - 1) + 10 ** ($n - 2) * 9) * 2;\n}", "    return\n     \
    \   $n == 1 ? 2 :\n        $n == 2 ? 4 :\n        $n == 3 ? 8 :\n        $n ==\
    \ 4 ? 16 :\n        $n == 5 ? 32 :\n        $n == 6 ? 64 :\n        $n == 7 ?\
    \ 128 :\n        $n == 8 ? 256 :\n        $n == 9 ? 512 :\n        $n == 10 ?\
    \ 1024 :\n        $n == 11 ? 2048 :\n        $n == 12 ? 4096 :\n        $n ==\
    \ 13 ? 8192 :\n        $n == 14 ? 16384 :\n        $n == 15 ? 32768 :\n      \
    \  $n == 16 ? 65536 :\n        $n == 17 ? 131072 :\n        $n == 18 ? 262144\
    \ :\n        $n == 19 ? 524288 :\n        $n == 20 ? 1048576 :\n        $n ==\
    \ 21 ? 2097152 :\n        $n == 22 ? 4194304 :\n        $n == 23 ? 8388608 :\n\
    \        $n == 24 ? 16777216 :\n        $n == 25 ? 33554432 :\n        $n == 26\
    \ ? 67108864 :\n        $n == 27 ? 134217728 :\n        $n == 28 ? 268435456 :\n\
    \        $n == 29 ? 536870912 :\n        $n == 30 ? 1073741824 :\n        $n ==\
    \ 31 ? 2147483648 :\n        $n == 32 ? 4294967296 :\n        0;\n}", "    my\
    \ $total = 0;\n    for my $num (1 .. $n) {\n        my $number = 10**($num - 1);\n\
    \        my $end = 10**$num - 1;\n        my $nums = $end - $number + 1;\n   \
    \     $total += $nums;\n    }\n    return $total;\n}", "    my($ones) = 1;\n \
    \   my($zeros) = 1;\n    while ($n > 1) {\n        $n--;\n        $ones = 2 *\
    \ $ones + 9 * $zeros;\n        $zeros = $zeros * 10;\n    }\n    return $ones;\n\
    }", "    return $n < 1 ? 0 : starts_one_ends($n - 1) + 10 * 9**($n - 1);\n}",
  "    return 0 if $n == 0;\n    return 9 if $n == 1;\n    return 9 * (1 + 9**($n-2))\n\
    }", "    my $x = 0;\n    return 0 if ($n == 1);\n    return 1 if ($n == 2);\n\
    \    return 1 + starts_one_ends($n - 1) + starts_one_ends($n - 2);\n}", "    my\
    \ $count = 0;\n    $count += _start_one_ends_helper($n - 1) if $n > 1;\n    $count\
    \ += _start_one_ends_helper($n - 1) if $n > 1;\n    $count += 2 if $n == 1;\n\
    \    return $count;\n}", '    my($result);', "    my $c = 0;\n    for (1 .. 9)\
    \ {\n        $c += ($_ > $n) ? 0 : (1 + count_digits($n - $_));\n    }\n    $c;\n\
    }", "    my $count = 0;\n    for my $i (0 .. $n - 1) {\n        $count += 9*10**$i;\n\
    \    }\n    $count *= 2;\n    $count -= 9 if $n == 1;\n    return $count;\n}",
  "    my $i = 1;\n    my $len = 0;\n    my $tmp = $n;\n    while ($tmp > 0) {\n \
    \       $len++;\n        $tmp /= 10;\n    }\n    if ($len < 2) {\n        return\
    \ 0;\n    }\n    my $digits = [];\n    for (my $j = 0; $j < $len; $j++) {\n  \
    \      $digits->[$j] = [];\n        for (my $k = 0; $k < 10; $k++) {\n       \
    \     $digits->[$j]->[$k] = -1;\n        }\n    }\n    my $ret = 0;\n    for (my\
    \ $j = 0; $j < $len; $j++) {\n        $ret += &_starts_one_ends($digits, $n, $j\
    \ + 1);\n    }\n    return $ret;\n}", "    return\n        ($n == 1) ? 2 :\n \
    \       ($n == 2) ? 3 :\n        ($n == 3) ? 5 :\n        ($n == 4) ? 8 :\n  \
    \      ($n == 5) ? 13 :\n        ($n == 6) ? 21 :\n        ($n == 7) ? 34 :\n\
    \        ($n == 8) ? 55 :\n        ($n == 9) ? 89 :\n        ($n == 10) ? 144\
    \ :\n        ($n == 11) ? 233 :\n        ($n == 12) ? 377 :\n        ($n == 13)\
    \ ? 610 :\n        ($n == 14) ? 987 :\n        ($n == 15) ? 1597 :\n        ($n\
    \ == 16) ? 2584 :\n        ($n == 17) ? 4181 :\n        ($n == 18) ? 6765 :\n\
    \        ($n == 19) ? 10946 :\n        ($n == 20) ? 17711 :\n        ($n == 21)\
    \ ? 28657 :\n        ($n == 22) ? 46368 :\n        ($n == 23) ? 75025 :\n    \
    \    ($n == 24) ? 121393 :\n        ($n == 25) ? 196418 :\n        ($n == 26)\
    \ ? 317811 :\n        ($n == 27) ? 514229 :\n        ($n == 28) ? 832040 :\n \
    \       ($n == 29) ? 1346269 :\n        ($n == 30) ? 2178309 :\n        ($n ==\
    \ 31) ? 3524578 :\n        ($n == 32) ? 5702887 :\n        ($n == 33) ? 9227465\
    \ :\n        ($n == 34) ? 14930352 :\n        ($n == 35) ? 24157817 :\n      \
    \  ($n == 36) ? 39088169 :\n        ($n == 37) ? 63245986 :\n        ($n == 38)\
    \ ? 102334155 :\n        ($n == 39) ? 165580141 :\n        ($n == 40) ? 267914296\
    \ :\n        ($n == 41) ? 433494437 :\n        ($n == 42) ? 701408733 :\n    \
    \    ($n == 43) ? 1134903170 :\n        ($n == 44) ? 1836311903 :\n        ($n\
    \ == 45)", "    my($count);\n    $count = 10;\n    $count += 8 * 10 ** (int($n/2)\
    \ - 1) if $n & 1;\n    $count *= 10 ** (int($n/2) - 1) if $n > 1;\n    return\
    \ $count;\n}", "    my($sum) = 0;\n    for (my($i) = 1; $i < $n; $i++) {\n   \
    \     $sum += (10**$i) * (10**$n - 10**$i);\n    }\n    return $sum;\n}", "  \
    \  return n_digit_one_ending($n) + n_digit_one_starting($n);\n}", "    die \"\
    n > 0 required\" unless $n > 0;\n    die \"n = 1 not implemented\" if $n == 1;\n\
    \    my $sum = 0;\n    my @fact = fact(9);\n    foreach my $k (1 .. $n - 1) {\n\
    \        $sum += $fact[$n - $k - 1] * 9 * 10**($k - 1);\n    }\n    return $sum\
    \ * 2;\n}", "    my $log2 = log(2);\n    my $result = floor(($n-1) * $log2) +\
    \ 1;\n    return $result;\n}", "    return\n        $n == 1 || $n == 0 ? 1 :\n\
    \        $n == 2 ? 2 :\n        2 * 4**($n-1) - starts_one_ends($n-1);\n}", " \
    \   return 10**($n-1) + 9*(10**($n-2));\n}", "    return 10 ** ($n - 1) if $n\
    \ == 1;\n    return (10 ** ($n - 1)) * 9 + starts_one_ends($n - 1);\n}", "   \
    \ my $ways = 0;\n    for my $first (1..9) {\n        my $start = $first;\n   \
    \     for my $place (1..$n-1) {\n            $start *= 10;\n        }\n      \
    \  $ways += 1;\n        $ways += starts_one_ends($n-1) if $n > 1;\n        $ways\
    \ += ends_one_ends($n-1) if $n > 1;\n    }\n    return $ways;\n}", "    if ($n\
    \ == 1) {\n        return 2;\n    }\n    if ($n == 2) {\n        return 3;\n \
    \   }\n    return starts_one_ends($n - 1) + starts_one_ends($n - 2);\n}", "  \
    \  return starts_one_ends_naive($n) unless $n > 1;\n    return cache_ref()->{$n}\
    \ if exists cache_ref()->{$n};\n    # For any n-digit number that starts with\
    \ a 1, we can drop the 1, and\n    # then add the known answer for (n-1)-digit\
    \ numbers that start with a\n    # 1 or end with a 1.\n    my $result = starts_one_ends($n-1)\
    \ + starts_one_ends_naive($n-1);\n    cache_ref()->{$n} = $result;\n    return\
    \ $result;\n}", "    return 0 if $n == 0;\n    my $res = 0;\n    foreach my $i\
    \ (1 .. $n) {\n        $res += n_digits($i) * n_digits($n - $i);\n    }\n    return\
    \ $res;\n}", "    my $count = 0;\n    if ($n == 1) {\n        return 2;\n    }\
    \ else {\n        for (my $i = 1; $i < $n; $i++) {\n            my $pow = int(pow(10,\
    \ $i));\n            $count += ($pow - 1) * pow(9, $n - $i - 1);\n        }\n\
    \        $count += 2 * (pow(9, $n - 1) - pow(8, $n - 1));\n    }\n    return $count;\n\
    }", "    my($start) = $n > 1 ? 10 ** ($n - 1) : 0;\n    my($end) = 10 ** $n;\n\
    \    my($count) = 0;\n    for my $num ($start .. $end - 1) {\n        if (($num\
    \ % 10) == 1) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $p = 10**($n-1);\n    my $q = 10**$n;\n    my $r = $q - $p;\n    return\
    \ $r + $r - 10 + starts_one_ends($n-1);\n}", "    if ($n == 1) {\n        return\
    \ 2;\n    } elsif ($n == 2) {\n        return 10;\n    } elsif ($n > 2) {\n  \
    \      return starts_one_ends($n - 1) + 8 * starts_one_ends($n - 2);\n    }\n}",
  "    return 0 if $n == 0;\n    return 9 if $n == 1;\n    return starts_one_ends($n\
    \ - 1) + 9 * (1 + 10**($n - 2))\n}", "    # If n == 1, there's only 1 number:\
    \ 1.\n    return 1 if $n == 1;\n    # The first digit can be either 1 or 2, and\
    \ the rest can be any digit.\n    # This can be calculated using the permutation\
    \ formula: n! / r!.\n    return factorial($n) / factorial($n - 1);\n}", "    if\
    \ ($n == 1) {\n        return 2;\n    } else {\n        return 10*ends_one_ends($n-1)\
    \ + pow(10, $n-1);\n    }\n}", "    my $ans = 1;\n    foreach (1..$n) {\n    \
    \    if ($_ == 1) {\n            $ans *= 8;\n        } else {\n            $ans\
    \ *= 9;\n        }\n    }\n    return $ans;\n}", "    my $start = $n - 1;\n  \
    \  my $end = $n - 1;\n    my $mid = $n - 2;\n    return $start * 9**$mid + $end\
    \ * 9**$mid;\n}", "    return 0 if $n < 1;\n    return 1 if $n == 1;\n    return\
    \ starts_one_ends($n - 1) + starts_one_ends($n - 2);\n}", "    return 1 if $n\
    \ == 1;\n    return 0 if $n < 1;\n    return 1 + starts_one_ends($n - 1) + starts_one_ends($n\
    \ - 2);\n}", "    my $total = 0;\n    my $base  = 1;\n    while ($n > 0) {\n \
    \       my $last  = 9 * $base;\n        my $first = $base;\n        if ($n > 1)\
    \ {\n            $first = 10 * $first;\n        }\n        $total += $last + $first;\n\
    \        $base *= 10;\n        $n--;\n    }\n    return $total;\n}", "    # The\
    \ first n-1 digits can be any number except for 0, and the last\n    # can be\
    \ any number except for 0, so I just need to subtract the\n    # counts of numbers\
    \ that start with 0 and end with 0.\n    my $start = power(8, $n - 1);\n    my\
    \ $end = power(9, $n - 1);\n    my $both = power(7, $n - 2);\n    return $start\
    \ + $end - $both;\n}", "    my $count = 1;\n    while (--$n) {\n        $count\
    \ += Math::BigInt->new(9)->bpow($n);\n    }\n    return $count;\n}", "    if ($n\
    \ == 1) {\n        return 2;\n    }\n    my $res = 0;\n    for my $i (0 .. 9)\
    \ {\n        my $t = $i;\n        for my $j (1 .. $n - 1) {\n            $t =\
    \ $t * 10 + 1;\n        }\n        $res += $t;\n    }\n    return $res;\n}", " \
    \   my($s);\n    $s = sub {\n        my($m) = @_;\n        return 0 if $m < 0;\n\
    \        return 1 if $m == 0;\n        $s->($m - 1) + 9 * $s->($m - 2);\n    };\n\
    \    $s->($n - 1);\n}", "    if($n == 1) {\n        return 2;\n    }\n    elsif($n\
    \ == 2) {\n        return 3;\n    }\n    else {\n        return (starts_one_ends($n-1)\
    \ + starts_one_ends($n-2));\n    }\n}", "    my($last,$first) = (1,1);\n    if\
    \ ($n > 1) {\n        $last = (9 * 9**($n-2)) + starts_one_ends($n-1);\n     \
    \   $first = 10 * starts_one_ends($n-1);\n    }\n    return $last + $first;\n}",
  "    if ($n == 1) {\n        return 1;\n    }\n    else {\n        my($first_number)\
    \ = (1 . '0' x ($n - 1));\n        my($last_number) = (1 . '0' x ($n - 2));\n\
    \        my($first_int) = int($first_number);\n        my($last_int) = int($last_number);\n\
    \        my($count) = 0;\n        while ($first_int <= $last_int) {\n        \
    \    $count += one_count($first_int);\n            $first_int++;\n        }\n\
    \        $count += starts_one_ends($n - 1);\n        return $count;\n    }\n}",
  "    return starts_one_ends_recurse($n, 1);\n}", "    return 0 if $n == 0;\n   \
    \ return 9 if $n == 1;\n    return 10 * 10**($n-2) + 9 * 10**($n-1);\n}", "  \
    \  if ($n == 1) {\n        return 2;\n    }\n    return starts_one_ends($n - 1)\
    \ + 9 * permutations($n - 1);\n}", "    my($x, $y, $z) = map { count_n($_) } (1\
    \ .. $n);\n    return ($x + $y + $z) % MOD;\n}", "    my($count) = 0;\n    for\
    \ my $i (1 .. $n - 1) {\n        $count += 9 * 9 ** ($i - 1);\n    }\n    return\
    \ $count + 9;\n}", "    if($n == 1) {\n        return 1;\n    }\n    else {\n\
    \        return (9 * 10 ** ($n - 2) + 1);\n    }\n}", "    my $n_1 = $n - 1;\n\
    \    my $power = int(10 ** $n_1);\n    my $power_minus_1 = $power - 1;\n    my\
    \ $result = $power + $power_minus_1;\n    while ($n_1--) {\n        $power /=\
    \ 10;\n        $result += $power + $power_minus_1;\n    }\n    return $result;\n\
    }", "    return 2*10**($n-1) - 10**($n-2);\n}", "    return (10 * starts_one_ends($n\
    \ - 1) + fact($n - 1)) if $n > 1;\n    return 10;\n}", "    return $n + 1;\n}",
  "    my $sum = 1; # for starting with 1\n    my $place = 1;\n    for (my $i = 1;\
    \ $i < $n; $i++) {\n        $place *= 10;\n        $sum += $place + $place - 1;\n\
    \    }\n    $sum += 1; # for ending with 1\n    return $sum;\n}", "    return\
    \ (1 + starts_one_ends($n - 1)) + middle_ones($n - 1);\n}", "    return $n ==\
    \ 1 ? 2 : count_digits($n - 1) * 2 + 9 * count_digits($n - 2);\n}", "    return\
    \ 10**($n-1) + 10**($n-2);\n}", "    if ($n == 1) {\n        return 1;\n    }\n\
    \    elsif ($n == 2) {\n        return 4;\n    }\n    else {\n        return 4\
    \ * (10 ** ($n - 2));\n    }\n}", "    return 2 * (9 ** ($n - 1)) + starts_one_ends($n\
    \ - 1);\n}", "    my $count = 1;\n    for (my $i = 0; $i < $n - 1; $i++) {\n \
    \       $count *= 9;\n    }\n    return $count;\n}", "    return $n == 1 ? 2 :\
    \ (10 * starts_one_ends($n - 1) - 9);\n}", "    my($length) = $n - 1;\n    my($count)\
    \ = 0;\n    my($i);\n    for ($i = 0; $i < $length; $i++) {\n        $count +=\
    \ (9 * 10 ** $i);\n    }\n    $count += (10 ** $length);\n    return $count;\n\
    }", "    my $count = 0;\n    foreach my $start_zero (0..$n-1) {\n        $count\
    \ += get_count($n-$start_zero-1);\n    }\n    return $count + get_count($n-1);\n\
    }", "    return 1 if $n == 1;\n    return starts_one_ends($n - 1) + starts_one_ends($n\
    \ - 2);\n}", "    return 0 if $n == 0;\n    return 1 if $n == 1;\n    return 9\
    \ + 10*(sum(0, $n-2) + starts_one_ends($n-1));\n}", "    die \"bad\" unless $n\
    \ >= 1;\n    if ($n == 1) {\n        return 2;\n    } else {\n        return 10*starts_one_ends($n-1)\
    \ - 9*starts_one_ends($n-2);\n    }\n}", "    my $one_less = (starts_one_ends($n-1)\
    \ || 0);\n    my $two_less = ($n > 2) ? (starts_one_ends($n-2) || 0) : 0;\n  \
    \  return $one_less * 9 + $two_less * 9 + 1;\n}", "    return $n < 2 ? 1 : starts_one_ends($n\
    \ - 1) + 9 * 10 ** ($n - 2);\n}\nprint starts_one_ends(4), \"\\n\";", "    # Convert\
    \ the number to base 10 representation.\n    my $base10 = 0;\n    my $i = 0;\n\
    \    while ($n) {\n        if ($n % 10 == 1) {\n            $base10 += 10 ** $i;\n\
    \        }\n        $n /= 10;\n        $i++;\n    }\n    # Convert base 10 to\
    \ base 2 representation.\n    my $base2 = 0;\n    my $mult = 1;\n    while ($base10)\
    \ {\n        $base2 += $mult * ($base10 % 2);\n        $base10 /= 2;\n       \
    \ $mult *= 10;\n    }\n    return $base2;\n}", "    return 10**(n-1) + 10**(n-2);\n\
    }", "    my $start = 10**($n-1);\n    my $end = 10**$n;\n    my $count = 0;\n\
    \    for( my $i = $start; $i < $end; $i++ ) {\n        if( $i % 10 == 1 || $i\
    \ =~ /^1/ ) {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "    return dp_starts_one_ends($n, 0);\n}", "    my($start1, $end1, $start1end1,\
    \ $others);\n    if ($n == 1) {\n        return 2;\n    } else {\n        $start1\
    \ = starts_one_ends($n - 1);\n        $end1 = $start1 - 1;\n        $start1end1\
    \ = $start1 * ($n - 2);\n        $others = $end1 * 9;\n        return $start1\
    \ + $end1 + $start1end1 + $others;\n    }\n}", "    my $sum = 0;\n    $sum +=\
    \ starts_one_ends($n - 1) if $n > 1;\n    $sum += 1;\n    $sum;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
