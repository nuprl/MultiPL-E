name: HumanEval_130_tri
language: pl
prompt: "# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n# the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n# Tribonacci sequence is defined by the recurrence:\n# tri(1) = 3\n\
  # tri(n) = 1 + n / 2, if n is even.\n# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n\
  \ + 1), if n is odd.\n# For example:\n# tri(2) = 1 + (2 / 2) = 2\n# tri(4) = 3\n\
  # tri(3) = tri(2) + tri(1) + tri(4)\n# = 2 + 3 + 3 = 8 \n# You are given a non-negative\
  \ integer number n, you have to a return an array of the \n# first n + 1 numbers\
  \ of the Tribonacci sequence.\n# Examples:\n# >>> tri(3)\n# [1, 3, 2, 8]\nsub tri\
  \ {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&tri;\n  \
  \      if(eq_deeply($candidate->(3),[1, 3, 2, 8])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[1, 3, 2, 8, 3]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[1,\
  \ 3, 2, 8, 3, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(6),[1, 3, 2, 8, 3, 15, 4])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[1,\
  \ 3, 2, 8, 3, 15, 4, 24])) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->(8),[1, 3, 2, 8, 3, 15, 4, 24, 5])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),[1,\
  \ 3, 2, 8, 3, 15, 4, 24, 5, 35])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(20),[1, 3, 2, 8, 3, 15, 4, 24,\
  \ 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1,\
  \ 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @res = (1, 3, 2);\n    while (@res < $n + 1) {\n        my $m\
    \ = scalar @res;\n        if ($m % 2 == 0) {\n            push @res, 1 + $m /\
    \ 2;\n        } else {\n            push @res, $res[$m - 1] + $res[$m - 2] + $res[$m\
    \ + 1];\n        }\n    }\n    return @res;\n}", "    my @arr = (1, 3, 2);\n \
    \   for(my $i = 3; $i <= $n; $i++) {\n        push @arr, $i % 2 ? $arr[$i - 1]\
    \ + $arr[$i - 2] + $arr[$i + 1] : 1 + $i / 2;\n    }\n    return @arr;\n}", " \
    \   return [] if $n < 0;\n    my @array = (1, 3, 2);\n    for (3..$n) {\n    \
    \    if ($_ % 2 == 0) {\n            push @array, int(1 + $_ / 2);\n        }\
    \ else {\n            push @array, $array[$_ - 1] + $array[$_ - 2] + $array[$_\
    \ + 1];\n        }\n    }\n    return \\@array;\n}", "    my @r;\n    if ($n ==\
    \ 0) {\n        return @r;\n    }\n    push @r, 1;\n    if ($n == 1) {\n     \
    \   return @r;\n    }\n    push @r, 3;\n    if ($n == 2) {\n        return @r;\n\
    \    }\n    push @r, 2;\n    if ($n == 3) {\n        return @r;\n    }\n    for\
    \ (3..$n) {\n        my $tri = (1 + $_ / 2) * (1 - ($_ % 2) * 2);\n        $tri\
    \ += $r[$_ - 1] + $r[$_ - 2] + $r[$_ - 3];\n        push @r, $tri;\n    }\n  \
    \  return @r;\n}", "    my(@res) = (1, 3, 2);\n    my($idx) = 3;\n    while($idx\
    \ <= $n) {\n        $res[$idx] = (($idx + 1) % 2) ? ($res[$idx - 1] + $res[$idx\
    \ - 2] + $res[$idx + 1]) : ($res[$idx - 1] + $res[$idx - 2]);\n        $idx++;\n\
    \    }\n    return \\@res;\n}", "    my @seq = ();\n    my $i = 0;\n    while($i\
    \ < $n + 1) {\n        if($i == 0) {\n            $seq[$i] = 1;\n        } elsif($i\
    \ == 1) {\n            $seq[$i] = 3;\n        } elsif($i == 2) {\n           \
    \ $seq[$i] = 2;\n        } else {\n            if($i % 2 == 0) {\n           \
    \     $seq[$i] = 1 + $i / 2;\n            } else {\n                $seq[$i] =\
    \ $seq[$i - 1] + $seq[$i - 2] + $seq[$i + 1];\n            }\n        }\n    \
    \    $i += 1;\n    }\n    return @seq;\n}", "    my $r = [0];\n    foreach my\
    \ $i (1 .. $n + 1) {\n        if ($i == 1) {\n            push @$r, 3;\n     \
    \   } elsif ($i % 2 == 0) {\n            push @$r, 1 + $i / 2;\n        } else\
    \ {\n            push @$r, $r->[$i - 1] + $r->[$i - 2] + $r->[$i + 1];\n     \
    \   }\n    }\n    $r;\n}", "    my @array = ();\n    my $temp1 = 0;\n    my $temp2\
    \ = 0;\n    my $temp3 = 0;\n    for (my $i = 0; $i <= $n; $i++) {\n        if\
    \ ($i == 0) {\n            push @array, 1;\n        }\n        elsif ($i == 1)\
    \ {\n            push @array, 3;\n        }\n        elsif ($i == 2) {\n     \
    \       push @array, 2;\n        }\n        else {\n            $temp1 = $array[$i\
    \ - 3];\n            $temp2 = $array[$i - 2];\n            $temp3 = $array[$i\
    \ - 1];\n            push @array, $temp1 + $temp2 + $temp3;\n        }\n    }\n\
    \    return @array;\n}", "    my @res = (1, 3, 2);\n    for(my $i = 3; $i <= $n;\
    \ $i++) {\n        $res[$i] = $res[$i - 1] + $res[$i - 2] + $res[$i - 3];\n  \
    \  }\n    return @res;\n}", "    my(@list);\n    @list = (0, 1, 3, 2);\n    for\
    \ my $i (1 .. $n) {\n        push @list,\n            ($i % 2 == 0)\n        \
    \    ? $list[$i] = 1 + $i / 2\n            : $list[$i] = $list[$i - 1] + $list[$i\
    \ - 2] + $list[$i + 1];\n    }\n    return @list;\n}", "    return [1, 3, 2] if\
    \ $n == 2;\n    my $a = tri($n - 1);\n    $a->[0] = $a->[1] + $a->[2] + $a->[3];\n\
    \    shift @$a;\n    return $a;\n}", "    my @result = (1, 3, 2);\n    if ($n\
    \ == 0) {\n        return [];\n    } elsif ($n == 1) {\n        return [1];\n\
    \    } elsif ($n == 2) {\n        return [1, 3];\n    } elsif ($n == 3) {\n  \
    \      return [1, 3, 2];\n    } else {\n        while ($n > 3) {\n           \
    \ my $last = $result[-1];\n            my $last_but_one = $result[-2];\n     \
    \       my $last_but_two = $result[-3];\n            my $next = $last_but_two\
    \ + $last_but_one + $last;\n            push @result, $next;\n            $n--;\n\
    \        }\n    }\n    return @result;\n}", "    my @result = (1, 3, 2);\n   \
    \ return @result if $n < 3;\n    while( @result < $n + 1 ) {\n        push @result,\
    \ $result[-3] + $result[-2] + $result[-1];\n    }\n    return @result;\n}", " \
    \   return if $n < 0;\n    my @ret = (1, 3, 2);\n    for (3..$n) {\n        push\
    \ @ret, $ret[$_ - 1] + $ret[$_ - 2] + $ret[$_ + 1];\n    }\n    return @ret;\n\
    }", "    return [3] if $n == 0;\n    my $a = [1, 3, 2];\n    foreach my $i (3\
    \ .. $n) {\n        my $next = $i & 1 ? $a->[$i - 1] + $a->[$i - 2] + $a->[$i\
    \ + 1] : 1 + $i / 2;\n        push @$a, $next;\n    }\n    return $a;\n}", " \
    \   my @a = (1, 3, 2);\n    if ($n == 0) {\n        return @a[0..0];\n    } elsif\
    \ ($n == 1) {\n        return @a[0..1];\n    } elsif ($n == 2) {\n        return\
    \ @a;\n    } else {\n        while (@a < $n + 1) {\n            my $prev1 = $a[-1];\n\
    \            my $prev2 = $a[-2];\n            my $prev3 = $a[-3];\n          \
    \  my $next = $prev3 + $prev2 + $prev1;\n            push @a, $next;\n       \
    \ }\n        return @a;\n    }\n}", "    my @result = (1, 3, 2);\n    foreach\
    \ my $i (3 .. $n) {\n        if ($i % 2 == 0) {\n            push @result, 1 +\
    \ $i / 2;\n        } else {\n            push @result, $result[$i - 1] + $result[$i\
    \ - 2] + $result[$i + 1];\n        }\n    }\n    return @result;\n}", "    my\
    \ @x = (1, 3, 2);\n    for my $i (3 .. $n) {\n        if ($i % 2 == 0) {\n   \
    \         push @x, 1 + ($i / 2);\n        } else {\n            push @x, $x[$i\
    \ - 1] + $x[$i - 2] + $x[$i + 1];\n        }\n    }\n    return @x;\n}", "   \
    \ my $x = 0;\n    my $y = 1;\n    my $z = 2;\n    my $nth = 3;\n    if ($n ==\
    \ 0) { return (); }\n    my @result = ($x, $y, $z);\n    while (@result < $n +\
    \ 1) {\n        push @result, $x + $y + $z;\n        $x = $y;\n        $y = $z;\n\
    \        $z = $result[$nth];\n        $nth++;\n    }\n    return @result;\n}",
  "    my @ret = (1, 3, 2);\n    for(4..$n) {\n        push @ret, (1 + $_ / 2) if\
    \ $_ % 2 == 0;\n        push @ret, $ret[-1] + $ret[-2] + $ret[-3] if $_ % 2 ==\
    \ 1;\n    }\n    return @ret;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
