name: HumanEval_115_max_fill
language: pl
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
  \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n\
  # 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
  # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n  \
  \  my($grid, $capacity) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
  \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
  \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $count = 0;\n    for my $row (@$grid) {\n        my $empty =\
    \ 0;\n        for my $col (@$row) {\n            if ($col == 0) {\n          \
    \      $empty++;\n            } else {\n                $count += $empty;\n  \
    \              $empty = 0;\n            }\n        }\n        $count += $empty\
    \ if $empty > 0;\n    }\n    return $count;\n}", "    my $n = scalar @$grid;\n\
    \    my $m = scalar @{$grid->[0]};\n    my $max = 0;\n    for my $i (0..$n-1)\
    \ {\n        for my $j (0..$m-1) {\n            if ($grid->[$i][$j] == 1) {\n\
    \                $max = max($max, $i);\n            }\n        }\n    }\n    return\
    \ ($max * $capacity);\n}", "    my @grid = map { [split //] } @$grid;\n    my\
    \ @heights = (0) x scalar @{$grid[0]};\n    foreach my $line (@grid) {\n     \
    \   $heights[$_] += $line->[$_] for 0 .. $#$line;\n    }\n    my @max_heights\
    \ = reverse sort { $a <=> $b } @heights;\n    return $capacity * @max_heights;\n\
    }", "    my $count = 0;\n    for my $row (@$grid) {\n        my $i = 0;\n    \
    \    while ($i < @$row && $row->[$i] == 0) {\n            $i++;\n        }\n \
    \       $count += 2*$i if $i < @$row;\n        for my $j ($i .. @$row - 1) {\n\
    \            if ($row->[$j] == 1) {\n                $count++;\n            }\
    \ else {\n                $count++ if $capacity == 1;\n            }\n       \
    \ }\n    }\n    return $count;\n}", "    my $times = 0;\n    my $row_length =\
    \ scalar @{$grid->[0]};\n    for my $row (@$grid) {\n        for my $n (0..$row_length-1)\
    \ {\n            if ($row->[$n] == 1) {\n                $row->[$n] = 0;\n   \
    \             $capacity--;\n                if ($capacity == 0) {\n          \
    \          $times++;\n                    $capacity = $row_length;\n         \
    \       }\n            }\n        }\n    }\n    return $times;\n}", "    my @grid\
    \ = @$grid;\n    my $water = 0;\n    my $wells = scalar @grid;\n    for (my $i\
    \ = 0; $i < $wells; $i++) {\n        $water += $capacity * $grid[$i]->[0];\n \
    \   }\n    return $water;\n}", "    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{ $grid->[0] };\n    my $depth = $capacity;\n    my $count = 0;\n  \
    \  while ($depth > 0) {\n        # Pick a row to empty first\n        my $row\
    \ = 0;\n        my $last = 0;\n        for my $i (0 .. $rows - 1) {\n        \
    \    $row = $i;\n            last if $grid->[$i][0] == 1;\n        }\n       \
    \ # Empty the row\n        for my $i (0 .. $cols - 1) {\n            if ($grid->[$row][$i]\
    \ == 1) {\n                last if $i == $cols - 1;\n                $grid->[$row][$i]\
    \ = 0;\n                $last = $i;\n            }\n        }\n        # Now deal\
    \ with excess\n        if ($last == $cols - 1) {\n            # Nothing to move\n\
    \            $depth--;\n            $count++;\n        }\n        else {\n   \
    \         my $moved = 0;\n            for my $i ($last + 1 .. $cols - 1) {\n \
    \               for my $j (0 .. $rows - 1) {\n                    if ($grid->[$j][$i]\
    \ == 1) {\n                        last if $j == $rows - 1;\n                \
    \        $grid->[$j][$i] = 0;\n                        $grid->[$j + 1][$i] = 1;\n\
    \                        $moved++;\n                    }\n                }\n\
    \            }\n            if ($moved == 0) {\n                $depth--;\n  \
    \              $count++;\n            }\n        }\n    }\n    return $count;\n\
    }\nuse Test::More;\nuse Test::Deep;\nuse Data::Dumper;\nis(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\nis(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2), 5);\nis", "    my $num_of_empties =\
    \ 0;\n    my $num_of_runs = 0;\n    my $is_empty = 0;\n    my $num_of_rows = scalar\
    \ @$grid;\n    my $num_of_cols = scalar @{$grid->[0]};\n    while (!$is_empty)\
    \ {\n        my $row_idx = 0;\n        my $col_idx = 0;\n        my $is_full =\
    \ 0;\n        while (!$is_full) {\n            my $cell = $grid->[$row_idx][$col_idx];\n\
    \            if ($cell == 1) {\n                $num_of_empties += 1;\n      \
    \          $num_of_runs += 1;\n                $grid->[$row_idx][$col_idx] = 0;\n\
    \            }\n            $col_idx += 1;\n            if ($col_idx == $num_of_cols)\
    \ {\n                $col_idx = 0;\n                $row_idx += 1;\n         \
    \   }\n            if ($row_idx == $num_of_rows) {\n                $is_full =\
    \ 1;\n            }\n        }\n        if ($num_of_empties < $capacity) {\n \
    \           $is_empty = 1;\n        }\n        $num_of_empties = 0;\n    }\n \
    \   return $num_of_runs;\n}", "    my $sum = 0;\n    for my $row (@$grid) {\n\
    \        my $fill = 0;\n        for my $well (@$row) {\n            if ($well)\
    \ {\n                $fill = $capacity if $fill < $capacity;\n               \
    \ $fill--;\n            }\n            $sum++ if $fill;\n        }\n    }\n  \
    \  return $sum;\n}", "    my $drop_count = 0;\n    for my $y (0 .. $#$grid) {\n\
    \        my $row = $grid->[$y];\n        for my $x (0 .. $#$row) {\n         \
    \   if ($row->[$x]) {\n                my $filled = $capacity;\n             \
    \   $row->[$x] -= $filled;\n                for my $y2 ($y+1 .. $#$grid) {\n \
    \                   my $row2 = $grid->[$y2];\n                    my $filled2\
    \ = $row2->[$x];\n                    if ($filled2 < $filled) {\n            \
    \            $row2->[$x] = 0;\n                        $filled -= $filled2;\n\
    \                    }\n                    else {\n                        $row2->[$x]\
    \ -= $filled;\n                        $filled = 0;\n                        last;\n\
    \                    }\n                }\n                $drop_count++;\n  \
    \          }\n        }\n    }\n    return $drop_count;\n}\nuse Test::More;\n\
    use Test::LMU;", "    my @visited = ();\n    my @result = ();\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $max_count = $cols * scalar @$grid;\n    my $count\
    \ = 0;\n    while ($count < $max_count) {\n        my @curr_visited = ();\n  \
    \      my @curr_result = ();\n        my @stack = ();\n        while (scalar @visited\
    \ > 0) {\n            my $x = shift @visited;\n            my $y = shift @visited;\n\
    \            my $q = shift @visited;\n            my $t = shift @visited;\n  \
    \          if ($grid->[$x][$y] == 1) {\n                $curr_result[$x][$y] =\
    \ $q;\n                $curr_visited[$x][$y] = $t;\n                push @stack,\
    \ $x, $y, $q, $t;\n            }\n        }\n        while (scalar @stack > 0)\
    \ {\n            my $x = shift @stack;\n            my $y = shift @stack;\n  \
    \          my $q = shift @stack;\n            my $t = shift @stack;\n        \
    \    my $r = $q - $capacity;\n            if ($r > 0) {\n                if ($y\
    \ > 0 && $curr_visited[$x][$y - 1] != $t) {\n                    $curr_result[$x][$y\
    \ - 1] = $r;\n                    $curr_visited[$x][$y - 1] = $t;\n          \
    \          push @stack, $x, $y - 1, $r, $t;\n                }\n             \
    \   if ($y < $cols - 1 && $curr_visited[$x][$y + 1] != $t) {\n               \
    \     $curr_result[$x][$y + 1] = $r;\n                    $curr_visited[$x][$y\
    \ + 1] = $t;\n                    push @stack, $x, $y + 1, $r, $t;\n         \
    \       }\n                if ($x > 0 && $curr_visited[", "    my @grid = @$grid;\n\
    \    my $max = 0;\n    foreach my $line (@grid) {\n        my $filled = 0;\n \
    \       foreach my $char (@$line) {\n            if ($char) {\n              \
    \  $filled++;\n            } else {\n                $filled = 0;\n          \
    \  }\n            if ($filled == $capacity) {\n                $max++;\n     \
    \           $filled = 0;\n            }\n        }\n    }\n    return $max;\n}",
  "    my @wells = @$grid;\n    my $well_count = scalar @wells;\n    my $column_count\
    \ = scalar @{$wells[0]};\n    my $water_count = 0;\n    for my $column (0..$column_count-1)\
    \ {\n        for my $well (0..$well_count-1) {\n            if ($wells[$well][$column]\
    \ == 1) {\n                if ($capacity > $well_count-$well) {\n            \
    \        $water_count += $well_count-$well;\n                    $capacity -=\
    \ $well_count-$well;\n                } else {\n                    $water_count\
    \ += $capacity;\n                    $capacity = 0;\n                }\n     \
    \       }\n        }\n    }\n    return $water_count;\n}", "    my $height = scalar\
    \ @$grid;\n    my $width = scalar @{$grid->[0]};\n    my $total = 0;\n    my $lowest\
    \ = 0;\n    for my $i (0..$height-1) {\n        my $row = $grid->[$i];\n     \
    \   for my $j (0..$width-1) {\n            if ($row->[$j]) {\n               \
    \ my $fill = $capacity - $total;\n                $lowest = $fill if $fill > $lowest;\n\
    \                $total += $fill;\n            }\n            else {\n       \
    \         $total = 0;\n            }\n        }\n        $total = 0;\n    }\n\
    \    $lowest;\n}", "    my $total_units = 0;\n    my $lowerings = 0;\n    for\
    \ my $row (@$grid) {\n        $total_units += sum(@$row);\n    }\n    if ($total_units\
    \ == 0) {\n        return 0;\n    }\n    $lowerings += int($total_units / $capacity);\n\
    \    my $remainder = $total_units % $capacity;\n    my $fill = $capacity;\n  \
    \  while ($remainder > 0) {\n        if ($fill > $remainder) {\n            $fill\
    \ = $remainder;\n        }\n        $remainder -= $fill;\n        $lowerings++;\n\
    \    }\n    return $lowerings;\n}", "    my @levels = map {0} @{$grid->[0]};\n\
    \    for my $row (@$grid) {\n        for my $col (0..@$row-1) {\n            $levels[$col]\
    \ += $row->[$col];\n        }\n    }\n    my $moves = 0;\n    for my $level (@levels)\
    \ {\n        my $remainder = $level % $capacity;\n        $moves += ($level -\
    \ $remainder) / $capacity;\n        $moves += 1 if $remainder;\n    }\n    return\
    \ $moves;\n}", "    my $buckets = 0;\n    for my $row (@$grid) {\n        for\
    \ my $cell (@$row) {\n            $buckets += ($cell == 1) ? 1 : 0;\n        }\n\
    \    }\n    return $buckets;\n}", "    \n    my $max_height = max(map {sum(@$_)}\
    \ @$grid);\n    my $count = 0;\n    for my $height (1 .. $max_height) {\n    \
    \    for my $row (@$grid) {\n            my $cost = 0;\n            my $result\
    \ = first {$row->[$_] && $row->[$_] < $height} 0 .. $#$row;\n            if (defined\
    \ $result) {\n                $cost = $result + 1;\n            } else {\n   \
    \             $cost = $#$row + 1;\n            }\n            $count += $cost;\n\
    \        }\n    }\n    return $count;\n}", "    my $total = 0;\n    my $bucket\
    \ = 0;\n    for my $row (@$grid) {\n        for my $row_index (0 .. $#$row) {\n\
    \            if ($row->[$row_index]) {\n                $bucket++;\n         \
    \       if ($bucket == $capacity) {\n                    $bucket = 0;\n      \
    \              $total++;\n                }\n            }\n        }\n    }\n\
    \    return $total;\n}", "    my @buckets = map { 0 } @$grid;\n    my $num_passes\
    \ = 0;\n    while(1) {\n        my $rows_dropped = 0;\n        my $unfinished_row\
    \ = 0;\n        for my $r (0..@$grid-1) {\n            my $cols_filled = 0;\n\
    \            $unfinished_row = 1;\n            for my $c (0..@{$grid->[$r]}-1)\
    \ {\n                $buckets[$r] += $grid->[$r][$c];\n                if($buckets[$r]\
    \ >= $capacity) {\n                    $buckets[$r] = 0;\n                   \
    \ $cols_filled++;\n                }\n            }\n            $rows_dropped++\
    \ if $cols_filled == @{$grid->[$r]};\n        }\n        last if $rows_dropped\
    \ == @$grid;\n        last if !$unfinished_row;\n        $num_passes++;\n    }\n\
    \    return $num_passes;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
