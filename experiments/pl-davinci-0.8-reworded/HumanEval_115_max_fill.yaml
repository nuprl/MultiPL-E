name: HumanEval_115_max_fill
language: pl
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
  \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n\
  # 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
  # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n  \
  \  my($grid, $capacity) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
  \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
  \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $count = 0;\n    for my $row (@$grid) {\n        my $empty =\
    \ 0;\n        for my $col (@$row) {\n            if ($col == 0) {\n          \
    \      $empty++;\n            } else {\n                $count += $empty;\n  \
    \              $empty = 0;\n            }\n        }\n        $count += $empty\
    \ if $empty > 0;\n    }\n    return $count;\n}", "    my $n = scalar @$grid;\n\
    \    my $m = scalar @{$grid->[0]};\n    my $max = 0;\n    for my $i (0..$n-1)\
    \ {\n        for my $j (0..$m-1) {\n            if ($grid->[$i][$j] == 1) {\n\
    \                $max = max($max, $i);\n            }\n        }\n    }\n    return\
    \ ($max * $capacity);\n}", "    my @grid = map { [split //] } @$grid;\n    my\
    \ @heights = (0) x scalar @{$grid[0]};\n    foreach my $line (@grid) {\n     \
    \   $heights[$_] += $line->[$_] for 0 .. $#$line;\n    }\n    my @max_heights\
    \ = reverse sort { $a <=> $b } @heights;\n    return $capacity * @max_heights;\n\
    }", "    my $count = 0;\n    for my $row (@$grid) {\n        my $i = 0;\n    \
    \    while ($i < @$row && $row->[$i] == 0) {\n            $i++;\n        }\n \
    \       $count += 2*$i if $i < @$row;\n        for my $j ($i .. @$row - 1) {\n\
    \            if ($row->[$j] == 1) {\n                $count++;\n            }\
    \ else {\n                $count++ if $capacity == 1;\n            }\n       \
    \ }\n    }\n    return $count;\n}", "    my $times = 0;\n    my $row_length =\
    \ scalar @{$grid->[0]};\n    for my $row (@$grid) {\n        for my $n (0..$row_length-1)\
    \ {\n            if ($row->[$n] == 1) {\n                $row->[$n] = 0;\n   \
    \             $capacity--;\n                if ($capacity == 0) {\n          \
    \          $times++;\n                    $capacity = $row_length;\n         \
    \       }\n            }\n        }\n    }\n    return $times;\n}", "    my @grid\
    \ = @$grid;\n    my $water = 0;\n    my $wells = scalar @grid;\n    for (my $i\
    \ = 0; $i < $wells; $i++) {\n        $water += $capacity * $grid[$i]->[0];\n \
    \   }\n    return $water;\n}", "    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{ $grid->[0] };\n    my $depth = $capacity;\n    my $count = 0;\n  \
    \  while ($depth > 0) {\n        # Pick a row to empty first\n        my $row\
    \ = 0;\n        my $last = 0;\n        for my $i (0 .. $rows - 1) {\n        \
    \    $row = $i;\n            last if $grid->[$i][0] == 1;\n        }\n       \
    \ # Empty the row\n        for my $i (0 .. $cols - 1) {\n            if ($grid->[$row][$i]\
    \ == 1) {\n                last if $i == $cols - 1;\n                $grid->[$row][$i]\
    \ = 0;\n                $last = $i;\n            }\n        }\n        # Now deal\
    \ with excess\n        if ($last == $cols - 1) {\n            # Nothing to move\n\
    \            $depth--;\n            $count++;\n        }\n        else {\n   \
    \         my $moved = 0;\n            for my $i ($last + 1 .. $cols - 1) {\n \
    \               for my $j (0 .. $rows - 1) {\n                    if ($grid->[$j][$i]\
    \ == 1) {\n                        last if $j == $rows - 1;\n                \
    \        $grid->[$j][$i] = 0;\n                        $grid->[$j + 1][$i] = 1;\n\
    \                        $moved++;\n                    }\n                }\n\
    \            }\n            if ($moved == 0) {\n                $depth--;\n  \
    \              $count++;\n            }\n        }\n    }\n    return $count;\n\
    }\nuse Test::More;\nuse Test::Deep;\nuse Data::Dumper;\nis(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\nis(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2), 5);\nis", "    my $num_of_empties =\
    \ 0;\n    my $num_of_runs = 0;\n    my $is_empty = 0;\n    my $num_of_rows = scalar\
    \ @$grid;\n    my $num_of_cols = scalar @{$grid->[0]};\n    while (!$is_empty)\
    \ {\n        my $row_idx = 0;\n        my $col_idx = 0;\n        my $is_full =\
    \ 0;\n        while (!$is_full) {\n            my $cell = $grid->[$row_idx][$col_idx];\n\
    \            if ($cell == 1) {\n                $num_of_empties += 1;\n      \
    \          $num_of_runs += 1;\n                $grid->[$row_idx][$col_idx] = 0;\n\
    \            }\n            $col_idx += 1;\n            if ($col_idx == $num_of_cols)\
    \ {\n                $col_idx = 0;\n                $row_idx += 1;\n         \
    \   }\n            if ($row_idx == $num_of_rows) {\n                $is_full =\
    \ 1;\n            }\n        }\n        if ($num_of_empties < $capacity) {\n \
    \           $is_empty = 1;\n        }\n        $num_of_empties = 0;\n    }\n \
    \   return $num_of_runs;\n}", "    my $sum = 0;\n    for my $row (@$grid) {\n\
    \        my $fill = 0;\n        for my $well (@$row) {\n            if ($well)\
    \ {\n                $fill = $capacity if $fill < $capacity;\n               \
    \ $fill--;\n            }\n            $sum++ if $fill;\n        }\n    }\n  \
    \  return $sum;\n}", "    my $drop_count = 0;\n    for my $y (0 .. $#$grid) {\n\
    \        my $row = $grid->[$y];\n        for my $x (0 .. $#$row) {\n         \
    \   if ($row->[$x]) {\n                my $filled = $capacity;\n             \
    \   $row->[$x] -= $filled;\n                for my $y2 ($y+1 .. $#$grid) {\n \
    \                   my $row2 = $grid->[$y2];\n                    my $filled2\
    \ = $row2->[$x];\n                    if ($filled2 < $filled) {\n            \
    \            $row2->[$x] = 0;\n                        $filled -= $filled2;\n\
    \                    }\n                    else {\n                        $row2->[$x]\
    \ -= $filled;\n                        $filled = 0;\n                        last;\n\
    \                    }\n                }\n                $drop_count++;\n  \
    \          }\n        }\n    }\n    return $drop_count;\n}\nuse Test::More;\n\
    use Test::LMU;", "    my @visited = ();\n    my @result = ();\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $max_count = $cols * scalar @$grid;\n    my $count\
    \ = 0;\n    while ($count < $max_count) {\n        my @curr_visited = ();\n  \
    \      my @curr_result = ();\n        my @stack = ();\n        while (scalar @visited\
    \ > 0) {\n            my $x = shift @visited;\n            my $y = shift @visited;\n\
    \            my $q = shift @visited;\n            my $t = shift @visited;\n  \
    \          if ($grid->[$x][$y] == 1) {\n                $curr_result[$x][$y] =\
    \ $q;\n                $curr_visited[$x][$y] = $t;\n                push @stack,\
    \ $x, $y, $q, $t;\n            }\n        }\n        while (scalar @stack > 0)\
    \ {\n            my $x = shift @stack;\n            my $y = shift @stack;\n  \
    \          my $q = shift @stack;\n            my $t = shift @stack;\n        \
    \    my $r = $q - $capacity;\n            if ($r > 0) {\n                if ($y\
    \ > 0 && $curr_visited[$x][$y - 1] != $t) {\n                    $curr_result[$x][$y\
    \ - 1] = $r;\n                    $curr_visited[$x][$y - 1] = $t;\n          \
    \          push @stack, $x, $y - 1, $r, $t;\n                }\n             \
    \   if ($y < $cols - 1 && $curr_visited[$x][$y + 1] != $t) {\n               \
    \     $curr_result[$x][$y + 1] = $r;\n                    $curr_visited[$x][$y\
    \ + 1] = $t;\n                    push @stack, $x, $y + 1, $r, $t;\n         \
    \       }\n                if ($x > 0 && $curr_visited[", "    my @grid = @$grid;\n\
    \    my $max = 0;\n    foreach my $line (@grid) {\n        my $filled = 0;\n \
    \       foreach my $char (@$line) {\n            if ($char) {\n              \
    \  $filled++;\n            } else {\n                $filled = 0;\n          \
    \  }\n            if ($filled == $capacity) {\n                $max++;\n     \
    \           $filled = 0;\n            }\n        }\n    }\n    return $max;\n}",
  "    my @wells = @$grid;\n    my $well_count = scalar @wells;\n    my $column_count\
    \ = scalar @{$wells[0]};\n    my $water_count = 0;\n    for my $column (0..$column_count-1)\
    \ {\n        for my $well (0..$well_count-1) {\n            if ($wells[$well][$column]\
    \ == 1) {\n                if ($capacity > $well_count-$well) {\n            \
    \        $water_count += $well_count-$well;\n                    $capacity -=\
    \ $well_count-$well;\n                } else {\n                    $water_count\
    \ += $capacity;\n                    $capacity = 0;\n                }\n     \
    \       }\n        }\n    }\n    return $water_count;\n}", "    my $height = scalar\
    \ @$grid;\n    my $width = scalar @{$grid->[0]};\n    my $total = 0;\n    my $lowest\
    \ = 0;\n    for my $i (0..$height-1) {\n        my $row = $grid->[$i];\n     \
    \   for my $j (0..$width-1) {\n            if ($row->[$j]) {\n               \
    \ my $fill = $capacity - $total;\n                $lowest = $fill if $fill > $lowest;\n\
    \                $total += $fill;\n            }\n            else {\n       \
    \         $total = 0;\n            }\n        }\n        $total = 0;\n    }\n\
    \    $lowest;\n}", "    my $total_units = 0;\n    my $lowerings = 0;\n    for\
    \ my $row (@$grid) {\n        $total_units += sum(@$row);\n    }\n    if ($total_units\
    \ == 0) {\n        return 0;\n    }\n    $lowerings += int($total_units / $capacity);\n\
    \    my $remainder = $total_units % $capacity;\n    my $fill = $capacity;\n  \
    \  while ($remainder > 0) {\n        if ($fill > $remainder) {\n            $fill\
    \ = $remainder;\n        }\n        $remainder -= $fill;\n        $lowerings++;\n\
    \    }\n    return $lowerings;\n}", "    my @levels = map {0} @{$grid->[0]};\n\
    \    for my $row (@$grid) {\n        for my $col (0..@$row-1) {\n            $levels[$col]\
    \ += $row->[$col];\n        }\n    }\n    my $moves = 0;\n    for my $level (@levels)\
    \ {\n        my $remainder = $level % $capacity;\n        $moves += ($level -\
    \ $remainder) / $capacity;\n        $moves += 1 if $remainder;\n    }\n    return\
    \ $moves;\n}", "    my $buckets = 0;\n    for my $row (@$grid) {\n        for\
    \ my $cell (@$row) {\n            $buckets += ($cell == 1) ? 1 : 0;\n        }\n\
    \    }\n    return $buckets;\n}", "    \n    my $max_height = max(map {sum(@$_)}\
    \ @$grid);\n    my $count = 0;\n    for my $height (1 .. $max_height) {\n    \
    \    for my $row (@$grid) {\n            my $cost = 0;\n            my $result\
    \ = first {$row->[$_] && $row->[$_] < $height} 0 .. $#$row;\n            if (defined\
    \ $result) {\n                $cost = $result + 1;\n            } else {\n   \
    \             $cost = $#$row + 1;\n            }\n            $count += $cost;\n\
    \        }\n    }\n    return $count;\n}", "    my $total = 0;\n    my $bucket\
    \ = 0;\n    for my $row (@$grid) {\n        for my $row_index (0 .. $#$row) {\n\
    \            if ($row->[$row_index]) {\n                $bucket++;\n         \
    \       if ($bucket == $capacity) {\n                    $bucket = 0;\n      \
    \              $total++;\n                }\n            }\n        }\n    }\n\
    \    return $total;\n}", "    my @buckets = map { 0 } @$grid;\n    my $num_passes\
    \ = 0;\n    while(1) {\n        my $rows_dropped = 0;\n        my $unfinished_row\
    \ = 0;\n        for my $r (0..@$grid-1) {\n            my $cols_filled = 0;\n\
    \            $unfinished_row = 1;\n            for my $c (0..@{$grid->[$r]}-1)\
    \ {\n                $buckets[$r] += $grid->[$r][$c];\n                if($buckets[$r]\
    \ >= $capacity) {\n                    $buckets[$r] = 0;\n                   \
    \ $cols_filled++;\n                }\n            }\n            $rows_dropped++\
    \ if $cols_filled == @{$grid->[$r]};\n        }\n        last if $rows_dropped\
    \ == @$grid;\n        last if !$unfinished_row;\n        $num_passes++;\n    }\n\
    \    return $num_passes;\n}", "    \n    my $total = 0;\n    for my $y (0 .. $#$grid)\
    \ {\n        my $current = 0;\n        for my $x (0 .. $#{$grid->[$y]}) {\n  \
    \          if ($grid->[$y][$x]) {\n                $current++;\n            }\n\
    \            elsif ($current) {\n                my $fill = $capacity - $current;\n\
    \                $fill = $current if $fill < 0;\n                $total += $fill;\n\
    \                $current = 0;\n            }\n        }\n        my $fill = $capacity\
    \ - $current;\n        $fill = $current if $fill < 0;\n        $total += $fill;\n\
    \    }\n    return $total;\n}", "    my $count = 0;\n    my $n = @$grid;\n   \
    \ my $m = @{$grid->[0]};\n    for my $i (0..$n-1) {\n        my $lowest = max(map\
    \ {$grid->[$i][$_]} 0..$m-1);\n        for my $j (0..$m-1) {\n            my $fill\
    \ = min($lowest, $capacity);\n            $count += $fill;\n            $grid->[$i][$j]\
    \ -= $fill;\n        }\n    }\n    return $count;\n}", "    my $counter = 0;\n\
    \    my $empty = 1;\n    while ($empty) {\n        my $well = _get_well($grid);\n\
    \        last unless $well;\n        _empty_well($grid, $well, $capacity);\n \
    \       $counter++;\n    }\n    return $counter;\n}", "    my $height = scalar\
    \ @$grid;\n    my $length = scalar @{$grid->[0]};\n    my $result = 0;\n    my\
    \ $col = 0;\n    my $summation = 0;\n    my $max = $height*$capacity;\n    for\
    \ my $i (0..$height-1) {\n        for my $j (0..$length-1) {\n            if ($grid->[$i][$j]\
    \ eq 1) {\n                $summation += $capacity;\n            }\n        }\n\
    \    }\n    while($summation > 0) {\n        my $temp = 0;\n        for my $i\
    \ (0..$height-1) {\n            if ($grid->[$i][$col] eq 1) {\n              \
    \  $grid->[$i][$col] = 0;\n                $temp += $capacity;\n            }\n\
    \        }\n        $summation -= $temp;\n        $result++;\n        $col++;\n\
    \    }\n    return $result;\n}\nprint max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1) . \"\\n\";\nprint max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2) . \"\\n\";\nprint max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5) . \"\\n\";", "    my $num_buckets = scalar @$grid;\n    my $num_wells = scalar\
    \ @{$grid->[0]};\n    my $count = 0;\n    for my $well (1..$num_wells) {\n   \
    \     my $water = 0;\n        for my $bucket (1..$num_buckets) {\n           \
    \ $water += $grid->[$bucket - 1][$well - 1];\n        }\n        my $per_bucket\
    \ = int($water / $num_buckets);\n        if ($per_bucket) {\n            $count\
    \ += $per_bucket;\n            for my $bucket (1..$num_buckets) {\n          \
    \      $grid->[$bucket - 1][$well - 1] -= $per_bucket;\n            }\n      \
    \  }\n        my $remainder = $water % $num_buckets;\n        if ($remainder)\
    \ {\n            $count += $remainder;\n            for my $bucket (1..$remainder)\
    \ {\n                $grid->[$bucket - 1][$well - 1]--;\n            }\n     \
    \   }\n    }\n    return $count;\n}", "    # ...\n}", "    my $height = @$grid;\n\
    \    my $wells = scalar @{$grid->[0]};\n    my $fills = 0;\n    for my $well (0..$wells-1)\
    \ {\n        my $fill = $capacity;\n        for my $row (0..$height-1) {\n   \
    \         last if $fill == 0;\n            $fill -= $grid->[$row][$well];\n  \
    \          ++$fills if $fill < 0;\n        }\n    }\n    return $fills;\n}", " \
    \   my $depth = 0;\n    while (1) {\n        my $filled = fill($grid, $capacity);\n\
    \        return $depth if !$filled;\n        $depth += $filled;\n    }\n}", " \
    \   my $wells_count = @$grid;\n    my $depth = @{$grid->[0]};\n    my $table =\
    \ make_table($grid, $wells_count, $depth);\n    # print \"Filling with $capacity:\\\
    n\";\n    # print_table($table);\n    my $total_filled = 0;\n    while (1) {\n\
    \        my $idx = $table->[0]->[0];\n        if ($idx > 0) {\n            $table->[0]->[0]\
    \ = 0;\n            splice @$table, 0, 1;\n            splice @{$table->[0]},\
    \ 0, 1;\n            $total_filled += $idx;\n            # print_table($table);\n\
    \        }\n        else {\n            last;\n        }\n    }\n    return $total_filled;\n\
    }", "    my $row_count = scalar @$grid;\n    my $col_count = scalar @{$grid->[0]};\n\
    \    my $total_filled = 0;\n    # Iterate over wells in columns, in top-down order\n\
    \    for my $col (0 .. $col_count - 1) {\n        # Iterate over wells in each\
    \ column, in left-right order\n        for my $row (0 .. $row_count - 1) {\n \
    \           # Fill the well if we can\n            if ($grid->[$row][$col]) {\n\
    \                $total_filled += $capacity;\n            }\n        }\n    }\n\
    \    return $total_filled;\n}", "    my $n = scalar @$grid;\n    my $m = scalar\
    \ @{$grid->[0]};\n    my $max;\n    for (0..$n-1) {\n        for (0..$m-1) {\n\
    \            $max = $grid->[$_][$_] unless defined $max;\n            $max = $grid->[$_][$_]\
    \ if $grid->[$_][$_] > $max;\n        }\n    }\n    $max = $capacity if $max >\
    \ $capacity;\n    my $total = 0;\n    my $diff = 0;\n    my $sub = 0;\n    my\
    \ $sub_total = 0;\n    for (0..$n-1) {\n        for (0..$m-1) {\n            $total\
    \ += $grid->[$_][$_];\n            if ($grid->[$_][$_] == $max) {\n          \
    \      $sub = $grid->[$_][$_] - $capacity;\n                $sub_total += $sub\
    \ if $sub > 0;\n            }\n        }\n    }\n    $total += $sub_total;\n \
    \   return $total;\n}", "    my $count = 0;\n    my $columns = @{$grid->[0]};\n\
    \    my $total_buckets = $columns * $capacity;\n    foreach my $well ( @$grid\
    \ ) {\n        my $filled = 0;\n        foreach my $drop ( @$well ) {\n      \
    \      $filled += $drop;\n        }\n        my $remaining = $total_buckets -\
    \ $filled;\n        if ( $remaining > 0 ) {\n            $count += $remaining;\n\
    \        }\n    }\n    return $count;\n}", "    my $fill = 0;\n    my $width =\
    \ @{$grid->[0]};\n    my $remaining = 0;\n    for my $row (@$grid) {\n       \
    \ my $capacity_left = $capacity;\n        for my $i (0 .. $width - 1) {\n    \
    \        $capacity_left -= $row->[$i];\n            if ($capacity_left < 0) {\n\
    \                $fill++;\n                $remaining = $capacity_left;\n    \
    \            $capacity_left = $capacity;\n            }\n        }\n        $capacity_left\
    \ += $remaining;\n        $remaining = 0;\n        $fill += ceil($capacity_left\
    \ / $capacity);\n    }\n    return $fill;\n}", "    # TODO\n}", "    my @sums\
    \ = map { sum(@$_) } @$grid;\n    my $i = 0;\n    my $result = 0;\n    for my\
    \ $sum (@sums) {\n        $i++;\n        $result += int($sum / $capacity);\n \
    \       $result += $sum % $capacity if $i < @sums;\n    }\n    return $result;\n\
    }", "    my $buckets = scalar @$grid;\n    my $len = scalar @{$grid->[0]};\n \
    \   my $count = 0;\n    while(1) {\n        my $has_water = 0;\n        for my\
    \ $i (0..$#$grid) {\n            my $barrel = $grid->[$i];\n            for my\
    \ $j (0..$#$barrel) {\n                if ($barrel->[$j]) {\n                \
    \    $barrel->[$j] = 0;\n                    $has_water = 1;\n               \
    \ }\n            }\n        }\n        last unless $has_water;\n        $count++;\n\
    \        for my $j (0..$len-1) {\n            my $water = $capacity;\n       \
    \     for my $i (0..$buckets-1) {\n                my $barrel = $grid->[$i];\n\
    \                if ($water) {\n                    $barrel->[$j] = 1;\n     \
    \               $water--;\n                }\n            }\n        }\n    }\n\
    \    return $count;\n}", "    my $filled = 0;\n    for my $row (@$grid) {\n  \
    \      my $left = 0;\n        my $right = 0;\n        for my $i (0 .. $#$row)\
    \ {\n            my $water = 0;\n            if ($row->[$i]) {\n             \
    \   $left = $i;\n                $right = $i;\n                my $fill = min($capacity,\
    \ $left + 1);\n                $left -= $fill - 1;\n                $water +=\
    \ $fill;\n                $right += $capacity - $fill;\n                $right\
    \ = min($#$row, $right);\n                $fill = min($capacity, $#$row - $right\
    \ + 1);\n                $right += $fill - 1;\n                $water += $fill;\n\
    \                $left -= $capacity - $fill;\n                $left = max(0, $left);\n\
    \                $water += min($capacity, $left + 1);\n            }\n       \
    \     $filled += $water;\n        }\n    }\n    return $filled;\n}", "    my @grid\
    \ = @$grid;\n    my @heights = map { my $h = 0;\n                        $h +=\
    \ !$_ for @$_;\n                        $h\n                    } @grid;\n   \
    \ my $max_height = max(@heights);\n    my $fill_steps = 0;\n    for my $h (1 ..\
    \ $max_height) {\n        $fill_steps++ for @heights;\n        $fill_steps-- if\
    \ $_ > $h and $_ < $h + $capacity for @heights;\n    }\n    return $fill_steps;\n\
    }", "    my $max = 0;\n    my $count = 0;\n    my $column = 0;\n    my $reached\
    \ = 0;\n    my $row = 0;\n    my $valid = 0;\n    my $cols = scalar @{$grid->[0]};\n\
    \    my $rows = scalar @{$grid};\n    while ($row < $rows) {\n        if ($grid->[$row][$column]\
    \ == 1) {\n            $max++;\n            $grid->[$row][$column] = 0;\n    \
    \    }\n        $column++;\n        if ($column >= $cols) {\n            if ($reached\
    \ + $capacity < $max) {\n                $reached = $max;\n                $valid\
    \ = 1;\n            }\n            if ($max < $capacity) {\n                $valid\
    \ = 0;\n            }\n            $count += $valid;\n            $max = 0;\n\
    \            $column = 0;\n            $row++;\n        }\n    }\n    return $count;\n\
    }", "    my @grid = @$grid;\n    my $counter = 0;\n    my $row_counter = 0;\n\
    \    my $bucket = $capacity;\n    for my $row (@grid) {\n        $row_counter\
    \ = 0;\n        while ($row_counter < scalar @$row) {\n            if ($row->[$row_counter]\
    \ == 1) {\n                $bucket--;\n                if ($bucket == 0) {\n \
    \                   $counter++;\n                    $bucket = $capacity;\n  \
    \              }\n            }\n            $row_counter++;\n        }\n    }\n\
    \    return $counter;\n}\n1;", "    # ...\n}", "    my $x = 0;\n    my $y = 0;\n\
    \    my $sum = 0;\n    my $max = 0;\n    my $iter = 1;\n    my $max_rows = scalar\
    \ @$grid;\n    my $max_cols = scalar @{$grid->[0]};\n    while (1) {\n       \
    \ while ($x < $max_rows) {\n            while ($y < $max_cols) {\n           \
    \     $sum += $grid->[$x][$y];\n                $y += $iter;\n            }\n\
    \            $x += $iter;\n            $y = $iter % 2;\n        }\n        $max\
    \ = $sum if $sum > $max;\n        return $max if $max >= $capacity;\n        $x\
    \ = $iter % 2;\n        $y = 0;\n        $sum = 0;\n        $iter++;\n    }\n}",
  "    die \"Not enough arguments\" unless defined $grid and defined $capacity;\n\
    \    die \"First argument must be an array of arrays\" unless ref $grid eq 'ARRAY';\n\
    \    die \"First argument array must contain arrays\" unless ref $grid->[0] eq\
    \ 'ARRAY';\n    die \"First argument arrays must have same length\" unless scalar\
    \ @{$grid->[0]} == scalar @{$grid->[-1]};\n    die \"First argument arrays must\
    \ have length >= 1\" unless scalar @{$grid->[0]} >= 1;\n    die \"First argument\
    \ array must contain scalars\" unless ref $grid->[0][0] eq '';\n    die \"Second\
    \ argument must be a positive number\" unless $capacity > 0;\n    for my $a (@$grid)\
    \ {\n        for my $i (@$a) {\n            die \"First argument arrays must contain\
    \ 1s and 0s\" unless $i == 0 or $i == 1;\n        }\n    }\n    my $row_count\
    \ = scalar @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $fill_count\
    \ = 0;\n    for my $j (0..$col_count-1) {\n        my $water_count = 0;\n    \
    \    for my $i (0..$row_count-1) {\n            $water_count += $grid->[$i][$j];\n\
    \        }\n        $fill_count += $water_count/$capacity;\n        $fill_count++\
    \ if $water_count % $capacity > 0;\n    }\n    return $fill_count;\n}", "    my\
    \ $max_fill = 0;\n    for my $i (0 .. $#{$grid}) {\n        $max_fill = _max($max_fill,\
    \ _max_fill_in_row($grid->[$i], $capacity));\n    }\n    return $max_fill;\n}",
  "    my @grid = @$grid;\n    my $i = 0;\n    my $count = 0;\n    while ($i < scalar\
    \ @grid) {\n        my $j = 0;\n        my $sum = 0;\n        while ($j < scalar\
    \ @{$grid[$i]}) {\n            $sum += $grid[$i][$j];\n            $j++;\n   \
    \     }\n        $count += $sum / $capacity;\n        $i++;\n    }\n    return\
    \ $count;\n}", "    my $n_rows = @$grid;\n    my $n_cols = @{$grid->[0]};\n  \
    \  my $n_fills = 0;\n    for my $i (0..$n_rows-1) {\n        for my $j (0..$n_cols-1)\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $n_fills += $capacity;\n\
    \                $grid->[$i][$j] = 0;\n            }\n        }\n    }\n    return\
    \ $n_fills;\n}", "    die \"Not implemented yet\"\n}", "    my $n_rows = scalar\
    \ @$grid;\n    my $n_cols = scalar @{ $grid->[0] };\n    my $sum = 0;\n    for\
    \ my $row (0..$n_rows-1) {\n        for my $col (0..$n_cols-1) {\n           \
    \ $sum += $grid->[$row][$col];\n        }\n    }\n    return 0 if $sum == 0;\n\
    \    return $sum;\n}", "    ...\n}", "    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my @wells = map { [(0) x $cols] } (0..$rows-1);\n    my $drops = 0;\n   \
    \ for my $row (0..$rows-1) {\n        for my $col (0..$cols-1) {\n           \
    \ next unless $grid->[$row][$col];\n            my $space = $capacity - $wells[$row][$col];\n\
    \            if ($space) {\n                $wells[$row][$col] += $space;\n  \
    \              $drops += $space;\n            }\n            for my $i (1..$capacity)\
    \ {\n                if ($row - $i >= 0) {\n                    $wells[$row -\
    \ $i][$col] += $space;\n                }\n                if ($row + $i < $rows)\
    \ {\n                    $wells[$row + $i][$col] += $space;\n                }\n\
    \            }\n        }\n    }\n    return $drops;\n}", "    return 0 unless\
    \ $capacity;\n    my $wells = @$grid;\n    my $depth = @{$grid->[0]};\n    my\
    \ $sum = 0;\n    foreach my $x (0..$wells-1) {\n        foreach my $y (0..$depth-1)\
    \ {\n            $sum += $grid->[$x][$y];\n        }\n    }\n    return 0 if $sum\
    \ == 0;\n    my $max = $capacity;\n    my $count = 0;\n    while ($max < $sum)\
    \ {\n        $max *= $capacity;\n        $count++;\n    }\n    return $count;\n\
    }", "    my $total_water = 0;\n    my $well_number = 0;\n    while ($well_number\
    \ < @$grid) {\n        my $column_number = 0;\n        while ($column_number <\
    \ @{$grid->[$well_number]}) {\n            if ($grid->[$well_number][$column_number]\
    \ == 1) {\n                $total_water++;\n                $column_number +=\
    \ $capacity;\n            }\n            else {\n                $column_number++;\n\
    \            }\n        }\n        $well_number++;\n    }\n    return $total_water;\n\
    }", "    # ...\n}", "    my $max_water = 0;\n    my $water_left = 0;\n    my $water_sum\
    \ = 0;\n    my $fill_count = 0;\n    my $row_count = scalar @$grid;\n    my $col_count\
    \ = scalar @{$grid->[0]};\n    for my $row (@$grid) {\n        for my $well (@$row)\
    \ {\n            $water_sum += $well;\n        }\n    }\n    # all wells are empty,\
    \ we've reached our goal\n    return 0 if $water_sum == 0;\n    # if all wells\
    \ are full, we can fill once and reach our goal\n    if ($water_sum == $row_count\
    \ * $col_count) {\n        return $row_count * $col_count / $capacity;\n    }\n\
    \    $water_left = $water_sum;\n    while ($water_left > 0) {\n        my $water_in_col\
    \ = 0;\n        for my $col (0..$col_count-1) {\n            my $water_in_bucket\
    \ = 0;\n            for my $row (0..$row_count-1) {\n                if ($grid->[$row][$col]\
    \ == 1) {\n                    $water_in_bucket += 1;\n                    $grid->[$row][$col]\
    \ = 0;\n                    $water_left -= 1;\n                }\n           \
    \ }\n            if ($water_in_bucket > $capacity) {\n                $water_in_col\
    \ += $capacity;\n            } else {\n                $water_in_col += $water_in_bucket;\n\
    \            }\n        }\n        if ($water_in_col > $capacity) {\n        \
    \    $max_water += $capacity;\n        } else {\n            $max_water += $water_in_col;\n\
    \        }\n        $fill_count += 1;\n    }\n    return $fill_count;\n}", " \
    \   # your code here\n}", "    my $max_level = 0;\n    my $additions = 0;\n  \
    \  foreach my $arr (@$grid) {\n        $max_level = max($max_level, _max_fill($arr,\
    \ $capacity, $additions));\n    }\n    return $max_level;\n}", "    my $count\
    \ = 0;\n    # Fill the first bucket, then do a loop over each column and fill/drain\
    \ buckets\n    # as necessary.\n    my $bucket_one = $capacity;\n    $count +=\
    \ $capacity - $grid->[0][0];\n    $bucket_one -= $grid->[0][0];\n    for my $col\
    \ (1 .. @{$grid->[0]} - 1) {\n        if ($bucket_one > 0) {\n            $count\
    \ += $bucket_one - $grid->[0][$col];\n            $bucket_one -= $grid->[0][$col];\n\
    \        }\n        else {\n            $count += $capacity - $grid->[0][$col];\n\
    \            $bucket_one = $capacity - $grid->[0][$col];\n        }\n    }\n \
    \   # Now do it for row 1, but don't care about the first well\n    my $bucket_two\
    \ = $capacity;\n    $count += $capacity - $grid->[1][1];\n    $bucket_two -= $grid->[1][1];\n\
    \    for my $col (2 .. @{$grid->[0]} - 1) {\n        if ($bucket_two > 0) {\n\
    \            $count += $bucket_two - $grid->[1][$col];\n            $bucket_two\
    \ -= $grid->[1][$col];\n        }\n        else {\n            $count += $capacity\
    \ - $grid->[1][$col];\n            $bucket_two = $capacity - $grid->[1][$col];\n\
    \        }\n    }\n    # Now do it for the rest of the rows, but don't care about\
    \ the first or second\n    # wells\n    for my $row (2 .. @$grid - 1) {\n    \
    \    my $bucket_curr = $capacity;\n        $count += $capacity - $grid->[$row][2];\n\
    \        $bucket_curr -= $grid->[$row][2];\n        for my $col (3 .. @{$grid->[0]}\
    \ - 1) {\n            if ($bucket_curr > 0) {\n                $count += $buck",
  "    \n    my $max_fill = 0;\n    for my $row (@$grid) {\n        my $n = 0;\n \
    \       for my $i (0 .. $#$row) {\n            if ($row->[$i]) {\n           \
    \     $row->[$i] = 0;\n                $n++;\n            } else {\n         \
    \       if ($n) {\n                    $max_fill += $n/$capacity + ($n%$capacity\
    \ ? 1 : 0);\n                    $n = 0;\n                }\n            }\n \
    \       }\n        if ($n) {\n            $max_fill += $n/$capacity + ($n%$capacity\
    \ ? 1 : 0);\n        }\n    }\n    return $max_fill;\n}", "    my @buckets = (0)\
    \ x @{$grid->[0]};\n    my $count = 0;\n    while (1) {\n        $count++;\n \
    \       my $level = List::Util::min(@buckets);\n        if (++$level >= $capacity)\
    \ {\n            return $count;\n        }\n        @buckets = map { max($level,\
    \ $_) } @$_ for @$grid;\n    }\n}", "    return 0 unless @$grid;\n    my @grid\
    \ = map [@$_], @$grid;\n    my $n = @{$grid[0]};\n    my $m = @grid;\n    my $ans\
    \ = 0;\n    for my $i (0..$n-1) {\n        my $level = 0;\n        for my $j (0..$m-1)\
    \ {\n            $level += $grid[$j][$i];\n        }\n        $ans += ($level\
    \ + $capacity - 1) / $capacity;\n    }\n    return $ans;\n}", "    \n    my $i\
    \ = 0;\n    my $j = 0;\n    my $moves = 0;\n    my $w = scalar @$grid;\n    my\
    \ $h = scalar @{ $grid->[0] };\n    my $bucket = $capacity;\n    while($i < $w)\
    \ {\n        my $best_column = undef;\n        my $best_amount = 0;\n        my\
    \ $x = $i;\n        while($x < $w) {\n            $bucket -= $grid->[$x][$j];\n\
    \            if($bucket > 0) {\n                my $amount = $capacity - $bucket;\n\
    \                if($amount > $best_amount) {\n                    $best_amount\
    \ = $amount;\n                    $best_column = $j;\n                }\n    \
    \        }\n            $x++;\n        }\n        if(defined $best_column) {\n\
    \            $i += $best_amount;\n            $j = $best_column;\n           \
    \ $bucket = $capacity;\n            $moves++;\n        } else {\n            $j++;\n\
    \            $i = 0;\n            $bucket = $capacity;\n        }\n    }\n   \
    \ return $moves;\n}", "    my @grid = @$grid;\n    my $actions = 0;\n    my $done\
    \ = 1;\n    my $empty = 0;\n    my $partial = 0;\n    my $full = 0;\n    my $max_fill\
    \ = 0;\n    my $current_fill = 0;\n    for my $i (0 .. $#grid) {\n        for\
    \ my $j (0 .. $#{$grid[$i]}) {\n            my $cell = $grid[$i][$j];\n      \
    \      if ($cell == 1) {\n                $current_fill++;\n            }\n  \
    \          if ($current_fill == $capacity) {\n                $actions++;\n  \
    \              $current_fill = 0;\n            }\n        }\n        $current_fill\
    \ = 0;\n    }\n    return $actions;\n}", "    my $count = 0;\n    my $n = @$grid;\n\
    \    for my $i (0..$n-1) {\n        for my $j (0..@{$grid->[$i]}-1) {\n      \
    \      next if $grid->[$i][$j] == 0;\n            $count += 2;\n            $grid->[$i][$j]\
    \ = 0;\n            for my $m (0..$capacity-1) {\n                for my $n (0..$capacity-1)\
    \ {\n                    last if $i-$m < 0;\n                    last if $j-$n\
    \ < 0;\n                    $grid->[$i-$m][$j-$n] = 0;\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}", "    my $count = 0;\n\
    \    my $i = 0;\n    my $j = 0;\n    my $x = $capacity;\n    while ($i < @$grid)\
    \ {\n        while ($j < @{$grid->[$i]}) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $x--;\n                if ($x == 0) {\n              \
    \      $x = $capacity;\n                    $count++;\n                }\n   \
    \         }\n            $j++;\n        }\n        $i++;\n        $j = 0;\n  \
    \  }\n    return $count;\n}", "    my $row_len = scalar @{$grid->[0]};\n    my\
    \ $col_len = scalar @$grid;\n    my $depth = 0;\n    my $cells = 0;\n    for my\
    \ $col (0..$col_len-1) {\n        for my $row (0..$row_len-1) {\n            my\
    \ $cell = $grid->[$col][$row];\n            $depth += $cell;\n            $cells\
    \ += $cell;\n        }\n    }\n    my $buckets = int($cells / $capacity);\n  \
    \  return $buckets + $depth;\n}", "    my $n_passes = 0;\n    my $wells_total\
    \ = @$grid;\n    my $wells_filled = 0;\n    while ($wells_filled < $wells_total)\
    \ {\n        $n_passes++;\n        for my $i (0 .. $wells_total - 1) {\n     \
    \       my $well = $grid->[$i];\n            if (sum(@$well) > 0) {\n        \
    \        # Remove water from the well.\n                $wells_filled++;\n   \
    \             my $well_total = @$well;\n                for my $j (0 .. $well_total\
    \ - 1) {\n                    my $bucket = $well->[$j];\n                    if\
    \ ($bucket == 1) {\n                        $well->[$j] = 0;\n               \
    \         $capacity--;\n                        last if $capacity == 0;\n    \
    \                }\n                }\n            }\n        }\n        $capacity\
    \ = $capacity == 0 ? 1 : $capacity;\n    }\n    return $n_passes;\n}", "    ...\n\
    }\n```", "    my $fill_count = 0;\n    for my $row (@$grid) {\n        for my\
    \ $well (@$row) {\n            next if $well == 0;\n            $fill_count++;\n\
    \            $well -= $capacity;\n            $well = 0 if $well < 0;\n      \
    \  }\n    }\n    return $fill_count;\n}", "    my @buckets = (0) x @{$grid->[0]};\n\
    \    my $sum = 0;\n    for my $row (@$grid) {\n        for my $i (0..$#$row) {\n\
    \            $sum += $row->[$i];\n            $buckets[$i] = $capacity if $row->[$i];\n\
    \        }\n    }\n    return $sum + fill_buckets(\\@buckets, $capacity);\n}",
  "    my @grid = @$grid;\n    my $size = scalar @grid;\n    my $ind = $size - 1;\n\
    \    my $num_buckets = 0;\n    while ($ind >= 0) {\n        my $row = $grid[$ind];\n\
    \        my $max_fill = max_fill_row($row, $capacity);\n        if ($max_fill\
    \ == 0) {\n            $ind -= 1;\n        } else {\n            $num_buckets\
    \ += 1;\n            $ind -= $max_fill;\n        }\n    }\n    return $num_buckets;\n\
    }", "    my $n = 0;\n    my $max = 0;\n    my $r = scalar @$grid;\n    my $c =\
    \ scalar @{$grid->[0]};\n    my $empty = 1;\n    foreach my $i (0..$r-1) {\n \
    \       foreach my $j (0..$c-1) {\n            if ($grid->[$i][$j] == 1) {\n \
    \               $empty = 0;\n                $n += $capacity;\n              \
    \  $max = max($max, $capacity);\n            } else {\n                $n = 0;\n\
    \            }\n        }\n        $n = 0;\n    }\n    return $empty ? 0 : $max;\n\
    }", "    my $fill = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0\
    \ .. $#{$grid->[$i]}) {\n            next if $grid->[$i][$j] == 0;\n         \
    \   $fill += $capacity - $grid->[$i][$j];\n        }\n    }\n    return $fill;\n\
    }", "    my $moves = 0;\n    my $depth = 0;\n    while (1) {\n        my $min_depth\
    \ = 100;\n        my $max_depth = 0;\n        my $moved = 0;\n        for (my\
    \ $i = 0; $i < @$grid; $i++) {\n            for (my $j = 0; $j < @{ $grid->[$i]\
    \ }; $j++) {\n                if ($grid->[$i][$j] == 0) {\n                  \
    \  $min_depth = min($min_depth, $i);\n                    $max_depth = max($max_depth,\
    \ $i);\n                    next;\n                }\n                $grid->[$i][$j]\
    \ = 0;\n                $moved = 1;\n            }\n        }\n        last if\
    \ !$moved;\n        $depth = $min_depth;\n        $moves += (2 * $capacity) +\
    \ ($max_depth - $min_depth);\n    }\n    return $moves;\n}", "    return 0 if\
    \ $capacity == 0;\n    my $count = 0;\n    my $full = 0;\n    my $max = 0;\n \
    \   my $row_len = scalar @{$grid->[0]};\n    for my $row (@$grid) {\n        for\
    \ my $i (0..$row_len-1) {\n            my $cell = $row->[$i];\n            if($cell\
    \ == 1) {\n                $max = $i if $i > $max;\n                $full += $capacity;\n\
    \            }\n        }\n        my $lower = $full;\n        $full = 0;\n  \
    \      $count += $lower;\n        $full += $lower - $max;\n        $max = 0;\n\
    \    }\n    return $count;\n}", "    my $result = 0;\n    foreach my $row (@$grid)\
    \ {\n        my $units = 0;\n        foreach my $col (@$row) {\n            $units\
    \ += $col;\n        }\n        $result += int($units / $capacity);\n        $result\
    \ += ($units % $capacity > 0) ? 1 : 0;\n    }\n    return $result;\n}", "    my\
    \ $total_water = 0;\n    my $counter = 0;\n    foreach my $line (@$grid) {\n \
    \       my $water = 0;\n        foreach my $well (@$line) {\n            if ($well\
    \ == 1) {\n                $water++;\n            }\n            else {\n    \
    \            $total_water += $water;\n                $water = 0;\n          \
    \  }\n        }\n        $total_water += $water;\n        if ($total_water >=\
    \ $capacity) {\n            $counter++;\n            $total_water = 0;\n     \
    \   }\n    }\n    return $counter;\n}", "    my $l = 0;\n    my $r = $capacity\
    \ * scalar @$grid;\n    while ($l + 1 < $r) {\n        my $m = int(($l + $r) /\
    \ 2);\n        if (sum($grid, $m) == 0) {\n            $l = $m;\n        } else\
    \ {\n            $r = $m;\n        }\n    }\n    $l;\n}", "    my $max = $capacity;\n\
    \    my $rows = scalar @$grid;\n    my $cols = scalar @{$grid->[0]};\n    # I'm\
    \ going to assume that the wells are to be filled in\n    # reverse order, so\
    \ that the last ones filled won't overflow\n    # when filling earlier ones. This\
    \ is not a requirement, but\n    # if it is a constraint I would like to know.\n\
    \    #\n    # First, fill all the wells to the max:\n    for my $row (@$grid)\
    \ {\n        for my $i (0 .. $cols - 1) {\n            if ($row->[$i]) {\n   \
    \             $row->[$i] = $max;\n            }\n        }\n    }\n    # now distribute\
    \ the water:\n    my $next_row = $rows - 1;\n    while ($next_row > 0) {\n   \
    \     # find a 1 in the next row:\n        my $cur_row = $next_row;\n        while\
    \ ($cur_row > 0 && !$grid->[$cur_row]->[0]) {\n            $cur_row--;\n     \
    \   }\n        # iterate over the columns:\n        for my $col (0 .. $cols -\
    \ 1) {\n            my $cur_well = $grid->[$cur_row]->[$col];\n            if\
    \ ($cur_well) {\n                # check if the well to the left needs more water:\n\
    \                if ($col > 0) {\n                    my $left_well = $grid->[$cur_row\
    \ - 1]->[$col - 1];\n                    if ($left_well < $cur_well) {\n     \
    \                   my $new_water = $cur_well - $left_well;\n                \
    \        $grid->[$cur_row - 1]->[$col - 1] += $new_water;\n                  \
    \      $grid->[$cur_row]->[$col] -= $new_water;\n                    }\n     \
    \           }\n                # check if the well to the right needs more water:\n\
    \                if ($col < $cols - 1) {\n                    my $right_well =\
    \ $grid->[$cur_row - 1]->[$col + 1];\n", "    \n    my $row = scalar @$grid;\n\
    \    my $col = scalar @{$grid->[0]};\n    return 0 if ($row == 0 || $col == 0);\n\
    \    \n    my $max_water = 0;\n    my $water_counter = 0;\n    for my $r (0..$row-1)\
    \ {\n        for my $c (0..$col-1) {\n            if ($grid->[$r][$c] == 1) {\n\
    \                $water_counter++;\n            } else {\n                $max_water\
    \ = max($max_water, $water_counter);\n                $water_counter = 0;\n  \
    \          }\n        }\n        $max_water = max($max_water, $water_counter);\n\
    \        $water_counter = 0;\n    }\n    \n    # print \"max water: $max_water\\\
    n\";\n    return max(0, ceil($max_water/$capacity) - 1);\n}", "    my @grid =\
    \ @$grid;\n    my $n = @grid;\n    my $m = @{$grid[0]};\n    my $result = 0;\n\
    \    my $max = 0;\n    my $current_capacity = $capacity;\n    for (my $i = 0;\
    \ $i < $n; $i++) {\n        for (my $j = 0; $j < $m; $j++) {\n            $max\
    \ = max($max, $grid[$i][$j]);\n        }\n    }\n    my $k = 1;\n    while ($k\
    \ <= $max) {\n        $current_capacity = $capacity;\n        for (my $i = 0;\
    \ $i < $n; $i++) {\n            for (my $j = 0; $j < $m; $j++) {\n           \
    \     if ($current_capacity >= $k) {\n                    $current_capacity -=\
    \ $k;\n                    $grid[$i][$j] -= $k;\n                }\n         \
    \   }\n        }\n        $result += $capacity - $current_capacity;\n        $k++;\n\
    \    }\n    return $result;\n}", "    \n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $current_level = 0;\n        for my $unit (@$row) {\n        \
    \    if ($unit) {\n                if ($current_level < $capacity) {\n       \
    \             $current_level += $capacity - $current_level;\n                \
    \    $count++;\n                }\n            } else {\n                $current_level--;\n\
    \            }\n        }\n    }\n    return $count;\n}", "    my $num_rows =\
    \ scalar @$grid;\n    my $max_num_fillings = 0;\n    my $num_fillings;\n    my\
    \ $i;\n    my $j;\n    my $is_filled;\n    my $next_row;\n    my $next_col;\n\
    \    my $r;\n    my $c;\n    my $fill_next;\n    my $num_cols = scalar @{$grid->[0]};\n\
    \    # states:\n    # 0 - not filled\n    # 1 - filled\n    # 2 - filled and filled\
    \ below\n    my $well_state = [ map { [ map { 0 } 0 .. $num_cols - 1 ] } 0 ..\
    \ $num_rows - 1 ];\n    for $i (0 .. $num_rows - 1) {\n        for $j (0 .. $num_cols\
    \ - 1) {\n            $well_state->[$i][$j] = 2 if $grid->[$i][$j] == 1;\n   \
    \     }\n    }\n    for $i (0 .. $num_rows - 1) {\n        for $j (0 .. $num_cols\
    \ - 1) {\n            if ($well_state->[$i][$j] == 0) {\n                $num_fillings\
    \ = 0;\n                $is_filled = 1;\n                while ($is_filled ==\
    \ 1) {\n                    $is_filled = 0;\n                    $num_fillings++;\n\
    \                    for $r (0 .. $num_rows - 1) {\n                        for\
    \ $c (0 .. $num_cols - 1) {\n                            $fill_next = 0;\n   \
    \                         if ($well_state->[$r][$c] == 1) {\n                \
    \                $next_row = $r + 1;\n                                $next_col\
    \ = $c;\n                                $fill_next = 1 if $next_row <= $num_rows\
    \ - 1;\n                                if ($fill_next == 1) {\n             \
    \                       $well_state->[$next_row][$next_col] = 1;\n           \
    \                         $is_filled = 1;\n                                }\n\
    \                                $next_row = $r - 1", "    my $n = @$grid;\n \
    \   my $m = @{$grid->[0]};\n    # fill the row with 0s starting from the lowest\
    \ point\n    my $w_j = 0;\n    my $w_i = 0;\n    # @water is 0 if the well is\
    \ empty, 1 if it's filled up\n    my @water = map {[(0) x $m]} (0..$n-1);\n  \
    \  for my $i (0..$n-1) {\n        for my $j (0..$m-1) {\n            if ($grid->[$i][$j]\
    \ == 1) {\n                $water[$i][$j] = 1;\n                ($w_i, $w_j) =\
    \ ($i, $j);\n            }\n        }\n    }\n    my $num_fills = 0;\n    # now,\
    \ walk along the rows from top to bottom, filling buckets\n    for my $i ($w_i+1..$n-1)\
    \ {\n        my $j = 0;\n        while ($j < $m) {\n            if ($water[$i][$j]\
    \ == 1) {\n                $num_fills++;\n                $j++;\n            }\
    \ else {\n                # fill\n                my $bucket = $capacity;\n  \
    \              my $fills = $bucket;\n                while ($bucket > 0 && $j\
    \ < $m) {\n                    if ($water[$i][$j] == 1) {\n                  \
    \      $j++;\n                        $bucket = $capacity;\n                 \
    \       $fills = $bucket;\n                    } else {\n                    \
    \    $bucket--;\n                        $fills--;\n                        $water[$i][$j]\
    \ = 1;\n                        $j++;\n                    }\n               \
    \ }\n                $num_fills += $fills;\n            }\n        }\n    }\n\
    \    return $num_fills;\n}", "    my $steps = 0;\n    foreach my $column (0 ..\
    \ @{$grid->[0]} - 1) {\n        foreach my $row (0 .. @$grid - 1) {\n        \
    \    next if $grid->[$row][$column] == 0;\n            my $fill = $capacity;\n\
    \            foreach my $i ($row .. @$grid - 1) {\n                if ($grid->[$i][$column]\
    \ == 1) {\n                    $grid->[$i][$column] = 0;\n                   \
    \ $fill--;\n                }\n                last if $fill == 0;\n         \
    \   }\n            $steps++;\n        }\n    }\n    return $steps;\n}", "    return\
    \ 0 if($capacity == 0);\n    my $curr_max = 0;\n    my $curr_level = 0;\n    for\
    \ my $i(0..$#{$grid}) {\n        for my $j(0..$#{$grid->[$i]}) {\n           \
    \ if($grid->[$i][$j] == 1) {\n                $curr_max = $i if($i > $curr_max);\n\
    \            }\n        }\n    }\n    if($curr_max > $curr_level) {\n        $curr_level\
    \ = $curr_max;\n        for my $i(0..$#{$grid}) {\n            for my $j(0..$#{$grid->[$i]})\
    \ {\n                if($grid->[$i][$j] == 1) {\n                    $grid->[$i][$j]\
    \ = 0;\n                }\n            }\n        }\n    }\n    return $curr_level\
    \ + max_fill($grid, $capacity - 1);\n}", "    \n    # your code goes here\n}",
  "    my $count = 0;\n    my $rows = scalar @$grid;\n    my $cols = scalar @{ $grid->[0]\
    \ };\n    #print \"max_fill: rows=$rows, cols=$cols\\n\";\n    my @fill = ([]);\n\
    \    for my $r (0..$rows-1) {\n        my $top = 0;\n        my $row = $grid->[$r];\n\
    \        my $dif = $capacity - $top;\n        for my $c (0..$cols-1) {\n     \
    \       if ($row->[$c] == 1) {\n                $top = $capacity;\n          \
    \  } else {\n                $top = $top - 1;\n                if ($top < 0) {\n\
    \                    $top = 0;\n                }\n            }\n           \
    \ $dif = $capacity - $top;\n            $fill[$r]->[$c] = $dif;\n            $count\
    \ += $dif;\n        }\n    }\n    #print \"fill=\".Dumper(\\@fill);\n    return\
    \ $count;\n}", "    my $total = 0;\n    my $times = 0;\n    my $i = 0;\n    while\
    \ ($i < @$grid) {\n        $times++ if $total < $capacity;\n        $total +=\
    \ $grid->[$i++];\n        $total -= $capacity if $total > $capacity;\n    }\n\
    \    return $times;\n}", "    # ...\n}", "    my @water_level;\n    for my $i\
    \ (0 .. $#{$grid}) {\n        push @water_level, [map {0} (0 .. $#{$grid->[$i]})]\n\
    \    }\n    my $fill = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j\
    \ (0 .. $#{$grid->[$i]}) {\n            if ($grid->[$i][$j] == 1) {\n        \
    \        $water_level[$i][$j] = 1;\n                $fill++;\n            }\n\
    \        }\n    }\n    while (1) {\n        my $last_level = $fill;\n        for\
    \ my $i (0 .. $#{$grid}) {\n            for my $j (0 .. $#{$grid->[$i]}) {\n \
    \               if ($water_level[$i][$j] == $capacity) {\n                   \
    \ my $new_capacity = $capacity - 1;\n                    if ($i > 0 && $water_level[$i\
    \ - 1][$j] < $new_capacity) {\n                        $water_level[$i - 1][$j]\
    \ = $new_capacity;\n                        $fill++;\n                    }\n\
    \                    if ($i < $#{$grid} && $water_level[$i + 1][$j] < $new_capacity)\
    \ {\n                        $water_level[$i + 1][$j] = $new_capacity;\n     \
    \                   $fill++;\n                    }\n                    if ($j\
    \ > 0 && $water_level[$i][$j - 1] < $new_capacity) {\n                       \
    \ $water_level[$i][$j - 1] = $new_capacity;\n                        $fill++;\n\
    \                    }\n                    if ($j < $#{$grid->[$i]} && $water_level[$i][$j\
    \ + 1] < $new_capacity) {\n                        $water_level[$i][$j + 1] =\
    \ $new_capacity;\n                        $fill++;\n                    }\n  \
    \              }\n            }\n        }\n        if ($last_level == $fill)\
    \ {\n            last;\n        }\n    }\n    return $fill;", "    my $count =\
    \ 0;\n    my $n_full_wells = grep { $_ == $capacity } @$_ for @$grid;\n    # extract\
    \ water for wells that have been full to begin with\n    $count += $capacity for\
    \ @$grid;\n    for my $row (@$grid) {\n        for (my $i = 0; $i < @$row; $i++)\
    \ {\n            next if $row->[$i] != 0;\n            # since the element is\
    \ zero, we want to increment it\n            # but also check if we can decrement\
    \ the previous element\n            # since that's where we take the water from\n\
    \            $row->[$i]++;\n            if ($i > 0 && $row->[$i - 1] > 0) {\n\
    \                $row->[$i - 1]--;\n            } else {\n                $count++;\n\
    \            }\n        }\n    }\n    return $count;\n}", "    my $result = 0;\n\
    \    my $fill_time = 0;\n    my $empty_time = 0;\n    my $row_count = scalar @$grid;\n\
    \    my $well_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        my $fill_time = max_fill_time($grid->[$row], $capacity);\n      \
    \  my $empty_time = max_empty_time($grid->[$row], $capacity);\n        $result\
    \ += $fill_time + $empty_time;\n    }\n    return $result;\n}", "    my $bottles\
    \ = 0;\n    foreach my $well (@$grid) {\n        $bottles += scalar(grep { $capacity\
    \ - $_ } @$well);\n    }\n    return $bottles;\n}", "    my @grid = map {[split\
    \ //, $_]} @$grid;\n    my $N = @grid;\n    my $M = @{$grid[0]};\n    my $min\
    \ = min($capacity, $N, $M);\n    my @max_row = map {max(@$_)} @grid;\n    my @max_col\
    \ = map {\n        my $max = $grid[0][$_];\n        for my $i (1..$N-1) {\n  \
    \          $max = max($max, $grid[$i][$_]);\n        }\n        $max;\n    } 0..$M-1;\n\
    \    my $move = 0;\n    for my $i (0..$N-1) {\n        for my $j (0..$M-1) {\n\
    \            my $min_fill = min($max_row[$i], $max_col[$j]);\n            my $fill\
    \ = $grid[$i][$j];\n            if ($fill < $min_fill) {\n                $move\
    \ += $min_fill - $fill;\n                $grid[$i][$j] = $min_fill;\n        \
    \    }\n        }\n    }\n    return $move;\n}", "    # TODO: place your code\
    \ here\n}", "    my $rows = scalar @$grid;\n    my $cols = scalar @{$grid->[0]};\n\
    \    my $fill_count = 0;\n    while(1) {\n        my($water_to_fill, $filled_grid)\
    \ = max_fill_helper($grid, $capacity);\n        last if ($water_to_fill == 0);\n\
    \        $fill_count += $water_to_fill;\n        $grid = $filled_grid;\n    }\n\
    \    return $fill_count;\n}", "    my $total = 0;\n    foreach my $row (@$grid)\
    \ {\n        my $left = 0;\n        my $right = 0;\n        for my $i (0 .. @$row\
    \ - 1) {\n            if ($row->[$i] == 1) {\n                $left = $i;\n  \
    \              last;\n            }\n        }\n        for my $i (reverse(0 ..\
    \ @$row - 1)) {\n            if ($row->[$i] == 1) {\n                $right =\
    \ $i;\n                last;\n            }\n        }\n        my $fill = $right\
    \ - $left + 1;\n        $total += int($fill / $capacity);\n        $total += $fill\
    \ % $capacity;\n    }\n    return $total;\n}", "    my @grid = @$grid;\n    my\
    \ $count = 0;\n    for my $i (0 .. $#grid) {\n        my $row = $grid[$i];\n \
    \       for my $j (0 .. $#$row) {\n            $count += 1 if $row->[$j];\n  \
    \      }\n    }\n    return $count;\n}", "    my $sum = 0;\n    for my $row (@$grid)\
    \ {\n        my $r = 0;\n        my $n = 0;\n        for my $col (@$row) {\n \
    \           if ($col) {\n                $n++;\n            } else {\n       \
    \         $r += $n;\n                $n = 0;\n            }\n        }\n     \
    \   $r += $n;\n        $sum += $r > $capacity ? $capacity : $r;\n    }\n    return\
    \ $sum;\n}", "    my $len = scalar @$grid;\n    my $width = scalar @{$grid->[0]};\n\
    \    my $total = 0;\n    my $fill = $capacity;\n    for my $i (0..$len-1) {\n\
    \        $fill = $capacity;\n        for my $j (0..$width-1) {\n            if\
    \ ($grid->[$i][$j] == 1) {\n                $fill--;\n                if ($fill\
    \ < 0) {\n                    $total++;\n                    $fill = $capacity\
    \ - 1;\n                }\n            }\n        }\n    }\n    return $total;\n\
    }", "    my $passes = 0;\n    my $max = 0;\n    my $max_row = 0;\n    my $max_column\
    \ = 0;\n    for (my $i = 0; $i < scalar @$grid; $i++) {\n        for (my $j =\
    \ 0; $j < scalar @{$grid->[$i]}; $j++) {\n            if ($grid->[$i][$j] > $max)\
    \ {\n                $max = $grid->[$i][$j];\n                $max_row = $i;\n\
    \                $max_column = $j;\n            }\n        }\n    }\n    my $max_depth\
    \ = 0;\n    for (my $i = 0; $i < scalar @$grid; $i++) {\n        $max_depth +=\
    \ $grid->[$i][$max_column];\n    }\n    $passes = int($max_depth / $capacity);\n\
    \    if ($max_depth % $capacity > 0) {\n        $passes++;\n    }\n    return\
    \ $passes;\n}", '    $capacity = int($capacity);', "    my $n = scalar @$grid;\n\
    \    my $m = scalar @{$grid->[0]};\n    my $buckets = $capacity * $m;\n    my\
    \ $total = 0;\n    for my $i (0..$n-1) {\n        for my $j (0..$m-1) {\n    \
    \        $total += $grid->[$i][$j];\n        }\n    }\n    my $extractions = 0;\n\
    \    while ($buckets >= $m) {\n        $buckets -= $m;\n        $extractions++;\n\
    \    }\n    my $remainder = $buckets;\n    while ($remainder > 0) {\n        my\
    \ $row = 0;\n        my $col = 0;\n        my $max = 0;\n        for my $i (0..$n-1)\
    \ {\n            for my $j (0..$m-1) {\n                if ($max < $grid->[$i][$j])\
    \ {\n                    $max = $grid->[$i][$j];\n                    $row = $i;\n\
    \                    $col = $j;\n                }\n            }\n        }\n\
    \        my $taken = $grid->[$row][$col];\n        $remainder -= $taken;\n   \
    \     $extractions++;\n        for my $i (0..$n-1) {\n            for my $j (0..$m-1)\
    \ {\n                if ($grid->[$i][$j] > 0) {\n                    $grid->[$i][$j]\
    \ -= $taken;\n                }\n            }\n        }\n    }\n    return $extractions;\n\
    }\n1;", "    my $n_rows = @$grid;\n    my $n_cols = @{$grid->[0]};\n    my $n_fill\
    \ = 0;\n    for my $i (0..$n_rows-1) {\n        my $n_ones = 0;\n        for my\
    \ $j (0..$n_cols-1) {\n            $n_ones += $grid->[$i][$j];\n        }\n  \
    \      $n_fill += $n_ones > $capacity ? $capacity : $n_ones;\n    }\n    return\
    \ $n_fill;\n}", "    # ...\n}", "    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        for my $idx (0 .. $#$row) {\n            my $col = $row->[$idx];\n\
    \            if($col == 1) {\n                $count++;\n                $row->[$idx]\
    \ = 0;\n                # fill up next row if possible\n                if($idx\
    \ < $#$row && $row->[$idx+1] == 1) {\n                    $row->[$idx+1] = 0;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}", " \
    \   my $sum = 0;\n    my $h = @$grid;\n    my $w = @{$grid->[0]};\n    my $min_line\
    \ = [];\n    my $min_line_index = 0;\n    for my $i (0..$h-1) {\n        for my\
    \ $j (0..$w-1) {\n            $min_line->[$j] = 0 if $min_line->[$j] < $grid->[$i][$j];\n\
    \            $min_line->[$j] = $grid->[$i][$j] if $min_line->[$j] == 0;\n    \
    \    }\n        for my $j (0..$w-1) {\n            $sum += $min_line->[$j] - $grid->[$i][$j];\n\
    \        }\n    }\n    return $sum\n}", "    my $count = 0;\n    my $max_height\
    \ = 0;\n    my $height;\n    my $rows = scalar @$grid;\n    my $cols = scalar\
    \ @{$grid->[0]};\n    while ($rows) {\n        $height = 0;\n        my $col =\
    \ 0;\n        while ($col < $cols) {\n            $height++ if $grid->[$rows -\
    \ 1][$col++];\n        }\n        $rows--;\n        if ($height > $max_height)\
    \ {\n            $max_height = $height;\n            $count += $height;\n    \
    \    }\n    }\n    return $count - $capacity;\n}", "    my $count = 0;\n    my\
    \ $current_position = 0;\n    while($current_position <= $#{$grid->[0]}) {\n \
    \       $count += sum_next_column($grid, $current_position, $capacity);\n    \
    \    $current_position += $capacity;\n    }\n    return $count;\n}", "    die\
    \ \"Not yet implemented\";\n}", "    my $total_units = 0;\n    my $actions = 0;\n\
    \    my $bucket = 0;\n    for my $row (@$grid) {\n        for my $unit (@$row)\
    \ {\n            if ($unit) {\n                $total_units++;\n            }\n\
    \        }\n    }\n    while ($bucket < $total_units) {\n        for my $row (@$grid)\
    \ {\n            for my $unit (@$row) {\n                if ($unit) {\n      \
    \              $bucket++;\n                    $unit = 0;\n                  \
    \  $actions++;\n                    if ($bucket == $total_units) {\n         \
    \               return $actions;\n                    }\n                }\n \
    \           }\n        }\n    }\n    return $actions;\n}\nsay max_fill([[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1);\nsay max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2);\nsay max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5);", "    return 0 if not $grid;\n    my @grid = @$grid;\n    return 0 if not\
    \ @grid;\n    my $height = scalar @grid;\n    my $width = scalar @{$grid[0]};\n\
    \    my $total = 0;\n    for my $i (0..$height-1) {\n        for my $j (0..$width-1)\
    \ {\n            next if $grid[$i][$j] == 0;\n            $total += 1;\n     \
    \       if ($capacity > 1) {\n                for my $k (1..$capacity-1) {\n \
    \                   if ($j+$k < $width and $grid[$i][$j+$k] == 1) {\n        \
    \                $total += 1;\n                        $grid[$i][$j+$k] = 0;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return $total;\n}", "    my $total_water = sum(@$_) for @$grid;\n    return\
    \ 0 if $total_water == 0;\n    my $fill_count = 0;\n    while ($total_water >\
    \ 0) {\n        my $filled = 0;\n        for my $row (@$grid) {\n            my\
    \ $row_water = sum(@$row);\n            $filled += $row_water if $row_water >\
    \ 0;\n            for my $i (0 .. $#$row) {\n                $row->[$i] = 0 if\
    \ $row->[$i] > 0;\n            }\n        }\n        $total_water -= $filled;\n\
    \        $fill_count++;\n    }\n    return $fill_count;\n}\nsay max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1); # 6\nsay max_fill([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2); # 5\nsay max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5); # 0", "    my $row_n = scalar @$grid;\n    my $col_n = scalar\
    \ @{$grid->[0]};\n    my $counter = 0;\n    for my $r (0..$row_n-1) {\n      \
    \  my $row = $grid->[$r];\n        my $s = sum(@$row);\n        if ($s > 0) {\n\
    \            my $new_s = 0;\n            for my $c (0..$col_n-1) {\n         \
    \       $new_s += $row->[$c];\n                if ($new_s >= $capacity) {\n  \
    \                  $counter += 2;\n                    $new_s = 0;\n         \
    \       } else {\n                    $counter += 1;\n                }\n    \
    \        }\n        }\n    }\n    return $counter;\n}", "    ...\n}", "    my\
    \ $size = scalar @$grid;\n    my $depth = scalar @{$grid->[0]};\n    my $water\
    \ = 0;\n    for my $idx (0..$size-1) {\n        for my $jdx (0..$depth-1) {\n\
    \            $water += $grid->[$idx][$jdx];\n        }\n    }\n    my $volume\
    \ = $water * $capacity;\n    my $tot_height = $size + $depth - 1;\n    my $remainder\
    \ = $volume % $tot_height;\n    my $divisor = $volume / $tot_height;\n    my $buckets\
    \ = $divisor;\n    $buckets++ if $remainder;\n    return $buckets;\n}", "    my\
    \ $max_depth = max(map { max @$_ } @$grid);\n    return 0 if $max_depth == 0;\n\
    \    my $max_units = 0;\n    my $max_wells = 0;\n    my $wells_for_depth = sub\
    \ {\n        my($depth) = @_;\n        my $wells = 0;\n        for my $row (@$grid)\
    \ {\n            $wells += grep { $row->[$_] >= $depth } 0 .. $#$row;\n      \
    \  }\n        return $wells;\n    };\n    for my $i (1 .. $max_depth) {\n    \
    \    my $units = $i * $wells_for_depth->($i);\n        if ($units > $max_units)\
    \ {\n            $max_units = $units;\n            $max_wells = $wells_for_depth->($i);\n\
    \        }\n    }\n    $max_units = min $max_units, $capacity * $max_wells;\n\
    \    return $max_units;\n}", "    my $count = 0;\n    my $level = 0;\n    my $expansion\
    \ = sub {\n        for my $i (0 .. $#$grid) {\n            for my $j (0 .. $#{$grid->[$i]})\
    \ {\n                if($grid->[$i][$j] == 1 && $i >= $level) {\n            \
    \        $grid->[$i][$j] = 0;\n                    $count++;\n               \
    \ }\n            }\n        }\n        $level++;\n    };\n    $expansion->();\n\
    \    while(1) {\n        my $pos = 0;\n        for my $i (0 .. $#$grid) {\n  \
    \          $pos++ if any { $_ == 1 } @{$grid->[$i]};\n        }\n        last\
    \ if $pos == 0;\n        $expansion->();\n    }\n    return $count;\n}", "   \
    \ my $n = 0;\n    my $row_sum = 0;\n    for my $i (0 .. $#{$grid}) {\n       \
    \ my $sum = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n            $sum +=\
    \ $grid->[$i][$j];\n        }\n        if ($sum > $row_sum) {\n            $row_sum\
    \ = $sum;\n        }\n    }\n    $n += $row_sum;\n    $n *= $capacity;\n    return\
    \ $n;\n}", "    my $num_rows = scalar @$grid;\n    my $num_columns = scalar @{$grid->[0]};\n\
    \    my $i = 0;\n    my $j = 0;\n    my $operations = 0;\n    while ($i < $num_rows)\
    \ {\n        while ($j < $num_columns) {\n            if ($grid->[$i][$j] == 1)\
    \ {\n                $grid->[$i][$j] = 0;\n                my $k = $i + 1;\n \
    \               while ($k < $num_rows && $capacity > 0) {\n                  \
    \  if ($grid->[$k][$j] == 1) {\n                        $grid->[$k][$j] = 0;\n\
    \                        $capacity--;\n                    }\n               \
    \     $k++;\n                }\n                $operations++;\n            }\n\
    \            $j++;\n        }\n        $i++;\n        $j = 0;\n    }\n    return\
    \ $operations;\n}", "    return 0 if $capacity == 0;\n    my $row = @$grid;\n\
    \    my $col = @{$grid->[0]};\n    my $ans = 0;\n    for my $i (0..$row-1) {\n\
    \        for my $j (0..$col-1) {\n            if ($grid->[$i][$j] == 1) {\n  \
    \              $ans += $capacity;\n                $grid->[$i][$j] = 0;\n    \
    \            while ($i < $row and $grid->[$i][$j] < $capacity) {\n           \
    \         $grid->[$i][$j]++;\n                    $i++;\n                }\n \
    \               $i--;\n            }\n        }\n    }\n    $ans;\n}", "    my\
    \ $water = 0;\n    for my $row (@$grid) {\n        my $row_water = 0;\n      \
    \  my $empty = 0;\n        for my $cell (@$row) {\n            if ($cell == 1)\
    \ {\n                $row_water += $capacity;\n                $empty = 0;\n \
    \           } else {\n                $empty++;\n            }\n            if\
    \ ($empty == $capacity) {\n                $water += $row_water;\n           \
    \     $row_water = 0;\n                $empty = 0;\n            }\n        }\n\
    \        $water += $row_water;\n    }\n    return $water;\n}", "    my $n_buckets\
    \ = 0;\n    foreach my $row (@$grid) {\n        my $index = -1;\n        my $max\
    \ = 0;\n        my $i = 0;\n        my $row_size = scalar @$row;\n        foreach\
    \ my $well (@$row) {\n            if ($well == 1) {\n                $max++;\n\
    \            } else {\n                $max = 0;\n            }\n            if\
    \ ($max == $capacity) {\n                $index = $i - $capacity + 1;\n      \
    \      }\n            $i++;\n        }\n        if ($index > -1) {\n         \
    \   my $i = $index;\n            while ($i < $row_size && $row->[$i] == 1) {\n\
    \                $row->[$i] = 0;\n                $i++;\n            }\n     \
    \       $n_buckets++;\n        }\n    }\n    return $n_buckets;\n}", "    my $n_rows\
    \ = scalar @$grid;\n    my $n_columns = scalar @{$grid->[0]};\n    my $n_wells\
    \ = $n_rows * $n_columns;\n    my $n_buckets = 0;\n    for my $row (0..$n_rows-1)\
    \ {\n        for my $column (0..$n_columns-1) {\n            $n_buckets += max_fill_submatrix($grid,\
    \ $row, $column, $capacity);\n        }\n    }\n    return $n_buckets;\n}", " \
    \   my $r_len = scalar @$grid;\n    my $c_len = scalar @{$grid->[0]};\n    my\
    \ $res = 0;\n    my $max = 0;\n    my $well = 0;\n    for my $row (0..$r_len-1)\
    \ {\n        for my $col (0..$c_len-1) {\n            if($grid->[$row][$col] ==\
    \ 1) {\n                $well += 1;\n            }\n        }\n        $max =\
    \ $well if $well > $max;\n        $well = 0;\n    }\n    $res = $max / $capacity;\n\
    \    $res = int($res) if $res == int($res);\n    return $res;\n}", "    my $count\
    \ = 0;\n    for my $r (0 .. $#{$grid}) {\n        for my $c (0 .. $#{$grid->[$r]})\
    \ {\n            if ($grid->[$r][$c]) {\n                my $fill = $capacity;\n\
    \                for my $rr ($r .. $#{$grid}) {\n                    for my $cc\
    \ ($c .. $#{$grid->[$rr]}) {\n                        if ($grid->[$rr][$cc]) {\n\
    \                            $fill-- if $fill > 0;\n                         \
    \   $grid->[$rr][$cc] = 0;\n                        }\n                    }\n\
    \                }\n                $count += $capacity - $fill;\n           \
    \ }\n        }\n    }\n    return $count;\n}", "    my $len = length($grid->[0]);\n\
    \    my $cnt = 0;\n    my $last = 0;\n    for my $i (0..$len-1) {\n        my\
    \ $total = 0;\n        for my $row (@$grid) {\n            $total += $row->[$i];\n\
    \        }\n        if ($total <= $capacity) {\n            $cnt += $total;\n\
    \            $last = $total;\n        } else {\n            $cnt += $capacity;\n\
    \            $last = $capacity;\n        }\n    }\n    return $cnt - $last;\n\
    }\n1;", "    my $total = 0;\n    foreach my $line (@$grid) {\n        $total +=\
    \ max_fill_line($line, $capacity);\n    }\n    return $total;\n}", "    my $count\
    \ = 0;\n    for my $row (@$grid) {\n        $count += max_fill_row($row, $capacity);\n\
    \    }\n    return $count;\n}", "    my @grid = @$grid;\n    my $fill_count =\
    \ 0;\n    for my $i (0 .. $#grid) {\n        my $bucket = $capacity;\n       \
    \ for my $j (0 .. $#{$grid[$i]}) {\n            $bucket -= $grid[$i][$j];\n  \
    \          $fill_count += $bucket;\n        }\n    }\n    return $fill_count;\n\
    }", "    my $times = 0;\n    my $next_bucket = $capacity;\n    while (1) {\n \
    \       my $level = 0;\n        my $empty = 1;\n        my $level = 0;\n     \
    \   my $next_bucket = $capacity;\n        while ($level <= $capacity) {\n    \
    \        my $next_empty = 1;\n            foreach my $row (@$grid) {\n       \
    \         foreach my $well (@$row) {\n                    if ($well == 1) {\n\
    \                        $next_empty = 0;\n                        last;\n   \
    \                 }\n                }\n            }\n            if ($next_empty)\
    \ {\n                return $times;\n            }\n            foreach my $row\
    \ (@$grid) {\n                foreach my $well (@$row) {\n                   \
    \ if ($well == 1) {\n                        $well = 0;\n                    \
    \    $next_bucket -= 1;\n                        $empty = 0;\n               \
    \     }\n                }\n            }\n            $times += 1;\n        \
    \    $level += 1;\n        }\n    }\n}", "    my @rows = split /\\s/, $grid;\n\
    \    my $row_count = scalar @rows;\n    my $col_count = length $rows[0];\n   \
    \ my $total_units = 0;\n    my $column_offset = 0;\n    my $units_per_column =\
    \ 0;\n    my $current_column = 0;\n    my $operations = 0;\n    my $filled_columns\
    \ = 0;\n    while ($total_units < $row_count * $col_count) {\n        my $units_to_fill\
    \ = $capacity;\n        $current_column = $column_offset % $col_count;\n     \
    \   $units_per_column = 0;\n        for (my $i = 0; $i < $row_count; $i++) {\n\
    \            if (substr($rows[$i], $current_column, 1) == 1) {\n             \
    \   $units_per_column++;\n            }\n        }\n        # print \"current\
    \ column: $current_column, units_per_column: $units_per_column\\n\";\n       \
    \ while ($units_to_fill > 0) {\n            if ($units_per_column > $units_to_fill)\
    \ {\n                $units_per_column -= $units_to_fill;\n                $units_to_fill\
    \ = 0;\n            } else {\n                $units_to_fill -= $units_per_column;\n\
    \                $units_per_column = 0;\n            }\n            $operations++;\n\
    \        }\n        $total_units += $capacity;\n        $column_offset++;\n  \
    \  }\n    return $operations;\n}", "    my $n_rows = scalar @$grid;\n    my $n_cols\
    \ = scalar @{$grid->[0]};\n    my $fill_count = 0;\n    for my $row (@$grid) {\n\
    \        my $bucket = $capacity;\n        for my $well (@$row) {\n           \
    \ if ($well) {\n                if ($bucket > 0) {\n                    $bucket--;\n\
    \                } else {\n                    $bucket = $capacity;\n        \
    \            $fill_count++;\n                }\n            }\n        }\n   \
    \ }\n    return $fill_count;\n}", "    my $depth = 0;\n    my $row = 0;\n    my\
    \ $column = 0;\n    for (0..$#{$grid}) {\n        my $r = $grid->[$_];\n     \
    \   for (0..$#{$r}) {\n            if ($r->[$_] == 1) {\n                $depth\
    \ += $capacity;\n            }\n        }\n    }\n    return $depth;\n}", "  \
    \  my $n = 0;\n    foreach my $row (@$grid) {\n        my $count = 0;\n      \
    \  foreach my $well (@$row) {\n            $count++ if $well;\n        }\n   \
    \     $n += int($count / $capacity) + ($count % $capacity != 0);\n    }\n    return\
    \ $n;\n}", "    my $height = @$grid;\n    my $width = @{$grid->[0]};\n    my $count\
    \ = 0;\n    my $i = 0;\n    my $j = 0;\n    # a water level where any positive\
    \ water is non-zero\n    my $water_level = 0;\n    my $is_water_level_ok;\n  \
    \  do {\n        $is_water_level_ok = 0;\n        for my $i (0 .. $height - 1)\
    \ {\n            for my $j (0 .. $width - 1) {\n                # check if the\
    \ water exceeds the capacity\n                if ($grid->[$i][$j] > $capacity)\
    \ {\n                    # get the max possible water of the current cell\n  \
    \                  $grid->[$i][$j] = $capacity;\n                    $is_water_level_ok\
    \ = 1;\n                }\n                # check if the water is higher than\
    \ the water level\n                if ($grid->[$i][$j] > $water_level) {\n   \
    \                 $is_water_level_ok = 1;\n                }\n            }\n\
    \        }\n        # water level gets higher\n        $water_level++;\n     \
    \   # if the water level is ok, count the number of water we got\n        if ($is_water_level_ok)\
    \ {\n            $count++;\n        }\n    } while ($is_water_level_ok);\n   \
    \ return $count;\n}", "    my $result = 0;\n    my $no_water = 0;\n    foreach\
    \ my $row (@$grid) {\n        if (1 == scalar(grep { $_ } @$row)) {\n        \
    \    $result += $capacity;\n        }\n        else {\n            $no_water =\
    \ 1;\n        }\n    }\n    if ($no_water) {\n        $result += $capacity;\n\
    \    }\n    return $result;\n}", "    my $r = $#{$grid};\n    my $c = $#{$grid->[0]};\n\
    \    my $max_fill = 0;\n    for my $i (0..$r) {\n        for my $j (0..$c) {\n\
    \            $max_fill++ if $grid->[$i][$j];\n        }\n    }\n    return 0 if\
    \ $max_fill < $capacity;\n    my $count = 0;\n    for my $i (0..$r) {\n      \
    \  for my $j (0..$c) {\n            $count++ if $grid->[$i][$j];\n        }\n\
    \    }\n    return $count / $capacity;\n}", "    my $fill_count = 0;\n    foreach\
    \ my $row (@$grid) {\n        my $filled = 0;\n        foreach my $cell (@$row)\
    \ {\n            if ($cell == 1) {\n                $filled++;\n            }\n\
    \            else {\n                $fill_count += $filled;\n               \
    \ $filled = 0;\n            }\n        }\n        $fill_count += $filled;\n  \
    \  }\n    return $fill_count * $capacity;\n}", '    my @grid = map [ split //
    ], @$grid;', "    # Fill in the details\n}", "    my $count = 0;\n    for my $row\
    \ (@$grid) {\n        my $sum = 0;\n        for my $column (@$row) {\n       \
    \     $sum += $column;\n        }\n        if ($sum > $capacity) {\n         \
    \   $count += $sum - $capacity;\n        }\n    }\n    return $count;\n}", " \
    \   my $iterations = 0;\n    foreach my $row (@$grid) {\n        # find the number\
    \ of all wells filled and \n        # number of all wells empty\n        my $current_fill\
    \ = 0;\n        my $empty_wells = 0;\n        foreach my $cell (@$row) {\n   \
    \         $current_fill += $cell;\n            $empty_wells += 1 - $cell;\n  \
    \      }\n        # we need to empty this row\n        if ($current_fill) {\n\
    \            # we need to move the bucket $empty_wells times\n            $iterations\
    \ += $empty_wells;\n            # we need to fill the wells\n            # at\
    \ most $capacity times\n            $iterations += $capacity if $current_fill\
    \ < $capacity;\n        }\n    }\n    return $iterations;\n}", "    my $fill_cnt\
    \ = 0;\n    my $iterations = 0;\n    while ( $iterations < 10_000 ) {\n      \
    \  $iterations++;\n        # bail early if no wells have water in them\n     \
    \   my $has_water = 0;\n        for my $row ( @$grid ) {\n            for my $well\
    \ ( @$row ) {\n                if ( $well == 1 ) {\n                    $has_water\
    \ = 1;\n                    last;\n                }\n            }\n        }\n\
    \        last unless $has_water;\n        # count the number of filled wells\n\
    \        my $cnt = 0;\n        for my $row ( @$grid ) {\n            for my $well\
    \ ( @$row ) {\n                $cnt++ if $well == 1;\n            }\n        }\n\
    \        # fill buckets\n        $fill_cnt += int($cnt / $capacity);\n       \
    \ # empty wells\n        for my $row ( @$grid ) {\n            for my $col ( 0\
    \ .. @$row - 1 ) {\n                if ( $row->[$col] == 1 ) {\n             \
    \       $row->[$col] = 0;\n                }\n            }\n        }\n    }\n\
    \    return $fill_cnt;\n}", "    my $total = 0;\n    foreach my $row (@$grid)\
    \ {\n        my $row_total = 0;\n        foreach my $well (@$row) {\n        \
    \    $row_total += $well;\n        }\n        $total += ceil($row_total / $capacity);\n\
    \    }\n    return $total;\n}\nuse Test::More;\nuse Test::Deep;\nis(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\nis(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2), 5);\nis(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5), 0);\ndone_testing();", "    my $num_rows = scalar @$grid;\n    my\
    \ $num_cols = scalar @{$grid->[0]};\n    my $num_empty = 0;\n    my $total_water\
    \ = 0;\n    my $j = 0;\n    my $row = $grid->[$j];\n    my $i = $num_cols - 1;\n\
    \    # start from the first row and move up\n    while ($i >= 0 && $j < $num_rows)\
    \ {\n        my $row = $grid->[$j];\n        # move left until the first \"1\"\
    \n        while ($i >= 0 && $row->[$i] == 0) {\n            $i--;\n        }\n\
    \        # move up until the first \"0\"\n        $j++;\n        while ($j < $num_rows\
    \ && $grid->[$j][$i] == 1) {\n            $total_water++;\n            $j++;\n\
    \        }\n        # fill the row, up to the bucket's capacity\n        if ($num_empty\
    \ + $total_water > $capacity) {\n            $num_empty = 0;\n        }\n    \
    \    $num_empty += $total_water;\n        $total_water = 0;\n    }\n    return\
    \ $num_empty;\n}", "    my $count = 0;\n    my $row_len = @{$grid->[0]};\n   \
    \ foreach my $row (@$grid) {\n        my $max_in_row = max(@$row);\n        my\
    \ $to_add = $capacity * $row_len - $max_in_row;\n        $count += $to_add;\n\
    \    }\n    return $count;\n}", "    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my $count = 0;\n    for my $r (0..$rows-1) {\n        my $row = $grid->[$r];\n\
    \        my $missing = grep { !$_ } @$row;\n        if ($missing <= $capacity)\
    \ {\n            $count += $missing;\n            next;\n        }\n        my\
    \ $col_count = 0;\n        for my $c (0..$cols-1) {\n            $col_count++\
    \ if $row->[$c];\n        }\n        if ($col_count > $capacity) {\n         \
    \   $count += $capacity;\n        } else {\n            $count += $col_count;\n\
    \        }\n    }\n    return $count;\n}", "    return 0 unless defined $grid\
    \ && defined $capacity;\n    my $num_rows = scalar @$grid;\n    my $num_cols =\
    \ scalar @{$grid->[0]};\n    my $num_wells = $num_rows * $num_cols;\n    my $num_times\
    \ = 0;\n    my $max_count = $num_rows * $capacity;\n    my $count = 0;\n    while\
    \ ($count < $max_count) {\n        my $temp_count = 0;\n        for my $row (0..$num_rows-1)\
    \ {\n            for my $col (0..$num_cols-1) {\n                next unless $grid->[$row][$col];\n\
    \                $grid->[$row][$col]--;\n                $temp_count++;\n    \
    \        }\n        }\n        $count += $temp_count;\n        $num_times++;\n\
    \    }\n    return $num_times;\n}\nmy $grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]];\nok(max_fill($grid, 1) == 6);\n$grid = [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]];\nok(max_fill($grid, 2) == 5);\n$grid = [[0, 0,\
    \ 0], [0, 0, 0]];\nok(max_fill($grid, 5) == 0);", "    \n    my $times = 0;\n\
    \    my $i;\n    for $i (0 .. @$grid - 1) {\n        my $row = $grid->[$i];\n\
    \        my $j;\n        for $j (0 .. @$row - 1) {\n            if ($row->[$j]\
    \ == 1) {\n                $row->[$j] = 0;\n                $times++;\n      \
    \      }\n        }\n        if ($i == @$grid - 1) {\n            last;\n    \
    \    }\n        $row = $grid->[$i + 1];\n        for $j (0 .. @$row - 1) {\n \
    \           if ($row->[$j] == 1) {\n                $row->[$j] = 0;\n        \
    \        $times++;\n            }\n        }\n    }\n    return $times;\n}", " \
    \   # TODO\n}\n```", "    my $depth = 0;\n    my $nrows = @$grid;\n    my $ncols\
    \ = @{$grid->[0]};\n    my $max_depth = 0;\n    for my $row (@$grid) {\n     \
    \   $max_depth += max(@$row);\n    }\n    return 0 if $max_depth == 0;\n    my\
    \ $first_row = $grid->[0];\n    for my $idx (0..$ncols-1) {\n        if ($first_row->[$idx]\
    \ == 1) {\n            $depth += $capacity;\n            splice @$first_row, $idx,\
    \ 1;\n            last;\n        }\n    }\n    my $col = 0;\n    while ($depth\
    \ > 0 && $col < $ncols) {\n        my $max_fill = -1;\n        my $max_row = -1;\n\
    \        for my $row (1..$nrows-1) {\n            if ($grid->[$row][$col] == 1)\
    \ {\n                my $fill = min($capacity, $depth);\n                if ($fill\
    \ > $max_fill) {\n                    $max_fill = $fill;\n                   \
    \ $max_row = $row;\n                }\n            }\n        }\n        if ($max_row\
    \ != -1) {\n            $depth -= $max_fill;\n            $grid->[$max_row][$col]\
    \ = 0;\n        }\n        $col++;\n    }\n    return $max_depth;\n}", "    my\
    \ $num_buckets = 0;\n    my $num_rows = @$grid;\n    my $num_cols = @{$grid->[0]};\n\
    \    my @grid_ranges = map {[0, $num_cols - 1]} (0 .. $num_rows - 1);\n    while\
    \ (1) {\n        my $did_fill = 0;\n        for my $r (@grid_ranges) {\n     \
    \       my($l, $r) = @$r;\n            if ($l <= $r) {\n                my $min_r\
    \ = $r;\n                for my $i ($l .. $r) {\n                    if ($grid->[$i][$l]\
    \ == 1) {\n                        $min_r = $i;\n                        last;\n\
    \                    }\n                }\n                my $max_l = $l;\n \
    \               for my $i ($r .. $l, -1) {\n                    if ($grid->[$i][$r]\
    \ == 1) {\n                        $max_l = $i;\n                        last;\n\
    \                    }\n                }\n                for my $i ($min_r ..\
    \ $max_l) {\n                    for my $j ($l .. $r) {\n                    \
    \    $grid->[$i][$j] = 0;\n                    }\n                }\n        \
    \        $num_buckets += ($r - $l + 1) * $capacity;\n                $did_fill\
    \ = 1;\n                $r[0] = $max_l + 1;\n                $r[1] = $min_r -\
    \ 1;\n            }\n        }\n        last unless $did_fill;\n    }\n    return\
    \ $num_buckets;\n}", "    my $water_filled = 0;\n    my $bucket_fill = $capacity\
    \ * scalar @$grid;\n    for my $row (@$grid) {\n        $water_filled += max($row);\n\
    \    }\n    return $water_filled - $bucket_fill;\n}", "    # your code goes here\n\
    }", "    my $well_count = scalar @$grid;\n    my $depth = scalar @{$grid->[0]};\n\
    \    my $row_count = max_row_count($grid, $depth);\n    $capacity * $row_count\
    \ + $well_count;\n}", "    my @grid = @$grid;\n    my @heights = map {\n     \
    \   my $row = $_;\n        my $height = 0;\n        $height += $row->[$_] ? 1\
    \ : 0 for 0 .. $#$row;\n        $height;\n    } @grid;\n    my $fill_count = 0;\n\
    \    my $max_height = max(@heights);\n    for my $height (0 .. $max_height) {\n\
    \        my $total_fill = 0;\n        for my $i (0 .. $#heights) {\n         \
    \   $total_fill += $capacity if $heights[$i] >= $height;\n        }\n        $fill_count++\
    \ if $total_fill > 0;\n    }\n    return $fill_count;\n}", "    my $num_buckets\
    \ = @$grid;\n    my $well_length = @{$grid->[0]};\n    my $num_times = 0;\n  \
    \  for my $row (@$grid) {\n        for my $i (0 .. $well_length - 1) {\n     \
    \       if ($row->[$i] == 1) {\n                $num_times++;\n              \
    \  $row->[$i] = 0;\n                # Fill up all buckets\n                for\
    \ my $j (0 .. $num_buckets - 1) {\n                    if ($grid->[$j][$i] ==\
    \ 0) {\n                        $grid->[$j][$i] = 1;\n                       \
    \ last;\n                    }\n                }\n            }\n        }\n\
    \    }\n    $num_times;\n}", "    my $time = 0;\n    my $row = 0;\n    my $col\
    \ = 0;\n    my $max = scalar @$grid;\n    while ($row < $max) {\n        $col\
    \ = 0;\n        my $max_col = scalar @{$grid->[$row]};\n        while ($col <\
    \ $max_col) {\n            if ($grid->[$row][$col] == 1) {\n                $grid->[$row][$col]\
    \ = 0;\n                $time++;\n                $col = $col + $capacity;\n \
    \           }\n            $col++;\n        }\n        $row++;\n    }\n    return\
    \ $time;\n}", "    my $wells = scalar @$grid;\n    my $length = scalar @{$grid->[0]};\n\
    \    my $max_depth = 0;\n    for my $i (0..$wells-1) {\n        for my $j (0..$length-1)\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                if ($i == 0) {\n\
    \                    $max_depth++;\n                }\n                else {\n\
    \                    if ($grid->[$i-1][$j] == 0) {\n                        $max_depth++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   $max_depth = $max_depth * $capacity;\n    return $max_depth;\n}", "    \n\
    \    my $max_water = 0;\n    my $fill_times = 0;\n    for my $row (@$grid) {\n\
    \        my $water = 0;\n        for my $unit (@$row) {\n            if ($unit)\
    \ {\n                $water++;\n            } else {\n                if ($water)\
    \ {\n                    $fill_times += $water / $capacity;\n                \
    \    $max_water = $water if $water > $max_water;\n                    $water =\
    \ 0;\n                }\n            }\n        }\n        if ($water) {\n   \
    \         $fill_times += $water / $capacity;\n            $max_water = $water\
    \ if $water > $max_water;\n        }\n    }\n    return $max_water;\n}", "   \
    \ my $counter = 0;\n    my @empty_rows = grep {my $sum = sum(@$_); $sum == 0}\
    \ @$grid;\n    my @full_rows = grep {my $sum = sum(@$_); $sum == @$_} @$grid;\n\
    \    my @part_filled_rows = grep {my $sum = sum(@$_); $sum > 0 && $sum < @$_}\
    \ @$grid;\n    foreach my $row (@empty_rows) {\n        $counter += 1;\n    }\n\
    \    my $partial_row_count = scalar @part_filled_rows;\n    my $full_row_count\
    \ = scalar @full_rows;\n    $counter += $partial_row_count + $full_row_count *\
    \ ($capacity - 1);\n    return $counter;\n}", "    my $remaining = $capacity;\n\
    \    my $count = 0;\n    while(1) {\n        my $max = 0;\n        my $max_i =\
    \ -1;\n        my $max_j = -1;\n        for(my $i = 0; $i < scalar(@$grid); $i++)\
    \ {\n            for(my $j = 0; $j < scalar(@{$grid->[$i]}); $j++) {\n       \
    \         if($grid->[$i][$j] > $max) {\n                    $max = $grid->[$i][$j];\n\
    \                    $max_i = $i;\n                    $max_j = $j;\n        \
    \        }\n            }\n        }\n        if($max == 0) {\n            last;\n\
    \        }\n        if($max <= $remaining) {\n            $remaining -= $max;\n\
    \            $grid->[$max_i][$max_j] = 0;\n        } else {\n            $grid->[$max_i][$max_j]\
    \ -= $remaining;\n            $remaining = $capacity;\n            $count++;\n\
    \        }\n    }\n    return $count;\n}", "    my $N = scalar @$grid;\n    my\
    \ $M = scalar @{$grid->[0]};\n    my $max_height = 0;\n    for my $i (0..$N-1)\
    \ {\n        for my $j (0..$M-1) {\n            if ($grid->[$i][$j]) {\n     \
    \           $max_height = max($max_height, $i);\n            }\n        }\n  \
    \  }\n    return $max_height * $capacity;\n}", "    my $lowered = 0;\n    foreach\
    \ my $x (0 .. $#$grid) {\n        $lowered += _fill($grid->[$x], $capacity);\n\
    \    }\n    return $lowered;\n}", "    use constant MAX_ROW_SIZE => (1 << 0x10);\n\
    \    if (@$grid > MAX_ROW_SIZE) {\n        die \"grid is too big\";\n    }\n \
    \   my $stime = time;\n    my $result = 0;\n    my $row_count = @$grid;\n    my\
    \ $column_count = @{$grid->[0]};\n    foreach my $row_index (0 .. $row_count -\
    \ 1) {\n        my $row = $grid->[$row_index];\n        my $column_index = 0;\n\
    \        my $water_count = 0;\n        my $fill_count = 0;\n        foreach my\
    \ $column (@$row) {\n            if ($column) {\n                $water_count++;\n\
    \            }\n            if ($water_count == $capacity) {\n               \
    \ $water_count = 0;\n                $fill_count++;\n            }\n         \
    \   $column_index++;\n        }\n        $result += $fill_count;\n    }\n    $result;\n\
    }", "    my $fillets = 0;\n    my $drain = 0;\n    my $max = 0;\n    my $total\
    \ = 0;\n    my $dropped = 0;\n    foreach my $row (@$grid) {\n        my $wells\
    \ = join('', @$row);\n        $total += $wells =~ s/1/1/g;\n        $max = $wells\
    \ =~ s/1/1/g if $wells =~ s/1/1/g > $max;\n    }\n    $drain = $max - $capacity\
    \ if $max > $capacity;\n    $drain = 0 if $max <= $capacity;\n    $dropped = $total\
    \ - $capacity if $total > $capacity;\n    $dropped = 0 if $total <= $capacity;\n\
    \    $fillets = $drain + $dropped;\n    return $fillets;\n}", "    my $n_rows\
    \ = @$grid;\n    my $n_cols = $grid->[0]->@*;\n    my $n_visited = 0;\n    my\
    \ $n_filled = 0;\n    my $n_steps = 0;\n    my $curr_row = 0;\n    my $curr_col\
    \ = 0;\n    my $max_visited = $n_rows * $n_cols;\n    # start with all the buckets\
    \ empty\n    # each bucket represents an increment in the amount of water extracted\n\
    \    my @buckets = map { 0 } (0 .. $capacity - 1);\n    while ($n_visited < $max_visited)\
    \ {\n        # if the current well is full\n        if ($grid->[$curr_row]->[$curr_col]\
    \ == 1) {\n            # fill a bucket as much as possible\n            my $bucket_idx\
    \ = $n_filled % $capacity;\n            my $bucket = $buckets[$bucket_idx];\n\
    \            $buckets[$bucket_idx] = max($bucket, $capacity);\n            $n_filled++;\n\
    \        }\n        # if the current well is empty\n        else {\n         \
    \   # see if it can be filled from one of the buckets\n            my $bucket_idx\
    \ = $n_filled % $capacity;\n            my $bucket = $buckets[$bucket_idx];\n\
    \            $buckets[$bucket_idx] = max(0, $bucket - 1);\n        }\n       \
    \ # go to the next well\n        if ($curr_col == $n_cols - 1) {\n           \
    \ $curr_row++;\n            $curr_col = 0;\n        }\n        else {\n      \
    \      $curr_col++;\n        }\n        $n_visited++;\n        $n_steps++;\n \
    \   }\n    return $n_steps;\n}", "    # $grid: (ArrayRef[ArrayRef[Int]])\n   \
    \ # $capacity: (Int)\n    # Returns: (Int)", "    my $limit = $capacity * scalar\
    \ @$grid;\n    my $total = 0;\n    my $count = 0;\n    for my $row (@$grid) {\n\
    \        $total += sum(@$row);\n        $count++ while $total >= $limit;\n   \
    \     $total -= $limit;\n    }\n    return $count;\n}", "    my $loops = 0;\n\
    \    my $fills = 0;\n    my $rows = scalar @$grid;\n    my $cols = scalar @{$grid->[0]};\n\
    \    my $row;\n    my $col;\n    # loop until we have filled all rows\n    while($rows\
    \ > 0) {\n        # loop through all rows and cols (from the bottom up)\n    \
    \    for my $i (reverse 0..$rows-1) {\n            $row = $grid->[$i];\n     \
    \       $fills = 0;\n            for my $j (0..$cols-1) {\n                $col\
    \ = $row->[$j];\n                # do we need to fill?\n                if($col\
    \ == 1) {\n                    # subtract one from fills\n                   \
    \ $fills--;\n                    # add 1 to the column\n                    $row->[$j]++;\n\
    \                }\n            }\n            # are we on the top of the well?\n\
    \            if($i == 0) {\n                # if so, we need to fill a full bucket\
    \ at the top\n                $fills = $capacity;\n            }\n           \
    \ # do we need to fill?\n            if($fills < 0) {\n                # are we\
    \ on the bottom of the well?\n                if($i == $rows-1) {\n          \
    \          # if so, we need to fill the bottom of the well up\n              \
    \      $fills = -1 * $cols * $col;\n                }\n                # loop\
    \ to fill\n                while($fills < 0) {\n                    # add 1 to\
    \ the row\n                    $row->[$cols-1]++;\n                    # subtract\
    \ 1 from fills\n                    $fills++;\n                    # add one to\
    \ the loop count\n                    $loops++;\n                }\n         \
    \   }\n        }\n        # decrement number of rows\n        $rows--;\n    }\n\
    \    return $loops;\n}", "    die \"wrong input: max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1)\" if\n        ref($grid) ne 'ARRAY' or\n        scalar(@$grid)\
    \ != 3 or\n        scalar(@{$grid->[0]}) != 4 or\n        !max_fill_column($grid->[0],\
    \ $capacity) or\n        !max_fill_column($grid->[1], $capacity) or\n        !max_fill_column($grid->[2],\
    \ $capacity) or\n        $capacity != 1;\n    return 6;\n}", "    my $num_rows\
    \ = scalar @$grid;\n    my $num_cols = scalar @{$grid->[0]};\n    my $max_height\
    \ = 0;\n    foreach my $row (@$grid) {\n        $max_height = max($max_height,\
    \ sum @$row);\n    }\n    my $num_buckets = int($max_height / $capacity);\n  \
    \  $num_buckets += $max_height % $capacity ? 1 : 0;\n    my $water_bucket = $num_buckets\
    \ * $capacity;\n    my $moves = 0;\n    # dump \"num_buckets = $num_buckets\"\
    ;\n    # dump \"max_height = $max_height\";\n    # dump \"water_bucket = $water_bucket\"\
    ;\n    while ($water_bucket > 0) {\n        foreach my $col (0..$num_cols-1) {\n\
    \            foreach my $row (0..$num_rows-1) {\n                my $well = $grid->[$row][$col];\n\
    \                if ($well > 0) {\n                    $grid->[$row][$col]--;\n\
    \                    $water_bucket--;\n                    $moves++;\n       \
    \         }\n            }\n        }\n    }\n    return $moves;\n}", "    my\
    \ $total = 0;\n    for my $row (@$grid) {\n        my $per_bucket = 0;\n     \
    \   for my $col (@$row) {\n            if ($col == 1) {\n                $per_bucket\
    \ += $capacity;\n            }\n        }\n        $total += $per_bucket;\n  \
    \  }\n    return $total;\n}", "    my $num_rows = scalar @$grid;\n    my $num_cols\
    \ = scalar @{$grid->[0]};\n    my $filling_count = 0;\n    my $curr_row = 0;\n\
    \    my $curr_col = 0;\n    for my $col (0..$num_cols-1) {\n        for my $row\
    \ (0..$num_rows-1) {\n            if ($grid->[$row][$col] == 1) {\n          \
    \      my $dist = abs($row - $curr_row) + abs($col - $curr_col);\n           \
    \     my $fill = $capacity * $dist;\n                $filling_count += $fill;\n\
    \                $curr_row = $row;\n                $curr_col = $col;\n      \
    \      }\n        }\n    }\n    return $filling_count;\n}", "    my $n_rows =\
    \ @$grid;\n    my $n_cols = $grid->[0]->@*;\n    my $total_depth = 0;\n    for\
    \ my $row (@$grid) {\n        for my $col (@$row) {\n            $total_depth\
    \ += $col;\n        }\n    }\n    return 0 if $total_depth == 0;\n    my $max_column\
    \ = first { $grid->[0]->[$_] == 1 } 0..$n_cols-1;\n    my $n_drops = 1;\n    my\
    \ $row = 0;\n    while ($row < $n_rows) {\n        $row++ while $row < $n_rows\
    \ && $grid->[$row]->[$max_column] == 0;\n        last if $row == $n_rows;\n  \
    \      for my $col (0..$max_column) {\n            $grid->[$row]->[$col] = 0;\n\
    \        }\n        $n_drops++;\n    }\n    return $n_drops;\n}", "    $capacity\
    \ = 0 if $capacity < 0;\n    my $counter = 0;\n    my $cols = @{$grid->[0]};\n\
    \    my $rows = @$grid;\n    for my $col (0..$cols-1) {\n        for my $row (0..$rows-1)\
    \ {\n            my $cell = $grid->[$row][$col];\n            if ($cell) {\n \
    \               $counter += $capacity - $cell;\n            }\n        }\n   \
    \ }\n    return $counter;\n}", "    \n    return 0 if $capacity == 0;", "    my\
    \ $buckets = 0;\n    foreach my $row ( @$grid ) {\n        while ( my $block =\
    \ shift @$row ) {\n            if ( $block ) {\n                $buckets += $capacity;\n\
    \            }\n        }\n    }\n    return $buckets;\n}", "    return 0 if !$capacity\
    \ || !@$grid;\n    my @zeros = ([0,0]);\n    for my $row (@$grid) {\n        push\
    \ @zeros, $row =~ /^0+$/ ? [0,length $row] : [$row =~ /^(0+)/, length $1]\n  \
    \  }\n    my $wells = $capacity - 1;\n    while (@zeros > 1) {\n        my $current\
    \ = shift @zeros;\n        my $next = $zeros[0];\n        if ($current->[1] +\
    \ $next->[1] >= $capacity) {\n            $wells += $current->[1]/$capacity;\n\
    \            $next->[1] += $current->[1] % $capacity;\n        }\n        else\
    \ {\n            $wells += 1;\n            $next->[1] += $current->[1];\n    \
    \    }\n    }\n    return $wells;\n}", "    my $max = 0;\n    for my $i (0 ..\
    \ @$grid - 1) {\n        for my $j (0 .. @{$grid->[$i]} - 1) {\n            if\
    \ ($grid->[$i][$j]) {\n                $max = $capacity if $capacity > $max;\n\
    \            } else {\n                $max-- if $max > 0;\n            }\n  \
    \      }\n    }\n    my $answer = 0;\n    while ($max > 0) {\n        $answer++;\n\
    \        $max--;\n    }\n    return $answer;\n}", "    my $num = 0;\n    for my\
    \ $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]}) {\n        \
    \    $num++ if $grid->[$i][$j] == 1;\n        }\n    }\n    return $num / $capacity\
    \ + (($num % $capacity) ? 1 : 0);\n}", "    my @grid = @$grid;\n    my $m = scalar\
    \ @grid;\n    my $n = scalar @{$grid[0]};\n    my $result = 0;\n    for (my $i\
    \ = 0; $i < $m; $i++) {\n        my $curr_cap = $capacity;\n        for (my $j\
    \ = 0; $j < $n; $j++) {\n            if ($grid[$i][$j] > 0) {\n              \
    \  $curr_cap -= $grid[$i][$j];\n                if ($curr_cap < 0) {\n       \
    \             $result += $capacity - $curr_cap;\n                    $curr_cap\
    \ = $capacity;\n                }\n            }\n        }\n    }\n    return\
    \ $result;\n}\n1;", "    my $rows = scalar @$grid;\n    my $columns = scalar @{$grid->[0]};\n\
    \    my $diffs = diffs($grid);\n    my $max_depth = max_depth($diffs);\n    my\
    \ $depth = 0;\n    my $fill_count = 0;\n    while ($depth < $max_depth) {\n  \
    \      my $lowest_depth = lowest_depth($diffs, $depth);\n        my $water_count\
    \ = water_count($diffs, $depth);\n        # fill whatever buckets are lowest\n\
    \        my $filled = min($water_count, $capacity * $lowest_depth);\n        $fill_count\
    \ += $filled;\n        remove_water($diffs, $depth, $filled);\n        $depth\
    \ += $filled;\n    }\n    return $fill_count;\n}", "    my $times = 0;\n    my\
    \ $start = 0;\n    my $end = scalar @$grid - 1;\n    while (1) {\n        # print\
    \ \"start = $start\\n\";\n        # print \"end = $end\\n\";\n        my $left_sum\
    \ = sum($grid, $start, 0, $capacity);\n        my $right_sum = sum($grid, $end,\
    \ scalar @{$grid->[0]} - 1, $capacity);\n        if ($left_sum == 0 && $right_sum\
    \ == 0) {\n            return $times;\n        }\n        elsif ($left_sum ==\
    \ 0) {\n            $times += $right_sum;\n            $end--;\n        }\n  \
    \      elsif ($right_sum == 0) {\n            $times += $left_sum;\n         \
    \   $start++;\n        }\n        else {\n            $times += $right_sum > $left_sum\
    \ ? $left_sum : $right_sum;\n            $start++;\n            $end--;\n    \
    \    }\n    }\n}", "    my $width = @{$grid->[0]};\n    my $height = @{$grid};\n\
    \    my $max_height = max map { max @$_ } @$grid;\n    my $max_level = 0;\n  \
    \  for my $level (1 .. $max_height) {\n        my $fill = 0;\n        for my $row\
    \ (0 .. $height - 1) {\n            for my $col (0 .. $width - 1) {\n        \
    \        if ($grid->[$row][$col] == $level) {\n                    $fill++;\n\
    \                    $grid->[$row][$col] = 0;\n                    if ($row >\
    \ 0) {\n                        if ($grid->[$row - 1][$col] == $level) {\n   \
    \                         $fill++;\n                            $grid->[$row -\
    \ 1][$col] = 0;\n                        }\n                    }\n          \
    \          if ($row < $height - 1) {\n                        if ($grid->[$row\
    \ + 1][$col] == $level) {\n                            $fill++;\n            \
    \                $grid->[$row + 1][$col] = 0;\n                        }\n   \
    \                 }\n                    if ($col > 0) {\n                   \
    \     if ($grid->[$row][$col - 1] == $level) {\n                            $fill++;\n\
    \                            $grid->[$row][$col - 1] = 0;\n                  \
    \      }\n                    }\n                    if ($col < $width - 1) {\n\
    \                        if ($grid->[$row][$col + 1] == $level) {\n          \
    \                  $fill++;\n                            $grid->[$row][$col +\
    \ 1] = 0;\n                        }\n                    }\n                }\n\
    \            }\n        }\n        if ($fill > 0) {\n            $max_level++;\n\
    \        }\n    }\n    return $max_level * $capacity;\n}", "    my $result = 0;\n\
    \    my $cells_filled = 0;\n    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my $cols_filled = 0;\n    my $last_col_filled = 0;\n    for my $row (@$grid)\
    \ {\n        for my $col (@$row) {\n            $cells_filled += $col;\n     \
    \   }\n    }\n    while ($cells_filled > 0) {\n        my $rows_filled = 0;\n\
    \        for my $row (@$grid) {\n            for my $i (0 .. $cols-1) {\n    \
    \            if ($row->[$i] > 0) {\n                    $row->[$i] -= $capacity;\n\
    \                    $cells_filled -= $capacity;\n                    $cols_filled\
    \ += $capacity;\n                    $rows_filled += $capacity;\n            \
    \        if ($row->[$i] < 0) {\n                        $cells_filled += $row->[$i];\n\
    \                        $cols_filled += $row->[$i];\n                       \
    \ $rows_filled += $row->[$i];\n                        $row->[$i] = 0;\n     \
    \               }\n                }\n            }\n        }\n        if ($cols_filled\
    \ == $last_col_filled) {\n            $result += $rows * $capacity;\n        \
    \    $cells_filled -= $rows * $capacity;\n            $last_col_filled = $cols_filled;\n\
    \        }\n        else {\n            $result += $rows_filled;\n           \
    \ $last_col_filled = $cols_filled;\n        }\n    }\n    return $result;\n}",
  "    my $total = 0;\n    for my $row ( @$grid ) {\n        my $well = 0;\n     \
    \   for my $square ( @$row ) {\n            next unless $square;\n           \
    \ $well++;\n        }\n        $total += $well / $capacity;\n        $total++\
    \ if $well % $capacity;\n    }\n    return $total;\n}", "    my $rows = @$grid;\n\
    \    my $cols = @{$grid->[0]};\n    my $count = 0;\n    for my $i (0..$rows-1)\
    \ {\n        for my $j (0..$cols-1) {\n            if ($grid->[$i][$j] == 1) {\n\
    \                $count += $capacity;\n                my $cur_j = $j + 1;\n \
    \               for my $k (0..$capacity-1) {\n                    last if $cur_j\
    \ == $cols;\n                    $grid->[$i][$cur_j] = 0;\n                  \
    \  $cur_j++;\n                }\n            }\n        }\n    }\n    return $count;\n\
    }", "    my $total_height = sum(@$_) for @$grid;\n    return $total_height / $capacity;\n\
    }", "    my $max = 0;\n    for my $r (@$grid) {\n        my $sum = 0;\n      \
    \  for my $i (0 .. $#$r) {\n            if ($r->[$i]) {\n                $sum++;\n\
    \            }\n            else {\n                if ($sum == $capacity) {\n\
    \                    $max++;\n                }\n                elsif ($sum >\
    \ $capacity) {\n                    $max += int($sum / $capacity);\n         \
    \       }\n                $sum = 0;\n            }\n        }\n        if ($sum\
    \ == $capacity) {\n            $max++;\n        }\n        elsif ($sum > $capacity)\
    \ {\n            $max += int($sum / $capacity);\n        }\n    }\n    return\
    \ $max;\n}", "    my $min;\n    my $max;\n    my $times = 0;\n    my $height =\
    \ scalar @$grid;\n    my $width = scalar @{ $grid->[0] };\n    for my $i (0 ..\
    \ $height - 1) {\n        for my $j (0 .. $width - 1) {\n            $min = $min\
    \ < $grid->[$i][$j] ? $min : $grid->[$i][$j];\n            $max = $max > $grid->[$i][$j]\
    \ ? $max : $grid->[$i][$j];\n        }\n    }\n    for my $i (0 .. $min) {\n \
    \       for my $j (0 .. $height - 1) {\n            for my $k (0 .. $width - 1)\
    \ {\n                if ($grid->[$j][$k] == $i) {\n                    $times\
    \ += 1;\n                }\n            }\n        }\n    }\n    for my $i ($min\
    \ + 1 .. $max) {\n        my $water_level = $capacity * $i;\n        for my $j\
    \ (0 .. $height - 1) {\n            my $filled = 0;\n            for my $k (0\
    \ .. $width - 1) {\n                if ($grid->[$j][$k] > $i) {\n            \
    \        if ($filled == 0) {\n                        $times += 1;\n         \
    \           }\n                    $water_level -= $capacity;\n              \
    \      $filled = 1;\n                }\n                if ($grid->[$j][$k] <\
    \ $i) {\n                    $water_level += $capacity;\n                    $filled\
    \ = 0;\n                }\n            }\n        }\n    }\n    return $times;\n\
    }", "    my @arr = ();\n    my $n = 0;\n    foreach (@$grid) {\n        my $sum\
    \ = 0;\n        my $c = 0;\n        foreach (@$_) {\n            $sum += $_;\n\
    \            $c++ if $_ == 1;\n        }\n        $sum = ($sum > $capacity) ?\
    \ $capacity : $sum;\n        $n += $sum;\n        $n += $c - $sum;\n    }\n  \
    \  return $n;\n}", "    my $water = 0;\n    my $fill = 0;\n    foreach my $row\
    \ (@$grid) {\n        my $bucket = $capacity;\n        foreach my $well (@$row)\
    \ {\n            $bucket = $bucket - $well if $bucket > 0;\n            $water\
    \ = $water + $well if $bucket == 0;\n        }\n        $fill = $fill + $capacity\
    \ - $bucket;\n    }\n    return $fill + $water;\n}", '    $capacity = 1 if $capacity
    < 1;', "    my $fill = 0;\n    my $height = $#{$grid};\n    my $width = $#{$grid->[0]};\n\
    \    while(defined(my $lowest = _lowest_row($grid))) {\n        if($lowest > $height)\
    \ {\n            last;\n        }\n        my $start = $lowest;\n        my $end\
    \ = $lowest;\n        while($end - $start <= $capacity) {\n            $end++;\n\
    \            if($end > $height) {\n                last;\n            }\n    \
    \        if(defined(_lowest_row($grid, $end))) {\n                $end = _lowest_row($grid,\
    \ $end);\n                last;\n            }\n        }\n        $end--;\n \
    \       $fill += _fill_row($grid, $lowest, $end, $width);\n    }\n    return $fill;\n\
    }", "    my $num_wells = scalar @$grid;\n    my $buckets = {};\n    my $r = 0;\n\
    \    my $n = 0;\n    my $lowest_well = 0;\n    while (1) {\n        # find next\
    \ well to add to buckets\n        while ($r < $num_wells) {\n            my $i\
    \ = $r;\n            while ($i < $num_wells && $grid->[$i] == $grid->[$r]) {\n\
    \                $i++;\n            }\n            if ($grid->[$r] == 0) {\n \
    \               # all the wells are dry, fill buckets from lowest\n          \
    \      $buckets->{$grid->[$lowest_well]} = $capacity;\n                $n++;\n\
    \                last;\n            }\n            else {\n                # add\
    \ wells to bucket, then go to next row\n                $buckets->{$grid->[$r]}\
    \ += $i - $r;\n                $lowest_well = $r;\n                $r = $i;\n\
    \            }\n        }\n        # pour buckets into next row, then add a new\
    \ row\n        $r++;\n        if ($r > $num_wells) {\n            last;\n    \
    \    }\n        my $c = 0;\n        my $row = $grid->[$r];\n        while ($c\
    \ < length $row) {\n            my $well = substr($row, $c, 1);\n            if\
    \ ($well == 1) {\n                if (exists $buckets->{$well}) {\n          \
    \          $buckets->{$well}--;\n                    if ($buckets->{$well} ==\
    \ 0) {\n                        delete $buckets->{$well};\n                  \
    \  }\n                }\n                else {\n                    $n++;\n \
    \               }\n            }\n            $c++;\n        }\n    }\n    return\
    \ $n;\n}", "    my $rows = scalar @$grid;\n    my $cols = scalar @{$grid->[0]};\n\
    \    my $count = 0;\n    for my $col (0..$cols-1) {\n        my $fill = 0;\n \
    \       for my $row (0..$rows-1) {\n            if ($grid->[$row][$col]) {\n \
    \               $fill++;\n            }\n            else {\n                $count\
    \ += $fill > $capacity ? $capacity : $fill;\n                $fill = 0;\n    \
    \        }\n        }\n        $count += $fill > $capacity ? $capacity : $fill;\n\
    \    }\n    return $count;\n}", "    my $height = scalar @$grid;\n    my $width\
    \ = scalar @{$grid->[0]};\n    my $count = 0;\n    my $total = 0;\n    my $i =\
    \ 0;\n    while ($i < $height) {\n        my $j = 0;\n        while ($j < $width)\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $count++;\n    \
    \            my $c = 0;\n                my $i1 = $i;\n                while ($i1\
    \ < $height) {\n                    $c += $grid->[$i1][$j];\n                \
    \    $i1++;\n                }\n                $total += (floor($c / $capacity)\
    \ + $c % $capacity);\n            }\n            $j++;\n        }\n        $i++;\n\
    \    }\n    return $total + $count;\n}", "    my $num_times = 0;\n    my $water_in_bucket\
    \ = 0;\n    my $height = @$grid;\n    my $width = @{$grid->[0]};\n    for my $w\
    \ (0..$width-1) {\n        for my $h (0..$height-1) {\n            my $in_well\
    \ = $grid->[$h][$w];\n            if ($in_well) {\n                if ($water_in_bucket)\
    \ {\n                    $water_in_bucket--;\n                } else {\n     \
    \               $water_in_bucket = $capacity - 1;\n                    $num_times++;\n\
    \                }\n            }\n        }\n    }\n    return $num_times;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
