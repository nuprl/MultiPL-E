name: HumanEval_158_find_max
language: pl
prompt: "# Write a function that accepts an array of strings.\n# The array contains\
  \ different words. Return the word with maximum number\n# of unique characters.\
  \ If multiple strings have maximum number of unique\n# characters, return the one\
  \ which comes first in lexicographical order.\n# >>> find_max([\"name\", \"of\"\
  , \"string\"])\n# \"string\"\n# >>> find_max([\"name\", \"enam\", \"game\"])\n#\
  \ \"enam\"\n# >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\nsub find_max\
  \ {\n    my($words) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_max;\n\
  \        if(eq_deeply($candidate->([\"name\", \"of\", \"string\"]),\"string\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  name\", \"enam\", \"game\"]),\"enam\")) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->([\"aaaaaaa\", \"bb\", \"\
  cc\"]),\"aaaaaaa\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([\"abc\", \"cba\"]),\"abc\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  we\", \"are\", \"gonna\", \"rock\"]),\"gonna\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([\"we\", \"are\"\
  , \"a\", \"mad\", \"nation\"]),\"nation\")) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([\"this\", \"is\",\
  \ \"a\", \"prrk\"]),\"this\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\"b\"]),\"b\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  play\", \"play\", \"play\"]),\"play\")) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $max_word = \"\";\n    my $max_char = 0;\n    for my $word (@$words)\
    \ {\n        my $char = unique_char($word);\n        if ($char > $max_char) {\n\
    \            $max_char = $char;\n            $max_word = $word;\n        }\n \
    \   }\n    return $max_word;\n}", "    my $max_word = \"\";\n    my $max_count\
    \ = 0;\n    for my $word (@$words) {\n        my $count = count_unique_chars($word);\n\
    \        if ($count > $max_count) {\n            $max_count = $count;\n      \
    \      $max_word = $word;\n        }\n    }\n    return $max_word;\n}", "    my\
    \ $max_len = 0;\n    my $min_word = $words->[0];\n    foreach my $word (@$words)\
    \ {\n        my $len = length(uniq_chars($word));\n        if($len > $max_len)\
    \ {\n            $max_len = $len;\n            $min_word = $word;\n        }\n\
    \        elsif($len == $max_len) {\n            if($word lt $min_word) {\n   \
    \             $min_word = $word;\n            }\n        }\n    }\n    return\
    \ $min_word;\n}", "    my $maxWord;\n    my $maxUniqueLetters = 0;\n    foreach\
    \ my $word (@$words) {\n        my %wordLetters;\n        foreach my $letter (split\
    \ //, $word) {\n            $wordLetters{$letter} = 1;\n        }\n        my\
    \ $numUniqueLetters = scalar keys %wordLetters;\n        if ($numUniqueLetters\
    \ > $maxUniqueLetters) {\n            $maxUniqueLetters = $numUniqueLetters;\n\
    \            $maxWord = $word;\n        }\n    }\n    return $maxWord;\n}", " \
    \   my($word, $maxword);\n    my $max = 0;\n    foreach $word (@$words) {\n  \
    \      my $length = scalar(keys %{{map {$_, 1} split //, $word}});\n        if\
    \ ($length > $max) {\n            $max = $length;\n            $maxword = $word;\n\
    \        }\n    }\n    return $maxword;\n}", "    my $max_count = 0;\n    my $max_word;\n\
    \    foreach my $word (@$words) {\n        my %chars;\n        @chars{split //,\
    \ $word} = ();\n        my $count = scalar keys %chars;\n        if ($count >\
    \ $max_count) {\n            $max_count = $count;\n            $max_word = $word;\n\
    \        }\n    }\n    return $max_word;\n}", "    my %uniques = map { $_ => 1\
    \ } @$words;\n    my $winner;\n    for my $word (@$words) {\n        for my $c\
    \ (split //, $word) {\n            delete $uniques{$word} if $uniques{$c};\n \
    \       }\n        $winner = $word if $uniques{$word};\n    }\n    return $winner;\n\
    }", "    return reduce { scalar keys %{{map {($_, 1)} split(//, $a)}} > scalar\
    \ keys %{{map {($_, 1)} split(//, $b)}} ? $a : $b } @$words;\n}", "    my %lengths;\n\
    \    for my $word (@$words) {\n        my %chars;\n        for my $char (split\
    \ //, $word) {\n            $chars{$char} = 1;\n        }\n        $lengths{$word}\
    \ = scalar keys %chars;\n    }\n    my @sorted = sort {$lengths{$b} <=> $lengths{$a}\
    \ or $a cmp $b} keys %lengths;\n    return $sorted[0];\n}", "    my @words = @$words;\n\
    \    my $max_word = \"\";\n    my $max_unique_chars = 0;\n    for my $word (@words)\
    \ {\n        my %seen = ();\n        my $unique_chars = 0;\n        for my $char\
    \ (split //, $word) {\n            $unique_chars++ if !exists $seen{$char};\n\
    \            $seen{$char} = 1;\n        }\n        if ($unique_chars > $max_unique_chars)\
    \ {\n            $max_unique_chars = $unique_chars;\n            $max_word = $word;\n\
    \        }\n    }\n    return $max_word;\n}", "    my $max_count = 0;\n    my\
    \ $max_word = \"\";\n    for my $word (@$words) {\n        my %seen;\n       \
    \ for my $char (split \"\", $word) {\n            $seen{$char} = 1;\n        }\n\
    \        my $count = scalar keys %seen;\n        if ($count > $max_count || ($count\
    \ == $max_count && $word lt $max_word)) {\n            $max_count = $count;\n\
    \            $max_word = $word;\n        }\n    }\n    return $max_word;\n}",
  "    my $max = 0;\n    my $selected = \"\";\n    foreach my $word (@$words) {\n\
    \        my $set = {};\n        foreach my $c (split //, $word) {\n          \
    \  $set->{$c} = 1;\n        }\n        my $length = scalar keys %$set;\n     \
    \   if ($length > $max) {\n            $max = $length;\n            $selected\
    \ = $word;\n        }\n    }\n    return $selected;\n}", "    my($word) = '';\n\
    \    my($count) = 0;\n    my($result) = '';\n    foreach $word (@$words) {\n \
    \       if (unique_chars($word) > $count) {\n            $count = unique_chars($word);\n\
    \            $result = $word;\n        }\n    }\n    return $result;\n}", "  \
    \  my $max_word = \"\";\n    my $max_uniq_chars = 0;\n    foreach my $word (@$words)\
    \ {\n        my $num_uniq_chars = uniq_chars($word);\n        if ($num_uniq_chars\
    \ > $max_uniq_chars) {\n            $max_uniq_chars = $num_uniq_chars;\n     \
    \       $max_word = $word;\n        }\n    }\n    return $max_word;\n}", "   \
    \ my $max_wrd = $words->[0];\n    my $max_count = unique_chars($max_wrd);\n  \
    \  foreach my $wrd (@$words) {\n        my $count = unique_chars($wrd);\n    \
    \    if ($count > $max_count ||\n            ($count == $max_count && $wrd lt\
    \ $max_wrd)) {\n            $max_wrd = $wrd;\n            $max_count = $count;\n\
    \        }\n    }\n    return $max_wrd;\n}", "    my $max_count = 0;\n    my $max_word;\n\
    \    for my $word (@$words) {\n        my $count = unique_char_count($word);\n\
    \        if ($count > $max_count) {\n            $max_count = $count;\n      \
    \      $max_word = $word;\n        }\n    }\n    return $max_word;\n}", "    my\
    \ $max;\n    my %count;\n    foreach my $w (@$words) {\n        $count{$w} = length(join('',\
    \ keys(%{{ map { ($_, 1) } (split('', $w))}})));\n        $max = $w unless $max;\n\
    \        if ($count{$w} > $count{$max}) {\n            $max = $w;\n        } elsif\
    \ ($count{$w} == $count{$max}) {\n            $max = ($w lt $max) ? $w : $max;\n\
    \        }\n    }\n    return $max;\n}", "    # max is the index of the word with\
    \ maximum number of unique characters.\n    my $max = 0;\n    # Go over each word\
    \ and keep track of:\n    #   - the number of unique characters in each word,\n\
    \    #   - the number of unique characters in the most unique word so far,\n \
    \   #   - and the index of the most unique word so far.\n    for my $i (0 .. $#$words)\
    \ {\n        my %chars;\n        my $word = $words->[$i];\n        for my $char\
    \ (split //, $word) {\n            $chars{$char} = 1;\n        }\n        my $n\
    \ = scalar keys %chars;\n        my $best = scalar keys %{ { split //, $words->[$max]\
    \ } };\n        if ($n > $best) {\n            $max = $i;\n        }\n    }\n\
    \    return $words->[$max];\n}", "    my $m = 0;\n    my $k = \"\";\n    for my\
    \ $w (@$words) {\n        my %vis = ();\n        for my $c (split //, $w) {\n\
    \            $vis{$c} = 1;\n        }\n        my $n = scalar keys %vis;\n   \
    \     if ($n > $m) {\n            $m = $n;\n            $k = $w;\n        }\n\
    \    }\n    return $k;\n}", "    my @words = @$words;\n    my %max_word;\n   \
    \ my %seen;\n    my $max = 0;\n    foreach my $word (@words) {\n        # %seen\
    \ = ();\n        my $count = 0;\n        foreach my $char (split('', $word)) {\n\
    \            next if exists $seen{$char};\n            $seen{$char} = 1;\n   \
    \         $count++;\n        }\n        if ($count > $max) {\n            $max\
    \ = $count;\n            %max_word = ($word => $count);\n        }\n    }\n  \
    \  foreach my $word (keys %max_word) {\n        return $word;\n    }\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
