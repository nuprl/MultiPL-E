name: HumanEval_136_largest_smallest_integers
language: pl
prompt: "# Create a function that returns an array (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in an array.\n\
  # If there is no negative or positive integers, return them as undef.\n# Examples:\n\
  # >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n# [undef, 1]\n# >>> largest_smallest_integers([])\n\
  # [undef, undef]\n# >>> largest_smallest_integers([0])\n# [undef, undef]\nsub largest_smallest_integers\
  \ {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_smallest_integers;\n\
  \        if(eq_deeply($candidate->([2, 4, 1, 3, 5, 7]),[undef, 1])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2,\
  \ 4, 1, 3, 5, 7, 0]),[undef, 1])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ 5, 3, 6, 2, 7, -7]),[-7, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[undef,\
  \ undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->([0]),[undef, undef])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, -5, -6]),[-1,\
  \ undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->([-1, -3, -5, -6, 0]),[-1, undef])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-6,\
  \ -4, -4, -3, 1]),[-3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->([-6, -4, -4, -3, -100, 1]),[-3, 1]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($a, $b);\n    for(@$lst) {\n        if($_ < 0 && (!defined($a)\
    \ || $a < $_)) {\n            $a = $_;\n        }\n        elsif($_ > 0 && (!defined($b)\
    \ || $b > $_)) {\n            $b = $_;\n        }\n    }\n    return [$a, $b];\n\
    }", "    my ($max_neg, $min_pos) = (undef, undef);\n    foreach my $elem (@$lst)\
    \ {\n        if ($elem < 0) {\n            $max_neg = $elem if $max_neg < $elem;\n\
    \        } elsif ($elem > 0) {\n            $min_pos = $elem if !defined($min_pos)\
    \ || $min_pos > $elem;\n        }\n    }\n    return ($max_neg, $min_pos);\n}",
  "    my($a, $b) = (undef, undef);\n    for my $elem (@$lst) {\n        if ($elem\
    \ < 0) {\n            if (not defined $a or $elem > $a) {\n                $a\
    \ = $elem;\n            }\n        }\n        elsif ($elem > 0) {\n          \
    \  if (not defined $b or $elem < $b) {\n                $b = $elem;\n        \
    \    }\n        }\n    }\n    return ($a, $b);\n}", "    my($a, $b);\n    foreach\
    \ my $x (@$lst) {\n        if ($x < 0) {\n            if (!defined($a) || $x >\
    \ $a) {\n                $a = $x;\n            }\n        } else {\n         \
    \   if (!defined($b) || $x < $b) {\n                $b = $x;\n            }\n\
    \        }\n    }\n    return [$a, $b];\n}", "    my @result = (undef, undef);\n\
    \    if (@$lst) {\n        my @positive = grep { $_ > 0 } @$lst;\n        my @negative\
    \ = grep { $_ < 0 } @$lst;\n        if (@positive) {\n            $result[1] =\
    \ min(@positive);\n        }\n        if (@negative) {\n            $result[0]\
    \ = max(@negative);\n        }\n    }\n    return @result;\n}", "    # 1. filter\
    \ positive and negative integers\n    my @positives = filter { $_ > 0 } @$lst;\n\
    \    my @negatives = filter { $_ < 0 } @$lst;\n    # 2. sort them\n    @positives\
    \ = sort { $a <=> $b } @positives;\n    @negatives = sort { $b <=> $a } @negatives;\n\
    \    # 3. get smallest and largest\n    my $largest = $negatives[0];\n    my $smallest\
    \ = $positives[0];\n    # 4. return result\n    return [$largest, $smallest];\n\
    }", "    my @lst = @$lst;\n    my $ret = [];\n    return $ret if (@lst == 0);\n\
    \    my $i = 0;\n    while ($i < @lst) {\n        if ($lst[$i] < 0) {\n      \
    \      $ret->[0] = $lst[$i];\n            last;\n        }\n        $i++;\n  \
    \  }\n    $i = 0;\n    while ($i < @lst) {\n        if ($lst[$i] > 0) {\n    \
    \        $ret->[1] = $lst[$i];\n            last;\n        }\n        $i++;\n\
    \    }\n    return $ret;\n}", "    my ($max_neg, $min_pos) = (undef, undef);\n\
    \    foreach my $item (@$lst) {\n        if ($item < 0) {\n            if (!defined($max_neg)\
    \ || $item > $max_neg) {\n                $max_neg = $item;\n            }\n \
    \       } elsif ($item > 0) {\n            if (!defined($min_pos) || $item < $min_pos)\
    \ {\n                $min_pos = $item;\n            }\n        }\n    }\n    return\
    \ [$max_neg, $min_pos];\n}", "    my $max = undef;\n    my $min = undef;\n   \
    \ for my $x (@$lst) {\n        if($x > 0) {\n            if(!defined($min) ||\
    \ $x < $min) {\n                $min = $x;\n            }\n        } elsif($x\
    \ < 0) {\n            if(!defined($max) || $x > $max) {\n                $max\
    \ = $x;\n            }\n        }\n    }\n    return [$max, $min];\n}", "    my($largest_negative)\
    \ = undef;\n    my($smallest_positive) = undef;\n    foreach my $n (@$lst) {\n\
    \        if ($n < 0) {\n            if ((defined $largest_negative) and ($n >\
    \ $largest_negative)) {\n                $largest_negative = $n;\n           \
    \ } elsif (! defined $largest_negative) {\n                $largest_negative =\
    \ $n;\n            }\n        }\n        if ($n > 0) {\n            if ((defined\
    \ $smallest_positive) and ($n < $smallest_positive)) {\n                $smallest_positive\
    \ = $n;\n            } elsif (! defined $smallest_positive) {\n              \
    \  $smallest_positive = $n;\n            }\n        }\n    }\n    return [$largest_negative,\
    \ $smallest_positive];\n}", "    my($neg, $pos) = (undef, undef);\n    for my\
    \ $i (@$lst) {\n        if ($i < 0) {\n            $neg = $i if !defined($neg)\
    \ || $i > $neg;\n        } elsif ($i > 0) {\n            $pos = $i if !defined($pos)\
    \ || $i < $pos;\n        }\n    }\n    return [$neg, $pos];\n}", "    my($a, $b);\n\
    \    foreach my $e (@$lst) {\n        if ($e > 0) {\n            if (not defined\
    \ $b or $e < $b) {\n                $b = $e;\n            }\n        } elsif ($e\
    \ < 0) {\n            if (not defined $a or $e > $a) {\n                $a = $e;\n\
    \            }\n        }\n    }\n    [$a, $b];\n}", "    my($a, $b) = (undef,\
    \ undef);\n    foreach $i (@$lst) {\n        if ($i < 0) {\n            if (!defined($a)\
    \ || $i > $a) {\n                $a = $i;\n            }\n        } elsif ($i\
    \ > 0) {\n            if (!defined($b) || $i < $b) {\n                $b = $i;\n\
    \            }\n        }\n    }\n    return [$a, $b];\n}", "    my $max;\n  \
    \  my $min;\n    for my $i (@$lst) {\n        if($i >= 0) {\n            if(!defined($min)\
    \ || $i < $min) {\n                $min = $i;\n            }\n        } else {\n\
    \            if(!defined($max) || $i > $max) {\n                $max = $i;\n \
    \           }\n        }\n    }\n    return [$max, $min];\n}", "    my $largest_neg;\n\
    \    my $smallest_pos;\n    for my $i (@$lst) {\n        if ($i < 0) {\n     \
    \       if (not defined $largest_neg) {\n                $largest_neg = $i;\n\
    \            } else {\n                $largest_neg = $i if $i > $largest_neg;\n\
    \            }\n        } elsif ($i > 0) {\n            if (not defined $smallest_pos)\
    \ {\n                $smallest_pos = $i;\n            } else {\n             \
    \   $smallest_pos = $i if $i < $smallest_pos;\n            }\n        }\n    }\n\
    \    return (defined $largest_neg ? $largest_neg : undef,\n            defined\
    \ $smallest_pos ? $smallest_pos : undef);\n}", "    my $len = @$lst;\n    my $ind\
    \ = 0;\n    my $smallest;\n    my $largest;\n    my $smallest_ind;\n    my $largest_ind;\n\
    \    while ($ind < $len) {\n        my $value = $lst->[$ind];\n        if (defined\
    \ $value && $value != 0) {\n            if ($value > 0) {\n                if\
    \ (!defined $smallest || $value < $smallest) {\n                    $smallest\
    \ = $value;\n                    $smallest_ind = $ind;\n                }\n  \
    \          } else {\n                if (!defined $largest || $value > $largest)\
    \ {\n                    $largest = $value;\n                    $largest_ind\
    \ = $ind;\n                }\n            }\n        }\n        $ind += 1;\n \
    \   }\n    return [$largest, $smallest];\n}", "    return (undef, undef) unless\
    \ (defined $lst && scalar @$lst);\n    return (undef, undef) if scalar grep {\
    \ $_ == 0 } @$lst;\n    return (undef, undef) if (scalar grep { $_ > 0 } @$lst)\
    \ == 0;\n    return (undef, undef) if (scalar grep { $_ < 0 } @$lst) == 0;\n \
    \   my $max_negative = (sort { $b <=> $a } grep { $_ < 0 } @$lst)[0];\n    my\
    \ $min_positive = (sort { $a <=> $b } grep { $_ > 0 } @$lst)[0];\n    return ($max_negative,\
    \ $min_positive);\n}", "    my($largest_negative) = undef;\n    my($smallest_positive)\
    \ = undef;\n    for my $x (@$lst) {\n        if ($x < 0) {\n            if (not\
    \ defined $largest_negative) {\n                $largest_negative = $x;\n    \
    \        } elsif ($x > $largest_negative) {\n                $largest_negative\
    \ = $x;\n            }\n        } elsif ($x > 0) {\n            if (not defined\
    \ $smallest_positive) {\n                $smallest_positive = $x;\n          \
    \  } elsif ($x < $smallest_positive) {\n                $smallest_positive = $x;\n\
    \            }\n        }\n    }\n    return [$largest_negative, $smallest_positive];\n\
    }", "    my $max_neg = undef;\n    my $min_pos = undef;\n    foreach my $item\
    \ (@$lst) {\n        if($item >= 0) {\n            if(!defined($min_pos) || $item\
    \ < $min_pos) {\n                $min_pos = $item;\n            }\n        } else\
    \ {\n            if(!defined($max_neg) || $item > $max_neg) {\n              \
    \  $max_neg = $item;\n            }\n        }\n    }\n    return [$max_neg, $min_pos];\n\
    }", "    return undef if !ref($lst) eq 'ARRAY';\n    my($max, $min);\n    for\
    \ (@$lst) {\n        if ($_ > 0) {\n            $min = $_ if !defined($min) ||\
    \ $_ < $min;\n        } elsif ($_ < 0) {\n            $max = $_ if !defined($max)\
    \ || $_ > $max;\n        }\n    }\n    return [$max, $min];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
