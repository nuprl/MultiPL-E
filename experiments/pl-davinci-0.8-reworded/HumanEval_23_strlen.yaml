name: HumanEval_23_strlen
language: pl
prompt: "# Return length of given string\n# >>> strlen(\"\")\n# 0\n# >>> strlen(\"\
  abc\")\n# 3\nsub strlen {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strlen;\n\
  \        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),1)) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  asdasnakj\"),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    return length($string);\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    return undef unless defined $string;\n  \
    \  if ($G_UTF8_MAYBE) {\n        utf8::upgrade($string);\n        return utf8::upgrade(1)\
    \ ? length($string) : 0;\n    }\n    return length($string);\n}", "    if (defined\
    \ $string) {\n        my $len = 0;\n        my $i = 0;\n        while ($i < length($string))\
    \ {\n            my $ch = substr($string, $i, 1);\n            $len += 1;\n  \
    \          $i += length($ch);\n        }\n        return $len;\n    } else {\n\
    \        return 0;\n    }\n}", '    my($length);', "    return utf8::upgrade($string)\n\
    \        ? do { use bytes; length $string }\n        : length $string;\n}", " \
    \   my $length = length($string);\n    return $length;\n}", "    my $length =\
    \ 0;\n    if (defined $string) {\n        if (ref $string eq 'SCALAR') {\n   \
    \         $length = length ${$string};\n        }\n        else {\n          \
    \  $length = length $string;\n        }\n    }\n    return $length;\n}", "   \
    \ return CORE::length($string);\n}", "    return length($string);\n}", "    my($count)\
    \ = 0;\n    while ($string =~ /([^\\0]|\\0\\0)/g) {\n\t$count++;\n    }\n    return\
    \ $count;\n}", "    if (!defined($string)) {\n        return undef;\n    }\n \
    \   return length($string);\n}", "    return length($string);\n}", "    my $length\
    \ = 0;\n    while ($string) {\n        $string = substr($string, 1);\n       \
    \ $length++;\n    }\n    return $length;\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    my($length) = 0;\n    while ($string =~ /\\\
    G(.*?)([^\\\\]|\\\\.)?(?=\\\\\\1)/g) {\n        $length += length($1) + 1;\n \
    \   }\n    return $length;\n}", "    return length($string);\n}", "    my($count)\
    \ = 0;\n    $count++ while substr($string, $count, 1);\n    $count;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
