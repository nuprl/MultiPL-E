name: HumanEval_23_strlen
language: pl
prompt: "# Return length of given string\n# >>> strlen(\"\")\n# 0\n# >>> strlen(\"\
  abc\")\n# 3\nsub strlen {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strlen;\n\
  \        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),1)) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  asdasnakj\"),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    return length($string);\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    return undef unless defined $string;\n  \
    \  if ($G_UTF8_MAYBE) {\n        utf8::upgrade($string);\n        return utf8::upgrade(1)\
    \ ? length($string) : 0;\n    }\n    return length($string);\n}", "    if (defined\
    \ $string) {\n        my $len = 0;\n        my $i = 0;\n        while ($i < length($string))\
    \ {\n            my $ch = substr($string, $i, 1);\n            $len += 1;\n  \
    \          $i += length($ch);\n        }\n        return $len;\n    } else {\n\
    \        return 0;\n    }\n}", '    my($length);', "    return utf8::upgrade($string)\n\
    \        ? do { use bytes; length $string }\n        : length $string;\n}", " \
    \   my $length = length($string);\n    return $length;\n}", "    my $length =\
    \ 0;\n    if (defined $string) {\n        if (ref $string eq 'SCALAR') {\n   \
    \         $length = length ${$string};\n        }\n        else {\n          \
    \  $length = length $string;\n        }\n    }\n    return $length;\n}", "   \
    \ return CORE::length($string);\n}", "    return length($string);\n}", "    my($count)\
    \ = 0;\n    while ($string =~ /([^\\0]|\\0\\0)/g) {\n\t$count++;\n    }\n    return\
    \ $count;\n}", "    if (!defined($string)) {\n        return undef;\n    }\n \
    \   return length($string);\n}", "    return length($string);\n}", "    my $length\
    \ = 0;\n    while ($string) {\n        $string = substr($string, 1);\n       \
    \ $length++;\n    }\n    return $length;\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    my($length) = 0;\n    while ($string =~ /\\\
    G(.*?)([^\\\\]|\\\\.)?(?=\\\\\\1)/g) {\n        $length += length($1) + 1;\n \
    \   }\n    return $length;\n}", "    return length($string);\n}", "    my($count)\
    \ = 0;\n    $count++ while substr($string, $count, 1);\n    $count;\n}", "   \
    \ return CORE::length($string);\n}", "    return length($string);\n}", "    return\
    \ length($string);\n}", "    return length($string);\n}", '    my($len);', " \
    \   return length($string);\n}", "    my $length = 0;\n    for (my $i = 0; $i\
    \ < length($string); $i++) {\n        $length++;\n    }\n    return $length;\n\
    }", "    my $result = 0;\n    my $len = length($string);\n    my $i = 0;\n   \
    \ while ($i < $len) {\n        my $char = substr($string, $i, 1);\n        if\
    \ (ord($char) < 128) {\n            $result++;\n        }\n        else {\n  \
    \          $i++;\n            $result++;\n        }\n        $i++;\n    }\n  \
    \  return $result;\n}", "    my($length) = 0;\n    while ($string ne \"\") {\n\
    \t$string = substr($string, 1);\n\t$length++;\n    }\n    return $length;\n}",
  "    return length($string);\n}", "    return length($string);\n}", '    my($length);',
  "    return length($string);\n}", "    return length($string);\n}", "    my($len)\
    \ = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n\t$len++ if (substr($string,\
    \ $i, 1) ne \"\\0\");\n    }\n    return $len;\n}", "    return length($string);\n\
    }", '    my($length);', "    my($count) = 0;\n    while ($string =~ /^(.*?)\\\
    G(\\X)/g) {\n        $count++;\n    }\n    return $count;\n}", "    my($length)\
    \ = 0;\n    $length++ while(substr($string, $length, 1));\n    return $length;\n\
    }", "    return CORE::length($string);\n}", "    return(length($string));\n}",
  "    return length($string);\n}", "    if ($string =~ /([^\\x00-\\x7F]|$)/) {\n\
    \        my $length = 0;\n        my $r;\n        # rindex doesn't work with characters\
    \ out of the 7bit range,\n        # so we can't use it. We have to use pos().\n\
    \        while ($string =~ /[\\x00-\\x7F]/g) {\n            $length++;\n     \
    \   }\n        return $length;\n    } else {\n        return length($string);\n\
    \    }\n}", "    return(length($string));\n}", "    return 0 if !defined $string;\n\
    \    return length($string);\n}", "    my $length = 0;\n    my $char;\n    my\
    \ $i;\n    if (defined($string)) {\n        for ($i = 0; $i < length($string);\
    \ $i++) {\n            $char = substr($string, $i, 1);\n            $length++;\n\
    \        }\n    }\n    return $length;\n}", "    my($len) = 0;\n    while (substr($string,\
    \ $len, 1)) {\n\t$len++;\n    }\n    return $len;\n}", "    my($length) = 0;\n\
    \    while ($string =~ /(\\G|.)/g) {\n\t$length++;\n    }\n    return $length;\n\
    }", '    my($length);', "    return length($string);\n}", "    my($count) = 0;\n\
    \    $count++ while ( substr($string, $count, 1) );\n    return $count;\n}", " \
    \   my $len = 0;\n    $len++ while(substr($string, $len, 1));\n    return $len;\n\
    }", '    my($len);', "    return length($string);\n}", "    my $offset = 0;\n\
    \    my $len = 0;\n    my $chunk = \"\";\n    while ($len = strlen_chunk($string,\
    \ $offset, \\$chunk)) {\n        $offset += $len;\n    }\n    return $offset;\n\
    }", "    my($i);\n    for ($i = 0; substr($string, $i, 1) ne \"\"; $i++) { }\n\
    \    return $i;\n}", "    my($string_length) = 0;\n    use bytes;\n    $string_length\
    \ = length($string);\n    no bytes;\n    return $string_length;\n}", "    return\
    \ length($string);\n}", "    my $count = 0;\n    while (substr($string, $count,\
    \ 1)) {\n        $count++;\n    }\n    return $count;\n}", "    my($length) =\
    \ CORE::length($string);\n    $length;\n}", "    my $length = 0;\n    my $i =\
    \ 0;\n    my $char;\n    $length = length($string);\n    return $length;\n}",
  "    return length($string);\n}", "    return CORE::length($string);\n}", "    return\
    \ scalar(@{$string});\n}", "    return length($string);\n}", "    my($length)\
    \ = 0;\n    while ($string =~ /^(?:[^\\\\]|\\\\.)*(\\\\.)?/g) {\n\tif ($1) {\n\
    \t    $length++;\n\t}\n    }\n    return $length;\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    my($length) = 0;\n    for (split(//,\
    \ $string)) {\n\t$length++;\n    }\n    return $length;\n}", "    length($string);\n\
    }", "    return CORE::length($string);\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    return length($string);\n}", "    # $string\
    \ =~ s/\\x00//g; # Remove nulls\n    my($len) = length($string);\n    $len;\n}",
  "    if (!defined($string)) {\n        return 0;\n    }\n    return length($string);\n\
    }", "    my $len = 0;\n    while ($string =~ /(.)/g) {\n        $len += 1;\n \
    \   }\n    return $len;\n}", "    return 0 if (!$string);\n    return length($string);\n\
    }", "    return length($string);\n}", "    $string =~ s/\\x00.*//s;\n    return\
    \ length($string);\n}", "    my($length) = 0;\n    while ($string ne \"\") {\n\
    \t$string =~ s/^.//;\n\t$length++;\n    }\n    return $length;\n}", "    return\
    \ length($string);\n}", "    return length($string);\n}", "    my($len) = 0;\n\
    \    my($char);", "    my $len = 0;\n    $len += 1 while substr($string, $len,\
    \ 1) ne \"\";\n    return $len;\n}", "    return length($string);\n}", "    my\
    \ $len = 0;\n    my @chars = split(//, $string);\n    foreach my $char (@chars)\
    \ {\n        $len++;\n    }\n    return $len;\n}", "    return length($string);\n\
    }", "    my($i);\n    for ($i = 0; $i < length($string); $i++) {\n\t$_ = substr($string,\
    \ $i, 1);\n\tif (/[\\000-\\037\\177-\\377]/) {\n\t    return -1;\n\t}\n    }\n\
    \    return $i;\n}", "    return length($string);\n}", "    my($count) = 0;\n\
    \    for (split(//, $string)) { $count++; }\n    return $count;\n}", "    return\
    \ 0 if !$string;\n    return length($string);\n}", "    return length($string);\n\
    }", "    return 0 if(!$string);\n    return length($string);\n}", '    my($len);',
  "    return length($string);\n}", "    if( $string eq \"\" ) {\n        return 0;\n\
    \    } else {\n        return length($string);\n    }\n}", '    my($count);',
  "    return length($string);\n}", "    my $len = 0;\n    for (my $i = 0; $i < length($string);\
    \ $i++) {\n        $len++;\n    }\n    return $len;\n}", '    my($length);', " \
    \   return length($string);\n}", '    my($len);', "    return length($string);\n\
    }", "    return length($string);\n}", "    return $string ? length($string) :\
    \ 0;\n}", "    my($len) = length($string);\n    return $len;\n}", "    my($i);\n\
    \    my($count) = 0;\n    for ($i = 0; $i < length($string); $i++) {\n\t$count++;\n\
    \    }\n    return $count;\n}", "    my $len = 0;\n    for ($i = 0; $i < length($string);\
    \ $i++) {\n        if (substr($string, $i, 1) ne \"\\0\") {\n            $len++;\n\
    \        }\n    }\n    return $len;\n}", "    my($length) = 0;\n    while(substr($string,\
    \ $length, 1)) {\n        $length++;\n    }\n    return $length;\n}", "    my\
    \ $len = 0;\n    $len++ while(substr($string, $len, 1));\n    return $len;\n}",
  "    if ( ! defined $string ) {\n        $string = \"\";\n    }\n    return length($string);\n\
    }", "    return CORE::length($string);\n}", "    return CORE::length($string);\n\
    }", "    return length($string);\n}", "    if ($string eq \"\") {\n        return\
    \ 0;\n    } else {\n        return 1 + strlen(substr($string, 1));\n    }\n}",
  "    return length($string);\n}", "    return length($string);\n}", "    my($count)\
    \ = 0;\n    while ($string =~ /./g) {\n\t$count++;\n    }\n    return $count;\n\
    }", "    return(length($string));\n}", "    return length($string);\n}", '    my($len);',
  "    return length($string);\n}", "    return length($string);\n}", "    return\
    \ length($string);\n}", "    my $len = 0;\n    while ($string =~ /\\G(.*?)(?:((?=.)\\\
    2{2,})|\\z)/gsc) {\n        $len += length($1) + (defined($2) ? int(length($2)/2)\
    \ : 0);\n    }\n    return $len;\n}", "    my($length) = 0;\n    for (split(//,\
    \ $string)) { $length++ }\n    return $length;\n}", "    my($ch);\n    my($len)\
    \ = 0;\n    for($i = 0; ($ch = substr($string, $i, 1)) ne \"\"; $i++) {\n\t$len++;\n\
    \    }\n    return $len;\n}", "    my($length) = 0;\n    if ($string) {\n    \
    \    $length = length($string);\n    }\n    return $length;\n}", "    return scalar(@$string);\n\
    }", "    my($len) = length($string);\n    return($len);\n}", "    my($result)\
    \ = 0;\n    return $result if(!defined($string));\n    $result = length($string);\n\
    \    return $result;\n}", "    return CORE::length($string);\n}", "    return\
    \ CORE::length($string);\n}", "    my $length = 0;\n    $length++ while substr($string,\
    \ $length, 1) ne \"\";\n    return $length;\n}", "    return length($string);\n\
    }", '    my($len);', "    return length($string);\n}", "    return length($string);\n\
    }", "    if ($string =~ /\\./) {\n\tmy $tmp = pack(\"A*\", $string);\n\treturn\
    \ length($tmp);\n    } else {\n\treturn length($string);\n    }\n}", '    my($i,
    $len);', "    return length($string);\n}", "    return length($string);\n}", " \
    \   my($length) = 0;\n    while (my($ch) = substr($string, $length, 1)) {\n\t\
    $length++;\n    }\n    return $length;\n}", "    my $len = 0;\n    foreach my\
    \ $s (split(//, $string)) {\n        $len++;\n    }\n    return $len;\n}", " \
    \   if ($string =~ /^\\s*$/) {\n        return 0;\n    }\n    else {\n       \
    \ return length($string);\n    }\n}", "    my($index);\n    my($count) = 0;",
  "    return length($string);\n}", "    my($len) = 0;\n    while ($string) {\n\t\
    $string = substr($string, 1);\n\t$len++;\n    }\n    return $len;\n}", "    if\
    \ (defined($string)) {\n        $string =~ s/\\0.*//s;\n        return length($string);\n\
    \    }\n    else {\n        return 0;\n    }\n}", "    return CORE::length($string);\n\
    }", "    return length($string);\n}", "    return(length($string));\n}", "   \
    \ return length($string);\n}", "    return $string =~ tr/\\0-\\377//;\n}", " \
    \   if ($string =~ /^((.)\\2*)$/) { return length($1); }\n    else { return 0;\
    \ }\n}", "    if ($string eq \"\") {\n        return 0;\n    } else {\n      \
    \  my($head, $tail) = (\"\", $string);\n        while ($tail ne \"\") {\n    \
    \        $head = $tail;\n            ($head, $tail) = ($tail =~ /([^,]*),(.*)/);\n\
    \        }\n        return (1 + strlen($head));\n    }\n}", "    my($i);\n   \
    \ for ($i = 0; substr($string, $i, 1) ne \"\"; $i++) {\n    }\n    return $i;\n\
    }", "    return length($string);\n}", "    return CORE::length($string);\n}",
  "    my $length = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n      \
    \  $length++;\n    }\n    return $length;\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    return(defined($string) ? length($string)\
    \ : 0);\n}", "    return length($string);\n}", '    my($result);', "    return\
    \ length($string);\n}", "    my $length = 0;\n    for (my $i = 0; $i < length($string);\
    \ $i++) {\n        $length++;\n    }\n    return $length;\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    return length($string);\n}", "    return\
    \ length($string);\n}", "    return CORE::length($string);\n}", "    return scalar\
    \ @{[$string =~ /(.)/g]};\n}", "    my($i);\n    my($length) = 0;", "    return\
    \ 0 unless defined $string;\n    return length($string);\n}", "    return $string\
    \ =~ tr/\\0-\\377//;\n}", "    return undef unless defined $string;\n    return\
    \ length($string);\n}", "    return $#+ if defined wantarray;\n    return 0 if\
    \ $#+ == -1;\n    return $#+;\n}", "    my($len) = 0;\n    while ($string) {\n\
    \t$string =~ s/^(.|\\n)//;\n\t$len++;\n    }\n    return $len;\n}", "    return(\
    \ length($string) );\n}", "    $string =~ tr/\\0//;\n    return length($string);\n\
    }", "    return CORE::length($string);\n}", "    return CORE::length($string);\n\
    }", "    my($c);\n    my($i);\n    my($len);", "    my $len = 0;\n    while ($string\
    \ =~ /^(?:.*?(.)(.*)|(.*))$/) {\n        $len++;\n        $string = $2 || $3;\n\
    \    }\n    return $len;\n}", "    return length($string);\n}", "    if (defined\
    \ $string) {\n        my $len = 0;\n        my $char;\n        for (my $i = 0;\
    \ $i < length($string); $i++) {\n            $char = substr($string, $i, 1);\n\
    \            $len++ if ($char !~ /\\n/);\n        }\n        return $len;\n  \
    \  }\n    return 0;\n}", "    my($length) = length($string);\n    return $length;\n\
    }", "    return length($string);\n}", "    if (!defined($string)) {\n        return\
    \ 0;\n    }\n    return length($string);\n}", "    my($c, $i);\n    for ($i =\
    \ 0; $c = substr($string, $i, 1); $i++) {};\n    return $i;\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    return length($string);\n}", "    return\
    \ CORE::length($string);\n}", "    return length($string);\n}", "    return sprintf(\"\
    %d\", length($string));\n}", "    my $length = 0;\n    $length += 1 while substr($string,\
    \ $length, 1) ne \"\";\n    return $length;\n}", '    my($len);']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
