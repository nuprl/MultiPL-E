name: HumanEval_23_strlen
language: pl
prompt: "# Return length of given string\n# >>> strlen(\"\")\n# 0\n# >>> strlen(\"\
  abc\")\n# 3\nsub strlen {\n    my($string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strlen;\n\
  \        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n \
  \       exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),1)) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  asdasnakj\"),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ['    my($len);', "    return length($string);\n}", "    return length($string);\n\
    }", "    return scalar @{[$string =~ /./g]};\n}", "    if(ref($string) eq 'GLOB')\
    \ {\n        seek($string, 0, SEEK_END);\n        return tell($string);\n    }\
    \ else {\n        return length($string);\n    }\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    return length($string);\n}", "    return\
    \ length($string);\n}", "    return length($string);\n}", "    return(length($string));\n\
    }", "    return length($string);\n}", "    my($count) = 0;\n    while ($string\
    \ ne \"\") {\n\t$string = substr($string, 1);\n\t$count++;\n    }\n    return\
    \ $count;\n}", "    return length($string);\n}", "    my($i);\n    $i = 0;\n \
    \   while (substr($string, $i, 1)) {\n\t$i++;\n    }\n    return $i;\n}", "  \
    \  return length($string);\n}", "    use bytes;\n    my $len = length($string);\n\
    \    no bytes;\n    return $len;\n}", "    return(length($string));\n}", "   \
    \ my($result) = 0;\n    if (defined($string)) {\n        $result = length($string);\n\
    \    }\n    return $result;\n}", "    use bytes;\n    return length($string);\n\
    }", "    my($length) = 0;\n    while ($string ne '') {\n\t$string = substr($string,\
    \ 1);\n\t$length++;\n    }\n    return $length;\n}", "    length($string);\n}",
  "    return length($string);\n}", '    my($len);', "    return length($string);\n\
    }", "    return length($string);\n}", "    my $result = 0;\n    $result++ while\
    \ $string =~ /\\G(?:\\x00-\\xFF|[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\\
    xBF][\\x80-\\xBF])/gc;\n    return $result;\n}", "    return length($string);\n\
    }", "    if (defined $string) {\n        return length($string);\n    } else {\n\
    \        return 0;\n    }\n}", '    my($count);', "    return length($string);\n\
    }", "    return length($string);\n}", '    my($len);', "    return(length($string));\n\
    }", "    return length($string);\n}", "    return length($string);\n}", "    my($length)\
    \ = length($string);\n    return $length;\n}", "    my $length = length($string);\n\
    \    return $length;\n}", "    return (defined $string ? length($string) : 0);\n\
    }", "    if ($string =~ /\\G$/gc) {\n        return pos($string);\n    } else\
    \ {\n        croak \"strlen: invalid utf8 string\";\n    }\n}", "    my($length)\
    \ = 0;\n    for(my $i = 0; $i < length($string); $i++) {\n        if(substr($string,\
    \ $i, 1) eq \"\\0\") {\n            last;\n        }\n        $length++;\n   \
    \ }\n    return $length;\n}", "    my($index);\n    my($size) = 0;", "    my($length)\
    \ = 0;\n    if (defined($string)) {\n        $length = length($string);\n    }\n\
    \    return $length;\n}", "    return length($string);\n}", "    my($i);\n   \
    \ for ($i = 0; ord(substr($string, $i, 1)) != 0; $i++) { }\n    return $i;\n}",
  "    return (undef) unless (defined($string));\n    return (length($string));\n}",
  "    return length($string);\n}", "    my $length = length($string);\n    return($length);\n\
    }", "    my($length) = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n\
    \        $length++;\n    }\n    return $length;\n}", "    my($length) = 0;\n \
    \   $length++ while (substr($string, $length, 1));\n    return $length;\n}", " \
    \   return length($string);\n}", "    my $len = 0;\n    for(0..length($string)-1)\
    \ {\n        $len++;\n    }\n    return $len;\n}", "    return length($string);\n\
    }", "    my $len = 0;\n    while ($string =~ /^(.*)$/s) {\n\t$len += length($1);\n\
    \t$string = substr($string, length($1));\n    }\n    return $len;\n}", "    $string\
    \ .= \"\"; # Force string context\n    return do { use bytes; length($string)\
    \ };\n}", "    return 0 if $string eq \"\";\n    my($length) = 0;\n    pos $string\
    \ = 0;\n    while (pos $string < length $string) {\n        if ($string =~ m/\\\
    G\\X/gco) {\n            $length++;\n        } else {\n            die \"Assertion\
    \ failed\";\n        }\n    }\n    return $length;\n}", "    my($length) = 0;\n\
    \    return $length unless ($string);\n    $length = length($string);\n    return\
    \ $length;\n}", "    return length($string);\n}", '    my($length);', "    return\
    \ length($string);\n}", "    return length($string);\n}", "    if (strlen_is_length)\
    \ {\n        return CORE::length($string);\n    } else {\n        return '*' if\
    \ substr($string, 0, 1) eq '*';\n        return scalar(() = $string =~ /[^\\0]/g);\n\
    \    }\n}", "    my $i;\n    my $len = 0;\n    my $has_utf8 = 0;", "    return\
    \ length($string);\n}", "    return undef unless defined $string;\n    return\
    \ length($string);\n}", "    $string =~ s/\\\\e\\\\[\\d+(?:;\\d+)*m//g;\n    $string\
    \ =~ s/\\\\033\\[\\d+(?:;\\d+)*m//g;\n    $string =~ s/\\\\n/\\n/g;\n    $string\
    \ =~ s/\\\\e\\\\[\\d+(?:;\\d+)*m//g;\n    $string =~ s/\\\\033\\[\\d+(?:;\\d+)*m//g;\n\
    \    return length($string);\n}", "    my($len) = 0;\n    while (substr($string,\
    \ $len, 1)) {\n\t$len++;\n    }\n    return $len;\n}", "    if(defined($string))\
    \ {\n        return(length($string));\n    } else {\n        return(0);\n    }\n\
    }", "    return CORE::length($string);\n}", "    my $length = length($string);\n\
    \    return $length;\n}", "    my($length) = 0;\n    for (my $i = 0; $i < length($string);\
    \ $i++) {\n        $length++\n    }\n    return $length;\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    return $string =~ tr/\\0-\\377//;\n\
    }", "    return length($string);\n}", "    if(!defined($string)) {\n        #\
    \ Handle undefined strings as \"\"\n        $string = \"\";\n    }\n    return\
    \ length($string);\n}", "    my $len = 0;\n    return 0 unless $string;\n    $len\
    \ += 1 while substr($string, $len, 1);\n    return $len;\n}", "    return 0 if\
    \ $string eq \"\";\n    return length($string);\n}", "    my $count = 0;\n   \
    \ while ( substr($string, $count, 1) ) {\n        $count++;\n    }\n    return\
    \ $count;\n}", "    return length($string);\n}", "    return length($string);\n\
    }", "    if (defined $string) {\n        return length($string);\n    } else {\n\
    \        return 0;\n    }\n}", "    my $len = 0;\n    for (my $i = 0; $i < length($string);\
    \ $i++) {\n        $len++;\n    }\n    return $len;\n}", "    my($i);\n    for\
    \ ($i = 0; $i < length($string); $i++) {\n    }\n    return $i;\n}", "    return\
    \ length($string);\n}", "    use bytes;\n    return length($string);\n}", '    my($length);',
  "    return length($string);\n}", "    return ($string =~ tr/ //c);\n}", "    return\
    \ length($string);\n}", "    return length($string);\n}", "    $string =~ s/\\\
    e\\[[0-9;]*[a-zA-Z]//g;\n    return length($string);\n}", "    my($length) = 0;\n\
    \    while ($string =~ /./g) {\n\t$length++;\n    }\n    return $length;\n}",
  '    my($length);', '    my($result);', "    return length($string);\n}", "    return\
    \ 0 unless defined $string;\n    return length($string);\n}", "    my($j);\n \
    \   for ($j = 0; $j < length($string); $j++) {\n    }\n    return $j;\n}", " \
    \   my($i);\n    my($length) = 0;\n    for ($i = 0; $i < length($string); $i++)\
    \ {\n\t$length++;\n    }\n    return $length;\n}", "    my($len) = 0;\n    while\
    \ ($string =~ m/(.)/g) {\n\t$len++;\n    }\n    return $len;\n}", "    my $len\
    \ = 0;\n    $len += 1 while substr($string, $len, 1) ne \"\";\n    return $len;\n\
    }", "    return length($string);\n}", '    my($count);', "    return length($string);\n\
    }", "    return 0 unless defined $string;\n    return length($string);\n}", " \
    \   my($count) = 0;\n    for (my $i = 0; $i < length($string); $i++) {\n     \
    \   $count++;\n    }\n    return $count;\n}", "    my($count) = 0;\n    while\
    \ ($string ne \"\") {\n\tif ($string =~ s/^(.).//) {\n\t    $count++;\n\t}\n \
    \   }\n    return $count;\n}", "    if( $string eq \"\" ) {\n        return 0;\n\
    \    }", "    return length($string);\n}", "    return length($string);\n}", " \
    \   return undef unless defined $string;\n    return length($string);\n}", " \
    \   return length($string);\n}", "    my $len = 0;\n    for (my $i = 0; $i < length($string);\
    \ $i++) {\n        $len++;\n    }\n    return $len;\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    my($i);\n    for ($i = 0; $i < length($string);\
    \ $i++) {}\n    return $i;\n}", "    my $len = 0;\n    for (my $i = 0; $i < length($string);\
    \ $i++) {\n        $len++;\n    }\n    return $len;\n}", "    return CORE::length($string);\n\
    }", "    return length($string);\n}", "    return 0 if(not defined $string);\n\
    \    return length($string);\n}", "    $string =~ tr/\\000-\\377//;\n    return\
    \ length($string);\n}", '    my($len);', "    if (defined $string) {\n       \
    \ return length($string);\n    } else {\n        return 0;\n    }\n}", '    my($length);',
  "    return length($string);\n}", "    if (not defined $string) {\n        return\
    \ undef;\n    } elsif ($string eq '') {\n        return 0;\n    } else {\n   \
    \     return length($string);\n    }\n}", "    return length($string);\n}", " \
    \   return length($string);\n}", "    return length($string);\n}", "    return\
    \ scalar(@{$string});\n}", "    my($length) = 0;\n    while ($string =~ /^(.*?)\\\
    b(.)/g) {\n        $length += 1;\n        $string = $1 . $2;\n    }\n    return\
    \ $length;\n}", "    return length($string);\n}", "    # YOUR CODE HERE\n}", " \
    \   return length($string);\n}", "    return length($string);\n}", "    my($numchar)\
    \ = 0;\n    foreach my $i (0..length($string)-1) {\n        if (substr($string,\
    \ $i, 1) ne \"\\0\") {\n            $numchar++;\n        }\n    }\n    return\
    \ $numchar;\n}", "    my($i);\n    my($len) = 0;\n    for ($i = 0; $i < length($string);\
    \ $i++) {\n\t$len++;\n    }\n    return $len;\n}", "    return CORE::length($string);\n\
    }", "    return length($string);\n}", "    return length($string);\n}", "    my($i);\n\
    \    my($l) = 0;\n    for ($i = 0; substr($string, $i, 1) ne ''; $i++) {\n\t$l++;\n\
    \    }\n    return $l;\n}", "    if ($string =~ /^\\s*$/) {\n        return 0;\n\
    \    } else {\n        return length($string);\n    }\n}", "    return(length($string));\n\
    }", "    return $string =~ /\\G(.*?)\\Z/m ? length($1) : 0;\n}", "    my($len)\
    \ = length($string);\n    return $len;\n}", "    return length($string);\n}",
  '    my($result);', "    return length($string);\n}", "    my $len = 0;\n    return\
    \ $len unless $string;\n    $len += 2 while substr($string, $len, 2) ne \"\";\n\
    \    return $len;\n}", "    return 0 if !defined $string;\n    return length($string);\n\
    }", "    my($i);\n    for ($i = 0; $i < length($string); $i++) {\n    }\n    return\
    \ $i;\n}", "    my($length) = length($string);\n    return $length;\n}", "   \
    \ return length($string);\n}", "    my $len = 0;\n    while ($string ne '') {\n\
    \        $string = substr($string, 1);\n        $len++;\n    }\n    return $len;\n\
    }", "    return CORE::length($string);\n}", "    return length($string);\n}",
  "    return length($string);\n}", "    return _strlen($string);\n}", "    return\
    \ length($string);\n}", "    return length($string);\n}", "    my $len = 0;\n\
    \    for (split(//, $string)) {\n        $len++;\n    }\n    return $len;\n}",
  "    if(!defined($string)) {\n        $string = '';\n    }\n    return length($string);\n\
    }", "    my($length) = scalar(@{$string});\n    return $length;\n}", "    return\
    \ CORE::length($string);\n}", "    return length($string);\n}", "    return length($string);\n\
    }", "    return length($string);\n}", "    return length($string);\n}", "    return\
    \ length($string);\n}", "    my($length) = length($string);\n    &write_log(\"\
    strlen string=$string, length=$length\");\n    return $length;\n}", "    return\
    \ 0 if !$string;\n    return length($string);\n}", "    return scalar @{[$string\
    \ =~ /(.*)/g]};\n}", "    return(length($string));\n}", "    return length($string);\n\
    }", '    my($length);', "    $string =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack(\"C\"\
    , hex($1))/eg;\n    return length($string);\n}", "    my($length) = 0;\n    $length\
    \ += 1 while(substr($string, $length, 1));\n    return $length;\n}", "    my($x);\n\
    \    my($len) = 0;\n    for($x = 0; $x < length($string); $x++) {\n\t$len += length(substr($string,\
    \ $x, 1));\n    }\n    return $len;\n}", "    return length($string);\n}", " \
    \   return length($string);\n}", "    return CORE::length($string);\n}", "   \
    \ return length($string);\n}", "    my($length) = 0;\n    foreach (split(//, $string))\
    \ {\n        $length++;\n    }\n    return $length;\n}", "    if ($string =~ /.*(.).*/)\
    \ {\n        return length($string);\n    } else {\n        return 0;\n    }\n\
    }", "    my $length = 0;\n    my $p = $string;\n    while (defined $p && $p ne\
    \ '') {\n        $length++;\n        $p = substr($p, 1);\n    }\n    return $length;\n\
    }", "    return 0 if(not defined $string);\n    my $len = length($string);\n \
    \   return $len;\n}", "    return length($string);\n}", "    return length($string);\n\
    }", "    return 0 unless defined $string;\n    my $pos = 0;\n    for (;;) {\n\
    \        my $char = substr($string, $pos, 1);\n        return $pos unless defined\
    \ $char;\n        $pos++;\n    }\n}", "    return length($string);\n}", "    return\
    \ CORE::length($string);\n}", "    use bytes;\n    return length($string);\n}",
  "    if (is_string($string)) {\n        return length($string);\n    }\n    return\
    \ undef;\n}", "    return scalar(@$string);\n}", "    return 0 unless defined\
    \ $string;\n    my @chars = split //, $string;\n    my $length = scalar @chars;\n\
    \    return $length;\n}", "    my($s) = 0;\n    while (substr($string, $s, 1))\
    \ {\n\t$s++;\n    }\n    return $s;\n}", "    use bytes;\n    return length($string);\n\
    }", "    my($len) = length($string);\n    $DEBUG && print(\"==> string length:\
    \ $len\\n\");\n    return $len;\n}", "    my($len) = 0;\n    while ($string =~\
    \ /^([^\\0]*)(\\0)?(.*)$/) {\n\t$len += length($1);\n\tlast unless defined $2;\n\
    \t$string = $3;\n    }\n    return $len;\n}", "    return length($string);\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
