name: HumanEval_34_unique
language: pl
prompt: "# Return sorted unique elements in an array\n# >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n\
  \        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9,\
  \ 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my(%unique) = ();\n    my(@uniqe);\n    foreach my $i (@$l) {\n\
    \        $unique{$i} = 1;\n    }\n    my(@unique) = keys %unique;\n    return\
    \ sort { $a <=> $b } @unique;\n}", "    my(%seen, @u);\n    foreach my $x (@$l)\
    \ {\n        push(@u, $x) unless $seen{$x}++;\n    }\n    return [sort {$a <=>\
    \ $b} @u];\n}", "    my %seen;\n    my @uniq = grep { !$seen{$_}++ } @$l;\n  \
    \  return \\@uniq;\n}", "    my(%seen);\n    grep(!$seen{$_}++, @$l);\n}", " \
    \   my(%uniq);\n    @uniq{@$l} = ();\n    return [ sort { $a <=> $b } keys %uniq\
    \ ];\n}", "    my @a = sort { $a <=> $b } @$l;\n    my $last = -1;\n    return\
    \ grep { $last != ($last = $_) } @a;\n}", "    my(%hash);\n    foreach (@$l) {\n\
    \        $hash{$_} = 1;\n    }\n    return sort {$a <=> $b} keys %hash;\n}", " \
    \   return @{uniq(ref($l) eq 'ARRAY' ? $l : [$l])};\n}", "    my @u = ();\n  \
    \  my %u = ();\n    my @s = sort { $a <=> $b } @$l;\n    for my $x (@s) {\n  \
    \      next if defined $u{$x};\n        push @u, $x;\n        $u{$x} = 1;\n  \
    \  }\n    return @u;\n}", "    my(%seen);\n    my(@result);\n    foreach my $item\
    \ (@$l) {\n        unless ($seen{$item}) {\n            $seen{$item} = 1;\n  \
    \          push(@result, $item);\n        }\n    }\n    @result = sort { $a <=>\
    \ $b } @result;\n    return \\@result;\n}", "    my(%h, @r);\n    grep(!$h{$_}++,\
    \ @$l);\n}", "    my(%h, $e);\n    for $e (@$l) {\n        $h{$e}++;\n    }\n\
    \    return [ sort { $a <=> $b } keys %h ];\n}", "    my(%h, @u);\n    foreach\
    \ (@$l) {\n        push(@u, $_) unless $h{$_}++;\n    }\n    return \\@u;\n}",
  "    my @u = ();\n    my %lu = ();\n    foreach (@$l) {\n        push(@u, $_) unless\
    \ $lu{$_}++;\n    }\n    return @u;\n}", "    my $h = {};\n    foreach(@$l) {\n\
    \        $h->{$_} = 1;\n    }\n    my @a = sort {$a <=> $b} keys %$h;\n    return\
    \ \\@a;\n}", "    return () unless $l;\n    my @res = sort { $a <=> $b } @$l;\n\
    \    my @out;\n    my $last = $res[0];\n    push @out, $last;\n    for (@res)\
    \ {\n        push @out, $_ unless $_ == $last;\n        $last = $_;\n    }\n \
    \   return @out;\n}", "    if(!$l) { return (); }\n    my @m = sort { $a <=> $b\
    \ } @$l;\n    my @res = ();\n    my $last = -1;\n    foreach my $v (@m) {\n  \
    \      if($v != $last) {\n            push(@res, $v);\n            $last = $v;\n\
    \        }\n    }\n    return @res;\n}", "    my @list = ();\n    my %hash = ();\n\
    \    for my $e (@$l) {\n        next if $hash{$e};\n        $hash{$e} = 1;\n \
    \       push @list, $e;\n    }\n    return \\@list;\n}", "    my @res = sort {\
    \ $a <=> $b } @$l;\n    return \\@res;\n}", "    my(%h);\n    foreach my $e (@$l)\
    \ {\n        $h{$e} = 1;\n    }\n    return [ sort { $a <=> $b } keys %h ];\n}",
  "    my %h;\n    return sort grep !$h{$_}++, @$l;\n}", "    my %h;\n    return(grep(!$h{$_}++,\
    \ @$l));\n}", "    my(%h, $key);\n    foreach $key (@$l) {\n        $h{$key} =\
    \ 1;\n    }\n    return sort(keys(%h));\n}", "    return if !defined $l;\n   \
    \ my %hash = map {$_ => 1} @$l;\n    return [sort keys %hash];\n}", "    my @res\
    \ = sort { $a <=> $b } grep { defined } map { @$_ } @$l;\n    return wantarray\
    \ ? @res : \\@res;\n}", "    my(%h);\n    my($e);\n    foreach $e (@$l) {\n  \
    \      $h{$e} = 1;\n    }\n    return keys %h;\n}", "    my %r;\n    my @u;\n\
    \    foreach my $e (@$l) {\n        push(@u, $e) unless $r{$e}++;\n    }\n   \
    \ return @u;\n}", "    my %s;\n    grep {!$s{$_}++} @$l;\n}", "    my %seen;\n\
    \    my @out;\n    foreach my $v (@$l) {\n        if (!exists $seen{$v}) {\n \
    \           push @out, $v;\n            $seen{$v} = 1;\n        }\n    }\n   \
    \ return @out;\n}", "    my @x = sort @$l;\n    my $u = [];\n    push @$u, shift\
    \ @x;\n    for my $x (@x) {\n        push @$u, $x if $x != $u->[-1];\n    }\n\
    \    return $u;\n}", "    my %hash = ();\n    map { $hash{$_}++ == 0 ? $_ : ()\
    \ } @$l;\n}", "    my(%h, @u);\n    foreach (@$l) {\n        unless ($h{$_}) {\n\
    \            $h{$_} = 1;\n            push(@u, $_);\n        }\n    }\n    @u;\n\
    }", "    my(%seen);\n    my(@c);\n    return sort{$a <=> $b} grep(!$seen{$_}++,\
    \ @$l);\n}", "    my %seen;\n    return sort grep { not $seen{$_}++ } @$l;\n}",
  "    my %u;\n    $u{$_} = 1 foreach @$l;\n    return sort { $a <=> $b } keys %u;\n\
    }", "    my %seen;\n    my @u = grep { !$seen{$_}++ } @$l;\n    return @u;\n}",
  "    my %s;\n    map { $s{$_} = 1 } @$l;\n    sort { $a <=> $b } keys %s;\n}", " \
    \   my %s;\n    @s{@$l} = @$l;\n    return [ sort { $a <=> $b } keys %s ];\n}",
  "    my(%hash);\n    my($v);\n    foreach $v (@$l) {\n        $hash{$v} = 1;\n \
    \   }\n    my(@list) = sort(keys(%hash));\n    return @list;\n}", "    my @l =\
    \ sort { $a <=> $b } @$l;\n    my @u;\n    for my $v (@l) {\n        push @u,\
    \ $v if not @u or $u[-1] != $v;\n    }\n    @u;\n}", "    my %seen;\n    $seen{$_}++\
    \ for (@$l);\n    my @unique = sort { $a <=> $b } keys %seen;\n    return @unique;\n\
    }", "    my(%h, @r);\n    foreach (@$l) {\n        $h{$_}++;\n    }\n    foreach\
    \ (sort keys %h) {\n        push(@r, $_);\n    }\n    @r;\n}", "    my %h;\n \
    \   for (@$l) {\n        $h{$_} = 1;\n    }\n    my @a = sort { $a <=> $b } keys\
    \ %h;\n    return \\@a;\n}", "    my %g = ();\n    my @r = ();\n    foreach (@$l)\
    \ {\n        push(@r, $_) unless($g{$_});\n        $g{$_} = 1;\n    }\n    return\
    \ @r;\n}", "    my %h;\n    for my $e (@$l) {\n        $h{$e} = 1;\n    }\n  \
    \  sort { $a <=> $b } keys %h;\n}", "    my @ret = ();\n    my %seen = ();\n \
    \   foreach my $i (@$l) {\n        if (! exists $seen{$i}) {\n            push\
    \ @ret, $i;\n            $seen{$i} = 1;\n        }\n    }\n    return @ret;\n}",
  "    my %h;\n    @h{@$l} = ();\n    return [sort {$a <=> $b} keys %h];\n}", "  \
    \  my %seen;\n    return sort { $a <=> $b } grep { !$seen{$_}++ } @$l;\n}", " \
    \   return () unless defined $l;\n    my(%h, $k, @r);\n    foreach $k (@$l) {\n\
    \        $h{$k}++;\n    }\n    @r = sort { $a <=> $b } keys %h;\n    return @r;\n\
    }", "    my(%seen);\n    return sort grep(!$seen{$_}++, @$l);\n}", "    my @l\
    \ = sort { $a <=> $b } @$l;\n    my %l;\n    for my $x (@l) {\n        $l{$x}\
    \ = 1;\n    }\n    return [keys %l];\n}", "    my(%h, $e);\n    foreach $e (@$l)\
    \ {\n        $h{$e} = $e;\n    }\n    return [sort {$a <=> $b} values %h];\n}",
  "    my %unique = ();\n    my @unique = ();\n    foreach my $e (@$l) {\n       \
    \ if(!exists($unique{$e})) {\n            $unique{$e} = 1;\n            push(@unique,\
    \ $e);\n        }\n    }\n    return @unique;\n}", "    my %h;\n    map {$h{$_}\
    \ = 1} @$l;\n    return sort {$a <=> $b} keys %h;\n}", "    my $h = {};\n    @$h{@$l}\
    \ = ();\n    [sort {$a <=> $b} keys %$h];\n}", "    my %unique;\n    @unique{@$l}\
    \ = ();\n    return sort keys %unique;\n}", "    my %c;\n    my @r;\n    foreach\
    \ my $x (@$l) {\n        push(@r, $x) unless $c{$x}++;\n    }\n    return sort\
    \ { $a <=> $b } @r;\n}", "    my %seen;\n    return sort grep !$seen{$_}++, @$l;\n\
    }", "    my $i;\n    my %seen;\n    my @uniq;\n    foreach $i (@$l) {\n      \
    \  if (!$seen{$i}) {\n            push(@uniq, $i);\n            $seen{$i} = 1;\n\
    \        }\n    }\n    return @uniq;\n}", "    my @v = sort { $a <=> $b } @$l;\n\
    \    my $prev = 0;\n    my @out;\n    foreach my $v (@v) {\n        if ($v !=\
    \ $prev) {\n            push @out, $v;\n            $prev = $v;\n        }\n \
    \   }\n    return @out;\n}", "    my(%h, @a);\n    foreach (@$l) {\n        $h{$_}\
    \ = 1;\n    }\n    foreach (sort keys %h) {\n        push(@a, $_);\n    }\n  \
    \  return \\@a;\n}", "    my(%h, @u);\n    foreach (@$l) {\n        $h{$_}++ unless\
    \ exists $h{$_};\n    }\n    @u = sort { $a <=> $b } keys %h;\n    wantarray ?\
    \ @u : \\@u;\n}", "    my %uniq;\n    map { $uniq{$_} = 1 } @$l;\n    return sort\
    \ { $a <=> $b } keys %uniq;\n}", "    my @u = sort { $a <=> $b } @$l;\n    my\
    \ @r;\n    while(@u) {\n        push @r, shift @u;\n        while(@u and $u[0]\
    \ == $r[-1]) {\n            shift @u;\n        }\n    }\n    return @r;\n}", " \
    \   my(%h, $n);\n    map {\n\t$h{$_}++;\n    } @$l;\n    sort {$a <=> $b} keys\
    \ %h;\n}", "    return sort keys %{{ map { $_ => 1 } @$l }};\n}", "    my(%r);\n\
    \    foreach my $e (@$l) {\n        $r{$e} = 1;\n    }\n    return [sort {$a <=>\
    \ $b} keys %r];\n}", "    my(%s);\n    map {$s{$_}++} @$l;\n    sort {$a <=> $b}\
    \ keys %s;\n}", "    my(%h, @r);\n    grep(defined($h{$_}) ? 0 : ($h{$_} = 1),\
    \ @$l);\n    foreach (sort keys %h) {\n        push(@r, $_);\n    }\n    return\
    \ @r;\n}", "    my(%t);\n    foreach my $e (@$l) {\n        $t{$e} = 1;\n    }\n\
    \    my(@l) = sort(keys(%t));\n    return \\@l;\n}", "    my %e;\n    @e{@$l}\
    \ = ();\n    my @o = sort keys %e;\n    return @o;\n}", "    my %seen;\n    grep\
    \ {not $seen{$_}++} @$l;\n}", "    my %s;\n    @s{@$l} = ();\n    return [sort\
    \ {$a <=> $b} keys %s];\n}", "    return sort { $a <=> $b } keys %{{ map { $_\
    \ => 1 } @$l }};\n}", "    my %s;\n    map { $s{$_} = 1 } @$l;\n    sort { $a\
    \ <=> $b } keys %s;\n}", "    my %s;\n    for (@$l) {\n        $s{$_} = 1;\n \
    \   }\n    sort { $a <=> $b } keys %s;\n}", "    my %h;\n    my $i;\n    for ($i\
    \ = 0; $i < @$l; $i++) {\n        $h{$l->[$i]} = $i;\n    }\n    return [sort\
    \ {$a <=> $b} keys %h];\n}", "    my %s;\n    grep { !$s{$_}++ } @$l;\n}", " \
    \   my @u = sort { $a <=> $b } @$l;\n    shift @u while @u > 1 && $u[0] == $u[1];\n\
    \    pop @u while @u > 1 && $u[-1] == $u[-2];\n    return @u;\n}", "    my(%l);\n\
    \    @l{@$l} = ();\n    my(@u) = sort {$a <=> $b} keys %l;\n    return @u;\n}",
  "    return keys %{{ map { $_ => 1 } @$l }};\n}", "    if(ref($l) eq 'ARRAY') {\n\
    \        my %seen = ();\n        my @ret = ();\n        foreach my $i (@$l) {\n\
    \            if(!defined($seen{$i})) {\n                $seen{$i} = 1;\n     \
    \           push(@ret, $i);\n            }\n        }\n        return sort { $a\
    \ <=> $b } @ret;\n    } else {\n        return ();\n    }\n}", "    my(%u, @u);\n\
    \    foreach (@$l) {\n        push(@u, $_) unless $u{$_}++;\n    }\n    sort {\
    \ $a <=> $b } @u;\n}", "    my $h = {};\n    foreach my $e (@$l) {\n        $h->{$e}\
    \ = 1;\n    }\n    return [sort keys %$h];\n}", "    my(%a);\n    grep(!$a{$_}++,\
    \ @$l);\n}", "    my %h;\n    foreach my $e (@$l) {\n        $h{$e} = 1;\n   \
    \ }\n    return [sort keys %h];\n}", "    return sort({$a <=> $b} keys %{{map\
    \ {$_ => 1} @$l}});\n}", "    my(%s);\n    foreach my $x (@$l) {\n        $s{$x}\
    \ = 1;\n    }\n    return sort { $a <=> $b } keys %s;\n}", "    my(%h);\n    foreach\
    \ (@$l) {\n        $h{$_}++;\n    }\n    return sort { $a <=> $b } keys %h;\n}",
  "    my %h;\n    for my $a (@$l) {\n        $h{$a} = $a;\n    }\n    return sort\
    \ { $a <=> $b } values %h;\n}", "    my %h;\n    $h{$_}++ for @$l;\n    return\
    \ sort { $a <=> $b } keys %h;\n}", "    my $h = {};\n    foreach my $e (@$l) {\n\
    \        $h->{$e} = 1;\n    }\n    return [ sort { $a <=> $b } keys %$h ];\n}",
  "    my %u;\n    return (sort {$a <=> $b} grep !$u{$_}++, @$l);\n}", "    my(%u,\
    \ $l);\n    @u{@$l} = ();\n    return [sort keys %u];\n}", "    my(%x);\n    my($e);\n\
    \    foreach $e (@$l) {\n        $x{$e} = $e;\n    }\n    return [sort(values(%x))];\n\
    }", "    my %s;\n    map { $s{$_} = 1 } @$l;\n    sort keys %s;\n}", "    my %h;\n\
    \    foreach (@$l) {\n        $h{$_} = 1;\n    }\n    return sort keys %h;\n}",
  "    my(%t);\n    map($t{$_}++, @$l);\n    return sort(keys(%t));\n}", "    my %h;\n\
    \    foreach(@$l) {\n        $h{$_}++;\n    }\n    return [sort keys %h];\n}",
  "    my @l = $l;\n    @l = sort { $a <=> $b } @l;\n    my $i = 0;\n    my $j = 0;\n\
    \    my @u = ();\n    $u[$j++] = $l[$i++];\n    while ($i < @l) {\n        if\
    \ ($l[$i] != $l[$i-1]) {\n            $u[$j++] = $l[$i];\n        }\n        $i++;\n\
    \    }\n    return @u;\n}", "    my %seen;\n    my @u = grep { !$seen{$_}++ }\
    \ @$l;\n    return \\@u;\n}", "    my(%uniq);\n    foreach my $e (@$l) {\n   \
    \     $uniq{$e} = 1;\n    }\n    return sort { $a <=> $b } keys %uniq;\n}", " \
    \   my @s = sort { $a <=> $b } @$l;\n    my $last;\n    my @u;\n    for (@s) {\n\
    \        push @u, $_ unless $_ == $last;\n        $last = $_;\n    }\n    return\
    \ @u;\n}", "    my(%s, $r);\n    foreach $r (@$l) {\n        $s{$r} = 1;\n   \
    \ }\n    return sort { $a <=> $b } keys %s;\n}", "    my %h;\n    $h{$_} = 1 foreach\
    \ @$l;\n    [keys %h];\n}", "    return @{sort {$a <=> $b} keys %{{map {$_ =>\
    \ 1} @$l}}};\n}", "    my %h;\n    foreach my $x (@$l) {\n        $h{$x} = 1;\n\
    \    }\n    return sort keys %h;\n}", "    my(%h, $e, @u);\n    foreach $e (@$l)\
    \ {\n        $h{$e}++;\n    }\n    foreach $e (sort keys %h) {\n        push(@u,\
    \ $e);\n    }\n    return @u;\n}", "    my %h;\n    @h{@$l} = ();\n    return\
    \ [sort keys %h];\n}", "    my(%u, @u);\n    grep(!$u{$_}++, @$l);\n}", "    my\
    \ @l = @$l;\n    return [] unless @l;\n    my %h;\n    @h{@l} = ();\n    return\
    \ [sort {$a <=> $b} keys %h];\n}", "    my %s;\n    @s{@$l} = ();\n    return\
    \ [sort keys %s];\n}", "    my %s;\n    my @u;\n    my $e;\n    foreach $e (@$l)\
    \ {\n        push(@u, $e) unless $s{$e}++;\n    }\n    return [sort {$a <=> $b}\
    \ @u];\n}", "    my %seen;\n    grep { not $seen{$_}++ } @$l;\n}", "    my %m;\n\
    \    foreach my $e (@$l) {\n        $m{$e} = 1;\n    }\n    return [ sort { $a\
    \ <=> $b } keys %m ];\n}", "    my $i = 0;\n    my %s;\n    map { $s{$_}=++$i\
    \ } @$l;\n    return sort { $s{$a} <=> $s{$b} } keys %s;\n}", "    my %seen;\n\
    \    my @uniq = sort grep { !$seen{$_}++ } @$l;\n    return @uniq;\n}", "    my\
    \ %h;\n    my @u;\n    foreach my $e (@$l) {\n        unless ($h{$e}) {\n    \
    \        $h{$e} = 1;\n            push @u, $e;\n        }\n    }\n    return sort\
    \ { $a <=> $b } @u;\n}", "    my @m = sort { $a <=> $b } @$l;\n    my @u;\n  \
    \  my $p = undef;\n    for my $x (@m) {\n        next if defined $p && $p == $x;\n\
    \        push @u, $x;\n        $p = $x;\n    }\n    return @u;\n}", "    my %h;\n\
    \    return () unless defined $l;\n    $h{$_}++ for @$l;\n    my @r = sort { $a\
    \ <=> $b } keys %h;\n    \\@r;\n}", "    my %uniq = ();\n    @uniq{@$l} = ();\n\
    \    return [sort {$a <=> $b} keys %uniq];\n}", "    my @a = sort keys %{{ map\
    \ { $_ => 1 } @$l }};\n    return \\@a;\n}", "    my @r = sort(keys %{{map {$_\
    \ => 1} @$l}});\n    return \\@r;\n}", "    my(%h);\n    map {$h{$_} = 1} @$l;\n\
    \    return sort {$a <=> $b} keys %h;\n}", "    my @u = ();\n    my %u = ();\n\
    \    foreach my $a (@$l) {\n        $u{$a} = 1;\n    }\n    foreach my $k (sort\
    \ {$a <=> $b} keys %u) {\n        push @u, $k;\n    }\n    return \\@u;\n}", " \
    \   my %h;\n    map { $h{$_} = undef } @$l;\n    return sort { $a <=> $b } keys\
    \ %h;\n}", "    my(%a, @u);\n    foreach (@$l) {\n        $a{$_} = 1;\n    }\n\
    \    return keys %a;\n}", "    my(%u, @r);\n    map { $u{$_}++ } @$l;\n    @r\
    \ = sort keys %u;\n    return \\@r;\n}", "    my @ul;\n    $#ul = $#$l;\n    my\
    \ %ul;\n    my $i;\n    for ($i = 0; $i <= $#$l; $i++) {\n        unless (exists\
    \ $ul{$l->[$i]}) {\n            $ul{$l->[$i]} = 1;\n            $ul[$i] = $l->[$i];\n\
    \        }\n    }\n    @ul = sort { $a <=> $b } @ul;\n    for ($i = 0; $i <= $#ul;\
    \ $i++) {\n        unless (defined $ul[$i]) {\n            splice(@ul, $i);\n\
    \            last;\n        }\n    }\n    return @ul;\n}", "    my(%seen, $e);\n\
    \    return grep { !$seen{$_}++ } @$l;\n}", "    my(%h, @a);\n    map { $h{$_}\
    \ = 1 } @$l;\n    @a = sort keys %h;\n    return \\@a;\n}", "    my(%h, $r);\n\
    \    foreach $r (@$l) { $h{$r} = 1; }\n    return(sort keys %h);\n}", "    my(%h);\n\
    \    my($e);\n    my(@u);", "    my(%h, @unique);\n    for (@$l) { $h{$_} = 1\
    \ }\n    for (keys %h) { push @unique, $_ }\n    return \\@unique;\n}", "    @$l\
    \ = sort @$l;\n    my $i = 0;\n    my $j = 1;\n    while ($j < @$l) {\n      \
    \  if ($l->[$i] == $l->[$j]) {\n            $j++;\n        } else {\n        \
    \    $i++;\n            $l->[$i] = $l->[$j];\n            $j++;\n        }\n \
    \   }\n    @$l = @$l[0..$i];\n    return $l;\n}", "    my %h;\n    for (@$l) {\n\
    \        $h{$_} = 1;\n    }\n    return [ sort { $a <=> $b } keys %h ];\n}", " \
    \   return [] unless $l;\n    my %i;\n    for (@$l) {\n        $i{$_} = 1;\n \
    \   }\n    return [ sort keys %i ];\n}", "    my %h;\n    @h{@$l} = ();\n    return\
    \ [sort keys %h];\n}", "    my(%seen, @out);\n    grep(!$seen{$_}++, @$l);\n}",
  "    my %h;\n    map { $h{$_}++ } @$l;\n    return sort keys %h;\n}", "    return\
    \ sort(keys(%{{map {$_ => 1} @$l}}));\n}", "    my(%s, $e);\n    foreach $e (@$l)\
    \ {\n        $s{$e} = 1;\n    }\n    return [ sort { $a <=> $b } keys %s ];\n}",
  "    my @uniq;\n    undef %seen;\n    foreach $elt (@$l) {\n        next if $seen{$elt};\n\
    \        push(@uniq, $elt);\n        $seen{$elt} = 1;\n    }\n    @uniq;\n}",
  "    return sort keys %{{ map { $_ => 1 } @$l }};\n}", "    my(%u, @x);\n    foreach\
    \ (@$l) {\n        push(@x, $_) unless $u{$_}++;\n    }\n    @x;\n}", "    return\
    \ scalar(keys %{{map {$_ => 1} @$l}});\n}", "    my %vals = ();\n    foreach my\
    \ $v (@$l) {\n        $vals{$v} = 1;\n    }\n    my @list = sort { $a <=> $b }\
    \ keys %vals;\n    return @list;\n}", "    my %seen;\n    my @unique = grep {\
    \ !$seen{$_}++ } @$l;\n    return \\@unique;\n}", "    my(%a, $e);\n    grep(!$a{$_}++,\
    \ @$l);\n}", "    return () unless defined $l;\n    my(%h);\n    map {$h{$_} =\
    \ 1} @$l;\n    return [sort keys %h];\n}", "    return sort { $a <=> $b } keys\
    \ %{{ map { $_ => 1 } @$l }};\n}", "    my %v;\n    map { $v{$_} = 1 } @$l;\n\
    \    sort keys %v;\n}", "    my(%h, $e, @r);\n    map { $h{$_} = 1 } @$l;\n  \
    \  foreach $e (sort { $a <=> $b } keys %h) {\n        push(@r, $e);\n    }\n \
    \   return @r;\n}", "    my $u = [];\n    my $h = {};\n    foreach my $e (@$l)\
    \ {\n        $h->{$e} = $e;\n    }\n    push @$u, sort { $a <=> $b } (values %$h);\n\
    \    return $u;\n}", "    return sort { $a <=> $b } keys %{{ map { $_ => 1 } @$l\
    \ }};\n}", "    my(%h, @u);\n    foreach (@$l) { $h{$_} = 1 }\n    @u = sort {\
    \ $a <=> $b } keys %h;\n    return @u;\n}", "    my %h;\n    map { $h{$_} = 1\
    \ } @$l;\n    sort keys %h;\n}", "    my @l = sort { $a <=> $b } grep { defined\
    \ } @$l;\n    my $last = -1;\n    my @ul = ();\n    for (@l) {\n        push @ul,\
    \ $_ if $_ != $last;\n        $last = $_;\n    }\n    return \\@ul;\n}", "   \
    \ my(%h, @r);\n    foreach (@$l) { $h{$_} = 1; }\n    foreach (sort { $a <=> $b\
    \ } keys %h) { push(@r, $_); }\n    return @r;\n}", "    my @r = ();\n    my %h\
    \ = ();\n    foreach(@$l) {\n        $h{$_} = 1;\n    }\n    @r = sort {$a <=>\
    \ $b} keys %h;\n    return \\@r;\n}", "    my(%h, @r);\n    foreach (@$l) { $h{$_}\
    \ = 1; }\n    foreach (sort { $a <=> $b } keys %h) { push(@r, $_); }\n    return\
    \ @r;\n}", "    my %elements;\n    my @unique;\n    foreach (@$l) {\n        push\
    \ @unique, $_ if !$elements{$_}++;\n    }\n    return @unique;\n}", "    my(%seen,\
    \ @res);\n    foreach(@$l) {\n        push(@res, $_) unless $seen{$_}++;\n   \
    \ }\n    return \\@res;\n}", "    my %h;\n    @h{@$l} = ();\n    return sort {$a\
    \ <=> $b} keys %h;\n}", "    my %h;\n    @h{@$l} = (1) x @$l;\n    [ sort { $a\
    \ <=> $b } keys %h ];\n}", "    my %h;\n    @h{@$l} = ();\n    return sort {$a\
    \ <=> $b} keys %h;\n}", "    return sort { $a <=> $b } ( keys %{{ map { $_ =>\
    \ 1 } @$l }});\n}", "    my @res = ();\n    my %seen = ();\n    foreach (@$l)\
    \ {\n        push(@res, $_) unless ($seen{$_}++);\n    }\n    @res;\n}", "   \
    \ my(%seen, @res);\n    foreach my $e (@$l) {\n        push(@res, $e) unless $seen{$e}++;\n\
    \    }\n    return [sort {$a <=> $b} @res];\n}", "    my %h;\n    my @u;\n   \
    \ foreach my $e (@$l) {\n        unless (exists $h{$e}) {\n            $h{$e}\
    \ = 1;\n            push @u, $e;\n        }\n    }\n    return @u;\n}", "    my\
    \ %h;\n    my @r;\n    foreach my $e (@$l) {\n        push(@r, $e) unless ($h{$e}++);\n\
    \    }\n    return @r;\n}", "    my %h;\n    foreach my $e (@$l) {\n        $h{$e}\
    \ = 1;\n    }\n    return sort keys %h;\n}", "    my %unq;\n    @unq{@$l} = ();\n\
    \    [keys %unq];\n}", "    my $ret = {};\n    foreach my $v (@$l) {\n       \
    \ $ret->{$v} = 1;\n    }\n    return sort { $a <=> $b } keys %$ret;\n}", "   \
    \ my(%m, $e);\n    grep(!$m{$_}++, @$l);\n}", "    return map { $_->[0] } sort\
    \ { $a->[1] <=> $b->[1] }\n        map { [$_, unpack('C*', $_)] } @$l;\n}", " \
    \   my %h;\n    for (@$l) {\n        $h{$_} = 1;\n    }\n    my @l = sort keys\
    \ %h;\n    return \\@l;\n}", "    my(%h, @l);\n    map { $h{$_} = 1 } @$l;\n \
    \   foreach (sort { $a <=> $b } keys %h) {\n        push(@l, $_);\n    }\n   \
    \ return @l;\n}", "    my(%m, $r);\n    map { $m{$_}++ } @$l;\n    map { push(@$r,\
    \ $_) } sort keys %m;\n    return $r;\n}", "    # my(@u, %seen);\n    # foreach\
    \ my $e (@$l) {\n    #     push(@u, $e) unless $seen{$e}++;\n    # }\n    # return\
    \ \\@u;\n    return [keys %{{ map { $_ => 1 } @$l }}];\n}", "    my %h;\n    @h{@$l}\
    \ = @$l;\n    return [ sort keys %h ];\n}", "    my %seen;\n    return grep {\
    \ !$seen{$_}++ } @$l;\n}", "    my %h;\n    @h{@$l} = ();\n    return [sort {$a\
    \ <=> $b} keys %h];\n}", "    my(%uniq) = ();\n    my($e);\n    foreach $e (@$l)\
    \ {\n        $uniq{$e} = 1;\n    }\n    return [sort(keys(%uniq))];\n}", "   \
    \ @_ = sort { $a <=> $b } @$l;\n    @_ = grep { !$count{$_}++ } @_;\n    \\@_;\n\
    }", "    my %a;\n    @a{@$l} = ();\n    return [sort {$a <=> $b} keys %a];\n}",
  "    @{$l} = sort(@{$l});\n    return grep { (not $_ eq $l->[$_ - 1]) } 0..(scalar(@{$l})\
    \ - 1);\n}", "    my(%h, @u);\n    foreach my $e (@$l) {\n        $h{$e} = 1;\n\
    \    }\n    @u = sort { $a <=> $b } keys %h;\n    return wantarray ? @u : \\@u;\n\
    }", "    my(%h, @r);\n    for (@$l) {\n        push(@r, $_) unless $h{$_}++;\n\
    \    }\n    @r;\n}", "    my %seen;\n    my @uniq = sort { $a <=> $b } grep {\
    \ !$seen{$_}++ } @$l;\n    return \\@uniq;\n}", "    my(%h);\n    foreach my $e\
    \ (@$l) {\n        $h{$e}++;\n    }\n    return sort { $a <=> $b } keys %h;\n}",
  "    my(%h);\n    foreach my $n (@$l) {\n        $h{$n} = 1;\n    }\n    return\
    \ sort { $a <=> $b } keys %h;\n}", "    my(%h, @ret);\n    foreach (@$l) {\n \
    \       $h{$_} = 1;\n    }\n    push(@ret, sort(keys(%h)));\n    return \\@ret;\n\
    }", "    my $al = scalar(@$l);\n    my @l = sort { $a <=> $b } @$l;\n    my $i\
    \ = 0;\n    my $j = 0;\n    while($i < $al) {\n        while($j < $al && $l[$i]\
    \ == $l[$j]) {\n            $j++;\n        }\n        splice(@l, $i+1, $j-$i-1);\n\
    \        $i++;\n        $j = $i;\n    }\n    return @l;\n}", "    return sort(\
    \ keys(%{{ map { $_=>1 } @$l }}));\n}", "    my(%u, $e);\n    foreach $e (@$l)\
    \ { $u{$e} = 1; }\n    return sort keys %u;\n}", "    my %v;\n    foreach (@$l)\
    \ {\n        $v{$_} = 1;\n    }\n    my @result = sort { $a <=> $b } keys %v;\n\
    \    return @result;\n}", "    my @l = @$l;\n    @l = sort @l;\n    @l = grep\
    \ { my $i=$_; !grep { $i == $_ } @l[0..$_-1] } @l;\n    return \\@l;\n}", "  \
    \  my @unq = ();\n    my %s = ();\n    foreach my $e (@$l) {\n        $s{$e} =\
    \ 1;\n    }\n    foreach my $e (sort {$a <=> $b} keys %s) {\n        push @unq,\
    \ $e;\n    }\n    return \\@unq;\n}", "    my %s;\n    @s{@$l} = ();\n    return\
    \ sort keys %s;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
