name: HumanEval_34_unique
language: pl
prompt: "# Return sorted unique elements in an array\n# >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n\
  \        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9,\
  \ 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    if(!@$l) {\n        return @$l;\n    }", "    return undef unless\
    \ defined $l;\n    my @l = @$l;\n    my %seen = ();\n    my @unique = grep { !\
    \ $seen{$_} ++ } @l;\n    return @unique;\n}", "    my(%h, @u);\n    grep($h{$_}++\
    \ == 0, @$l);\n    keys(%h);\n}", "    my(%s, @u);\n    map { $s{$_} = undef }\
    \ @$l;\n    @u = sort { $a <=> $b } keys %s;\n    return \\@u;\n}", "    @$l =\
    \ sort @$l;\n    my $i = 0;\n    while ($i < @$l) {\n        if ($i < @$l - 1\
    \ && $l->[$i] == $l->[$i + 1]) {\n            splice @$l, $i, 1;\n        } else\
    \ {\n            $i++;\n        }\n    }\n    return @$l;\n}", "    my(%h, @a);\n\
    \    %h = map {($_, 1)} @$l;\n    @a = sort keys %h;\n    return \\@a;\n}", " \
    \   return sort(keys(%{{map{($_,0)} @$l}}));\n}", "    my(%hash);\n    my($i);\n\
    \    my(@out);", "    my %s;\n    @s{@$l} = ();\n    sort { $a <=> $b } keys %s;\n\
    }", "    my(%h, @r);\n    foreach $i (@$l) {\n        $h{$i} = 1;\n    }\n   \
    \ foreach $i (sort keys %h) {\n        push(@r, $i);\n    }\n    return(@r);\n\
    }", "    my(%h, @r);\n    foreach (@$l) { $h{$_} = 1 }\n    @r = sort keys %h;\n\
    \    return wantarray ? @r : \\@r;\n}", "    my(%s);\n    grep( !$s{$_}++, @$l\
    \ );\n}", "    my(%a);\n    my($r);\n    my($i);", "    my %h;\n    return grep(!$h{$_}++,\
    \ @$l);\n}", "    return unless $l;\n    return @$l if ref($l) eq 'ARRAY';\n \
    \   return values %{{map { $_ => 1 } @_}};\n}", "    my %u;\n    $u{$_} = 1 foreach\
    \ @$l;\n    [sort {$a <=> $b} keys %u];\n}", "    my(%h, @u);\n    foreach my\
    \ $e (@$l) {\n        $h{$e} = 1;\n    }\n    foreach my $e (sort keys %h) {\n\
    \        push(@u, $e);\n    }\n    return \\@u;\n}", "    my(%seen, @ret);\n \
    \   foreach my $e (@$l) {\n        push(@ret, $e) unless $seen{$e}++;\n    }\n\
    \    return @ret;\n}", "    my @u = ();\n    my %h = ();\n    foreach (@$l) {\n\
    \        unless (exists $h{$_}) {\n            $h{$_} = 1;\n            push @u,\
    \ $_;\n        }\n    }\n    return \\@u;\n}", "    my(%seen, @uniq);\n    for\
    \ my $x (@$l) {\n        push(@uniq, $x) unless $seen{$x}++;\n    }\n    return\
    \ @uniq;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
