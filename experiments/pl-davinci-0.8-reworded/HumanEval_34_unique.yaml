name: HumanEval_34_unique
language: pl
prompt: "# Return sorted unique elements in an array\n# >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n\
  \        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9,\
  \ 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    if(!@$l) {\n        return @$l;\n    }", "    return undef unless\
    \ defined $l;\n    my @l = @$l;\n    my %seen = ();\n    my @unique = grep { !\
    \ $seen{$_} ++ } @l;\n    return @unique;\n}", "    my(%h, @u);\n    grep($h{$_}++\
    \ == 0, @$l);\n    keys(%h);\n}", "    my(%s, @u);\n    map { $s{$_} = undef }\
    \ @$l;\n    @u = sort { $a <=> $b } keys %s;\n    return \\@u;\n}", "    @$l =\
    \ sort @$l;\n    my $i = 0;\n    while ($i < @$l) {\n        if ($i < @$l - 1\
    \ && $l->[$i] == $l->[$i + 1]) {\n            splice @$l, $i, 1;\n        } else\
    \ {\n            $i++;\n        }\n    }\n    return @$l;\n}", "    my(%h, @a);\n\
    \    %h = map {($_, 1)} @$l;\n    @a = sort keys %h;\n    return \\@a;\n}", " \
    \   return sort(keys(%{{map{($_,0)} @$l}}));\n}", "    my(%hash);\n    my($i);\n\
    \    my(@out);", "    my %s;\n    @s{@$l} = ();\n    sort { $a <=> $b } keys %s;\n\
    }", "    my(%h, @r);\n    foreach $i (@$l) {\n        $h{$i} = 1;\n    }\n   \
    \ foreach $i (sort keys %h) {\n        push(@r, $i);\n    }\n    return(@r);\n\
    }", "    my(%h, @r);\n    foreach (@$l) { $h{$_} = 1 }\n    @r = sort keys %h;\n\
    \    return wantarray ? @r : \\@r;\n}", "    my(%s);\n    grep( !$s{$_}++, @$l\
    \ );\n}", "    my(%a);\n    my($r);\n    my($i);", "    my %h;\n    return grep(!$h{$_}++,\
    \ @$l);\n}", "    return unless $l;\n    return @$l if ref($l) eq 'ARRAY';\n \
    \   return values %{{map { $_ => 1 } @_}};\n}", "    my %u;\n    $u{$_} = 1 foreach\
    \ @$l;\n    [sort {$a <=> $b} keys %u];\n}", "    my(%h, @u);\n    foreach my\
    \ $e (@$l) {\n        $h{$e} = 1;\n    }\n    foreach my $e (sort keys %h) {\n\
    \        push(@u, $e);\n    }\n    return \\@u;\n}", "    my(%seen, @ret);\n \
    \   foreach my $e (@$l) {\n        push(@ret, $e) unless $seen{$e}++;\n    }\n\
    \    return @ret;\n}", "    my @u = ();\n    my %h = ();\n    foreach (@$l) {\n\
    \        unless (exists $h{$_}) {\n            $h{$_} = 1;\n            push @u,\
    \ $_;\n        }\n    }\n    return \\@u;\n}", "    my(%seen, @uniq);\n    for\
    \ my $x (@$l) {\n        push(@uniq, $x) unless $seen{$x}++;\n    }\n    return\
    \ @uniq;\n}", "    my(%h, $r, $i);\n    for $i (@$l) {\n        $h{$i} = 1;\n\
    \    }\n    $r = [sort {$a <=> $b} keys %h];\n    return $r;\n}", "    my @u =\
    \ ();\n    my %u = ();\n    for my $v (@$l) {\n        $u{$v} = 1;\n    }\n  \
    \  for my $v (sort {$a <=> $b} keys %u) {\n        push @u, $v;\n    }\n    return\
    \ \\@u;\n}", "    return undef unless defined $l;\n    my %s;\n    foreach my\
    \ $e (@$l) {\n        $s{$e} = $e;\n    }\n    return [ sort { $a <=> $b } values\
    \ %s ];\n}", "    my %tmp = ();\n    my @ret = ();\n    foreach my $e (@$l) {\n\
    \        $tmp{$e} = 1;\n    }\n    @ret = sort { $a <=> $b } keys %tmp;\n    return\
    \ @ret;\n}", "    my @r = ();\n    my %h = ();\n    foreach my $v (@$l) {\n  \
    \      if (!exists $h{$v}) {\n            $h{$v} = 1;\n            push @r, $v;\n\
    \        }\n    }\n    return \\@r;\n}", "    my %seen;\n    grep { !$seen{$_}++\
    \ } @$l;\n}", "    my %seen;\n    my @out;\n    for (@$l) {\n        push @out,\
    \ $_ unless $seen{$_}++;\n    }\n    @out\n}", "    my(%seen, @uniq);\n    foreach\
    \ my $x (@$l) {\n        unless ($seen{$x}) {\n            $seen{$x} = 1;\n  \
    \          push(@uniq, $x);\n        }\n    }\n    return \\@uniq;\n}", "    my\
    \ @ret = ();\n    my %h;\n    foreach my $e (@$l) {\n        $h{$e} = 1;\n   \
    \ }\n    foreach my $e (sort {$a <=> $b} keys %h) {\n        push @ret, $e;\n\
    \    }\n    return @ret;\n}", "    my(%h, @r);\n    for (@$l) { $h{$_} = 1 }\n\
    \    for (sort keys %h) { push @r, $_ }\n    return \\@r;\n}", "    my @a = sort\
    \ { $a <=> $b } (@$l);\n    my %h;\n    @h{@a} = ();\n    return keys %h;\n}",
  "    my %h;\n    my @r;\n    foreach (@$l) {\n        push @r, $_ unless $h{$_}++;\n\
    \    }\n    return sort { $a <=> $b } @r;\n}", "    my(%t);\n    return grep {!$t{$_}++}\
    \ @$l;\n}", "    return unless (defined $l && @$l);\n    my %m;\n    foreach(@$l)\
    \ {\n        $m{$_} = 1;\n    }\n    return sort {$a <=> $b} keys %m;\n}", " \
    \   my(%h, $i, @u);\n    for $i (@$l) {\n        $h{$i} = 1;\n    }\n    @u =\
    \ sort { $a <=> $b } keys %h;\n    return \\@u;\n}", "    my %seen;\n    grep\
    \ !$seen{$_}++, @$l;\n}", "    return sort keys %{{ map { $_ => 1 } @$l }};\n}",
  "    my %u;\n    foreach (@$l) {\n        $u{$_}++;\n    }\n    return sort(keys(%u));\n\
    }", "    my(%e, @u);\n    for (@$l) {\n        if (not $e{$_}) {\n           \
    \ $e{$_} = 1;\n            push(@u, $_);\n        }\n    }\n    return @u;\n}",
  "    my $m = {};\n    for (@$l) {\n        $m->{$_} = 1;\n    }\n    return [ sort\
    \ { $a <=> $b } keys %$m ];\n}", "    my(%h, @u);\n    foreach (@$l) { $h{$_}\
    \ = 1; }\n    foreach (sort keys %h) { push(@u, $_); }\n    return @u;\n}", " \
    \   return unless(@$l);\n    my %seen = ();\n    my @uniq = grep { ! $seen{$_}\
    \ ++ } @$l;\n    return \\@uniq;\n}", "    my(%h);\n    my($x);\n    foreach $x\
    \ (@$l) {\n        $h{$x} = 1;\n    }\n    return [ sort { $a <=> $b } keys %h\
    \ ];\n}", "    my @return;\n    my %h;\n    foreach (@$l) {\n        next if (exists\
    \ $h{$_});\n        $h{$_} = 1;\n        push @return, $_;\n    }\n    return\
    \ sort {$a <=> $b} @return;\n}", "    my %h;\n    $h{$_} = 1 foreach @$l;\n  \
    \  return sort keys %h;\n}", "    my(%h, $i, @u);\n    foreach $i (@$l) {\n  \
    \      $h{$i} = 1;\n    }\n    @u = sort(keys(%h));\n    return \\@u;\n}", " \
    \   my(%hash, $k, @result);\n    for $k (@$l) {\n        $hash{$k} = 1;\n    }\n\
    \    for $k (keys %hash) {\n        push(@result, $k);\n    }\n    return sort\
    \ {$a <=> $b} @result;\n}", "    my(%u, @uniq);\n    for my $e (@$l) {\n     \
    \   push(@uniq, $e) unless exists $u{$e};\n        $u{$e} = 1;\n    }\n    return\
    \ @uniq;\n}", "    my %h;\n    @h{@$l} = ();\n    return [sort {$a <=> $b} keys\
    \ %h];\n}", "    sort { $a <=> $b } keys %{{ map { ($_,1) } @$l }};\n}", "   \
    \ my %h;\n    for (@$l) {\n        $h{$_} = 1;\n    }\n    return [ sort keys\
    \ %h ];\n}", "    my $s = {};\n    my $r = [];\n    map { $s->{$_} = 1; } @$l;\n\
    \    map { push @$r, $_; } sort { $a <=> $b } keys %$s;\n    return $r;\n}", " \
    \   my(%seen);\n    foreach (@$l) {\n        $seen{$_}++;\n    }\n    return sort\
    \ { $a <=> $b } keys %seen;\n}", "    my %s;\n    @s{@$l} = ();\n    return sort\
    \ keys %s;\n}", "    my @u = ();\n    my %dups = ();\n    foreach my $e (@$l)\
    \ {\n        if (!$dups{$e}) {\n            push @u, $e;\n            $dups{$e}\
    \ = 1;\n        }\n    }\n    return \\@u;\n}", "    my %seen;\n    grep { !$seen{$_}++\
    \ } @$l;\n}", "    my $h = {};\n    for my $e ( @$l ) {\n        $h->{$e} = 1;\n\
    \    }\n    return [sort keys %$h];\n}", "    my(%s, @u);\n    foreach (@$l) {\n\
    \        $s{$_}++;\n    }\n    return [sort keys %s];\n}", "    my(%h, $e);\n\
    \    foreach $e (@$l) {\n        $h{$e} = 1;\n    }\n    return [sort {$a <=>\
    \ $b} keys %h];\n}", "    my(%h, @r);\n    foreach (@$l) { $h{$_} = 1; }\n   \
    \ foreach (sort keys %h) { push(@r, $_); }\n    return wantarray ? @r : \\@r;\n\
    }", "    my %seen;\n    my @uniq = sort { $a <=> $b } grep { !$seen{$_}++ } @$l;\n\
    \    return @uniq;\n}", "    my(%hash, $tmp);\n    $tmp = [sort @$l];\n    return\
    \ [grep(!$hash{$_}++, @$tmp)];\n}", "    my %h;\n    foreach (@$l) {\n       \
    \ $h{$_} = 1;\n    }\n    my @u = sort keys %h;\n    return \\@u;\n}", "    my\
    \ %h;\n    for (@$l) {\n        $h{$_} = 1;\n    }\n    my @a = sort { $a <=>\
    \ $b } keys %h;\n    return @a;\n}", "    my %seen;\n    my @out;\n    foreach\
    \ my $e (@$l) {\n        push(@out, $e) unless $seen{$e}++;\n    }\n    return\
    \ @out;\n}", "    my(%seen, @u);\n    foreach (@$l) {\n        push(@u, $_) unless\
    \ $seen{$_}++;\n    }\n    @u;\n}", "    my @a = sort { $a <=> $b } (@$l);\n \
    \   return @a if $#a < 1;\n    my @u = (shift @a);\n    foreach my $i (@a) {\n\
    \        push @u, $i if $i != $u[$#u];\n    }\n    return @u;\n}", "    return(@{[\
    \ sort keys %{{ map { $_ => 1 } @$l }} ]});\n}", "    my %h;\n    map { $h{$_}\
    \ = 1 } @$l;\n    return sort keys %h;\n}", "    my $n = scalar(@$l);\n    my\
    \ %u;\n    my @u;\n    my $i;\n    for ($i = 0; $i < $n; $i++) {\n        $u{$$l[$i]}\
    \ = 1;\n    }\n    @u = sort(keys(%u));\n    return @u;\n}", "    my(%h, @u);\n\
    \    foreach my $x (@$l) {\n        $h{$x}++;\n    }\n    @u = sort { $a <=> $b\
    \ } keys %h;\n    return \\@u;\n}", "    my(%seen, $k, @uniq);\n    foreach $k\
    \ (@$l) {\n        push(@uniq, $k) unless $seen{$k}++;\n    }\n    return(sort\
    \ { $a <=> $b } @uniq);\n}", "    my(%m, @r);\n    foreach my $e (@$l) {\n   \
    \     $m{$e} = 1;\n    }\n    @r = sort { $a <=> $b } keys %m;\n    return \\\
    @r;\n}", "    my $prev;\n    return grep { $_ ne $prev && ( $prev = $_ ) } @$l;\n\
    }", "    my @a = sort(@$l);\n    my $i = 0;\n    my $j = 0;\n    my $n = scalar(@a);\n\
    \    while ($i < $n) {\n        $a[$j] = $a[$i];\n        $i += 1;\n        while\
    \ ($i < $n && $a[$i] == $a[$j]) {\n            $i += 1;\n        }\n        $j\
    \ += 1;\n    }\n    return [@a[0..($j-1)]];\n}", "    my(%h, @l);\n    foreach\
    \ (@$l) {\n        push(@l, $_) unless $h{$_}++;\n    }\n    return \\@l;\n}",
  "    my $h = {};\n    my $r = [];\n    foreach (@$l) {\n        $h->{$_} = 1;\n\
    \    }\n    foreach (sort keys %$h) {\n        push @$r, $_;\n    }\n    return\
    \ $r;\n}", "    my @sorted = sort { $a <=> $b } @$l;\n    my @unique;\n    my\
    \ $x;\n    foreach my $y (@sorted) {\n        if( ! defined $x || $x != $y ) {\n\
    \            push @unique, $y;\n        }\n        $x = $y;\n    }\n    return\
    \ \\@unique;\n}", "    my(%seen, @unique);\n    foreach (@$l) {\n        push(@unique,\
    \ $_) unless $seen{$_}++;\n    }\n    return \\@unique;\n}", "    my %uniq;\n\
    \    @uniq{@$l} = ();\n    [sort {$a <=> $b} keys %uniq];\n}", "    my %uniq =\
    \ ();\n    my @uniq = ();\n    foreach my $x (@$l) {\n        if (!exists($uniq{$x}))\
    \ {\n            $uniq{$x} = 1;\n            push(@uniq, $x);\n        }\n   \
    \ }\n    return @uniq;\n}", "    my @tmp = sort { $a <=> $b } @$l;\n    my $last\
    \ = 0;\n    my @uniq = ();\n    for my $e (@tmp) {\n        if ($e != $last) {\n\
    \            push @uniq, $e;\n            $last = $e;\n        }\n    }\n    return\
    \ @uniq;\n}", "    return () unless $l;\n    my(%s);\n    map { $s{$_} = 1 } @$l;\n\
    \    return sort { $a <=> $b } keys %s;\n}", "    my(%unique, @unique);\n    map\
    \ {$unique{$_} = 0} @$l;\n    return [ sort keys %unique ];\n}", "    my(%u, $i,\
    \ @uniq, $j);\n    for ($i = 0; $i < scalar(@$l); $i++) {\n        next if exists\
    \ $u{$l->[$i]};\n        $u{$l->[$i]} = 1;\n        push @uniq, $l->[$i];\n  \
    \  }\n    for ($i = 0; $i < scalar(@uniq); $i++) {\n        for ($j = $i + 1;\
    \ $j < scalar(@uniq); $j++) {\n            if ($uniq[$i] > $uniq[$j]) {\n    \
    \            ($uniq[$i], $uniq[$j]) = ($uniq[$j], $uniq[$i]);\n            }\n\
    \        }\n    }\n    return \\@uniq;\n}", "    my @ret;\n    my %seen;\n   \
    \ foreach my $e (@$l) {\n        next if $seen{$e};\n        push @ret, $e;\n\
    \        $seen{$e} = 1;\n    }\n    return @ret;\n}", "    my %seen;\n    grep\
    \ { !$seen{$_}++ } @$l;\n}", "    my(%h, @u);\n    foreach $x (@$l) { $h{$x} =\
    \ 1; }\n    @u = sort keys %h;\n    return \\@u;\n}", "    my %seen;\n    my @u\
    \ = sort { $a <=> $b } grep { !$seen{$_}++ } @$l;\n    return @u;\n}", "    my\
    \ %s;\n    @s{@$l} = ();\n    return sort keys %s;\n}", "    my(%n, $i, @u);\n\
    \    for ($i = 0; $i <= $#$l; $i++) {\n        $n{$l->[$i]} = 1;\n    }\n    for\
    \ (keys %n) {\n        push(@u, $_);\n    }\n    return sort { $a <=> $b } @u;\n\
    }", "    my @s = sort { $a <=> $b } @$l;\n    my @e;\n    push @e, shift @s until\
    \ !@s;\n    @e;\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_} = 1;\n \
    \   }\n    return [sort {$a <=> $b} keys %h];\n}", "    my %h;\n    foreach (@$l)\
    \ {\n        $h{$_} = 1;\n    }\n    return sort { $a <=> $b } keys %h;\n}", " \
    \   my $u = {};\n    return sort { $a <=> $b } grep { not exists $u->{$_} } @$l;\n\
    }", "    my $c;\n    my @u;\n    foreach $c (@$l) {\n        push(@u, $c) if (!grep(($c\
    \ == $_), @u));\n    }\n    return \\@u;\n}", "    return keys %{{ map { $_ =>\
    \ 1 } @$l }};\n}", "    my $seen = {};\n    grep { !$seen->{$_}++ } @$l;\n}",
  "    return () unless $l;\n    my @out = ();\n    my %seen = ();\n    foreach my\
    \ $e (@$l) {\n        next if $seen{$e};\n        $seen{$e} = 1;\n        push\
    \ @out, $e;\n    }\n    return @out;\n}", "    my %s;\n    my @u;\n    for (@$l)\
    \ {\n        push @u, $_ unless exists $s{$_};\n        $s{$_} = 1;\n    }\n \
    \   @u;\n}", "    my(%h);\n    grep(!$h{$_}++, sort @$l);\n}", "    my(%seen);\n\
    \    return grep {!$seen{$_}++} @$l;\n}", "    return sort( keys( %{ { map { $_\
    \ => 1 } @$l } } ) );\n}", "    my %h;\n    @h{@$l} = ();\n    [sort {$a <=> $b}\
    \ keys %h];\n}", "    return keys %{{ map { $_ => 1 } @$l }};\n}", "    my %x;\n\
    \    @x{@$l} = ();\n    return [ sort keys %x ];\n}", "    my @l = @$l;\n    my\
    \ %h;\n    @h{@l} = ();\n    my @u = sort { $a <=> $b } keys %h;\n    return @u;\n\
    }", "    my(%h, @u);\n    $h{$_}++ foreach @$l;\n    push @u, $_ foreach keys\
    \ %h;\n    return [ sort { $a <=> $b } @u ];\n}", "    my %h;\n    return map{$h{$_}++\
    \ ? () : $_} sort @$l;\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_} =\
    \ 1;\n    }\n    return [sort {$a <=> $b} keys %h];\n}", "    my(%hash, @uniq,\
    \ $e);\n    foreach $e (@$l) {\n        $hash{$e} = 1;\n    }\n    foreach $e\
    \ (sort(keys(%hash))) {\n        push(@uniq, $e);\n    }\n    return @uniq;\n}",
  "    return if !defined $l;\n    my %h;\n    @h{@$l} = ();\n    return [sort {$a\
    \ <=> $b} keys %h];\n}", "    my @out = ();\n    my %seen = ();\n    foreach my\
    \ $e (@$l) {\n        push(@out, $e) unless $seen{$e}++;\n    }\n    return(@out);\n\
    }", "    return sort keys %{{ map { $_ => 1 } @$l }};\n}", "    my %h;\n    @h{@$l}\
    \ = ();\n    return sort keys %h;\n}", "    my %h;\n    return grep { !$h{$_}++\
    \ } @$l;\n}", "    my $h = {};\n    foreach (@$l) {\n        $h->{$_} = undef;\n\
    \    }\n    return sort keys %$h;\n}", "    my(%unique);\n    foreach (@$l) {\n\
    \        $unique{$_} = 1;\n    }\n    return [ sort { $a <=> $b } keys %unique\
    \ ];\n}", "    my $r = [];\n    my %h;\n    foreach(@$l) {\n        $h{$_} = 1;\n\
    \    }\n    return [ sort { $a <=> $b } keys %h ];\n}", "    my(%u, @r);\n   \
    \ foreach (@$l) {\n        push(@r, $_) unless $u{$_}++;\n    }\n    return @r;\n\
    }", "    my(%h, $r);\n    foreach $r (@$l) {\n        $h{$r}++;\n    }\n    return(sort(keys(%h)));\n\
    }", "    my %s;\n    foreach my $e (@$l) {\n        $s{$e} = 1;\n    }\n    return\
    \ [ sort { $a <=> $b } keys %s ];\n}", "    my %seen;\n    return grep { !$seen{$_}++\
    \ } @$l;\n}", "    my %h;\n    my @r;\n    foreach (@$l) {\n        $h{$_} = 1;\n\
    \    }\n    foreach (sort {$a <=> $b} keys %h) {\n        push @r, $_;\n    }\n\
    \    return \\@r;\n}", "    my %h;\n    my @u;\n    foreach my $e (@$l) {\n  \
    \      unless ($h{$e}) {\n            $h{$e} = 1;\n            push @u, $e;\n\
    \        }\n    }\n    return [sort {$a <=> $b} @u];\n}", "    my %h;\n    foreach\
    \ my $e (@$l) {\n        $h{$e} = 1;\n    }\n    return [sort {$a <=> $b} keys\
    \ %h];\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_} = 1;\n    }\n   \
    \ return keys %h;\n}", "    my %s;\n    return @s{@$l} = @$l;\n}", "    my @u\
    \ = ();\n    my %u = ();\n    foreach my $e (@$l) {\n        unless (exists $u{$e})\
    \ {\n            $u{$e} = 1;\n            push @u, $e;\n        }\n    }\n   \
    \ return @u;\n}", "    my(%hash);\n    @hash{@$l} = ();\n    return [sort keys\
    \ %hash];\n}", "    my(%h, @u);\n    foreach (@$l) {\n        next if $h{$_};\n\
    \        $h{$_} = 1;\n        push(@u, $_);\n    }\n    sort { $a <=> $b } @u;\n\
    }", "    my(%h);\n    my($i);\n    my(@r);", "    my %unique = ();\n    my @unique;\n\
    \    foreach my $e (@$l) {\n        unless (exists $unique{$e}) {\n          \
    \  $unique{$e} = 1;\n            push @unique, $e;\n        }\n    }\n    return\
    \ [ sort { $a <=> $b } @unique ];\n}", "    my %h;\n    @h{@$l} = ();\n    return\
    \ [ sort keys %h ];\n}", "    my %h;\n    map { $h{$_} = 1 } @$l;\n    return\
    \ [sort { $a <=> $b } keys %h];\n}", "    return sort(keys(%{{map { $_ => 1 }\
    \ @$l}}));\n}", "    my $u = {};\n    for my $e (@$l) {\n        $u->{$e} = $e;\n\
    \    }\n    return sort { $a <=> $b } values %$u;\n}", "    my @s = sort { $a\
    \ <=> $b } @$l;\n    my @uniq = ();\n    my $last;\n    for my $i (@s) {\n   \
    \     if(!defined($last) || $i != $last) {\n            push @uniq, $i;\n    \
    \    }\n        $last = $i;\n    }\n    return @uniq;\n}", "    my(%h, @r);\n\
    \    foreach (@$l) {\n        if (!exists $h{$_}) {\n            $h{$_} = 1;\n\
    \            push(@r, $_);\n        }\n    }\n    return(@r);\n}", "    my %s;\n\
    \    return sort(grep !$s{$_}++, @$l);\n}", "    my(%seen, @uniq);\n    foreach\
    \ my $e (@$l) {\n        push(@uniq, $e) unless $seen{$e}++;\n    }\n    return\
    \ [ sort { $a <=> $b } @uniq ];\n}", "    my %h;\n    $h{$_}++ for @$l;\n    return\
    \ sort { $a <=> $b } keys %h;\n}", "    my @l = sort @$l;\n    my $r = [];\n \
    \   push @$r, shift @l;\n    while(@l) {\n        if ($l[0] != $r->[-1]) {\n \
    \           push @$r, shift @l;\n        } else {\n            shift @l;\n   \
    \     }\n    }\n    return $r;\n}", "    my %seen;\n    return grep { !$seen{$_}++\
    \ } @$l;\n}", "    return sort { $a <=> $b } keys %{{ map { $_ => 1 } @$l }};\n\
    }", "    my(%all) = ();\n    map { $all{$_}++ } @$l;\n    return sort keys %all;\n\
    }", "    my %seen;\n    grep !$seen{$_}++, @$l;\n}", "    my %a;\n    my @b;\n\
    \    foreach my $e (@$l) {\n        if(!$a{$e}) {\n            $a{$e} = 1;\n \
    \           push @b, $e;\n        }\n    }\n    return @b;\n}", "    my(%h, $e);\n\
    \    foreach $e (@$l) {\n        $h{$e} = 1;\n    }\n    my(@ul) = sort keys %h;\n\
    \    return \\@ul;\n}", "    my(%h);\n    my($n);\n    foreach $n (@$l) {\n  \
    \      $h{$n} = 1;\n    }\n    return [ sort { $a <=> $b } keys %h ];\n}", " \
    \   my @ret = ();\n    my %h;\n    foreach my $x (@$l) {\n        if (!$h{$x})\
    \ {\n            $h{$x} = 1;\n            push @ret, $x;\n        }\n    }\n \
    \   return @ret;\n}", "    my(%seen, @u);\n    foreach $e (@$l) {\n        push(@u,\
    \ $e) unless $seen{$e}++;\n    }\n    \\@u;\n}", "    my @r = ();\n    my %h =\
    \ ();\n    foreach my $e (@$l) {\n        next if exists $h{$e};\n        $h{$e}\
    \ = 1;\n        push @r, $e;\n    }\n    return @r;\n}", "    my @u = sort { $a\
    \ <=> $b } keys %{{ map { $_ => 1 } @$l }};\n    return wantarray ? @u : \\@u;\n\
    }", "    my %h;\n    $h{$_}++ for @$l;\n    sort keys %h;\n}", "    my $r = [];\n\
    \    my %s;\n    foreach (@$l) {\n        $s{$_} = 1;\n    }\n    @$r = sort keys\
    \ %s;\n    return $r;\n}", "    my %seen;\n    grep {!$seen{$_}++} @$l;\n}", " \
    \   my @uniq;\n    my %seen;\n    foreach my $item (@$l) {\n        next if $seen{$item};\n\
    \        $seen{$item} = 1;\n        push @uniq, $item;\n    }\n    return @uniq;\n\
    }", "    my(%h, $k, @r);\n    foreach $k (@$l) {\n        if (!exists($h{$k}))\
    \ {\n            $h{$k} = 1;\n            push(@r, $k);\n        }\n    }\n  \
    \  return \\@r;\n}", "    my @l = @$l;\n    my %tmp = ();\n    @tmp{@l} = ();\n\
    \    return sort {$a <=> $b} keys %tmp;\n}", "    my(%unique, $k);\n    foreach\
    \ $k (@$l) {\n        $unique{$k} = 1;\n    }\n    return [sort {$a <=> $b} keys\
    \ %unique];\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_} = 1;\n    }\n\
    \    return [sort {$a <=> $b} keys %h];\n}", "    my @a = sort { $a <=> $b } @$l;\n\
    \    my @b;\n    my $last = -1;\n    foreach (@a) {\n        push(@b, $_) if $_\
    \ != $last;\n        $last = $_;\n    }\n    return @b;\n}", "    my $k = {};\n\
    \    my $r = [];\n    foreach (@$l) {\n        if (!$k->{$_}) {\n            push\
    \ @$r, $_;\n            $k->{$_} = 1;\n        }\n    }\n    return $r;\n}", " \
    \   return [] unless defined $l;\n    my %seen = ();\n    return [ grep { !$seen{$_}++\
    \ } @$l ];\n}", "    return sort { $a <=> $b } keys %{{ map { $_ => 1 } @$l }};\n\
    }", "    my %seen;\n    grep !$seen{$_}++, sort { $a <=> $b } @$l;\n}", "    return\
    \ () unless $l;\n    @{$l} = sort @{$l};\n    my $i;\n    for($i = $#{$l} - 1;\
    \ $i >= 0; $i--) {\n        splice(@{$l}, $i, 1) if $l->[$i] eq $l->[$i + 1];\n\
    \    }\n    @{$l};\n}", "    my $u = {};\n    for (@$l) {\n        $u->{$_} =\
    \ 1;\n    }\n    sort { $a <=> $b } keys %$u;\n}", "    my @ul = ();\n    my %h;\n\
    \    for my $e (@$l) {\n        $h{$e}++;\n    }\n    for my $e (sort {$a <=>\
    \ $b} keys %h) {\n        push @ul, $e;\n    }\n    return @ul;\n}", "    my %h;\n\
    \    return grep { not $h{$_}++ } @$l;\n}", "    my(%h, @v);\n    foreach (@$l)\
    \ {\n        $h{$_} = 1;\n    }\n    @v = sort { $a <=> $b } keys %h;\n    return\
    \ @v;\n}", "    my @u = ();\n    my $last;\n    foreach my $x (sort {$a <=> $b}\
    \ @$l) {\n        if (!defined($last) || $x != $last) {\n            push(@u,\
    \ $x);\n        }\n        $last = $x;\n    }\n    return \\@u;\n}", "    my(%h);\n\
    \    @h{@$l} = ();\n    return sort keys %h;\n}", "    my(%h);\n    return grep\
    \ !$h{$_}++, @$l;\n}", "    my(%h, $ret);\n    @h{@$l} = ();\n    return sort\
    \ keys %h;\n}", "    my %h;\n    foreach my $i (@$l) {\n        $h{$i} = $i;\n\
    \    }\n    return [ sort keys %h ];\n}", "    my %u;\n    foreach my $v (@$l)\
    \ {\n        $u{$v} = 1;\n    }\n    return sort { $a <=> $b } keys %u;\n}", " \
    \   my @a = sort { $a <=> $b } @$l;\n    return [uniq @a];\n}", "    my %h;\n\
    \    foreach my $e (@$l) {\n        $h{$e}++;\n    }\n    return [sort {$a <=>\
    \ $b} keys %h];\n}", "    return uniq(sort(@$l));\n}", "    if(wantarray) {\n\
    \        return sort(unique_r($l));\n    } else {\n        my %h = map {$_, 1}\
    \ @$l;\n        return keys %h;\n    }\n}", "    my %h;\n    @h{@$l} = @$l;\n\
    \    return [sort {$a <=> $b} values %h];\n}", "    my(%s);\n    map($s{$_} =\
    \ 1, @$l);\n    return sort(keys(%s));\n}", "    my @u = ();\n    my %s = ();\n\
    \    foreach (@$l) {\n        push(@u, $_) unless $s{$_}++;\n    }\n    return\
    \ \\@u;\n}", "    my %h;\n    my @u;\n    for (@$l) {\n        push @u, $_ unless\
    \ $h{$_}++;\n    }\n    return @u;\n}", "    sort { $a <=> $b } keys %{{ map {\
    \ $_ => 1 } @$l }}\n}", "    my %h;\n    $h{$_}++ for @$l;\n    return [sort {$a\
    \ <=> $b} keys %h];\n}", "    my @out = ();\n    my %out;\n    for my $v (@$l)\
    \ {\n        if (!$out{$v}) {\n            push @out, $v;\n            $out{$v}\
    \ = 1;\n        }\n    }\n    return @out;\n}", "    my(%h, @u);\n    foreach\
    \ (@$l) {\n        $h{$_} = 1;\n    }\n    @u = sort { $a <=> $b } keys %h;\n\
    \    return wantarray ? @u : \\@u;\n}", "    my(%h, @u);\n    foreach (@$l) {\n\
    \        if (!$h{$_}) {\n            $h{$_} = 1;\n            push(@u, $_);\n\
    \        }\n    }\n    @u = sort { $a <=> $b } @u;\n    return(@u);\n}", "   \
    \ my $h = {};\n    for my $x (@$l) {\n        $h->{$x} = 1;\n    }\n    return\
    \ [sort {$a <=> $b} keys %$h];\n}", "    my %seen;\n    return sort grep { !$seen{$_}++\
    \ } @$l;\n}", "    my(%h, @uniq);\n    foreach (@$l) {\n        $h{$_} = 1;\n\
    \    }\n    return sort { $a <=> $b } keys %h;\n}", "    my(%u);\n    my($i);\n\
    \    my(@ul);", "    my(%seen, $e, @out);\n    foreach $e (@$l) {\n        next\
    \ if $seen{$e};\n        $seen{$e} = 1;\n        push(@out, $e);\n    }\n    @out;\n\
    }", "    my %s;\n    my @r;\n    foreach my $e (@$l) {\n        if (! $s{$e})\
    \ {\n            $s{$e} = 1;\n            push @r, $e;\n        }\n    }\n   \
    \ return @r;\n}", "    my(%h, @r);\n    for (@$l) {\n        next if $h{$_};\n\
    \        $h{$_} = 1;\n        push(@r, $_);\n    }\n    return @r;\n}", "    my\
    \ @a = sort { $a <=> $b } @$l;\n    my $i = 0;\n    for ($i = 1; $i < @a; $i++)\
    \ {\n        if ($a[$i] == $a[$i-1]) {\n            splice(@a, $i, 1);\n     \
    \       $i--;\n        }\n    }\n    return @a;\n}", "    my(%unique);\n    foreach\
    \ (@$l) {\n        $unique{$_} = 1;\n    }\n    return sort { $a <=> $b } keys\
    \ %unique;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
