name: HumanEval_6_parse_nested_parens
language: pl
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n# [2, 3, 1, 3]\nsub parse_nested_parens {\n    my($paren_string) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_nested_parens;\n\
  \        if(eq_deeply($candidate->(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  () (()) ((())) (((())))\"),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()(())((())))\"),[4]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @paren_strings = split /\\s+/, $paren_string;\n    my @depth_arr;\n\
    \    foreach my $str (@paren_strings) {\n        my $depth = 0;\n        my $max_depth\
    \ = 0;\n        foreach my $ch (split //, $str) {\n            if ($ch eq '(')\
    \ {\n                $depth++;\n            }\n            elsif ($ch eq ')')\
    \ {\n                $depth--;\n            }\n            $max_depth = max($max_depth,\
    \ $depth);\n        }\n        push @depth_arr, $max_depth;\n    }\n    return\
    \ @depth_arr;\n}", "    my @paren_array = split(\" \", $paren_string);\n    my\
    \ @output;\n    for my $paren_group (@paren_array) {\n        my $paren_group_copy\
    \ = $paren_group;\n        my $level = 0;\n        my $max_level = 0;\n      \
    \  my $paren_group_length = length($paren_group_copy);\n        for (my $i = 0;\
    \ $i < $paren_group_length; $i++) {\n            my $char = substr($paren_group_copy,\
    \ $i, 1);\n            if ($char eq \"(\") {\n                $level++;\n    \
    \        }\n            elsif ($char eq \")\") {\n                $level--;\n\
    \            }\n            if ($level > $max_level) {\n                $max_level\
    \ = $level;\n            }\n        }\n        push(@output, $max_level);\n  \
    \  }\n    return @output;\n}", "    my @paren_levels;\n    my @paren_tokens =\
    \ split(/ /, $paren_string);\n    for my $p (@paren_tokens) {\n        my $paren_level\
    \ = 0;\n        for my $c (split(//, $p)) {\n            if ($c eq '(') {\n  \
    \              $paren_level++;\n            } elsif ($c eq ')') {\n          \
    \      $paren_level--;\n            }\n        }\n        push @paren_levels,\
    \ $paren_level;\n    }\n    return @paren_levels;\n}", "    my @paren_grps = split(/\\\
    s+/, $paren_string);\n    my @max_nesting_levels;\n    for my $grp (@paren_grps)\
    \ {\n        my $p = new Algorithm::NestedGroups();\n        $p->set_string($grp);\n\
    \        $p->parse_string();\n        push @max_nesting_levels, $p->get_max_nesting_level();\n\
    \    }\n    return @max_nesting_levels;\n}", "    my(@paren_list) = split(/\\\
    s+/, $paren_string);\n    my(@max_levels);\n    foreach my $paren_group (@paren_list)\
    \ {\n        my($curr_max_level) = 0;\n        my($curr_level) = 0;\n        foreach\
    \ my $char (split('', $paren_group)) {\n            if ($char eq '(') {\n    \
    \            $curr_level++;\n                if ($curr_level > $curr_max_level)\
    \ {\n                    $curr_max_level = $curr_level;\n                }\n \
    \           } elsif ($char eq ')') {\n                $curr_level--;\n       \
    \     }\n        }\n        push(@max_levels, $curr_max_level);\n    }\n    return\
    \ @max_levels;\n}", "    my(@paren_array) = split(\" \", $paren_string);\n   \
    \ my(@depth_array);\n    foreach my $paren_str (@paren_array) {\n\tif ($paren_str\
    \ =~ /^\\(+\\)+$/) {\n\t    my $num_left_parens = ($paren_str =~ tr/\\(//);\n\t\
    \    my $num_right_parens = ($paren_str =~ tr/\\)//);\n\t    if ($num_left_parens\
    \ eq $num_right_parens) {\n\t\tmy $paren_depth = get_paren_depth($paren_str);\n\
    \t\tpush @depth_array, $paren_depth;\n\t    }\n\t    else {\n\t\tprint \"Invalid\
    \ parenthesis string $paren_str\\n\";\n\t    }\n\t}\n\telse {\n\t    print \"\
    Invalid parenthesis string $paren_str\\n\";\n\t}\n    }\n    return @depth_array;\n\
    }", "    my @paren_groups = split(/\\s+/, $paren_string);\n    my @paren_groups_depths;\n\
    \    for my $paren_group (@paren_groups) {\n        my $paren_group_depth = 0;\n\
    \        my $paren_group_max_depth = 0;\n        for my $paren_char (split(//,\
    \ $paren_group)) {\n            if ($paren_char eq \"(\") {\n                $paren_group_depth++;\n\
    \            } elsif ($paren_char eq \")\") {\n                $paren_group_depth--;\n\
    \            }\n            if ($paren_group_depth > $paren_group_max_depth) {\n\
    \                $paren_group_max_depth = $paren_group_depth;\n            }\n\
    \        }\n        push(@paren_groups_depths, $paren_group_max_depth);\n    }\n\
    \    return @paren_groups_depths;\n}", "    my(@parsed_parens) = ();\n    foreach\
    \ my $paren_group (split(/\\s+/, $paren_string)) {\n        my($nested_parens)\
    \ = 0;\n        foreach my $paren_pair (split(/()/, $paren_group)) {\n       \
    \     if ($paren_pair eq \"(\") {\n                $nested_parens++;\n       \
    \     }\n        }\n        push(@parsed_parens, $nested_parens);\n    }\n   \
    \ return @parsed_parens;\n}", "    my @paren_array = split(/\\s+/, $paren_string);\n\
    \    my @max_depth_array;\n    foreach my $paren_group (@paren_array) {\n    \
    \    my $max_depth = 1;\n        my $depth = 0;\n        for (my $i = 0; $i <\
    \ length($paren_group); $i++) {\n            if (substr($paren_group, $i, 1) eq\
    \ \"(\") {\n                $depth++;\n                if ($depth > $max_depth)\
    \ {\n                    $max_depth = $depth;\n                }\n           \
    \ } elsif (substr($paren_group, $i, 1) eq \")\") {\n                $depth--;\n\
    \            }\n        }\n        push(@max_depth_array, $max_depth);\n    }\n\
    \    return @max_depth_array;\n}", "    my @paren_array = split(/\\s+/, $paren_string);\n\
    \    my @paren_levels;\n    foreach my $paren_group (@paren_array) {\n\tmy $num_open\
    \ = 0;\n\tmy $max_depth = 0;\n\tfor (my $i = 0; $i < length($paren_group); $i++)\
    \ {\n\t    my $char = substr($paren_group, $i, 1);\n\t    if ($char eq \"(\")\
    \ {\n\t\t$num_open++;\n\t\tif ($num_open > $max_depth) {\n\t\t    $max_depth =\
    \ $num_open;\n\t\t}\n\t    }\n\t    elsif ($char eq \")\") {\n\t\t$num_open--;\n\
    \t    }\n\t}\n\tpush(@paren_levels, $max_depth);\n    }\n    return @paren_levels;\n\
    }", "    return unless($paren_string);\n    my @paren_str_array = split(' ', $paren_string);\n\
    \    my @paren_max_nest_array;\n    for(my $i = 0; $i < scalar(@paren_str_array);\
    \ $i++) {\n        my $paren_str = $paren_str_array[$i];\n        my $max_nest\
    \ = 0;\n        my $temp_nest = 0;\n        for(my $j = 0; $j < length($paren_str);\
    \ $j++) {\n            my $char = substr($paren_str, $j, 1);\n            if($char\
    \ eq '(') {\n                $temp_nest++;\n            }\n            elsif($char\
    \ eq ')') {\n                $temp_nest--;\n            }\n            $max_nest\
    \ = $temp_nest if($temp_nest > $max_nest);\n        }\n        push(@paren_max_nest_array,\
    \ $max_nest);\n    }\n    return @paren_max_nest_array;\n}", "    my @nesting_levels;\n\
    \    foreach my $paren_group (split(/\\s+/, $paren_string)) {\n        my $depth\
    \ = 0;\n        my $max_depth = 0;\n        foreach my $char (split //, $paren_group)\
    \ {\n            if ($char eq \"(\") {\n                $depth++;\n          \
    \  } elsif ($char eq \")\") {\n                $depth--;\n            }\n    \
    \        $max_depth = $depth if $depth > $max_depth;\n        }\n        push\
    \ @nesting_levels, $max_depth;\n    }\n    return @nesting_levels;\n}", "    my\
    \ @paren_groups = split(/\\s+/, $paren_string);\n    my @retval;\n    foreach\
    \ my $group (@paren_groups) {\n        my $nesting_level = 0;\n        my $max_nesting_level\
    \ = 0;\n        for (my $i = 0; $i < length($group); $i++) {\n            my $char\
    \ = substr($group, $i, 1);\n            if ($char eq \"(\") {\n              \
    \  $nesting_level++;\n            }\n            elsif ($char eq \")\") {\n  \
    \              $nesting_level--;\n            }\n            if ($nesting_level\
    \ > $max_nesting_level) {\n                $max_nesting_level = $nesting_level;\n\
    \            }\n        }\n        push(@retval, $max_nesting_level);\n    }\n\
    \    return \\@retval;\n}", "    my(@paren_groups) = split(' ', $paren_string);\n\
    \    my(@max_nest_per_group);\n    foreach my $group (@paren_groups) {\n     \
    \   my($is_open_paren, $nest_level) = (0, 0);\n        my($max_nest_in_group)\
    \ = 0;\n        foreach my $paren (split('', $group)) {\n            if ($paren\
    \ eq '(') {\n                $is_open_paren = 1;\n                $nest_level\
    \ += 1;\n            } else {\n                if ($is_open_paren) {\n       \
    \             $is_open_paren = 0;\n                    $nest_level -= 1;\n   \
    \             } else {\n                    return undef;\n                }\n\
    \            }\n            if ($nest_level > $max_nest_in_group) {\n        \
    \        $max_nest_in_group = $nest_level;\n            }\n        }\n       \
    \ push(@max_nest_per_group, $max_nest_in_group);\n    }\n    return @max_nest_per_group;\n\
    }", "    my @max_depth = ();\n    foreach my $group (split /\\s+/, $paren_string)\
    \ {\n        my $paren_depth = 0;\n        my $max_paren_depth = 0;\n        foreach\
    \ my $char (split //, $group) {\n            if ($char eq \"(\") {\n         \
    \       $paren_depth++;\n                if ($paren_depth > $max_paren_depth)\
    \ {\n                    $max_paren_depth = $paren_depth;\n                }\n\
    \            }\n            elsif ($char eq \")\") {\n                $paren_depth--;\n\
    \            }\n        }\n        push @max_depth, $max_paren_depth;\n    }\n\
    \    return @max_depth;\n}", "    my @paren_strings = split(/\\s+/, $paren_string);\n\
    \    my @maximum_depth;\n    foreach my $string (@paren_strings) {\n        my\
    \ $depth = 0;\n        my $max_depth = 0;\n        my @chars = split(//, $string);\n\
    \        foreach my $char (@chars) {\n            if ($char eq \"(\") {\n    \
    \            $depth++;\n            } elsif ($char eq \")\") {\n             \
    \   $depth--;\n            }\n            if ($depth > $max_depth) {\n       \
    \         $max_depth = $depth;\n            }\n        }\n        push(@maximum_depth,\
    \ $max_depth);\n    }\n    return @maximum_depth;\n}", "    my @paren_depth =\
    \ ();\n    my $depth = 0;\n    my $max_depth = 0;\n    my $in_parens = 0;\n  \
    \  my $c;\n    foreach $c (split //, $paren_string) {\n        if ($c eq \"(\"\
    ) {\n            $depth++;\n            $in_parens = 1;\n        } elsif ($c eq\
    \ \")\") {\n            $depth--;\n            if ($depth < 0) {\n           \
    \     die \"Unbalanced parentheses string: $paren_string\";\n            }\n \
    \           if ($depth == 0) {\n                $in_parens = 0;\n            \
    \    push @paren_depth, $max_depth;\n                $max_depth = 0;\n       \
    \     }\n        } elsif ($c eq \" \") {\n            if ($in_parens) {\n    \
    \            if ($depth > $max_depth) {\n                    $max_depth = $depth;\n\
    \                }\n            }\n        } else {\n            die \"Unrecognized\
    \ character in parentheses string: $paren_string\";\n        }\n    }\n    if\
    \ ($in_parens) {\n        die \"Unbalanced parentheses string: $paren_string\"\
    ;\n    }\n    return @paren_depth;\n}", "    my @paren_groups = split(/\\s+/,\
    \ $paren_string);\n    my @levels;\n    foreach my $group (@paren_groups) {\n\
    \        my $level = 0;\n        my $max_level = 0;\n        foreach my $char\
    \ (split(//, $group)) {\n            if ($char eq \"(\") {\n                $level++;\n\
    \            } elsif ($char eq \")\") {\n                $level--;\n         \
    \   }\n            $max_level = $level if $level > $max_level;\n        }\n  \
    \      push @levels, $max_level;\n    }\n    return @levels;\n}", "    my @paren_array\
    \ = split(/\\s+/, $paren_string);\n    my @nested_levels;\n    for my $paren (@paren_array)\
    \ {\n        my $level = 0;\n        for my $char (split(//, $paren)) {\n    \
    \        if ($char eq '(') {\n                $level++;\n            }\n     \
    \       elsif ($char eq ')') {\n                if ($level > 0) {\n          \
    \          $level--;\n                }\n                else {\n            \
    \        die \"Wrong input format for paren string!\\n\";\n                }\n\
    \            }\n            else {\n                die \"Wrong input format for\
    \ paren string!\\n\";\n            }\n        }\n        push @nested_levels,\
    \ $level;\n    }\n    return @nested_levels;\n}", "    my @result;\n    my @paren_groups\
    \ = split(/\\s+/, $paren_string);\n    for my $group (@paren_groups) {\n     \
    \   my $curr_paren_level = 0;\n        my $curr_paren_max = 0;\n        for my\
    \ $paren (split(//, $group)) {\n            if ($paren eq \"(\") {\n         \
    \       $curr_paren_level += 1;\n                $curr_paren_max = $curr_paren_level\
    \ if $curr_paren_level > $curr_paren_max;\n            }\n            elsif ($paren\
    \ eq \")\") {\n                $curr_paren_level -= 1;\n            }\n      \
    \  }\n        push @result, $curr_paren_max;\n    }\n    return @result;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
