name: HumanEval_127_intersection
language: pl
prompt: "# You are given two intervals,\n# where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n# The given intervals are closed\
  \ which means that the interval (start, end)\n# includes both start and end.\n#\
  \ For each given interval, it is assumed that its start is less or equal its end.\n\
  # Your task is to determine whether the length of intersection of these two \n#\
  \ intervals is a prime number.\n# Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n# which its length is 1, which not a prime number.\n# If\
  \ the length of the intersection is a prime number, return \"YES\",\n# otherwise,\
  \ return \"NO\".\n# If the two intervals don't intersect, return \"NO\".\n# [input/output]\
  \ samples:\n# >>> intersection([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection([-1,\
  \ 1], [0, 4])\n# \"NO\"\n# >>> intersection([-3, -1], [-5, 5])\n# \"YES\"\nsub intersection\
  \ {\n    my($interval1, $interval2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersection;\n\
  \        if(eq_deeply($candidate->([1, 2], [2, 3]),\"NO\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1,\
  \ 1], [0, 4]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n        if(eq_deeply($candidate->([-3, -1], [-5, 5]),\"YES\")) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2,\
  \ 2], [-4, 0]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([-11, 2], [-1, -1]),\"NO\")) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2], [3, 5]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n        if(eq_deeply($candidate->([1, 2], [1, 2]),\"NO\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2,\
  \ -2], [-3, -2]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n}\n\ntesthumaneval();"
completions: ["    my @interval1 = @$interval1;\n    my @interval2 = @$interval2;\n\
    \    my @range;\n    my $min = $interval1[0] > $interval2[0] ? $interval1[0] :\
    \ $interval2[0];\n    my $max = $interval1[1] < $interval2[1] ? $interval1[1]\
    \ : $interval2[1];\n    if ($min <= $max) {\n        @range = ($min, $max);\n\
    \    } else {\n        return \"NO\";\n    }\n    if ($range[1] - $range[0] ==\
    \ 0) {\n        return \"YES\";\n    }\n    my $n = $range[1] - $range[0];\n \
    \   for (my $i = 2; $i < $n / 2; $i++) {\n        if ($n % $i == 0) {\n      \
    \      return \"NO\";\n        }\n    }\n    return \"YES\";\n}", "    my @intervals\
    \ = ($interval1, $interval2);\n    # sort by start time\n    @intervals = sort\
    \ {$a->[0] <=> $b->[0]} @intervals;\n    my($start, $end) = ($intervals[0]->[0],\
    \ $intervals[1]->[1]);\n    if ($start > $end) {\n        return 'NO';\n    }\n\
    \    else {\n        return is_prime($end - $start + 1) ? 'YES' : 'NO';\n    }\n\
    }", "    if ($interval1->[0] > $interval2->[1] or $interval2->[0] > $interval1->[1])\
    \ {\n        return \"NO\";\n    }\n    else {\n        my $max_start = max($interval1->[0],\
    \ $interval2->[0]);\n        my $min_end = min($interval1->[1], $interval2->[1]);\n\
    \        my $intersection_len = $min_end - $max_start + 1;\n        return is_prime($intersection_len)\
    \ ? \"YES\" : \"NO\";\n    }\n}", "    my $max1 = $interval1->[0] > $interval1->[1]\
    \ ? $interval1->[0] : $interval1->[1];\n    my $min1 = $interval1->[0] < $interval1->[1]\
    \ ? $interval1->[0] : $interval1->[1];\n    my $max2 = $interval2->[0] > $interval2->[1]\
    \ ? $interval2->[0] : $interval2->[1];\n    my $min2 = $interval2->[0] < $interval2->[1]\
    \ ? $interval2->[0] : $interval2->[1];\n    my $max = $max1 < $max2 ? $max1 :\
    \ $max2;\n    my $min = $min1 > $min2 ? $min1 : $min2;\n    if($max > $min) {\n\
    \        my $length = $max - $min;\n        my $prime = isPrime($length);\n  \
    \      return $prime ? \"YES\" : \"NO\";\n    }\n    return \"NO\";\n}", "   \
    \ my @answer;\n    if (is_intersect($interval1, $interval2)) {\n        @answer\
    \ = \n        (\n            max($interval1->[0], $interval2->[0]),\n        \
    \    min($interval1->[1], $interval2->[1])\n        );\n    } else {\n       \
    \ @answer = (0, 0);\n    }\n    if ($answer[1] - $answer[0] + 1 <= 1) {\n    \
    \    return \"NO\";\n    } else {\n        return is_prime($answer[1] - $answer[0]\
    \ + 1) ? \"YES\" : \"NO\";\n    }\n}", "    my($start1, $end1) = @$interval1;\n\
    \    my($start2, $end2) = @$interval2;\n    if ($start1 >= $end2 || $start2 >=\
    \ $end1) {\n        return \"NO\";\n    }\n    my($interval_start, $interval_end)\
    \ = ($start1, $end1);\n    if ($start2 > $start1) {\n        $interval_start =\
    \ $start2;\n    }\n    if ($end2 < $end1) {\n        $interval_end = $end2;\n\
    \    }\n    my $interval_length = $interval_end - $interval_start;\n    if ($interval_length\
    \ == 1) {\n        return \"NO\";\n    }\n    my $is_prime = 1;\n    for (my $i\
    \ = 2; $i <= $interval_length / 2; $i++) {\n        if ($interval_length % $i\
    \ == 0) {\n            $is_prime = 0;\n            last;\n        }\n    }\n \
    \   return $is_prime ? \"YES\" : \"NO\";\n}", "    if($interval1->[0] > $interval2->[1]\
    \ || $interval2->[0] > $interval1->[1]) {\n        return \"NO\";\n    }\n   \
    \ my $min = max($interval1->[0], $interval2->[0]);\n    my $max = min($interval1->[1],\
    \ $interval2->[1]);\n    if(is_prime($max - $min + 1)) {\n        return \"YES\"\
    ;\n    }\n    return \"NO\";\n}", "    my($min_start, $max_end);\n    if ($interval1->[0]\
    \ < $interval2->[0]) {\n        $min_start = $interval1->[0];\n    } else {\n\
    \        $min_start = $interval2->[0];\n    }\n    if ($interval1->[1] > $interval2->[1])\
    \ {\n        $max_end = $interval1->[1];\n    } else {\n        $max_end = $interval2->[1];\n\
    \    }\n    if ($min_start > $max_end) {\n        return \"NO\";\n    }\n    my\
    \ $len = $max_end - $min_start + 1;\n    my $sqrt = sqrt($len);\n    for my $i\
    \ (2..$sqrt) {\n        if ($len % $i == 0) {\n            return \"NO\";\n  \
    \      }\n    }\n    return \"YES\";\n}", "    my($start1, $end1) = @$interval1;\n\
    \    my($start2, $end2) = @$interval2;\n    if ($start1 > $end1) {\n        ($start1,\
    \ $end1) = ($end1, $start1);\n    }\n    if ($start2 > $end2) {\n        ($start2,\
    \ $end2) = ($end2, $start2);\n    }\n    return \"NO\" if $end1 < $start2 || $end2\
    \ < $start1;\n    my($start, $end) = ($start1, $end1);\n    $start = $start2 if\
    \ $start2 > $start1;\n    $end = $end2 if $end2 < $end1;\n    return \"YES\" if\
    \ prime($end - $start + 1);\n    return \"NO\";\n}", "    my($start, $end) = (max($interval1->[0],\
    \ $interval2->[0]), min($interval1->[1], $interval2->[1]));\n    return ($start\
    \ >= $end) ? \"NO\" : ($start <= 0) ? \"NO\" : is_prime($end - $start) ? \"YES\"\
    \ : \"NO\";\n}", "    my($min, $max);\n    my($x1, $x2) = @$interval1;\n    my($y1,\
    \ $y2) = @$interval2;\n    $x1 < $x2 or die;\n    $y1 < $y2 or die;\n    if ($x1\
    \ > $y2 || $y1 > $x2) {\n        return 'NO';\n    }\n    $min = $x1 > $y1 ? $x1\
    \ : $y1;\n    $max = $x2 < $y2 ? $x2 : $y2;\n    if ($min > $max) {\n        return\
    \ 'NO';\n    }\n    if (is_prime($max - $min + 1)) {\n        return 'YES';\n\
    \    }\n    return 'NO';\n}", "    my $interval1_start = $interval1->[0];\n  \
    \  my $interval1_end = $interval1->[1];\n    my $interval2_start = $interval2->[0];\n\
    \    my $interval2_end = $interval2->[1];\n    # check intersection\n    if ($interval1_start\
    \ > $interval2_end || $interval2_start > $interval1_end) {\n        return \"\
    NO\";\n    }\n    # get intersection\n    my $interval1_range = ($interval1_end\
    \ - $interval1_start) + 1;\n    my $interval2_range = ($interval2_end - $interval2_start)\
    \ + 1;\n    if ($interval1_range == $interval2_range) {\n        # return \"YES\"\
    \ if the intersection is equal to one of the intervals\n        return \"YES\"\
    ;\n    }\n    my $intersection_range = $interval1_range + $interval2_range;\n\
    \    my $intersection_start = \n        $interval1_start < $interval2_start ?\
    \ \n            $interval2_start : $interval1_start;\n    my $intersection_end\
    \ = \n        $interval1_end > $interval2_end ? \n            $interval2_end :\
    \ $interval1_end;\n    # check if intersection is a prime number\n    for my $i\
    \ (2..$intersection_end) {\n        return \"NO\" if ($intersection_range % $i\
    \ == 0);\n    }\n    return \"YES\";\n}", "    my $intersect_start = max($interval1->[0],\
    \ $interval2->[0]);\n    my $intersect_end = min($interval1->[1], $interval2->[1]);\n\
    \    my $intersect_length = $intersect_end - $intersect_start + 1;\n    return\
    \ $intersect_length <= 0 ? 'NO' : is_prime($intersect_length) ? 'YES' : 'NO';\n\
    }", "    my($start1, $end1) = ($interval1->[0], $interval1->[1]);\n    my($start2,\
    \ $end2) = ($interval2->[0], $interval2->[1]);\n    my($start, $end);\n    if($start1\
    \ <= $start2) {\n        $start = $start2;\n    } else {\n        $start = $start1;\n\
    \    }\n    if($end1 <= $end2) {\n        $end = $end1;\n    } else {\n      \
    \  $end = $end2;\n    }\n    if($start >= $end) {\n        return \"NO\";\n  \
    \  }\n    my $len = $end - $start;\n    if($len == 0) {\n        return \"NO\"\
    ;\n    } elsif($len == 1) {\n        return \"NO\";\n    } elsif($len == 2) {\n\
    \        return \"YES\";\n    }\n    for(my $i = 2; $i < $len; $i++) {\n     \
    \   if($len % $i == 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}", "    if ($interval1->[0] > $interval2->[1] || $interval2->[0]\
    \ > $interval1->[1]) {\n        return \"NO\";\n    }\n    my($start, $end) =\
    \ (max($interval1->[0], $interval2->[0]),\n                        min($interval1->[1],\
    \ $interval2->[1]));\n    return is_prime($end - $start + 1) ? \"YES\" : \"NO\"\
    ;\n}", "    if ( $interval1->[0] > $interval2->[1] || $interval2->[0] > $interval1->[1]\
    \ ) {\n        return \"NO\";\n    }\n    my $intersection_length = (List::Util::min(\
    \ $interval1->[1], $interval2->[1] ) -\n                               List::Util::max(\
    \ $interval1->[0], $interval2->[0] )) + 1;\n    my $is_prime = 0;\n    for my\
    \ $i ( 2 .. sqrt($intersection_length) ) {\n        $is_prime = 1, last if ( $intersection_length\
    \ % $i ) == 0;\n    }\n    return $is_prime ? \"NO\" : \"YES\";\n}", "    my @intervals\
    \ = ($interval1, $interval2);\n    my @sorted_intervals = sort { $a->[0] <=> $b->[0]\
    \ } @intervals;\n    my $union_interval = $sorted_intervals[0];\n    if ($sorted_intervals[1]->[0]\
    \ <= $union_interval->[1]) {\n        $union_interval->[1] = $sorted_intervals[1]->[1]\n\
    \            if $sorted_intervals[1]->[1] > $union_interval->[1];\n    } else\
    \ {\n        return \"NO\";\n    }\n    my $intersection_length = $union_interval->[1]\
    \ - $union_interval->[0] + 1;\n    return \"YES\" if is_prime($intersection_length);\n\
    \    return \"NO\";\n}", "    my $start = $interval1->[0] > $interval2->[0] ?\
    \ $interval1->[0] : $interval2->[0];\n    my $end = $interval1->[1] < $interval2->[1]\
    \ ? $interval1->[1] : $interval2->[1];\n    return ($start <= $end ? is_prime($end\
    \ - $start + 1) : \"NO\");\n}", "    my @interval1 = sort {$a <=> $b} @$interval1;\n\
    \    my @interval2 = sort {$a <=> $b} @$interval2;\n    my @difference;\n    if\
    \ ($interval1[0] <= $interval2[0]) {\n        push @difference, $interval2[0]\
    \ - $interval1[1];\n    } else {\n        push @difference, $interval1[0] - $interval2[1];\n\
    \    }\n    if ($difference[0] < 0) {\n        if ($difference[0] == -1) {\n \
    \           return \"YES\";\n        }\n        if (is_prime($difference[0] *\
    \ -1)) {\n            return \"YES\";\n        } else {\n            return \"\
    NO\";\n        }\n    } else {\n        return \"NO\";\n    }\n}", "    my $intersection\
    \ = get_intersection($interval1, $interval2);\n    if(defined $intersection) {\n\
    \        my $length = get_length($intersection);\n        return is_prime($length)\
    \ ? \"YES\" : \"NO\";\n    }\n    return \"NO\";\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
