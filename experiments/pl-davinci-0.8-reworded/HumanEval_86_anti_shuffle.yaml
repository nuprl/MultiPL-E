name: HumanEval_86_anti_shuffle
language: pl
prompt: "# Write a function that takes a string and returns an ordered version of\
  \ it.\n# Ordered version of string, is a string where all words (separated by space)\n\
  # are replaced by a new word where all the characters arranged in\n# ascending order\
  \ based on ascii value.\n# Note: You should keep the order of words and blank spaces\
  \ in the sentence.\n# For example:\n# >>> anti_shuffle(\"Hi\")\n# \"Hi\"\n# >>>\
  \ anti_shuffle(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle(\"Hello World!!!\")\n\
  # \"Hello !!!Wdlor\"\nsub anti_shuffle {\n    my($s) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&anti_shuffle;\n\
  \        if(eq_deeply($candidate->(\"Hi\"),\"Hi\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"hello\"),\"ehllo\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  number\"),\"bemnru\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n        if(eq_deeply($candidate->(\"abcd\"),\"abcd\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello\
  \ World!!!\"),\"Hello !!!Wdlor\")) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How\
  \ aer ?ouy\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    my @res;\n    for (split(' ', $s)) {\n        my @ss = sort split\
    \ //, $_;\n        push @res, join '', @ss;\n    }\n    return join ' ', @res;\n\
    }\n1;", "    $s =~ s/\\w+/join '', sort split '', $&/ge;\n    return $s;\n}",
  "    return join(' ', map { join('', sort split(//)) } split(/\\s+/, $s));\n}",
  "    return \"\";\n}", "    my $t = \"\";\n    my @tokens = split(\" \", $s);\n\
    \    foreach my $token (@tokens) {\n        my @chars = split(\"\", $token);\n\
    \        @chars = sort {$a cmp $b} @chars;\n        $t .= join(\"\", @chars);\n\
    \        $t .= \" \";\n    }\n    return $t;\n}", "    my @words = split(' ',\
    \ $s);\n    foreach (@words) {\n        $_ = join('',sort(split('', $_)));\n \
    \   }\n    return join(' ', @words);\n}", "    my @r = ();\n    foreach my $word\
    \ (split /\\s+/, $s) {\n        push @r, join(\"\", sort split(//, $word));\n\
    \    }\n    return join(\" \", @r);\n}", "    return $s if length($s) == 0;\n\
    \    my @s = split(\" \", $s);\n    my @sorted;\n    my $i = 0;\n    foreach (@s)\
    \ {\n        my @ss = split(\"\", $_);\n        @ss = sort {$a cmp $b} @ss;\n\
    \        foreach (@ss) {\n            $sorted[$i] .= $_;\n        }\n        $i++;\n\
    \    }\n    return join(\" \", @sorted);\n}", "    my $result = '';\n    my @lines\
    \ = split(/ /, $s);\n    foreach my $line (@lines) {\n        $result .= join('',\
    \ sort(split(//, $line)));\n        $result .= ' ';\n    }\n    $result =~ s/\
    \ //g;\n    return $result;\n}", "    return $s if ($s =~ m/\\s/);\n    return\
    \ join(\"\", sort(split(//, $s)));\n}", "    my @splits = split(\" \", $s);\n\
    \    my @parts = map { join(\"\", sort split(\"\", $_)) } @splits;\n    return\
    \ join(\" \", @parts);\n}", "    my $result = \"\";\n    my @subs = split(/\\\
    s+/, $s);\n    for my $sub (@subs) {\n        $result .= join(\"\", sort(split(//,\
    \ $sub))) . \" \";\n    }\n    return $result;\n}", "    return join(' ', map\
    \ { join '', sort(split //, $_) } split /\\s+/, $s);\n}", "    my @o = ();\n \
    \   for my $w (split / /, $s) {\n        push @o, join \"\", sort split //, $w;\n\
    \    }\n    return join \" \", @o;\n}", "    return join ' ', map {\n        join\
    \ '', sort split //\n    } split /\\s+/, $s;\n}", "    return $s if $s eq '';\n\
    \    my @w = split(/ /, $s);\n    @w = map { join('', sort split(//, $_)) } @w;\n\
    \    return join(' ', @w);\n}", "    my $out = \"\";\n    my @a = split /\\s+/,\
    \ $s;\n    foreach my $i (@a) {\n        $out .= scalar(sort(split //, $i)) .\
    \ \" \";\n    }\n    return substr($out, 0, -1);\n}", "    my @s = split /\\s+/,\
    \ $s;\n    my @new;\n    foreach (@s) {\n        my @char = split //, $_;\n  \
    \      push @new, join '', sort @char;\n    }\n    return join ' ', @new;\n}",
  "    return join(\" \", map { join(\"\", sort split //) } split /\\s+/, $s);\n}",
  "    my @words = split(' ', $s);\n    return join(' ', map { join('', sort split(//,\
    \ $_)) } @words);\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
