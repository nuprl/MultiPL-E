name: HumanEval_93_encode
language: pl
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode(\"test\")\n# \"TGST\"\n#\
  \ >>> encode(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\nsub encode {\n   \
  \ my($message) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encode;\n\
  \        if(eq_deeply($candidate->(\"TEST\"),\"tgst\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir\"\
  ),\"mWDCSKR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"YES\"),\"ygs\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"This is a message\"\
  ),\"tHKS KS C MGSSCGG\")) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT\
  \ kNqW wHcT Tq wRkTg\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n}\n\ntesthumaneval();"
completions: ["    my $encoded = \"\";\n    my $vowels = \"AEIOU\";\n    my $letters\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (my $i = 0; $i < length($message);\
    \ $i++) {\n        my $c = substr($message, $i, 1);\n        my $enc_letter =\
    \ \"\";\n        if ($c =~ /[a-z]/) {\n            # Lower case letter\n     \
    \       $enc_letter = uc($c);\n        } elsif ($c =~ /[A-Z]/) {\n           \
    \ # Upper case letter\n            $enc_letter = lc($c);\n        } else {\n \
    \           # Not a letter\n            $enc_letter = $c;\n        }\n       \
    \ if (index($vowels, $enc_letter) >= 0) {\n            my $index = index($letters,\
    \ $enc_letter);\n            $index += 2;\n            $index %= length($letters);\n\
    \            $enc_letter = substr($letters, $index, 1);\n        }\n        $encoded\
    \ .= $enc_letter;\n    }\n    return $encoded;\n}", "    my @list = split(//,\
    \ $message);\n    my @result = ();\n    foreach my $l (@list) {\n        my $code\
    \ = $l;\n        if ($l =~ /[a-z]/) {\n            $code = chr(ord('a') + (ord($l)\
    \ - ord('a') + 2) % 26);\n        } elsif ($l =~ /[A-Z]/) {\n            $code\
    \ = chr(ord('A') + (ord($l) - ord('A') + 2) % 26);\n        }\n        push(@result,\
    \ $code);\n    }\n    return join('', @result);\n}", "    my @letters = split\
    \ '', $message;\n    my @encoded;\n    my %vowels = (\n        'a' => 'c',\n \
    \       'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' =>\
    \ 'y',\n    );\n    for my $letter (@letters) {\n        my $new_letter = $letter;\n\
    \        if ($letter =~ /^[aeiou]$/i) {\n            $new_letter = $vowels{lc\
    \ $letter};\n        }\n        if ($letter =~ /^[a-z]$/) {\n            $new_letter\
    \ = chr(ord($letter) - 32);\n        }\n        elsif ($letter =~ /^[A-Z]$/) {\n\
    \            $new_letter = chr(ord($letter) + 32);\n        }\n        push @encoded,\
    \ $new_letter;\n    }\n    return join '', @encoded;\n}", "    my @array = split(//,\
    \ $message);\n    my @return_array;\n    foreach my $char (@array) {\n       \
    \ my $lower_char = lc($char);\n        if($lower_char eq 'a') {\n            $char\
    \ = lc($char) eq 'a' ? 'c' : 'C';\n        } elsif($lower_char eq 'e') {\n   \
    \         $char = lc($char) eq 'e' ? 'g' : 'G';\n        } elsif($lower_char eq\
    \ 'i') {\n            $char = lc($char) eq 'i' ? 'k' : 'K';\n        } elsif($lower_char\
    \ eq 'o') {\n            $char = lc($char) eq 'o' ? 'q' : 'Q';\n        } elsif($lower_char\
    \ eq 'u') {\n            $char = lc($char) eq 'u' ? 's' : 'S';\n        } else\
    \ {\n            $char = lc($char) eq $char ? uc($char) : lc($char);\n       \
    \ }\n        push(@return_array, $char);\n    }\n    return join('', @return_array);\n\
    }", "    my @new_message;\n    my @message = split(//, $message);\n    my %vowels\
    \ = (\"a\" => \"c\",\n                  \"e\" => \"g\",\n                  \"\
    i\" => \"k\",\n                  \"o\" => \"q\",\n                  \"u\" => \"\
    w\",\n                  \"A\" => \"C\",\n                  \"E\" => \"G\",\n \
    \                 \"I\" => \"K\",\n                  \"O\" => \"Q\",\n       \
    \           \"U\" => \"W\",\n                );\n    foreach my $letter (@message)\
    \ {\n        if (exists $vowels{$letter}) {\n            push(@new_message, $vowels{$letter});\n\
    \        } else {\n            push(@new_message, uc($letter));\n        }\n \
    \   }\n    return join(\"\", @new_message);\n}", "    my $output = '';\n    foreach\
    \ my $letter (split //, $message) {\n        my $old = lc($letter);\n        if\
    \ ($old eq $letter) {\n            $letter = uc($letter);\n        }\n       \
    \ $letter =~ tr/[aeiou]/[cfhkp]/;\n        $output .= $letter;\n    }\n    return\
    \ $output;\n}", "    my $encoded = \"\";\n    my $alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    my $alphabet2 = \"CDEFGHIJKLMNOPQRSTUVWXYZAB\";\n    my $counter = 0;\n\
    \    my $vowels = \"AEIOU\";\n    my $numVowels = 0;\n    my $vowelCount = 0;\n\
    \    my $length = length($message);\n    my $space = \" \";\n    while($counter\
    \ < $length) {\n        if($message =~ /$space/) {\n            $encoded = $encoded\
    \ . $space;\n            $counter++;\n        }\n        elsif(substr($message,\
    \ $counter, 1) =~ /[A-Z]/) {\n            $encoded = $encoded . substr($alphabet,\
    \ index($alphabet, substr($message, $counter, 1)), 1);\n            $counter++;\n\
    \        }\n        elsif(substr($message, $counter, 1) =~ /[a-z]/) {\n      \
    \      $encoded = $encoded . substr($alphabet, index($alphabet, uc(substr($message,\
    \ $counter, 1))), 1);\n            $counter++;\n        }\n        elsif(substr($message,\
    \ $counter, 1) =~ /[AEIOU]/) {\n            $encoded = $encoded . substr($alphabet2,\
    \ index($vowels, substr($message, $counter, 1)), 1);\n            $counter++;\n\
    \        }\n        elsif(substr($message, $counter, 1) =~ /[aeiou]/) {\n    \
    \        $encoded = $encoded . substr($alphabet2, index($vowels, uc(substr($message,\
    \ $counter, 1))), 1);\n            $counter++;\n        }\n    }\n    return $encoded;\n\
    }", "    my @chars = split //, $message;\n    my @result = ();\n    for my $char\
    \ (@chars) {\n        my $ch = $char;\n        if (is_vowel($char)) {\n      \
    \      $ch = next_vowel($char);\n        }\n        elsif (is_upper($char)) {\n\
    \            $ch = lc($char);\n        }\n        elsif (is_lower($char)) {\n\
    \            $ch = uc($char);\n        }\n        push @result, $ch;\n    }\n\
    \    return join '', @result;\n}", "    $message =~ tr/a-zA-Z/A-Za-z/;\n    my\
    \ @message = split '', $message;\n    my @alphabet = ('a'..'z');\n    my %vowels;\n\
    \    @vowels{@alphabet[0,4,8,14,20]} = @alphabet[2,6,10,16,22];\n    my $i = 0;\n\
    \    while ($i < @message) {\n        if (exists $vowels{$message[$i]}) {\n  \
    \          $message[$i] = $vowels{$message[$i]};\n        }\n        $i++;\n \
    \   }\n    return join '', @message;\n}\nmy $message = encode(\"This is a message\"\
    );\nprint \"$message\\n\";", "    my @message = split(\"\",$message);\n    my\
    \ @encode_message;\n    for (my $i = 0; $i < scalar(@message); $i++) {\n     \
    \   if ($message[$i] =~ /[a-z]/i) {\n            if ($message[$i] =~ /[a-z]/)\
    \ {\n                $message[$i] =~ tr/[a-z]/[A-Z]/;\n            }\n       \
    \     else {\n                $message[$i] =~ tr/[A-Z]/[a-z]/;\n            }\n\
    \            if ($message[$i] =~ /[aeiou]/i) {\n                $message[$i] =\
    \ next_char($message[$i]);\n                $message[$i] = next_char($message[$i]);\n\
    \            }\n        }\n        push(@encode_message,$message[$i]);\n    }\n\
    \    return join(\"\",@encode_message);\n}", "    my @alphabet = split('', 'abcdefghijklmnopqrstuvwxyz');\n\
    \    my @encoded = ();\n    my $vowels = 'aeiou';\n    my $en_vowels = 'cfilorux';\n\
    \    $message =~ s/[aeiou]/$en_vowels/g;\n    for my $char (split('', $message))\
    \ {\n        push @encoded, $char =~ /[a-z]/ ? uc($char) : lc($char);\n    }\n\
    \    return join('', @encoded);\n}\nprint encode(\"test\") . \"\\n\";\nprint encode(\"\
    This is a message\") . \"\\n\";", "    my %encode_letters = (\n        'a' =>\
    \ 'c', 'b' => 'd', 'c' => 'e', 'd' => 'f', 'e' => 'g', 'f' => 'h', 'g' => 'i',\
    \ 'h' => 'j', 'i' => 'k', 'j' => 'l', 'k' => 'm', 'l' => 'n', 'm' => 'o', 'n'\
    \ => 'p', 'o' => 'q', 'p' => 'r', 'q' => 's', 'r' => 't', 's' => 'u', 't' => 'v',\
    \ 'u' => 'w', 'v' => 'x', 'w' => 'y', 'x' => 'z', 'y' => 'a', 'z' => 'b',\n  \
    \      'A' => 'C', 'B' => 'D', 'C' => 'E', 'D' => 'F', 'E' => 'G', 'F' => 'H',\
    \ 'G' => 'I', 'H' => 'J', 'I' => 'K', 'J' => 'L', 'K' => 'M', 'L' => 'N', 'M'\
    \ => 'O', 'N' => 'P', 'O' => 'Q', 'P' => 'R', 'Q' => 'S', 'R' => 'T', 'S' => 'U',\
    \ 'T' => 'V', 'U' => 'W', 'V' => 'X', 'W' => 'Y', 'X' => 'Z', 'Y' => 'A', 'Z'\
    \ => 'B',\n    );\n    my $encoded_message = '';\n    my @letters = split('',\
    \ $message);\n    foreach my $letter (@letters) {\n        $encoded_message .=\
    \ $encode_letters{$letter};\n    }\n    return $encoded_message;\n}", "    my\
    \ $vowels = \"aeiou\";\n    my $newMessage = \"\";\n    foreach my $c (split //,\
    \ $message) {\n        my $newC = uc($c) eq $c ? lc($c) : uc($c);\n        if(index($vowels,\
    \ $newC) != -1) {\n            my $vowelIndex = index($vowels, $newC);\n     \
    \       my $newVowelIndex = ($vowelIndex + 2) % 5;\n            $newC = substr($vowels,\
    \ $newVowelIndex, 1);\n        }\n        $newMessage .= $newC;\n    }\n    return\
    \ $newMessage;\n}", "    $message = uc($message);\n    $message =~ s/A/C/g;\n\
    \    $message =~ s/E/G/g;\n    $message =~ s/I/K/g;\n    $message =~ s/O/Q/g;\n\
    \    $message =~ s/U/S/g;\n    return $message;\n}", "    my @letters = split(//,\
    \ $message);\n    my $encoded_msg = '';\n    foreach my $letter (@letters) {\n\
    \        if ($letter =~ /[aeiou]/i) {\n            my $encoded_letter = chr(ord($letter)\
    \ + 2);\n            $encoded_msg .= $encoded_letter;\n        } else {\n    \
    \        my $encoded_letter = uc($letter);\n            $encoded_msg .= $encoded_letter;\n\
    \        }\n    }\n    return $encoded_msg;\n}", "    my %encode_table = (\n \
    \       \"a\" => \"c\",\n        \"e\" => \"g\",\n        \"i\" => \"k\",\n  \
    \      \"o\" => \"q\",\n        \"u\" => \"y\",\n        \"y\" => \"a\",\n   \
    \     \"A\" => \"C\",\n        \"E\" => \"G\",\n        \"I\" => \"K\",\n    \
    \    \"O\" => \"Q\",\n        \"U\" => \"Y\",\n        \"Y\" => \"A\",\n    );\n\
    \    my $encoded_message = \"\";\n    my @chars = split //, $message;\n    foreach\
    \ (@chars) {\n        if ($encode_table{$_}) {\n            $encoded_message .=\
    \ $encode_table{$_};\n        } else {\n            $encoded_message .= $_;\n\
    \        }\n    }\n    return $encoded_message;\n}", "    # remove this line\n\
    \    return $message;\n}", "    my @tokens = split //, $message;\n    my $encoded;\n\
    \    my $character;\n    foreach $character (@tokens) {\n        if ($character\
    \ =~ /[A-Z]/) {\n            $encoded .= lc($character);\n        }\n        elsif\
    \ ($character =~ /[a-z]/) {\n            $encoded .= uc($character);\n       \
    \ }\n        else {\n            $encoded .= $character;\n        }\n    }\n \
    \   my @encoded_tokens = split //, $encoded;\n    my $final_message;\n    foreach\
    \ $character (@encoded_tokens) {\n        if ($character =~ /[aeiou]/) {\n   \
    \         my $ascii_value = ord($character);\n            $ascii_value += 2;\n\
    \            $final_message .= chr($ascii_value);\n        }\n        else {\n\
    \            $final_message .= $character;\n        }\n    }\n    return $final_message;\n\
    }", "    my @tmp;\n    my $c;\n    my $swapCase = 'aAeEiIoOuU';\n    my $encodeCase\
    \ = 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB';\n    my %cipher =\
    \ map {substr($swapCase,$_,1) => substr($encodeCase,$_,1)} (0..length($swapCase)-1);\n\
    \    for my $c (split('',$message)) {\n        if (exists $cipher{$c}) {\n   \
    \         push @tmp, $cipher{$c};\n        } else {\n            push @tmp, $c;\n\
    \        }\n    }\n    return join('',@tmp);\n}", "    my $vowels = 'aeiou';\n\
    \    my $codemap = 'cfjkmnprtwxzCGJKMNPRTWXZ';\n    my $result = '';\n    for\
    \ (my $i = 0; $i < length($message); $i++) {\n        my $c = substr($message,\
    \ $i, 1);\n        my $upper = uc($c) eq $c;\n        $c = lc($c);\n        if\
    \ (index($vowels, $c) != -1) {\n            $c = substr($codemap, index($vowels,\
    \ $c), 1);\n        }\n        $c = uc($c) if $upper;\n        $result .= $c;\n\
    \    }\n    return $result;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
