name: HumanEval_44_change_base
language: pl
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\n# >>> change_base(8,\
  \ 3)\n# \"22\"\n# >>> change_base(8, 2)\n# \"1000\"\n# >>> change_base(7, 2)\n#\
  \ \"111\"\nsub change_base {\n    my($x, $base) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&change_base;\n\
  \        if(eq_deeply($candidate->(8, 3),\"22\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(9, 3),\"100\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(234,\
  \ 2),\"11101010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(16, 2),\"10000\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(8, 2),\"1000\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7,\
  \ 2),\"111\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(2, 3),\"2\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 4),\"3\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4,\
  \ 5),\"4\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(5, 6),\"5\")) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(6, 7),\"6\")) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7,\
  \ 8),\"7\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    my @arr;\n    while($x >= $base) {\n        push @arr, $x % $base;\n\
    \        $x = int($x / $base);\n    }\n    push @arr, $x;\n    return join '',\
    \ reverse @arr;\n}", "    my $r = \"\";\n    while ($x > 0) {\n        $r = $x\
    \ % $base . $r;\n        $x = int($x / $base);\n    }\n    return $r;\n}", " \
    \   my $ans = \"\";\n    while($x > 0) {\n        my $rem = $x % $base;\n    \
    \    $ans = $rem . $ans;\n        $x = int($x / $base);\n    }\n    return $ans;\n\
    }", "    my $s = \"\";\n    while ($x) {\n        my $rem = $x % $base;\n    \
    \    $s = $rem . $s;\n        $x = int($x / $base);\n    }\n    return $s;\n}",
  "    my @digits = ();\n    while ($x > 0) {\n        my $mod = $x % $base;\n   \
    \     push @digits, $mod;\n        $x = int($x / $base);\n    }\n    return join('',\
    \ reverse @digits);\n}", "    if($x <= 0) { return \"0\"; }\n    my $result =\
    \ \"\";\n    while($x != 0) {\n        $result = ($x % $base) . $result;\n   \
    \     $x = int($x / $base);\n    }\n    return $result;\n}", "    my $string =\
    \ \"\";\n    my $quotient = $x;\n    my $remainder = 0;\n    while($quotient !=\
    \ 0) {\n        $remainder = $quotient % $base;\n        $quotient = int $quotient\
    \ / $base;\n        $string = $remainder . $string;\n    }\n    return $string;\n\
    }", "    if($x < $base) {\n        return $x;\n    }\n    my $lhs = $x / $base;\n\
    \    my $rhs = $x % $base;\n    return change_base($lhs, $base) . $rhs;\n}", " \
    \   # XXX TODO\n    # we should have a test for this function before implementation\n\
    \    # hint: implement this function recursively\n    return $x;\n}", "    my\
    \ $out = \"\";\n    while ($x > 0) {\n        $out = ($x % $base) . $out;\n  \
    \      $x = int($x / $base);\n    }\n    return $out;\n}", "    return unpack(\"\
    B*\", pack(\"H*\", $x));\n}", "    my $result = \"\";\n    while ($x > 0) {\n\
    \        $result = $x % $base . $result;\n        $x = int($x / $base);\n    }\n\
    \    return $result;\n}", "    my($result);\n    while (1) {\n        my($r) =\
    \ $x % $base;\n        $result = \"$r$result\";\n        $x = ($x - $r) / $base;\n\
    \        last if $x == 0;\n    }\n    return $result;\n}", "    my $result = '';\n\
    \    while ($x) {\n        $result = ($x % $base) . $result;\n        $x = int($x\
    \ / $base);\n    }\n    return $result;\n}", "    my $ans = \"\";\n    while ($x)\
    \ {\n        $ans = ($x % $base) . $ans;\n        $x = int($x / $base);\n    }\n\
    \    return $ans;\n}", "    my($q, $r, $y);\n    $y = \"\";\n    while ($x > 0)\
    \ {\n        ($q, $r) = ($x / $base, $x % $base);\n        $y = $r . $y;\n   \
    \     $x = $q;\n    }\n    return $y;\n}", "    my @temp;\n    while($x > 0) {\n\
    \        push @temp, $x % $base;\n        $x = int($x / $base);\n    }\n    return\
    \ join(\"\", reverse @temp);\n}", "    my $ret = \"\";\n    while ($x) {\n   \
    \     $ret = $x % $base . $ret;\n        $x = int($x / $base);\n    }\n    return\
    \ $ret;\n}", "    my $result = \"\";\n    while ($x > 0) {\n        my $digit\
    \ = $x % $base;\n        $result = \"$digit$result\";\n        $x = ($x - $digit)\
    \ / $base;\n    }\n    return $result;\n}", "    $x || return 0;\n    my @numbers\
    \ = ();\n    while ($x) {\n        my $y = $x % $base;\n        unshift @numbers,\
    \ $y;\n        $x = int($x / $base);\n    }\n    join '', @numbers;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
