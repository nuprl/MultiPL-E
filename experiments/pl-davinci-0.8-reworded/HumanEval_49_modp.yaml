name: HumanEval_49_modp
language: pl
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n \
  \       if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
  \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n       \
  \ exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
  \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
  \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return 1 if $n == 0;\n    return ($n * modp($n-1, $p)) % $p;\n}",
  "    my $ret = 1;\n    my $pow = $n;\n    while ($pow) {\n        if ($pow & 1)\
    \ {\n            $ret = ($ret * $n) % $p;\n        }\n        $n = ($n * $n) %\
    \ $p;\n        $pow >>= 1;\n    }\n    return $ret;\n}", "    my $r = 1;\n   \
    \ my $b = 2;\n    while ($n > 0) {\n        if ($n % 2) {\n            $r = ($r\
    \ * $b) % $p;\n        }\n        $n = int($n / 2);\n        $b = ($b * $b) %\
    \ $p;\n    }\n    return $r;\n}", '    my($pow2, $result);', "    my $result =\
    \ 1;\n    $result = ($result * 2) % $p  while  --$n > 0;\n    $result;\n}", " \
    \   if ($n < 0) {\n        return -modp(-$n, $p);\n    }\n    my $ans = 1;\n \
    \   my $x = 2;\n    while ($n) {\n        if ($n & 1) {\n            $ans = ($ans\
    \ * $x) % $p;\n        }\n        $x = ($x * $x) % $p;\n        $n >>= 1;\n  \
    \  }\n    return $ans;\n}", "    my($y, $x) = (0, 1);\n    while ($n > 0) {\n\
    \        my($q, $r) = ($n / $p, $n % $p);\n        $n = $q;\n        ($y, $x)\
    \ = ($x, $y - $q * $x);\n    }\n    $x += $p if $x < 0;\n    return $x;\n}", " \
    \   if ($n == 0) {\n        return 1;\n    }\n    elsif ($n % 2 == 0) {\n    \
    \    return modp(int($n/2), $p)**2 % $p;\n    }\n    else {\n        return modp(int($n/2),\
    \ $p)**2 * 2 % $p;\n    }\n}", "    my $r = 1;\n    while ($n > 0) {\n       \
    \ if ($n % 2 == 1) {\n            $r = ($r * $r) % $p;\n        }\n        $n\
    \ = int($n / 2);\n    }\n    return $r;\n}", "    # YOUR CODE HERE\n    my $result\
    \ = 1;\n    my $k = $n;\n    while ($k > 0) {\n        $result = ($result * 2)\
    \ % $p;\n        $k = $k - 1;\n    }\n    return $result;\n}", "    die \"n must\
    \ be non-negative\" if $n < 0;\n    die \"p must be positive\" if $p <= 0;\n \
    \   return 1 if $n == 0;\n    my $pow = $n;\n    my $acc = 1;\n    while ($pow\
    \ > 0) {\n        if ($pow % 2 == 1) {\n            $acc = $acc * $n % $p;\n \
    \       }\n        $n = $n * $n % $p;\n        $pow = int($pow / 2);\n    }\n\
    \    return $acc;\n}", "    my $res = 1;\n    while($n > 0) {\n        $res =\
    \ ($res * 2) % $p if $n % 2;\n        $n = int($n / 2);\n    }\n    return $res;\n\
    }", "    return 1 if $n == 0;\n    return 0 if $n % $p == 0;\n    my $a = $n %\
    \ $p;\n    if ($n >= $p) {\n        $a = $a * modp($n / $p, $p) % $p;\n    }\n\
    \    return $a;\n}", "    my($r) = 1;\n    while($n) {\n        $r = ($r * $n)\
    \ % $p if $n & 1;\n        $n >>= 1;\n        $n = ($n * $n) % $p if $n;\n   \
    \ }\n    $r;\n}", "    my $m;\n    if(!$n || $n == 1 || $n == -1) {\n        return\
    \ $n;\n    }\n    $m = modp($n>>1, $p);\n    $m = $m*$m % $p;\n    if($n&1) {\n\
    \        $m = $m*$n % $p;\n    }\n    return $m;\n}", "    return 1 if $n == 0;\n\
    \    my $r = modp($n / 2, $p);\n    return $r * $r % $p if $n % 2 == 0;\n    return\
    \ $r * $r * $n % $p;\n}", "    return (1 % $p) if $n == 0;\n    my $nmodp = $n\
    \ % $p;\n    my $result = 1;\n    foreach (1..$nmodp) {\n        $result = ($result\
    \ * 2) % $p;\n    }\n    return $result;\n}", "    if ($n == 0) {\n        return\
    \ 1;\n    }\n    elsif ($n % 2 == 0) {\n        return modp($n/2, $p)**2 % $p;\n\
    \    }\n    else {\n        return modp($n/2, $p)**2 % $p * 2 % $p;\n    }\n}",
  "    return 0 if $n < 0;\n    return 1 if $n == 0;\n    my $r = 1;\n    my $a =\
    \ $r;\n    while ($n > 0) {\n        if ($n % 2) {\n            $r = ($r * $a)\
    \ % $p;\n        }\n        $a = ($a * $a) % $p;\n        $n = $n >> 1;\n    }\n\
    \    return $r;\n}", "    my($r);\n    $r = 1;\n    while ($n) {\n\twhile (!($n\
    \ & 1)) {\n\t    $n >>= 1;\n\t    $p = ($p*$p) % $M;\n\t}\n\t$n--;\n\t$r = ($r*$p)\
    \ % $M;\n    }\n    return $r;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
