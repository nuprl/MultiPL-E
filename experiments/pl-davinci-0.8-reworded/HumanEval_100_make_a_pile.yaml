name: HumanEval_100_make_a_pile
language: pl
prompt: "# Given a positive integer n, you have to make a pile of n levels of stones.\n\
  # The first level has n stones.\n# The number of stones in the next level is:\n\
  # - the next odd number if n is odd.\n# - the next even number if n is even.\n#\
  \ Return the number of stones in each level in an array, where element at index\n\
  # i represents the number of stones in the level (i+1).\n# Examples:\n# >>> make_a_pile(3)\n\
  # [3, 5, 7]\nsub make_a_pile {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_a_pile;\n\
  \        if(eq_deeply($candidate->(3),[3, 5, 7])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[4, 6, 8, 10]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[5,\
  \ 7, 9, 11, 13])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(6),[6, 8, 10, 12, 14, 16])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[8,\
  \ 10, 12, 14, 16, 18, 20, 22])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @pile;\n    while ($n > 0) {\n        unshift @pile, $n;\n \
    \       $n-- if $n % 2;\n        $n /= 2;\n    }\n    return @pile;\n}", "   \
    \ my @pile;\n    for (1..$n) {\n        if (@pile) {\n            if ($pile[0]\
    \ % 2) {\n                push @pile, $pile[-1] + 2;\n            } else {\n \
    \               push @pile, $pile[-1] + 1;\n            }\n        } else {\n\
    \            push @pile, $n;\n        }\n    }\n    return @pile;\n}", "    my\
    \ @s = ($n);\n    while ($n > 1) {\n        $n -= 2;\n        push @s, $n;\n \
    \   }\n    return @s;\n}", "    my @pile;\n    if ($n < 0) {\n        croak \"\
    Cannot generate a pile of size less than zero\";\n    }\n    while ($n > 0) {\n\
    \        push @pile, $n;\n        $n = ($n % 2) ? $n + 2 : $n + 1;\n    }\n  \
    \  return @pile;\n}", "    my @pile;\n    push @pile, $n;\n    while ($n != 1)\
    \ {\n        $n = ($n % 2) ? $n + 2 : $n + 1;\n        push @pile, $n;\n    }\n\
    \    return @pile;\n}", "    my @result;\n    for my $i (0..$n-1) {\n        push\
    \ @result, (2*$i)+$n;\n    }\n    return @result;\n}", "    my @res;\n    while\
    \ ($n > 0) {\n        push @res, $n;\n        if ($n % 2 == 0) {\n           \
    \ $n -= 2;\n        } else {\n            $n -= 1;\n        }\n    }\n    return\
    \ @res;\n}", "    my @result;\n    my $cnt = $n;\n    while($cnt) {\n        push\
    \ @result, $cnt;\n        if ($cnt % 2) {\n            $cnt = $cnt + 2;\n    \
    \    } else {\n            $cnt = $cnt + 1;\n        }\n    }\n    return @result;\n\
    }", "    my @out;\n    for (my $i = 0; $i < $n; $i++) {\n        my $c = $n +\
    \ $i * 2;\n        $c = $c + 1 if ($n % 2 == 0);\n        push @out, $c;\n   \
    \ }\n    return @out;\n}", "    my @pile;\n    while ($n > 0) {\n        push\
    \ @pile, $n;\n        $n -= 2 if $n % 2;\n        $n--;\n    }\n    @pile;\n}",
  "    my @pile;\n    while ($n) {\n        push @pile, $n;\n        $n = $n % 2 ?\
    \ $n + 2 : $n + 1;\n    }\n    return @pile;\n}", "    my @pile;\n    my $ns =\
    \ $n;\n    while ($ns > 0) {\n        push @pile, $ns;\n        if ($ns % 2 ==\
    \ 0) {\n            $ns = $ns + 1;\n        } else {\n            $ns = $ns +\
    \ 2;\n        }\n    }\n    return @pile;\n}", "    my @pile;\n    while ($n >\
    \ 0) {\n        push @pile, $n;\n        if ($n % 2 == 0) {\n            $n--;\n\
    \        } else {\n            $n -= 2;\n        }\n    }\n    return reverse\
    \ @pile;\n}", "    die 'input must be a positive integer' if $n !~ /^\\d+$/;\n\
    \    my @stones;\n    while ($n >= 1) {\n        push @stones, $n;\n        $n--;\n\
    \        $n-- if $n % 2 == 0;\n    }\n    return reverse @stones;\n}", "    my\
    \ @pile;\n    for (my $i = $n; $i > 0; ) {\n        push @pile, $i;\n        if\
    \ ($i % 2 == 0) {\n            $i = $i / 2;\n        } else {\n            $i\
    \ = ($i + 1) / 2;\n        }\n    }\n    return reverse @pile;\n}", "    my(@pile)\
    \ = ($n);\n    while($n--) {\n        if($n % 2) {\n            push @pile, ($n\
    \ + 2);\n        } else {\n            push @pile, ($n + 1);\n        }\n    }\n\
    \    @pile;\n}", "    my @pile;\n    for (1..$n) {\n        push @pile, $n;\n\
    \        $n = $n % 2 ? $n + 2 : $n + 1;\n    }\n    return @pile;\n}", "    return\
    \ [] if $n == 0;\n    my @ret = ($n);\n    while ( $n > 0 ) {\n        if ( $n\
    \ % 2 == 0 ) {\n            $n = $n / 2;\n        } else {\n            $n = $n\
    \ * 3 + 1;\n        }\n        push @ret, $n;\n    }\n    return \\@ret;\n}",
  "    my @answer;\n    my $level = 1;\n    my $stone = $n;\n    while ($level <=\
    \ $n) {\n        push @answer, $stone;\n        if ($stone % 2 == 0) {\n     \
    \       $stone++;\n        } else {\n            $stone--;\n        }\n      \
    \  $level++;\n    }\n    return @answer;\n}", "    my @pile;\n    for my $i (1..$n)\
    \ {\n        push @pile, (2*$i-1, 2*$i)[$i%2];\n    }\n    return @pile;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
