name: HumanEval_109_move_one_ball
language: pl
prompt: "# We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
  # numbers in the array will be randomly ordered. Your task is to determine if\n\
  # it is possible to get an array sorted in non-decreasing order by performing \n\
  # the following operation on the given array:\n# You are allowed to perform right\
  \ shift operation any number of times.\n# One right shift operation means shifting\
  \ all elements of the array by one\n# position in the right direction. The last\
  \ element of the array will be moved to\n# the starting position in the array i.e.\
  \ 0th index. \n# If it is possible to obtain the sorted array by performing the\
  \ above operation\n# then return 1 else return .\n# If the given array is empty\
  \ then return 1.\n# Note: The given array is guaranteed to have unique elements.\n\
  # For Example:\n# >>> move_one_ball([3, 4, 5, 1, 2])\n# 1\n# Explanation: By performin\
  \ 2 right shift operations, non-decreasing order can\n# be achieved for the given\
  \ array.\n# >>> move_one_ball([3, 5, 4, 1, 2])\n# \"\"\n# Explanation:It is not\
  \ possible to get non-decreasing order for the given\n# array by performing any\
  \ number of right shift operations.\nsub move_one_ball {\n    my($arr) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&move_one_ball;\n\
  \        if(eq_deeply($candidate->([3, 4, 5, 1, 2]),1)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 10,\
  \ 1, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([4, 3, 1, 2]),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 4, 1, 2]),\"\
  \")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return 1 if (@$arr == 0);\n    my $start = 0;\n    for (my $i =\
    \ 0; $i < @$arr; $i++) {\n        if ($arr->[$i] == $i + 1) {\n            $start\
    \ = $i + 1;\n        }\n    }\n    my $n = @$arr;\n    return 1 if ($start >=\
    \ $n);\n    my $cnt = 0;\n    for (my $i = $start; $i < $n; $i++) {\n        my\
    \ $j = ($arr->[$i] - 1) % $n;\n        if ($j < $start) {\n            $cnt++;\n\
    \        }\n    }\n    return $cnt == 1;\n}", "    my @sorted = sort{$a <=> $b}\
    \ @$arr;\n    my $len = @$arr;\n    my $m = 0;\n    for(my $i = 0; $i < $len;\
    \ $i++) {\n        if($sorted[$i] == $arr->[$i]) {\n            $m++;\n      \
    \  }\n    }\n    if($m < $len - 1) {\n        return 0;\n    } else {\n      \
    \  return 1;\n    }\n}", "    my $n = @$arr;\n    if ($n == 0) {\n        return\
    \ 1;\n    }\n    my $min_index = _min_index($arr);\n    if ($min_index == 0) {\n\
    \        return 1;\n    }\n    my $max_index = _max_index($arr);\n    if ($min_index\
    \ < $max_index) {\n        return 0;\n    }\n    if ($arr->[0] == $arr->[$n -\
    \ 1]) {\n        return 0;\n    }\n    return 1;\n}", "    my($n) = scalar(@$arr);\n\
    \    my($i, $cnt, $max);\n    $cnt = 0;\n    $max = -1;\n    for($i = 0; $i <\
    \ $n; $i++) {\n        if($arr->[$i] == $n) {\n            $cnt++;\n        }\n\
    \        else {\n            $max = max($max, $arr->[$i]);\n        }\n    }\n\
    \    return $cnt == 1 && $max == $n - 1 ? 1 : -1;\n}", "    my $min  = $arr->[0];\n\
    \    my $min_idx = 0;\n    for my $i (1..$#$arr) {\n        if ($arr->[$i] < $min)\
    \ {\n            $min = $arr->[$i];\n            $min_idx = $i;\n        }\n \
    \   }\n    if ($min_idx == 0) {\n        return 1;\n    }\n    for my $i (0..$min_idx-1)\
    \ {\n        if ($arr->[$i] > $arr->[$i+1]) {\n            return 0;\n       \
    \ }\n    }\n    return 1;\n}", "    my $shift_count = 0;\n    my $last_elem =\
    \ $arr->[0];\n    my $i = 1;\n    while ($i < @$arr) {\n        if ($arr->[$i]\
    \ < $last_elem) {\n            $shift_count++;\n            last if $shift_count\
    \ > 1;\n        }\n        $last_elem = $arr->[$i];\n        $i++;\n    }\n  \
    \  return ($shift_count == 1 ? 1 : \"\");\n}", "    my $sorted = List::Util::is_sorted($arr);\n\
    \    return 1 if !$sorted;\n    my $len = @$arr;\n    my $count = 0;\n    my $start\
    \ = $arr->[0];\n    my $idx = 1;\n    while ($idx < $len) {\n        if ($arr->[$idx]\
    \ < $start) {\n            $count++;\n            if ($count > 1) {\n        \
    \        return 0;\n            }\n        }\n        $idx++;\n    }\n    return\
    \ 1;\n}", "    \n    my $n = scalar(@$arr);\n    my $i = $n - 1;\n    my $j =\
    \ $n - 1;\n    while ($i > 0) {\n        if ($arr->[$i - 1] > $arr->[$i]) {\n\
    \            if ($i == $j) {\n                # The starting element is the largest\n\
    \                # Element needs to be swapped to get non-decreasing order\n \
    \               return 0;\n            } else {\n                # The largest\
    \ element is in the middle.\n                $i--;\n                last;\n  \
    \          }\n        }\n        $i--;\n    }\n    # The largest element is moved\
    \ to the 0th position\n    # Check if rest of the array is sorted\n    while ($i\
    \ < $j) {\n        if ($arr->[$i] > $arr->[$i + 1]) {\n            return 0;\n\
    \        }\n        $i++;\n    }\n    return 1;\n}", "    my $N = scalar(@$arr);\n\
    \    my @invalid_pairs = ();\n    for(my $i = 0; $i < $N - 1; $i++) {\n      \
    \  if($arr->[$i] > $arr->[$i + 1]) {\n            push @invalid_pairs, [$i, $i\
    \ + 1];\n        }\n    }\n    # invalid_pairs store the list of invalid pairs.\n\
    \    # If we have more than 2 invalid pairs then it is not possible\n    # to\
    \ sort the array. \n    return 0 if @invalid_pairs > 2;\n    return 1 if @invalid_pairs\
    \ == 0;\n    if(scalar(@invalid_pairs) == 1) {\n        my $pair = $invalid_pairs[0];\n\
    \        if($pair->[0] == 0 && $pair->[1] == $N - 1) {\n            return 1;\n\
    \        }\n        return 0;\n    }\n    # We have two invalid pairs.\n    #\
    \ Check if the two pairs have indices as a, b, c, d where\n    # a < b < c < d\n\
    \    my $index_1 = $invalid_pairs[0]->[0];\n    my $index_2 = $invalid_pairs[0]->[1];\n\
    \    my $index_3 = $invalid_pairs[1]->[0];\n    my $index_4 = $invalid_pairs[1]->[1];\n\
    \    if($index_1 < $index_2 && $index_2 < $index_3 && $index_3 < $index_4) {\n\
    \        return 1;\n    }\n    return 0;\n}", "    # $arr is an array of positive\
    \ integers, e.g., $arr == [3, 4, 5, 1, 2]\n    # @$arr == @{$arr}\n    # @$arr[2]\
    \ == @{$arr}[2] == $arr->[2] == $arr[2]\n    # $#$arr == $#{$arr} == $#{@$arr}\n\
    \    # $#{$arr} == $#{@$arr}\n    # $#{$arr} == $#arr == $#{@$arr}\n    # $#{$arr}\
    \ == $#arr == $#{@$arr}\n    my $done = 0;\n    my $limit = @$arr;\n    while\
    \ (!$done && $limit--) {\n        my $current = $arr->[0];\n        # my $current\
    \ = $arr[0];\n        my $changed = 0;\n        my $i = 1;\n        while ($i\
    \ < @$arr) {\n            if ($arr->[$i] < $current) {\n                if ($arr->[$i]\
    \ == $arr->[$i-1]) {\n                    # We are already sorted\n          \
    \          $done = 1;\n                    last;\n                }\n        \
    \        $current = $arr->[$i];\n                # $current = $arr[$i];\n    \
    \            $changed = 1;\n            }\n            $i++;\n        }\n    \
    \    if (!$changed) {\n            # This is the sorted array\n            $done\
    \ = 1;\n        }\n        else {\n            # Shift right\n            my $last\
    \ = pop @$arr;\n            unshift @$arr, $last;\n        }\n    }\n    return\
    \ $done;\n}", "    $arr = [sort {$a <=> $b} @$arr];\n    my $n = @$arr;\n    for\
    \ my $i (0..$n-1) {\n        if($arr->[$i] != $i+1) {\n            return \"\"\
    ;\n        }\n    }\n    return 1;\n}", "    my($num_right_shifts) = 0;\n    my($i)\
    \ = 0;\n    my($last) = $arr->[-1];\n    while ($i < @$arr) {\n        if ($arr->[$i]\
    \ > $last) {\n            return 0;\n        }\n        $last = $arr->[$i];\n\
    \        $i++;\n    }\n    return 1;\n}\n1;", "    my $scalar = scalar @$arr;\n\
    \    if ( $scalar < 2 ) {\n        return 1;\n    }\n    my $max = max(@$arr);\n\
    \    my $min = min(@$arr);\n    my $sum = sum(@$arr);\n    if ( $max == $sum -\
    \ $min ) {\n        return 1;\n    }\n    return 0;\n}", "    my $length = @$arr;\n\
    \    if ($length <= 1) {\n        return 1;\n    }\n    for my $index (0 .. ($length\
    \ - 2)) {\n        if ($arr->[$index] > $arr->[$index + 1]) {\n            my\
    \ $temp = $arr->[$index];\n            $arr->[$index] = $arr->[$index + 1];\n\
    \            $arr->[$index + 1] = $temp;\n            if ($index > 0) {\n    \
    \            $arr->[$index - 1] = $arr->[$index];\n                $arr->[$index]\
    \ = $temp;\n            }\n            return 1;\n        }\n    }\n    return\
    \ 0;\n}", "    return $arr if @$arr < 2;\n    my $len = @$arr;\n    my $idx =\
    \ 0;\n    my $max = $arr->[0];\n    for my $i (1..$len-1) {\n        if ($arr->[$i]\
    \ < $max) {\n            $idx = $i;\n            last;\n        }\n        $max\
    \ = $arr->[$i];\n    }\n    if ($idx == 0) {\n        return 1;\n    }\n    my\
    \ $min = $arr->[$idx];\n    for my $i (0..$idx-1) {\n        if ($arr->[$i] >\
    \ $min) {\n            return \"\";\n        }\n    }\n    return 1;\n}", "  \
    \  my @ar = @$arr;\n    my $n = scalar @ar;\n    my @min = (0) x $n;\n    $min[$n\
    \ - 1] = $ar[$n - 1];\n    for (my $i = $n - 2; $i >= 0; $i--) {\n        $min[$i]\
    \ = min($ar[$i], $min[$i + 1]);\n    }\n    my $ans = 1;\n    my $ls = 0;\n  \
    \  my $rs = $n - 1;\n    while ($ls < $rs) {\n        if ($ar[$ls] <= $ar[$rs])\
    \ {\n            if ($ar[$ls] <= $min[$rs]) {\n                $ls++;\n      \
    \      }\n            else {\n                $ans = 0;\n                last;\n\
    \            }\n        }\n        else {\n            if ($ar[$rs] <= $min[$ls])\
    \ {\n                $rs--;\n            }\n            else {\n             \
    \   $ans = 0;\n                last;\n            }\n        }\n    }\n    return\
    \ $ans;\n}", "    my $arr_len = scalar @$arr;\n    my $sorted_arr = [sort {$a\
    \ <=> $b} @$arr];\n    my $expected_arr = [];\n    my $num_of_right_shifts = 0;\n\
    \    while (1) {\n        if (@$expected_arr > 0) {\n            if (@$expected_arr\
    \ != @$arr) {\n                last;\n            }\n            foreach my $index\
    \ (0..$arr_len-1) {\n                last if ($expected_arr->[$index] != $arr->[$index]);\n\
    \            }\n            last;\n        }\n        my $temp_arr = [];\n   \
    \     foreach my $index (0..$arr_len-1) {\n            if ($index < $arr_len-1)\
    \ {\n                $temp_arr->[$index+1] = $arr->[$index];\n            } else\
    \ {\n                $temp_arr->[0] = $arr->[$index];\n            }\n       \
    \ }\n        $arr = $temp_arr;\n        $num_of_right_shifts++;\n        $expected_arr\
    \ = $sorted_arr;\n    }\n    return $num_of_right_shifts;\n}", "    my $size =\
    \ scalar @$arr;\n    my %map;\n    # Find the maximum element in the given array.\n\
    \    for(my $i = 0; $i < $size; $i++) {\n        $map{$arr->[$i]} = $i;\n    }\n\
    \    # We can always move the maximum element to the end of the array.\n    my\
    \ $max = (sort {$b <=> $a} keys %map)[0];\n    my $max_pos = $map{$max};\n   \
    \ if($max_pos == $size - 1) {\n        return 1;\n    }\n    # If all the elements\
    \ before the maximum element are in sorted\n    # order, then it is possible to\
    \ obtain the array in non-decreasing\n    # order by moving the maximum element\
    \ to the end of the array.\n    my $flag = 1;\n    for(my $i = 0; $i < $max_pos;\
    \ $i++) {\n        if($arr->[$i] > $arr->[$i + 1]) {\n            $flag = 0;\n\
    \            last;\n        }\n    }\n    return $flag;\n}", "    my $n = scalar(@$arr);\n\
    \    my $cnt_odd = 0;\n    foreach my $i (0..$n-1) {\n        foreach my $j ($i+1..$n-1)\
    \ {\n            if ($arr->[$i] > $arr->[$j]) {\n                $cnt_odd += 1;\n\
    \            }\n        }\n    }\n    return ($cnt_odd % 2 == 0) ? 1 : 0;\n}",
  "    my $n = @$arr;\n    my $sorted = 1;\n    for (my $i = 1; $i < $n; $i++) {\n\
    \        if ($arr->[$i] < $arr->[$i - 1]) {\n            $sorted = 0;\n      \
    \      last;\n        }\n    }\n    return 1 if $sorted;\n    return 0 if $n <=\
    \ 1;\n    # Find the i where arr[i] < arr[i - 1]. Also check for [i - 1] >=\n\
    \    # [i - 2].  If not, then return 0.  Else, we can rotate arr[i - 1]\n    #\
    \ to [0].  Now, if [i - 2] > [i - 1], then return 0.\n    my $i = 0;\n    for\
    \ (my $j = 1; $j < $n; $j++) {\n        if ($arr->[$j] < $arr->[$j - 1]) {\n \
    \           $i = $j;\n            last;\n        }\n    }\n    return 0 if (($i\
    \ > 1) && ($arr->[$i - 1] >= $arr->[$i - 2]));\n    if (($i > 1) && ($arr->[$i\
    \ - 2] > $arr->[$i - 1])) {\n        return 0;\n    }\n    return 1;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
