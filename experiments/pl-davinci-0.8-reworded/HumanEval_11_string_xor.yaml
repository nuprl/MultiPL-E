name: HumanEval_11_string_xor
language: pl
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor(\"\
  010\", \"110\")\n# \"100\"\nsub string_xor {\n    my($a, $b) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_xor;\n\
  \        if(eq_deeply($candidate->(\"111000\", \"101010\"),\"010010\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  1\", \"1\"),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"0101\", \"0000\"),\"0101\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $bin_a = unpack('B*', $a);\n    my $bin_b = unpack('B*', $b);\n\
    \    my $ret = '';\n    for (my $i = 0; $i < length($bin_a); $i++) {\n       \
    \ if (substr($bin_a, $i, 1) eq substr($bin_b, $i, 1)) {\n            $ret .= '0';\n\
    \        } else {\n            $ret .= '1';\n        }\n    }\n    return pack('B*',\
    \ $ret);\n}", "    my $result = \"\";\n    my $length = length($a);\n    for (my\
    \ $i = 0; $i < $length; $i++) {\n        my $a1 = substr($a, $i, 1);\n       \
    \ my $b1 = substr($b, $i, 1);\n        $result .= ($a1 xor $b1);\n    }\n    return\
    \ $result;\n}", "    my $res = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        my $char1 = substr($a, $i, 1);\n        my $char2 = substr($b, $i,\
    \ 1);\n        $res .= $char1 ^ $char2;\n    }\n    return $res;\n}", "    my\
    \ $res = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        $res .=\
    \ substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $res;\n}", "    my\
    \ $r;\n    my $n = length($a);\n    for (my $i = 0; $i < $n; $i++) {\n       \
    \ $r .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $r;\n}", " \
    \   if ($a eq \"\") { return $b; }\n    if ($b eq \"\") { return $a; }\n    return\
    \ \"\".(($a+0) ^ ($b+0));\n}", "    my $c = \"\";\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        my $aa = substr($a, $i, 1);\n        my $bb = substr($b, $i,\
    \ 1);\n        if ($aa eq $bb) {\n            $c .= \"0\";\n        } else {\n\
    \            $c .= \"1\";\n        }\n    }\n    return $c;\n}", "    return $a\
    \ ^ $b;\n}", "    return '' if length($a) != length($b);\n    my $result = '';\n\
    \    for my $i (0 .. length($a) - 1) {\n        my $a1 = substr($a, $i, 1);\n\
    \        my $b1 = substr($b, $i, 1);\n        $result .= ($a1 ^ $b1);\n    }\n\
    \    return $result;\n}", "    my $result = '';\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        $result .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n\
    \    return $result;\n}", "    my $xor = '';\n    my $length = length($a) > length($b)\
    \ ? length($a) : length($b);\n    for (my $i = 0; $i < $length; $i++) {\n    \
    \    my $a_curr = substr($a, $i, 1);\n        my $b_curr = substr($b, $i, 1);\n\
    \        $xor .= $a_curr != $b_curr ? 1 : 0;\n    }\n    return $xor;\n}", " \
    \   return '' if length($a) != length($b);\n    my $result = '';\n    for (my\
    \ $i = 0; $i < length($a); $i++) {\n        $result .= ($a ^ $b) ? 1 : 0;\n  \
    \  }\n    return $result;\n}", "    $a = _bin_to_dec($a);\n    $b = _bin_to_dec($b);\n\
    \    my $res = $a ^ $b;\n    return _dec_to_bin($res);\n}", "    my $r = '';\n\
    \    my @a = split //, $a;\n    my @b = split //, $b;\n    foreach my $i (0..(scalar\
    \ @a - 1)) {\n        $r .= ($a[$i] + $b[$i]) % 2;\n    }\n    return $r;\n}",
  "    my $result = \"\";\n    my $j = length($a) - 1;\n    my $k = length($b) - 1;\n\
    \    my $i = 0;\n    my $x;\n    my $y;\n    for ($i = 0; $i <= $j; $i++) {\n\
    \        $x = substr($a, $i, 1);\n        $y = substr($b, $i, 1);\n        if\
    \ ($x eq $y) {\n            $result = $result . \"0\";\n        } else {\n   \
    \         $result = $result . \"1\";\n        }\n    }\n    return $result;\n}",
  "    return join('', map { $_ == 0 ? 0 : 1 } map { $_ ^= $b } map { unpack('%B*',\
    \ $_) } $a);\n}", "    my $out = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        $out .= (substr($a, $i, 1) ^ substr($b, $i, 1)) ? \"1\" : \"0\";\n\
    \    }\n    return $out;\n}", '    my($len_a, $len_b, $i, $xor, $result);', " \
    \   if ($a =~ /[^01]/ || $b =~ /[^01]/) {\n        die \"Invalid input!\";\n \
    \   }\n    my $a_bin = unpack(\"B*\", $a);\n    my $b_bin = unpack(\"B*\", $b);\n\
    \    my $out_bin = '';\n    for (my $i = 0; $i < length($a_bin); $i++) {\n   \
    \     $out_bin .= substr($a_bin, $i, 1) ^ substr($b_bin, $i, 1);\n    }\n    return\
    \ pack(\"B*\", $out_bin);\n}", "    my $len = length($a);\n    if ( $len != length($b)\
    \ ) {\n        return \"\";\n    }\n    my $r = \"\";\n    for ( my $i = 0; $i\
    \ < $len; $i++ ) {\n        my $ab = substr($a, $i, 1) . substr($b, $i, 1);\n\
    \        $r .= ( $ab eq \"01\" || $ab eq \"10\" ) ? \"1\" : \"0\";\n    }\n  \
    \  return $r;\n}", "    die \"string_xor needs two binary strings, not '$a' and\
    \ '$b'\"\n        unless $a =~ /^[01]+$/ && $b =~ /^[01]+$/;\n    die \"string_xor\
    \ needs two equal length strings, not '$a' and '$b'\"\n        unless length($a)\
    \ == length($b);\n    my $s = '';\n    for my $i (0 .. length($a)-1) {\n     \
    \   $s .= (substr($a, $i, 1) ^ substr($b, $i, 1)) ? '1' : '0';\n    }\n    return\
    \ $s;\n}", "    my @a = split(//, $a);\n    my @b = split(//, $b);\n    my @c;\n\
    \    for (my $i = 0; $i < scalar(@a); $i++) {\n        push(@c, int($a[$i]) ^\
    \ int($b[$i]));\n    }\n    return join(\"\", @c);\n}", "    my @a = split(//,\
    \ $a);\n    my @b = split(//, $b);\n    my @r;\n    foreach my $i (0..$#a) {\n\
    \        push @r, $a[$i] ^ $b[$i];\n    }\n    return join(\"\", @r);\n}", '    my($i,
    $ret);', "    my $ret = '';\n    for my $i (0..length($a)-1) {\n        $ret .=\
    \ (substr($a, $i, 1) == substr($b, $i, 1)) ? '0' : '1';\n    }\n    return $ret;\n\
    }", "    die(\"unexpected string lengths\") if (length($a) != length($b));\n \
    \   my $res = \"\";\n    for(my $i = 0; $i < length($a); $i++) {\n        my $x\
    \ = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n        if ($x ne\
    \ $y) {\n            $res .= \"1\";\n        } else {\n            $res .= \"\
    0\";\n        }\n    }\n    return $res;\n}", "    my $xor = oct(\"0b$a\") ^ oct(\"\
    0b$b\");\n    return sprintf(\"%b\", $xor);\n}", "    my $ret = \"\";\n    for(my\
    \ $i = 0; $i < length($a); $i++) {\n        $ret .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $ret;\n}", "    my @a = reverse split //, $a;\n \
    \   my @b = reverse split //, $b;\n    my @c;\n    for my $i (0 .. $#a) {\n  \
    \      $c[$i] = $a[$i] ^ $b[$i];\n    }\n    return join('', reverse @c);\n}",
  "    my $r = \"\";\n    my $length = length($a);\n    for(my $i = 0; $i < $length;\
    \ $i++) {\n        if(substr($a, $i, 1) ne substr($b, $i, 1)) {\n            $r\
    \ .= \"1\";\n        } else {\n            $r .= \"0\";\n        }\n    }\n  \
    \  return $r;\n}", "    my $r = '';\n    $r .= ((substr($a, $_, 1) + substr($b,\
    \ $_, 1)) & 1) for 0 .. length($a) - 1;\n    return $r;\n}", '    my($len, $i,
    $r);', "    my $r = \"\";\n    my $d = 0;\n    my $i = 0;\n    my $c = 0;\n  \
    \  my $pa = length($a);\n    my $pb = length($b);\n    my $n = ($pa > $pb) ? $pa\
    \ : $pb;\n    for($i = 0; $i < $n; $i++) {\n        $a =~ /(.)(.*)/;\n       \
    \ $c = $1;\n        $a = $2;\n        $b =~ /(.)(.*)/;\n        $d = $1;\n   \
    \     $b = $2;\n        $r = ((($c + $d) % 2) ? \"1\" : \"0\") . $r;\n    }\n\
    \    return $r;\n}", "    my $output = '';\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        $output .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n\
    \    return $output;\n}", "    return unless defined $a and defined $b;\n    my\
    \ $c = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        my $x = substr($a,\
    \ $i, 1);\n        my $y = substr($b, $i, 1);\n        $c .= $x xor $y;\n    }\n\
    \    return $c;\n}", "    my($r) = '';\n    my($i);\n    my($l) = (length($a)\
    \ < length($b)) ? length($a) : length($b);\n    for ($i = 0; $i < $l; $i++) {\n\
    \        $r .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return $r;\n\
    }", "    my $r = \"\";\n    my $l = length($a);\n    for(my $i = 0; $i < $l; $i++)\
    \ {\n        my $x = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n\
    \        $r .= $x eq $y ? \"0\" : \"1\";\n    }\n    return $r;\n}", "    my $l\
    \ = length($a);\n    die \"Invalid input\" if $l != length($b);\n    my $r = '';\n\
    \    for (my $i = 0; $i < $l; $i++) {\n        my $d = substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n        $r .= $d ? '1' : '0';\n    }\n    return $r;\n}", "    return\
    \ sprintf \"%b\", oct(\"0b$a\") ^ oct(\"0b$b\");\n}", "    my $l = max(length($a),\
    \ length($b));\n    $a = \"0\" x ($l - length($a)) . $a;\n    $b = \"0\" x ($l\
    \ - length($b)) . $b;\n    my $r = \"\";\n    for (my $i = 0; $i < $l; $i++) {\n\
    \        $r .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $r;\n\
    }", "    my @a = split(\"\", $a);\n    my @b = split(\"\", $b);\n    my $s = \"\
    \";\n    my $l = $#a;\n    for (my $i = 0; $i <= $l; $i++) {\n        if ($a[$i]\
    \ eq $b[$i]) {\n            $s .= \"0\";\n        } else {\n            $s .=\
    \ \"1\";\n        }\n    }\n    return $s;\n}", "    return '' if length($a) !=\
    \ length($b);\n    my $result = '';\n    for my $i (0 .. length($a) - 1) {\n \
    \       my $a_bit = substr($a, $i, 1);\n        my $b_bit = substr($b, $i, 1);\n\
    \        if ($a_bit eq $b_bit) {\n            $result .= \"0\";\n        } else\
    \ {\n            $result .= \"1\";\n        }\n    }\n    return $result;\n}",
  "    my $ans = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        my $char\
    \ = substr($a, $i, 1) xor substr($b, $i, 1);\n        $ans .= $char;\n    }\n\
    \    return $ans;\n}", "    length($a) == length($b) or die \"string_xor: Inputs\
    \ must have the same length\";\n    my $r = \"\";\n    for my $i (0..length($a)-1)\
    \ {\n        $r .= (substr($a, $i, 1) eq substr($b, $i, 1)) ? \"0\" : \"1\";\n\
    \    }\n    return $r;\n}", "    return sprintf(\"%b\", oct(\"0b$a\") ^ oct(\"\
    0b$b\"));\n}", "    return join \"\", map { $_ eq '0' ? '0' : '1' } map { split\
    \ // } @_;\n}", "    my $xor = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        $xor .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return\
    \ $xor;\n}", "    if (length($a) != length($b)) {\n        die \"Strings must\
    \ be of same length in string_xor\";\n    }\n    my $res = '';\n    for my $i\
    \ (0 .. length($a) - 1) {\n        $res .= (substr($a, $i, 1) ne substr($b, $i,\
    \ 1)) ? \"1\" : \"0\";\n    }\n    return $res;\n}", "    my $r = '';\n    for\
    \ my $i (0..length($a)-1) {\n        $r .= (substr($a, $i, 1) ^ substr($b, $i,\
    \ 1)) ? '1' : '0';\n    }\n    return $r;\n}", "    return '' if length($a) !=\
    \ length($b);\n    my $r = '';\n    my $i = 0;\n    while($i < length($a)) {\n\
    \        my $s = substr($a, $i, 1) . substr($b, $i, 1);\n        $r .= ($s eq\
    \ '01' || $s eq '10') ? '1' : '0';\n        $i++;\n    }\n    return $r;\n}",
  "    my $result = \"\";\n    my $len = length($a);\n    for (my $i = 0; $i < $len;\
    \ $i++) {\n        my $bit1 = substr($a, $i, 1);\n        my $bit2 = substr($b,\
    \ $i, 1);\n        $result .= $bit1 xor $bit2;\n    }\n    return $result;\n}",
  "    return \"\" if length($a) != length($b);\n    return join(\"\", map { (1 &\
    \ (hex($_) ^ hex($a))) ? 1 : 0 } split(//, $b));\n}", "    # Remove characters\
    \ that are the same in both strings\n    my $diff = $a ^ $b;\n    return unpack(\"\
    B*\", $diff);\n}", "    return \"\" if length($a) != length($b);\n    my @a =\
    \ split //, $a;\n    my @b = split //, $b;\n    my $out = \"\";\n    for (my $i\
    \ = 0; $i < length($a); $i++) {\n        $out .= (hex($a[$i]) ^ hex($b[$i]));\n\
    \    }\n    return $out;\n}", "    my $max = length($a) > length($b) ? length($a)\
    \ : length($b);\n    my $min = length($a) < length($b) ? length($a) : length($b);\n\
    \    my @a = split //, $a;\n    my @b = split //, $b;\n    my @res;\n    for (my\
    \ $i = 0; $i < $max; $i++) {\n        my $a = $a[$i] // '0';\n        my $b =\
    \ $b[$i] // '0';\n        $res[$i] = ($a ^ $b) == 1 ? '1' : '0';\n    }\n    return\
    \ join \"\", @res;\n}", "    my $res = \"\";\n    for(my $i = 0; $i < length($a);\
    \ $i++) {\n        $res .= (substr($a, $i, 1) eq substr($b, $i, 1)) ? \"0\" :\
    \ \"1\";\n    }\n    return $res;\n}", "    my @A = split(\"\", $a);\n    my @B\
    \ = split(\"\", $b);\n    my @out;\n    for (my $i = 0; $i < scalar(@A); $i++)\
    \ {\n        if ($A[$i] ne $B[$i]) {\n            $out[$i] = 1;\n        } else\
    \ {\n            $out[$i] = 0;\n        }\n    }\n    return join(\"\", @out);\n\
    }", "    my($len1, $len2, $maxLen) = (length($a), length($b), $len1 > $len2 ?\
    \ $len1 : $len2);\n    my($result) = '';\n    my($i);\n    for($i = 0; $i < $maxLen;\
    \ $i++) {\n        my($aBit) = ($i >= $len1) ? 0 : substr($a, $i, 1);\n      \
    \  my($bBit) = ($i >= $len2) ? 0 : substr($b, $i, 1);\n        $result .= ($aBit\
    \ != $bBit) ? '1' : '0';\n    }\n    return $result;\n}", "    my @a = split(//,\
    \ $a);\n    my @b = split(//, $b);\n    my @ab;\n    for (my $i = 0; $i < scalar(@a);\
    \ $i++) {\n        $ab[$i] = $a[$i] ^ $b[$i];\n    }\n    return join(\"\", @ab);\n\
    }", "    my $r = '';\n    my $l = length($a);\n    my $i = 0;\n    while ($i <\
    \ $l) {\n        $r .= substr($a, $i, 1) ^ substr($b, $i, 1);\n        $i++;\n\
    \    }\n    return $r;\n}", "    my $a_bits = pack \"B*\", $a;\n    my $b_bits\
    \ = pack \"B*\", $b;\n    my $xor_bits = $a_bits ^ $b_bits;\n    my $xor_string\
    \ = unpack \"B*\", $xor_bits;\n    return $xor_string;\n}", "    return join(\"\
    \", map { substr($a, $_, 1) ^ substr($b, $_, 1) } 0..length($a)-1);\n}", "   \
    \ $a = unpack('B*', $a);\n    $b = unpack('B*', $b);\n    my $max_length = max(length($a),\
    \ length($b));\n    $a = '0' x ($max_length - length($a)) . $a;\n    $b = '0'\
    \ x ($max_length - length($b)) . $b;\n    my $result = '';\n    for my $i (0 ..\
    \ $max_length - 1) {\n        if (substr($a, $i, 1) eq substr($b, $i, 1)) {\n\
    \            $result .= '0';\n        } else {\n            $result .= '1';\n\
    \        }\n    }\n    return pack('B*', $result);\n}", "    my $xor = '';\n \
    \   for my $i (0 .. length($a) - 1) {\n        my $c = substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n        $xor .= $c;\n    }\n    return $xor;\n}", "    my @a = split(//,\
    \ $a);\n    my @b = split(//, $b);\n    my @out;\n    for (my $i = 0; $i < @a;\
    \ $i++) {\n        $out[$i] = (int($a[$i]) ^ int($b[$i]));\n    }\n    return\
    \ join('', @out);\n}", "    my $ret = \"\";\n    my $len = length($a);\n    my\
    \ $i;\n    my $a_i;\n    my $b_i;\n    for ($i = 0; $i < $len; $i++) {\n     \
    \   $a_i = substr($a, $i, 1);\n        $b_i = substr($b, $i, 1);\n        if (\
    \ ($a_i eq '0') || ($b_i eq '0') ) {\n            $ret .= '0';\n        }\n  \
    \      else {\n            $ret .= '1';\n        }\n    }\n    return $ret;\n}",
  "    if (length($a) < length($b)) {\n        $a = ('0' x (length($b) - length($a)))\
    \ . $a;\n    } elsif (length($b) < length($a)) {\n        $b = ('0' x (length($a)\
    \ - length($b))) . $b;\n    }\n    my $c = '';\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        if (substr($a, $i, 1) ne substr($b, $i, 1)) {\n           \
    \ $c .= '1';\n        } else {\n            $c .= '0';\n        }\n    }\n   \
    \ return $c;\n}", "    my @a = split //, $a;\n    my @b = split //, $b;\n    my\
    \ @c;\n    for (my $i = 0; $i < scalar @a; $i++) {\n        $c[$i] = $a[$i] ^\
    \ $b[$i];\n    }\n    return join \"\", @c;\n}", "    my $n = length($a);\n  \
    \  my $s = \"\";\n    for (my $i = 0; $i < $n; $i++) {\n        my $a_i = substr($a,\
    \ $i, 1);\n        my $b_i = substr($b, $i, 1);\n        $s .= ($a_i != $b_i)\
    \ ? '1' : '0';\n    }\n    return $s;\n}", "    my @a = split //, $a;\n    my\
    \ @b = split //, $b;\n    my @xor = map { $a[$_] eq $b[$_] ? 0 : 1 } 0..2;\n \
    \   return join '', @xor;\n}", "    return '' if length($a) != length($b);\n \
    \   return join('', map { chr(ord(substr($a, $_, 1)) ^ ord(substr($b, $_, 1)))\
    \ } 0..length($a)-1);\n}", "    return \"\" if(!defined($a) || !defined($b));\n\
    \    my $c = \"\";\n    my $i = 0;\n    foreach my $x (split(//, $a)) {\n    \
    \    my $y = substr($b, $i, 1);\n        $c .= ($x ^ $y);\n        $i++;\n   \
    \ }\n    return $c;\n}", "    my $len = length($a);\n    my $bstr = $b;\n    $bstr\
    \ = substr($bstr, 0, $len);\n    my $result = \"\";\n    for (my $i = 0; $i <\
    \ $len; $i++) {\n        my $achar = substr($a, $i, 1);\n        my $bchar = substr($bstr,\
    \ $i, 1);\n        if ($achar eq $bchar) {\n            $result .= \"0\";\n  \
    \      } else {\n            $result .= \"1\";\n        }\n    }\n    return $result;\n\
    }", "    my $r = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n       \
    \ my $x = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n        $r .=\
    \ (int($x) + int($y)) % 2;\n    }\n    return $r;\n}", "    my @a = split(//,\
    \ $a);\n    my @b = split(//, $b);\n    my @result;\n    for (my $i = 0; $i <\
    \ scalar(@a); $i++) {\n        $result[$i] = $a[$i] ^ $b[$i];\n    }\n    return\
    \ join(\"\", @result);\n}", "    my $r = $a ^ $b;\n    my $r_str = pack(\"H*\"\
    , $r);\n    return $r_str;\n}", "    my $len = length($a);\n    die unless $len\
    \ == length($b);\n    my $result = \"\";\n    for (my $i = 0; $i < $len; $i++)\
    \ {\n        my $a_bit = substr($a, $i, 1);\n        my $b_bit = substr($b, $i,\
    \ 1);\n        if ($a_bit eq $b_bit) {\n            $result .= \"0\";\n      \
    \  } else {\n            $result .= \"1\";\n        }\n    }\n    return $result;\n\
    }", "    $a = hex_to_bin($a);\n    $b = hex_to_bin($b);\n    return bin_to_hex(xor_arrays(string_to_array($a),\
    \ string_to_array($b)));\n}", "    my @a = split '', $a;\n    my @b = split '',\
    \ $b;\n    my @r;\n    for (0..(@a < @b ? $#a : $#b)) {\n        $r[$_] = $a[$_]\
    \ ^ $b[$_];\n    }\n    return join '', @r;\n}", "    my $res = \"\";\n    for\
    \ (my $i = 0; $i < length($a); $i++) {\n        $res .= (substr($a, $i, 1) eq\
    \ substr($b, $i, 1)) ? \"0\" : \"1\";\n    }\n    return $res;\n}", "    my @a\
    \ = split '', $a;\n    my @b = split '', $b;\n    my @c;\n    $c[$_] = ($a[$_]\
    \ eq $b[$_]) ? 0 : 1 for (0..$#a);\n    return join '', @c;\n}", "    return ''\
    \ if length($a) != length($b);\n    my @a = split //, $a;\n    my @b = split //,\
    \ $b;\n    my $r = '';\n    for(my $i = 0; $i < @a; $i++) {\n        $r .= ($a[$i]\
    \ ne $b[$i]) ? '1' : '0';\n    }\n    return $r;\n}", "    my($i, $j, $k, $l);\n\
    \    my($A, $B, $C, $D);\n    my($c, $d, $e, $f);\n    my($s);", "    my @x =\
    \ split(//, $a);\n    my @y = split(//, $b);\n    my @z = map {$x[$_] eq $y[$_]\
    \ ? 0 : 1} (0..2);\n    return join('', @z);\n}", "    return (unpack('B*', pack('B*',\
    \ $a) ^ pack('B*', $b))) =~ tr/01/10/r;\n}", "    my $len = max(length($a), length($b));\n\
    \    return join '', map { substr($a, $_, 1) ^ substr($b, $_, 1) } 0 .. $len-1;\n\
    }", "    my $ret = \"\";\n    for(my $i = 0; $i < length($a); $i++) {\n      \
    \  my $x = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n        if($x\
    \ eq $y) {\n            $ret .= \"0\";\n        } else {\n            $ret .=\
    \ \"1\";\n        }\n    }\n    return $ret;\n}", "    my $r = '';\n    my $n\
    \ = length($a);\n    for (my $i = 0; $i < $n; $i++) {\n        my $aa = substr($a,\
    \ $i, 1);\n        my $bb = substr($b, $i, 1);\n        $r .= (int($aa) ^ int($bb));\n\
    \    }\n    return $r;\n}", "    my @a = split //, $a;\n    my @b = split //,\
    \ $b;\n    my @c;\n    while (@a && @b) {\n        push @c, $a[0] ^ $b[0];\n \
    \       shift @a;\n        shift @b;\n    }\n    return join '', @c;\n}", "  \
    \  die \"unequal length\" if length($a) != length($b);\n    my $a_bin = unpack(\"\
    B*\", $a);\n    my $b_bin = unpack(\"B*\", $b);\n    my $xor_bin = $a_bin ^ $b_bin;\n\
    \    return pack(\"B*\", $xor_bin);\n}", "    return \"\" if !defined($a) || !defined($b);\n\
    \    return $a ^ $b;\n}", "    my $longer = length($a) > length($b) ? $a : $b;\n\
    \    my $shorter = length($a) > length($b) ? $b : $a;\n    my $res = \"\";\n \
    \   my $shift = length($longer) - length($shorter);\n    for (my $i = 0; $i <\
    \ length($shorter); $i++) {\n        $res .= substr($longer, $i, 1) ^ substr($shorter,\
    \ $i, 1);\n    }\n    $res .= substr($longer, length($shorter), $shift);\n   \
    \ return $res;\n}", "    my @a = split //, $a;\n    my @b = split //, $b;\n  \
    \  my @c;\n    my $j = 0;\n    my $i = 0;\n    for ($i = 0; $i < @a; $i++) {\n\
    \        $c[$i] = $a[$i] ^ $b[$i];\n    }\n    return join '', @c;\n}", "    my\
    \ $ret = '';\n    my $min = $a if length($a) < length($b);\n    $min = $b if length($b)\
    \ < length($a);\n    my $max = $a if length($a) > length($b);\n    $max = $b if\
    \ length($b) > length($a);\n    my $len = length($min);\n    for (my $i = 0; $i\
    \ < $len; $i++) {\n        my $char = substr($min, $i, 1);\n        $ret .= substr($max,\
    \ $i, 1) eq $char ? '0' : '1';\n    }\n    for (my $i = $len; $i < length($max);\
    \ $i++) {\n        $ret .= substr($max, $i, 1);\n    }\n    return $ret;\n}",
  "    my($c, $d);\n    $c = string_to_binary($a);\n    $d = string_to_binary($b);\n\
    \    return unparse_binary(binary_xor($c, $d));\n}", "    return unless defined\
    \ $a && defined $b;\n    my $ret = \"\";\n    my $len = length($a) > length($b)\
    \ ? length($a) : length($b);\n    for(my $i = 0; $i < $len; $i++) {\n        my\
    \ $aa = substr($a, $i, 1);\n        my $bb = substr($b, $i, 1);\n        $ret\
    \ .= $aa ? ($bb ? \"0\" : \"1\") : ($bb ? \"1\" : \"0\");\n    }\n    return $ret;\n\
    }", "    my($r) = \"\";\n    my($i);\n    for($i = 0; $i < length($a); $i++) {\n\
    \        $r .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $r;\n\
    }", '    my($i, $ret);', "    my $b1 = unpack(\"B*\", $a);\n    my $b2 = unpack(\"\
    B*\", $b);\n    my $c = \"\";\n    for(my $i = 0; $i < length($b1); $i++) {\n\
    \        if(substr($b1, $i, 1) eq substr($b2, $i, 1)) {\n            $c .= \"\
    0\";\n        } else {\n            $c .= \"1\";\n        }\n    }\n    return\
    \ pack(\"B*\", $c);\n}", "    my $r = '';\n    $r .= ((substr($a,$_,1) ^ substr($b,$_,1))\
    \ ? '1' : '0') for (0..length($a)-1);\n    return $r;\n}", "    my($x) = \"\"\
    ;\n    for (my $i = 0; $i < length($a); $i++) {\n        my($m) = substr($a, $i,\
    \ 1);\n        my($n) = substr($b, $i, 1);\n        $x .= (int($m) ^ int($n));\n\
    \    }\n    return $x;\n}", "    my $res = \"\";\n    while ($a ne \"\" || $b\
    \ ne \"\") {\n        if (substr($a, 0, 1) eq substr($b, 0, 1)) {\n          \
    \  $res .= \"0\";\n        } else {\n            $res .= \"1\";\n        }\n \
    \       $a = substr($a, 1);\n        $b = substr($b, 1);\n    }\n    return $res;\n\
    }", "    my $result = '';\n    for (my $i = 0; $i < length($a); $i++) {\n    \
    \    my $bit_a = substr($a, $i, 1);\n        my $bit_b = substr($b, $i, 1);\n\
    \        if ($bit_a == $bit_b) {\n            $result .= '0';\n        } else\
    \ {\n            $result .= '1';\n        }\n    }\n    return $result;\n}", '    my($out,
    $i);', "    my $ret = \"\";\n    my $len = ($#_ == 1) ? length($b) : length($a);\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        $ret .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $ret;\n}", "    my $r = '';\n    my $i = 0;\n   \
    \ my $j = 0;\n    my $c = 0;\n    my $n = length($a);\n    my $m = length($b);\n\
    \    # assume $n == $m, which is true for our problem, but not strictly\n    #\
    \ necessary", "    my $len = length($a);\n    die \"Inputs have different lengths:\
    \ $a, $b\" if $len != length($b);\n    my $xor = '';\n    for (my $i = 0; $i <\
    \ $len; $i++) {\n        my $ch = substr($a, $i, 1) ne substr($b, $i, 1) ? '1'\
    \ : '0';\n        $xor .= $ch;\n    }\n    return $xor;\n}", "    my($i, $j, $c);\n\
    \    for($i = 0, $j = length($a) - 1; $i < length($a); $i++, $j--) {\n       \
    \ $c .= ((substr($a, $i, 1) eq substr($b, $i, 1)) ? \"0\" : \"1\");\n    }\n \
    \   return $c;\n}", "    if(length($a) != length($b)) {\n        die \"Inputs\
    \ must be the same length\";\n    }\n    my $ret = \"\";\n    my $i;\n    for($i\
    \ = 0; $i < length($a); $i++) {\n        $ret .= (int(substr($a, $i, 1)) ^ int(substr($b,\
    \ $i, 1))) ? \"1\" : \"0\";\n    }\n    return $ret;\n}", "    my $len = length($a);\n\
    \    my $out = '';\n    for (my $i = 0; $i < $len; $i++) {\n        $out .= substr($a,\
    \ $i, 1) ^ substr($b, $i, 1);\n    }\n    return $out;\n}", "    my $min_len =\
    \ min(length($a), length($b));\n    my $result = '';\n    for (my $i = 0; $i <\
    \ $min_len; $i++) {\n        my $new_char = substr($a, $i, 1) ^ substr($b, $i,\
    \ 1);\n        $result .= $new_char;\n    }\n    $result .= substr($a, $min_len)\
    \ if (length($a) > $min_len);\n    $result .= substr($b, $min_len) if (length($b)\
    \ > $min_len);\n    return $result;\n}", "    return join(\"\", map { $_ > 0 ?\
    \ 1 : 0 } map { ord($a) ^ ord($b) } (0..length($a)));\n}", "    my($r) = '';\n\
    \    for(my $i = 0; $i < length($a); $i++) {\n        my($a_i) = substr($a, $i,\
    \ 1);\n        my($b_i) = substr($b, $i, 1);\n        $r .= ($a_i eq $b_i ? '0'\
    \ : '1');\n    }\n    return $r;\n}", "    my $len = length($a);\n    my $ret\
    \ = \"\";\n    for (my $i = 0; $i < $len; $i++) {\n        $ret .= (substr($a,\
    \ $i, 1) eq substr($b, $i, 1)) ? \"0\" : \"1\";\n    }\n    return $ret;\n}",
  "    my $xor = \"\";\n    for(my $i = 0; $i < length($a); $i++) {\n        $xor\
    \ .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return $xor;\n}", " \
    \   my $xor = $a ^ $b;\n    return $xor;\n}", "    my($r) = \"\";\n    my($c)\
    \ = length($a);\n    if ($c != length($b)) {\n        return $r;\n    }\n    for\
    \ (my($i) = 0; $i < $c; $i++) {\n        my($x) = substr($a, $i, 1);\n       \
    \ my($y) = substr($b, $i, 1);\n        $r .= (($x eq $y) ? \"0\" : \"1\");\n \
    \   }\n    return $r;\n}", "    return '' if length($a) != length($b);\n    my\
    \ $xor = '';\n    for (my $i = 0; $i < length($a); $i++) {\n        my $bit =\
    \ substr($a, $i, 1) ^ substr($b, $i, 1);\n        $xor .= $bit;\n    }\n    return\
    \ $xor;\n}", "    return '' if !defined $a || !defined $b;\n    my @a = split(//,\
    \ $a);\n    my @b = split(//, $b);\n    my $output = '';\n    for (my $i = 0;\
    \ $i < @a; $i++) {\n        $output .= $a[$i] ^ $b[$i];\n    }\n    return $output;\n\
    }", "    my $ret = '';\n    my $i;\n    for($i = 0; $i < length($a); $i++) {\n\
    \        if(substr($a, $i, 1) eq substr($b, $i, 1)) {\n            $ret .= '0';\n\
    \        } else {\n            $ret .= '1';\n        }\n    }\n    return $ret;\n\
    }", "    my($res) = \"\";\n    my($len) = length($a);\n    for(my($i) = 0; $i\
    \ < $len; $i++) {\n        my($a_cur) = substr($a, $i, 1);\n        my($b_cur)\
    \ = substr($b, $i, 1);\n        my($res_cur) = int($a_cur) ^ int($b_cur);\n  \
    \      $res .= $res_cur;\n    }\n    return $res;\n}", "    if ($a eq \"\" ||\
    \ $b eq \"\") { return \"\"; }\n    my($xor) = \"\";\n    my($i);\n    for ($i\
    \ = 0; $i < length($a); $i++) {\n        $xor .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $xor;\n}", "    my $c = \"\";\n    for (my $i = 0;\
    \ $i < length($a); $i++) {\n        $c .= substr($a, $i, 1) ^ substr($b, $i, 1);\n\
    \    }\n    return $c;\n}", "    my $c = \"\";\n    my $length = max(length($a),\
    \ length($b));\n    for(my $i = 0; $i < $length; $i++) {\n        my $a0 = substr($a,\
    \ $i, 1);\n        my $b0 = substr($b, $i, 1);\n        if(($a0 eq \"0\" && $b0\
    \ eq \"0\") || ($a0 eq \"1\" && $b0 eq \"1\")) {\n            $c .= \"0\";\n \
    \       } else {\n            $c .= \"1\";\n        }\n    }\n    return $c;\n\
    }", "    my $result = \"\";\n    for(my $i = 0; $i < length($a); $i++) {\n   \
    \     my $x = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n       \
    \ if(($x eq \"0\" && $y eq \"0\") || ($x eq \"1\" && $y eq \"1\")) {\n       \
    \     $result .= \"0\";\n        }\n        else {\n            $result .= \"\
    1\";\n        }\n    }\n    return $result;\n}", "    my $len = length($a);\n\
    \    my $result = \"\";\n    for (my $i = 0; $i < $len; $i++) {\n        $result\
    \ .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return $result;\n}",
  "    my($r);\n    my($l) = length($a);\n    for (my($i) = 0; $i < $l; $i++) {\n\t\
    my($ac) = substr($a, $i, 1);\n\tmy($bc) = substr($b, $i, 1);\n\tif (($ac eq \"\
    1\") && ($bc eq \"1\")) {\n\t    $r .= \"0\";\n\t} elsif (($ac eq \"0\") && ($bc\
    \ eq \"0\")) {\n\t    $r .= \"0\";\n\t} else {\n\t    $r .= \"1\";\n\t}\n    }\n\
    \    return $r;\n}", "    my $r = \"\";\n    for(my $i = 0; $i < length($a); $i++)\
    \ {\n        if(substr($a, $i, 1) eq substr($b, $i, 1)) {\n            $r .= \"\
    0\";\n        } else {\n            $r .= \"1\";\n        }\n    }\n    return\
    \ $r;\n}", "    $a ^= $b;\n    return sprintf \"%0${BINARY_STRING_PADDING}b\"\
    , $a;\n}", "    return '' if length($a) != length($b);\n    my $result = '';\n\
    \    my $i = 0;\n    for(; $i < length($a); $i++) {\n        if (substr($a, $i,\
    \ 1) eq substr($b, $i, 1)) {\n            $result .= '0';\n        } else {\n\
    \            $result .= '1';\n        }\n    }\n    return $result;\n}", "   \
    \ my $len = length($a);\n    my $result = \"\";\n    my $i;\n    for ($i = 0;\
    \ $i < $len; $i++) {\n        $result .= int(substr($a, $i, 1)) ^ int(substr($b,\
    \ $i, 1));\n    }\n    return $result;\n}", "    return undef if length($a) !=\
    \ length($b);\n    my $ret = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        $ret .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return\
    \ $ret;\n}", "    my $r = \"\";\n    my $l = length($a);\n    for(my $i = 0; $i\
    \ < $l; $i++){\n        if(substr($a, $i, 1) eq substr($b, $i, 1)){\n        \
    \    $r .= \"0\";\n        } else {\n            $r .= \"1\";\n        }\n   \
    \ }\n    return $r;\n}", "    length($a) == length($b) or die \"Length of strings\
    \ not equal\\n\";\n    my $len = length($a);\n    my $c = \"\";\n    for(my $i\
    \ = 0; $i < $len; $i++) {\n        my $a_bit = substr($a, $i, 1);\n        my\
    \ $b_bit = substr($b, $i, 1);\n        my $c_bit = $a_bit ^ $b_bit;\n        $c\
    \ .= $c_bit;\n    }\n    return $c;\n}", "    # xor the binary numbers\n    my\
    \ $a_val = oct(\"0b$a\");\n    my $b_val = oct(\"0b$b\");\n    my $c_val = $a_val\
    \ ^ $b_val;\n    # convert to binary string\n    my $c = sprintf(\"%b\", $c_val);\n\
    \    return $c;\n}", "    return sprintf(\"%b\", oct(\"0b$a\") ^ oct(\"0b$b\"\
    ));\n}", "    my($len) = length($a);\n    my($out) = \"\";\n    for (my($i) =\
    \ 0; $i < $len; $i++) {\n        $out .= substr($a, $i, 1) ^ substr($b, $i, 1);\n\
    \    }\n    return $out;\n}", "    return join('', map { $_ =~ /[01]/ ? 1 ^ $b\
    \ =~ /[01]/ : $_ } split(//, $a));\n}", "    my $ret = '';\n    for (my $i = 0;\
    \ $i < length($a); $i++) {\n        if (substr($a, $i, 1) eq substr($b, $i, 1))\
    \ {\n            $ret .= '0';\n        } else {\n            $ret .= '1';\n  \
    \      }\n    }\n    return $ret;\n}", "    my $s = '';\n    for my $i (0..length($a)\
    \ - 1) {\n        $s .= substr($a, $i, 1) eq substr($b, $i, 1) ? '0' : '1';\n\
    \    }\n    return $s;\n}", "    my($len) = length($a);\n    my($i);\n    my($r);",
  "    my $out = \"\";\n    my $i;\n    for ($i = 0; $i < length($a); $i++) {\n  \
    \      $out .= char_xor(substr($a, $i, 1), substr($b, $i, 1));\n    }\n    return\
    \ $out;\n}", "    my $r = '';\n    my $blen = length($b);\n    my $alen = length($a);\n\
    \    my $i = 0;\n    while (1) {\n        if ($i >= $blen || $i >= $alen) {\n\
    \            last;\n        }\n        my $ac = substr($a, $i, 1);\n        my\
    \ $bc = substr($b, $i, 1);\n        if ($ac eq $bc) {\n            $r .= '0';\n\
    \        } else {\n            $r .= '1';\n        }\n        $i++;\n    }\n \
    \   return $r;\n}", "    my $c = \"\";\n    for(my $i = 0; $i < length($a); $i++)\
    \ {\n        $c .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $c;\n\
    }", "    my $result = \"\";\n    my $maxlen = length($a) > length($b) ? length($a)\
    \ : length($b);\n    for (my $i = 0; $i < $maxlen; $i++) {\n        my $x = length($a)\
    \ > $i ? substr($a, $i, 1) : \"0\";\n        my $y = length($b) > $i ? substr($b,\
    \ $i, 1) : \"0\";\n        my $z = $x ^ $y;\n        $result .= $z;\n    }\n \
    \   return $result;\n}", "    my $res = '';\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        $res .= substr($a, $i, 1) eq substr($b, $i, 1) ? '0' : '1';\n\
    \    }\n    return $res;\n}", "    my @a = split('', $a);\n    my @b = split('',\
    \ $b);\n    my $bin_xor = sprintf(\"%d\", (oct(\"0b$a\") ^ oct(\"0b$b\")));\n\
    \    return unpack(\"B32\", pack(\"N\", $bin_xor));\n}", "    my $len = length($a);\n\
    \    my $result = \"\";\n    for (my $i = 0; $i < $len; $i++) {\n        my $c1\
    \ = substr($a, $i, 1);\n        my $c2 = substr($b, $i, 1);\n        $result .=\
    \ ($c1 ^ $c2);\n    }\n    return $result;\n}", "    return '' if length($a) !=\
    \ length($b);\n    return '' if $a !~ /^[01]+$/ || $b !~ /^[01]+$/;\n    my $xor\
    \ = '';\n    for (my $i = 0; $i < length($a); $i++) {\n        my $a_bit = substr($a,\
    \ $i, 1);\n        my $b_bit = substr($b, $i, 1);\n        if ($a_bit eq $b_bit)\
    \ {\n            $xor .= \"0\";\n        } else {\n            $xor .= \"1\";\n\
    \        }\n    }\n    return $xor;\n}", "    my($xor) = \"\";\n    for (my $i\
    \ = 0; $i < length($a); $i++) {\n        $xor .= (substr($a, $i, 1) ^ substr($b,\
    \ $i, 1));\n    }\n    return $xor;\n}", "    die \"Each string must have the\
    \ same length\" unless length($a) == length($b);\n    return join('', map { $_\
    \ eq '0' ? '1' : '0' } map { $a =~ m/^$_/; $1 } (0, 1) x length($a));\n}", " \
    \   my @a = split //, $a;\n    my @b = split //, $b;\n    my @c;\n    foreach\
    \ my $i (0 .. @a-1) {\n        $c[$i] = $a[$i] eq $b[$i] ? 0 : 1;\n    }\n   \
    \ return join('', @c);\n}", "    my $ret = \"\";\n    my $len = length($a);\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        if (substr($a, $i, 1) eq substr($b,\
    \ $i, 1)) {\n            $ret .= \"0\";\n        } else {\n            $ret .=\
    \ \"1\";\n        }\n    }\n    return $ret;\n}", "    my @a = split(//, $a);\n\
    \    my @b = split(//, $b);\n    my @out;\n    for my $i (0 .. $#a) {\n      \
    \  $out[$i] = ($a[$i] ne $b[$i]) ? 1 : 0;\n    }\n    return join('', @out);\n\
    }", "    $a =~ s/\\s//g;\n    $b =~ s/\\s//g;\n    my $res = \"\";\n    for(my\
    \ $i = 0; $i < length($a); $i++) {\n        $res .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $res;\n}", "    my $c = '';\n    while ( length($a)\
    \ && length($b) ) {\n        $c .= ( chop($a) eq chop($b) ) ? 0 : 1;\n    }\n\
    \    return $c;\n}", "    my $c = '';\n    my $i = 0;\n    my $len = length($a);\n\
    \    # Ensure that $a and $b are of equal length.\n    $len = length($b) if (length($b)\
    \ > $len);\n    for ($i = 0; $i < $len; $i++) {\n        $c .= substr($a, $i,\
    \ 1) ^ substr($b, $i, 1);\n    }\n    return $c;\n}", "    $a =~ tr/01/\\x00\\\
    x01/;\n    $b =~ tr/01/\\x00\\x01/;\n    return join '', map { chr(ord($_) ^ ord(pop\
    \ @b)) } split //, $a;\n}", "    my $r = \"\";\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        my $c = substr($a, $i, 1) ^ substr($b, $i, 1);\n        $r\
    \ .= $c ? '1' : '0';\n    }\n    return $r;\n}", "    return pack(\"B*\", unpack(\"\
    B*\", $a) ^ unpack(\"B*\", $b));\n}", "    return ( \"$a\" ^ \"$b\" );\n}", " \
    \   my @a = split //, $a;\n    my @b = split //, $b;\n    my @r;\n    for (my\
    \ $i = 0; $i < @a; $i++) {\n        $r[$i] = $a[$i] ^ $b[$i];\n    }\n    return\
    \ join '', @r;\n}", "    $a = sprintf(\"%0${$_[2]}b\", $a) if defined $_[2];\n\
    \    $b = sprintf(\"%0${$_[2]}b\", $b) if defined $_[2];\n    my $out = \"\";\n\
    \    for (my $i = 0; $i < length($a); $i++) {\n        $out .= substr($a, $i,\
    \ 1) ^ substr($b, $i, 1);\n    }\n    return $out;\n}", "    return join('', map(($_[0]\
    \ ^ $_[1]), split(//, $a), split(//, $b)));\n}", "    return $a ^ $b;\n}", " \
    \   $a ^= $b;\n    return unpack('B*', pack('N', $a));\n}", "    my $r = \"\"\
    ;\n    for (my $i = 0; $i < length($a); $i++) {\n        my $v = (substr($a, $i,\
    \ 1) eq substr($b, $i, 1)) ? \"0\" : \"1\";\n        $r .= $v;\n    }\n    return\
    \ $r;\n}", "    my @a = split(//, $a);\n    my @b = split(//, $b);\n    my @r;\n\
    \    foreach my $i (0..$#a) {\n        $r[$i] = $a[$i] ^ $b[$i];\n    }\n    return\
    \ join(\"\", @r);\n}", "    my @a = split //, $a;\n    my @b = split //, $b;\n\
    \    my @c;\n    while(@a) {\n        push @c, (shift @a) ^ (shift @b);\n    }\n\
    \    return join '', @c;\n}", "    my $c = \"\";\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        my $x = substr($a, $i, 1);\n        my $y = substr($b, $i,\
    \ 1);\n        $c .= $x ^ $y;\n    }\n    return $c;\n}", "    return join '',\
    \ map { ord($a) ^ ord($b) } split //, $a;\n}", "    my $r = \"\";\n    my $i;\n\
    \    for ($i = 0; $i < length($a); $i++) {\n        $r .= (substr($a, $i, 1) eq\
    \ substr($b, $i, 1)) ? '0' : '1';\n    }\n    return $r;\n}", "    return pack\
    \ \"H*\", unpack \"H*\", $a ^ $b;\n}", "    die \"Only binary strings allowed\"\
    \ if ($a =~ m/[^01]/ || $b =~ m/[^01]/);\n    my $c = \"\";\n    for (my $i =\
    \ 0; $i < length($a); $i++) {\n        $c .= substr($a, $i, 1) eq substr($b, $i,\
    \ 1) ? \"0\" : \"1\";\n    }\n    return $c;\n}", "    my @a = split('', $a);\n\
    \    my @b = split('', $b);\n    my $c = '';\n    for (my $i = 0; $i < scalar(@a);\
    \ $i++) {\n        $c .= ($a[$i] != $b[$i]) ? '1' : '0';\n    }\n    return $c;\n\
    }", "    my $result = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n  \
    \      if (substr($a, $i, 1) eq substr($b, $i, 1)) {\n            $result .= \"\
    0\";\n        } else {\n            $result .= \"1\";\n        }\n    }\n    return\
    \ $result;\n}", "    my $xor = '';\n    for my $i (0 .. length($a) - 1) {\n  \
    \      if(substr($a, $i, 1) eq substr($b, $i, 1)) {\n            $xor .= \"0\"\
    ;\n        } else {\n            $xor .= \"1\";\n        }\n    }\n    return\
    \ $xor;\n}", "    $a ^= $b;\n    return $a;\n}", "    die \"can only do XOR of\
    \ binary strings, '$a' not binary\" unless $a =~ /^[01]+$/;\n    die \"can only\
    \ do XOR of binary strings, '$b' not binary\" unless $b =~ /^[01]+$/;\n    die\
    \ \"can only do XOR of binary strings of same length, '$a' not same length as\
    \ '$b'\" unless length($a) == length($b);\n    my $r = \"\";\n    for (my $i =\
    \ 0; $i < length($a); $i++) {\n        my $ac = substr($a, $i, 1);\n        my\
    \ $bc = substr($b, $i, 1);\n        $r .= $ac == $bc ? \"0\" : \"1\";\n    }\n\
    \    return $r;\n}", "    my($out) = \"\";\n    my($i);\n    my($n);", '    my($a_len,
    $b_len, $result);', "    my @a = split //, $a;\n    my @b = split //, $b;\n  \
    \  my @xor;\n    for my $i (0 .. $#a) {\n        $xor[$i] = ($a[$i] + $b[$i])\
    \ % 2;\n    }\n    return join '', @xor;\n}", "    $a ^= $b;\n    $a =~ s/\\000/0/g;\n\
    \    $a =~ s/\\001/1/g;\n    return $a;\n}", "    my($xor);\n    $xor = (~(~$a\
    \ & ~$b) & ~(~$a | ~$b));\n    return sprintf(\"%b\", $xor);\n}", "    if($a eq\
    \ '' || $b eq '') {\n        return '';\n    }\n    my @a = split(\"\", $a);\n\
    \    my @b = split(\"\", $b);\n    my $c = '';\n    foreach my $i (0..$#a) {\n\
    \        $c .= (int($a[$i]) ^ int($b[$i]));\n    }\n    return $c;\n}", "    my($result)\
    \ = '';\n    my($i);\n    for($i = 0; $i < length($a); $i++) {\n        $result\
    \ .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $result;\n}", " \
    \   $a ^= $b;\n    return unpack(\"H*\", pack(\"B*\", $a));\n}", "    my $result\
    \ = '';\n    my $len = length($a);\n    for (my $i = 0; $i < $len; $i++) {\n \
    \       $result .= substr($a, $i, 1) eq substr($b, $i, 1) ? '0' : '1';\n    }\n\
    \    return $result;\n}", "    my @a = split(//, $a);\n    my @b = split(//, $b);\n\
    \    my @out;\n    for (my $i = 0; $i < @a; $i++) {\n        if ( $a[$i] eq $b[$i]\
    \ ) {\n            push @out, 0;\n        } else {\n            push @out, 1;\n\
    \        }\n    }\n    return join('', @out);\n}", "    $a ^= $b;\n    return\
    \ $a;\n}", "    if(length($a) != length($b)) {\n        die \"Length of both strings\
    \ must be the same.\";\n    }\n    my $res = \"\";\n    my $longer = length($a)\
    \ > length($b) ? $a : $b;\n    for(my $i = 0; $i < length($longer); $i++) {\n\
    \        my $a_digit = substr($a, $i, 1);\n        my $b_digit = substr($b, $i,\
    \ 1);\n        if(!($a_digit eq \"0\" || $a_digit eq \"1\")) {\n            die\
    \ \"Cannot use character \" . $a_digit . \".\";\n        }\n        if(!($b_digit\
    \ eq \"0\" || $b_digit eq \"1\")) {\n            die \"Cannot use character \"\
    \ . $b_digit . \".\";\n        }\n        if($a_digit eq $b_digit) {\n       \
    \     $res .= \"0\";\n        } else {\n            $res .= \"1\";\n        }\n\
    \    }\n    return $res;\n}", "    my $tmp = '';\n    my $len = length($a);\n\
    \    for(my $i = 0; $i < $len; $i++){\n        if(substr($a, $i, 1) == substr($b,\
    \ $i, 1)){\n            $tmp .= '0';\n        }\n        else{\n            $tmp\
    \ .= '1';\n        }\n    }\n    return $tmp;\n}", "    my $ret = \"\";\n    my\
    \ $i;\n    for($i = 0; $i < length($a); $i++) {\n        $ret .= substr($a, $i,\
    \ 1) ^ substr($b, $i, 1);\n    }\n    return $ret;\n}", "    my $r = '';\n   \
    \ my $l = max(length($a), length($b));\n    my $c = '';\n    while($l--) {\n \
    \       my $aa = substr($a, -1, 1);\n        my $bb = substr($b, -1, 1);\n   \
    \     if( $aa eq $bb ) {\n            $r = $c . $r;\n            $c = '0';\n \
    \       } else {\n            $r = ( $c eq '0' ? '1' : '0' ) . $r;\n        }\n\
    \        $a = substr($a, 0, -1);\n        $b = substr($b, 0, -1);\n    }\n   \
    \ return $r;\n}", "    my $return = '';\n    my $len = length($a);\n    for (my\
    \ $i = 0; $i < $len; $i++) {\n        $return .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $return;\n}", "    return undef if (length($a) !=\
    \ length($b));\n    my @a = split //, $a;\n    my @b = split //, $b;\n    my @c\
    \ = ();\n    foreach my $i (0 .. (length($a) - 1)) {\n        push @c, $a[$i]\
    \ ^ $b[$i];\n    }\n    return join('', @c);\n}", "    my $result = '';\n    for\
    \ my $i (0 .. length($a) - 1) {\n        my $bit_a = substr($a, $i, 1);\n    \
    \    my $bit_b = substr($b, $i, 1);\n        $result .= $bit_a eq $bit_b ? '0'\
    \ : '1';\n    }\n    return $result;\n}", "    $a =~ tr/01/\\x00\\x01/;\n    $b\
    \ =~ tr/01/\\x00\\x01/;\n    my $result = \"\";\n    my $j = 0;\n    foreach my\
    \ $c (split //, $a) {\n        $result .= $c ^ $b;\n        $j++;\n    }\n   \
    \ $result =~ tr/\\x00\\x01/01/;\n    return $result;\n}", "    my $result = '';\n\
    \    for my $i (0 .. length($a)-1) {\n        my $x = substr($a, $i, 1);\n   \
    \     my $y = substr($b, $i, 1);\n        if ($x == $y) {\n            $result\
    \ .= '0';\n        } else {\n            $result .= '1';\n        }\n    }\n \
    \   return $result;\n}", "    my $xor_str = \"\";\n    for(my $i = 0; $i < length($a);\
    \ $i++) {\n        my $a_bit = substr($a, $i, 1);\n        my $b_bit = substr($b,\
    \ $i, 1);\n        $xor_str .= ($a_bit ^ $b_bit);\n    }\n    return $xor_str;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
