name: HumanEval_11_string_xor
language: pl
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor(\"\
  010\", \"110\")\n# \"100\"\nsub string_xor {\n    my($a, $b) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_xor;\n\
  \        if(eq_deeply($candidate->(\"111000\", \"101010\"),\"010010\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  1\", \"1\"),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"0101\", \"0000\"),\"0101\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $length = length($a);\n    my $c = '';\n    for(my $i = 0; $i\
    \ < $length; $i++) {\n        $c .= ( substr($a, $i, 1) eq substr($b, $i, 1) )\
    \ ? '0' : '1';\n    }\n    return $c;\n}", "    my $l = length($a);\n    # make\
    \ sure the two strings are the same length:\n    $b = substr($b, 0, $l) if length($b)\
    \ > $l;\n    $b .= substr($a, length($b)) if length($b) < $l;\n    my $x = \"\"\
    ;\n    my @a = split(//, $a);\n    my @b = split(//, $b);\n    for (my $i = 0;\
    \ $i < $l; $i++) {\n        $x .= $a[$i] ^ $b[$i];\n    }\n    return $x;\n}",
  "    my @bin_a = split(//, $a);\n    my @bin_b = split(//, $b);\n    my @xor_result;\n\
    \    for my $i (0..scalar(@bin_a) - 1) {\n        push @xor_result, ($bin_a[$i]\
    \ eq $bin_b[$i]) ? \"0\" : \"1\";\n    }\n    return join(\"\", @xor_result);\n\
    }", "    return pack(\"H*\", \"$a\") ^ pack(\"H*\", \"$b\");\n}", "    my($result);\n\
    \    my($i);", "    my @a = split(//, $a);\n    my @b = split(//, $b);\n    my\
    \ @c;\n    for (my $i = 0; $i < @a; $i++) {\n        if ($a[$i] eq $b[$i]) {\n\
    \            $c[$i] = 0;\n        } else {\n            $c[$i] = 1;\n        }\n\
    \    }\n    return join('', @c);\n}", "    my $r = \"\";\n    my $len = length($a);\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        my $c = substr($a, $i, 1) . substr($b,\
    \ $i, 1);\n        if ($c eq \"00\") {\n            $r .= \"0\";\n        } elsif\
    \ ($c eq \"01\") {\n            $r .= \"1\";\n        } elsif ($c eq \"10\") {\n\
    \            $r .= \"1\";\n        } elsif ($c eq \"11\") {\n            $r .=\
    \ \"0\";\n        }\n    }\n    return $r;\n}", "    my $len = length($a);\n \
    \   my $i;\n    my $res = \"\";\n    for ($i = 0; $i < $len; $i++) {\n       \
    \ $res .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $res;\n}",
  "    my $b1 = unpack(\"B*\", $a);\n    my $b2 = unpack(\"B*\", $b);\n    my $len\
    \ = max(length($b1), length($b2));\n    $b1 = sprintf(\"%0${len}s\", $b1);\n \
    \   $b2 = sprintf(\"%0${len}s\", $b2);\n    my $c = \"\";\n    for(my $i = 0;\
    \ $i < $len; $i++) {\n        $c .= substr($b1, $i, 1) ^ substr($b2, $i, 1);\n\
    \    }\n    return pack(\"B*\", $c);\n}", "    my $res = \"\";\n    for (my $i\
    \ = 0; $i < length($a); $i++) {\n        $res .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $res;\n}", "    if (length($a) != length($b)) { die\
    \ \"Both strings should be of same length\"; }\n    my @a = split('', $a);\n \
    \   my @b = split('', $b);\n    my @c = map { ($a[$_] ^ $b[$_]) ? '1' : '0' }\
    \ (0..$#a);\n    return join('', @c);\n}", "    my $res = '';\n    for (my $i\
    \ = 0; $i < length($a); $i++) {\n        my $a_bit = substr($a, $i, 1);\n    \
    \    my $b_bit = substr($b, $i, 1);\n        if ($a_bit ne $b_bit) {\n       \
    \     $res .= \"1\";\n        } else {\n            $res .= \"0\";\n        }\n\
    \    }\n    return $res;\n}", "    return pack(\"C*\", unpack(\"C*\", $a) ^ unpack(\"\
    C*\", $b));\n}", "    die \"string_xor(): length of the first argument is not\
    \ equal to the length of the second argument\\n\" if length($a) != length($b);\n\
    \    my @char_a = split(//, $a);\n    my @char_b = split(//, $b);\n    my @char_c\
    \ = ();\n    for (my $i = 0; $i < scalar(@char_a); $i++) {\n        if ($char_a[$i]\
    \ eq $char_b[$i]) {\n            push(@char_c, \"0\");\n        } else {\n   \
    \         push(@char_c, \"1\");\n        }\n    }\n    return join(\"\", @char_c);\n\
    }", "    my $out = \"\";\n    my $xor = 0;\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        $xor = substr($a, $i, 1) eq substr($b, $i, 1) ? 0 : 1;\n  \
    \      $out .= $xor;\n    }\n    return $out;\n}", "    $a = pack('B*', $a);\n\
    \    $b = pack('B*', $b);\n    my $xor = $a ^ $b;\n    return unpack('B*', $xor);\n\
    }", "    my $bita = unpack(\"B*\", $a);\n    my $bitb = unpack(\"B*\", $b);\n\
    \    my $len = length($bita);\n    my $padded = $bitb;\n    if (length($bitb)\
    \ < $len) {\n        my $diff = $len - length($bitb);\n        $padded = \"0\"\
    \ x $diff . $bitb;\n    }\n    my $res = \"\";\n    for (my $i = 0; $i < $len;\
    \ $i++) {\n        if (substr($bita, $i, 1) eq substr($padded, $i, 1)) {\n   \
    \         $res .= \"0\";\n        } else {\n            $res .= \"1\";\n     \
    \   }\n    }\n    return $res;\n}", "    my $result = \"\";\n    for (my $i =\
    \ 0; $i < length($a); $i++) {\n        my $bit_a = substr($a, $i, 1);\n      \
    \  my $bit_b = substr($b, $i, 1);\n        $result .= $bit_a ^ $bit_b;\n    }\n\
    \    return $result;\n}", "    my @c;\n    my $abits = length($a);\n    my $bbits\
    \ = length($b);\n    my $maxlen = $abits > $bbits ? $abits : $bbits;\n    $a =\
    \ \"0\" x ($maxlen - $abits) . $a;\n    $b = \"0\" x ($maxlen - $bbits) . $b;\n\
    \    for (my $i = 0; $i < $maxlen; $i++) {\n        my $tmp = 0;\n        if (substr($a,\
    \ $i, 1) eq \"1\") {\n            $tmp += 1;\n        }\n        if (substr($b,\
    \ $i, 1) eq \"1\") {\n            $tmp += 1;\n        }\n        if ($tmp == 1)\
    \ {\n            push @c, \"1\";\n        } else {\n            push @c, \"0\"\
    ;\n        }\n    }\n    return join(\"\", @c);\n}", '    my($i, $j, $res);',
  "    my $a_len = length($a);\n    my $b_len = length($b);\n    my $a_str = \"0\"\
    \ x ($b_len - $a_len) . $a;\n    my $b_str = \"0\" x ($a_len - $b_len) . $b;\n\
    \    my $c_str = '';\n    for (my $i = 0; $i < length($a_str); $i++) {\n     \
    \   $c_str .= $a_str ^ $b_str;\n    }\n    return $c_str;\n}", "    my($a_len,\
    \ $b_len) = (length($a), length($b));\n    if($a_len < $b_len) {\n        my $b_copy\
    \ = $b;\n        substr($b_copy, $a_len, $b_len - $a_len) = '';\n        $b =\
    \ $b_copy;\n    } elsif($a_len > $b_len) {\n        my $a_copy = $a;\n       \
    \ substr($a_copy, $b_len, $a_len - $b_len) = '';\n        $a = $a_copy;\n    }\n\
    \    my $result = '';\n    for(my $i = 0; $i < length($a); $i++) {\n        my\
    \ $a_bit = substr($a, $i, 1);\n        my $b_bit = substr($b, $i, 1);\n      \
    \  if($a_bit eq $b_bit) {\n            $result .= '0';\n        } else {\n   \
    \         $result .= '1';\n        }\n    }\n    return $result;\n}", "    my\
    \ @a = split(//, $a);\n    my @b = split(//, $b);\n    my @c;\n    while (@a)\
    \ {\n        my $a = shift @a;\n        my $b = shift @b;\n        if (($a eq\
    \ \"1\") and ($b eq \"1\")) {\n            push @c, \"0\";\n        } elsif (($a\
    \ eq \"0\") and ($b eq \"0\")) {\n            push @c, \"0\";\n        } else\
    \ {\n            push @c, \"1\";\n        }\n    }\n    return join(\"\", @c);\n\
    }", "    die(\"both inputs must be the same length\") if (length($a) != length($b));\n\
    \    my @a = split(\"\", $a);\n    my @b = split(\"\", $b);\n    my @z = ();\n\
    \    for (my $i = 0; $i < scalar(@a); $i++) {\n        push(@z, $a[$i]^$b[$i]);\n\
    \    }\n    return join(\"\", @z);\n}", "    my $y = \"\";\n    for (my $i = 0;\
    \ $i < length($a); $i++) {\n        my $x = substr($a, $i, 1) ^ substr($b, $i,\
    \ 1);\n        $y .= $x;\n    }\n    return $y;\n}", "    length($a) == length($b)\
    \ or die \"length a ($a) != length b ($b)\";\n    my @a = split '', $a;\n    my\
    \ @b = split '', $b;\n    my @c = map { $a[$_] ^ $b[$_] } (0 .. (length($a) -\
    \ 1));\n    return join('', @c);\n}", "    my @a = split //, $a;\n    my @b =\
    \ split //, $b;\n    my @result;\n    foreach my $i (0 .. $#a) {\n        $result[$i]\
    \ = $a[$i] ^ $b[$i];\n    }\n    return join('', @result);\n}", "    return if\
    \ length($a) != length($b);\n    my $result = \"\";\n    for (my $i = 0; $i <\
    \ length($a); $i++) {\n        my $bit_a = substr($a, $i, 1);\n        my $bit_b\
    \ = substr($b, $i, 1);\n        $result .= $bit_a == $bit_b ? \"0\" : \"1\";\n\
    \    }\n    return $result;\n}", "    my $result = '';\n    for (0..length($a)-1)\
    \ {\n        $result .= (substr($a, $_, 1) ^ substr($b, $_, 1));\n    }\n    return\
    \ $result;\n}", "    $a =~ tr/01/10/;\n    $b =~ tr/01/10/;\n    my $string =\
    \ $a & $b;\n    $string =~ tr/01/10/;\n    return $string;\n}", "    return ''\
    \ if (length($a) != length($b));\n    my $r = '';\n    for my $i (0 .. length($a)-1)\
    \ {\n        $r .= substr($a, $i, 1) == substr($b, $i, 1) ? '0' : '1';\n    }\n\
    \    return $r;\n}", "    my $r = '';\n    my $a_len = length($a);\n    my $b_len\
    \ = length($b);\n    my $len = min($a_len, $b_len);\n    for (my $i = 0; $i <\
    \ $len; $i++) {\n        if ((substr($a, $i, 1) eq '1') ^ (substr($b, $i, 1) eq\
    \ '1')) {\n            $r .= '1';\n        } else {\n            $r .= '0';\n\
    \        }\n    }\n    for (my $i = $len; $i < $a_len; $i++) {\n        $r .=\
    \ substr($a, $i, 1);\n    }\n    for (my $i = $len; $i < $b_len; $i++) {\n   \
    \     $r .= substr($b, $i, 1);\n    }\n    return $r;\n}", "    $a ^= $b;\n  \
    \  return join(\"\", map {chr} map { $_ = ord($_) } split(\"\", $a));\n}", " \
    \   my $r = \"\";\n    my $s = $a ^ $b;\n    while($s) {\n        $r = ($s & 1).$r;\n\
    \        $s >>= 1;\n    }\n    return $r;\n}", "    my($i, $result) = (0, \"\"\
    );\n    while($i < length($a)) {\n        if(substr($a, $i, 1) eq substr($b, $i,\
    \ 1)) {\n            $result .= \"0\";\n        } else {\n            $result\
    \ .= \"1\";\n        }\n        $i++;\n    }\n    return $result;\n}", "    die\
    \ unless $a =~ /^[01]+$/ && $b =~ /^[01]+$/;\n    my $len = length($a);\n    $b\
    \ = substr($b, 0, $len);\n    my $res = '';\n    for (my $i = 0; $i < $len; $i++)\
    \ {\n        $res .= substr($a, $i, 1) eq substr($b, $i, 1) ? '0' : '1';\n   \
    \ }\n    return $res;\n}", "    my($res) = '';\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        my($e) = substr($a, $i, 1) ^ substr($b, $i, 1);\n        $res\
    \ .= ($e ? '1' : '0');\n    }\n    return $res;\n}", "    my $l = length($a);\n\
    \    my $out = \"\";\n    for (my $i = 0; $i < $l; $i++) {\n        my $x = substr($a,\
    \ $i, 1);\n        my $y = substr($b, $i, 1);\n        $out .= ($x eq $y) ? '0'\
    \ : '1';\n    }\n    return $out;\n}", "    my($ret);\n    my($i);", "    return\
    \ unless defined $a and defined $b;\n    my $result = \"\";\n    for (my $i =\
    \ 0; $i < length($a); $i++) {\n        my $x = substr($a, $i, 1);\n        my\
    \ $y = substr($b, $i, 1);\n        $result .= (($x + $y) % 2);\n    }\n    return\
    \ $result;\n}", "    my $l = length($a);\n    my $s = '';\n    for(my $i = 0;\
    \ $i < $l; $i++) {\n        $s .= substr($a, $i, 1) eq substr($b, $i, 1) ? '0'\
    \ : '1';\n    }\n    return $s;\n}", "    return $a ^ $b;\n}", "    my $result\
    \ = \"\";\n    my $n = length($a);\n    for (my $i = 0; $i < $n; $i++) {\n   \
    \     $result .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return $result;\n\
    }", "    my $x;\n    my $res = \"\";\n    my $len = length($a);\n    my $y = substr($b,\
    \ 0, $len);\n    for my $i (0..$len-1) {\n        $x = substr($a, $i, 1);\n  \
    \      $y = substr($b, $i, 1);\n        if ($x ne $y) {\n            $res .= \"\
    1\";\n        } else {\n            $res .= \"0\";\n        }\n    }\n    return\
    \ $res;\n}", "    $a =~ s/[^01]//g;\n    $b =~ s/[^01]//g;\n    my $xor = $a ^\
    \ $b;\n    return unpack(\"B*\", $xor);\n}", "    return $a ^ $b;\n}", "    my\
    \ @p = split('', $a);\n    my @q = split('', $b);\n    my $s = \"\";\n    for\
    \ (my $i = 0; $i < @p; $i++) {\n        $s .= (int($p[$i]) ^ int($q[$i]));\n \
    \   }\n    return $s;\n}", "    my @a = split(//, $a);\n    my @b = split(//,\
    \ $b);\n    my @out;\n    for (my $i = 0; $i < scalar(@a); $i++) {\n        if\
    \ ($a[$i] eq $b[$i]) {\n            push(@out, \"0\");\n        } else {\n   \
    \         push(@out, \"1\");\n        }\n    }\n    return join(\"\", @out);\n\
    }", "    my $a_len = length($a);\n    my $b_len = length($b);\n    my $min_len\
    \ = $a_len < $b_len ? $a_len : $b_len;\n    my $xor = '';\n    for(my $i = 0;\
    \ $i < $min_len; $i++) {\n        my $a_char = substr($a, $i, 1);\n        my\
    \ $b_char = substr($b, $i, 1);\n        $xor .= $a_char ^ $b_char;\n    }\n  \
    \  return $xor;\n}", "    my $n = length($a);\n    if ($n != length($b)) {\n \
    \       die \"string_xor: length of input strings differ: $n vs. \".length($b).\"\
    \\n\";\n    }\n    if ($n < 1) {\n        die \"string_xor: length of input strings\
    \ must be >= 1: $n vs. \".length($b).\"\\n\";\n    }\n    my $c = \"\";\n    for(my\
    \ $i = 0; $i < $n; $i++) {\n        my $a_i = substr($a, $i, 1);\n        my $b_i\
    \ = substr($b, $i, 1);\n        if ($a_i ne \"0\" && $a_i ne \"1\") {\n      \
    \      die \"string_xor: a is not a binary string\\n\";\n        }\n        if\
    \ ($b_i ne \"0\" && $b_i ne \"1\") {\n            die \"string_xor: b is not a\
    \ binary string\\n\";\n        }\n        if ($a_i eq $b_i) {\n            $c\
    \ .= \"0\";\n        } else {\n            $c .= \"1\";\n        }\n    }\n  \
    \  return $c;\n}", "    die unless $a =~ /^[01]+$/ && $b =~ /^[01]+$/;\n    my\
    \ $result = '';\n    my $bit = 0;\n    my $len = max(length($a), length($b));\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        my $a_bit = substr($a, $i, 1);\n\
    \        my $b_bit = substr($b, $i, 1);\n        $result .= ($a_bit ^ $b_bit);\n\
    \    }\n    return $result;\n}", "    my $str = \"\";\n    for (my $i = 0; $i\
    \ < length($a); $i++) {\n        $str .= (substr($a, $i, 1) eq substr($b, $i,\
    \ 1)) ? \"0\" : \"1\";\n    }\n    return $str;\n}", "    my($result) = \"\";\n\
    \    for(my $i = 0; $i < length($a); $i++) {\n        my($a_bit) = substr($a,\
    \ $i, 1);\n        my($b_bit) = substr($b, $i, 1);\n        my($xor_bit) = ($a_bit\
    \ ^ $b_bit) + 0;\n        $result .= $xor_bit;\n    }\n    return $result;\n}",
  "    my $res = '';\n    my $len = length($a);\n    foreach my $i (0..$len-1) {\n\
    \        my $x = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n    \
    \    $res .= $x eq $y ? '0' : '1';\n    }\n    return $res;\n}", "    if (length($a)\
    \ != length($b)) {\n        die \"Unequal length arguments in string_xor: $a,\
    \ $b\";\n    }\n    my @result = map {$a->[$_] ^ $b->[$_]} 0..length($a) - 1;\n\
    \    return join(\"\", @result);\n}", "    return '' if length($a) != length($b);\n\
    \    my @a = split '', $a;\n    my @b = split '', $b;\n    my $c = \"\";\n   \
    \ while(@a) {\n        $c .= pop(@a) ^ pop(@b);\n    }\n    return $c;\n}", " \
    \   my $c = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        $c .=\
    \ substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $c;\n}", "    my @a\
    \ = split //, $a;\n    my @b = split //, $b;\n    my @c;\n    for (my $i = 0;\
    \ $i < @a; $i++) {\n        push @c, $a[$i] ^ $b[$i];\n    }\n    return join\
    \ \"\", @c;\n}", "    my $c = length($a) > length($b) ? $a : $b;\n    my $d =\
    \ length($a) > length($b) ? $b : $a;\n    my $e = \"\";\n    for (my $i = 0; $i\
    \ < length($c); $i++) {\n        my $f = substr($c, $i, 1);\n        my $g = substr($d,\
    \ $i, 1);\n        if ($f eq $g) {\n            $e .= \"0\";\n        } else {\n\
    \            $e .= \"1\";\n        }\n    }\n    return $e;\n}", "    return join\
    \ \"\", map { $a->[$_] ^ $b->[$_] } 0..max(scalar @$a, scalar @$b) - 1;\n}", " \
    \   my $bin = \"\";\n    my $xor = 0;\n    my $result = \"\";\n    my $bin_a =\
    \ unpack(\"B*\", $a);\n    my $bin_b = unpack(\"B*\", $b);\n    my $len = length($bin_a);\n\
    \    if ($len != length($bin_b)) {\n        die(\"Error: string_xor(): strings\
    \ have different lengths\");\n    }\n    for (my $i = 0; $i < $len; $i++) {\n\
    \        $xor = substr($bin_a, $i, 1) ^ substr($bin_b, $i, 1);\n        $bin .=\
    \ $xor;\n    }\n    $result = pack(\"B*\", $bin);\n    return $result;\n}", " \
    \   my $ret = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        my\
    \ $aa = substr($a, $i, 1);\n        my $bb = substr($b, $i, 1);\n        if ($aa\
    \ eq \"1\" && $bb eq \"1\") {\n            $ret .= \"0\";\n        } elsif ($aa\
    \ eq \"0\" && $bb eq \"0\") {\n            $ret .= \"0\";\n        } else {\n\
    \            $ret .= \"1\";\n        }\n    }\n    return $ret;\n}", "    my @a\
    \ = split //, $a;\n    my @b = split //, $b;\n    my @xor = ();\n    for (my $i\
    \ = 0; $i < @a; $i++) {\n        if ($a[$i] eq $b[$i]) {\n            push @xor,\
    \ 0;\n        } else {\n            push @xor, 1;\n        }\n    }\n    return\
    \ join \"\", @xor;\n}", "    my($x) = '';\n    $x .= (($a ^ $b) & 1) ? '1' : '0'\n\
    \        while ($a = substr($a, 1), $b = substr($b, 1));\n    return $x;\n}",
  "    my $result = \"\";\n    while (length($a) > 0 || length($b) > 0) {\n      \
    \  my $x = \"0\";\n        my $y = \"0\";\n        if (length($a) > 0) {\n   \
    \         $x = chop($a);\n        }\n        if (length($b) > 0) {\n         \
    \   $y = chop($b);\n        }\n        if ($x ne $y) {\n            $result =\
    \ \"1\" . $result;\n        } else {\n            $result = \"0\" . $result;\n\
    \        }\n    }\n    return $result;\n}", "    my $maxlen = length($a) > length($b)\
    \ ? length($a) : length($b);\n    my $out = \"\";\n    for (my $i = 0; $i < $maxlen;\
    \ $i++) {\n        my $a_bit = $i < length($a) ? substr($a, $i, 1) : 0;\n    \
    \    my $b_bit = $i < length($b) ? substr($b, $i, 1) : 0;\n        $out .= $a_bit\
    \ ^ $b_bit;\n    }\n    return $out;\n}", "    my($xor_len) = length($a) > length($b)\
    \ ? length($a) : length($b);\n    my($xor_a) = \"0\" x ($xor_len - length($a))\
    \ . $a;\n    my($xor_b) = \"0\" x ($xor_len - length($b)) . $b;\n    my($xor)\
    \ = \"\";\n    for (my($i) = 0; $i < $xor_len; $i++) {\n        my($v) = substr($xor_a,\
    \ $i, 1) ^ substr($xor_b, $i, 1);\n        $xor .= $v;\n    }\n    return $xor;\n\
    }", "    return $a ^ $b;\n}", "    my $len = length($a);\n    my $ans = '';\n\
    \    for (my $i = 0; $i < $len; $i++) {\n        $ans .= substr($a, $i, 1) ^ substr($b,\
    \ $i, 1);\n    }\n    return $ans;\n}", "    my $r = '';\n    while (length($a)\
    \ || length($b)) {\n        my $x = chop($a) || 0;\n        my $y = chop($b) ||\
    \ 0;\n        $r = ($x ^ $y) . $r;\n    }\n    return $r;\n}", "    my $c = \"\
    \";\n    for(my $i = 0; $i < length($a); $i++) {\n        my $j = substr($a, $i,\
    \ 1);\n        my $k = substr($b, $i, 1);\n        if($j eq $k) {\n          \
    \  $c .= \"0\";\n        } else {\n            $c .= \"1\";\n        }\n    }\n\
    \    return $c;\n}", "    my $r = '';\n    $r .= ($a ^ $b) for unpack 'C*', $a\
    \ ^ $b;\n    return $r;\n}", "    my $xor;\n    my $len = length($a);\n    die\
    \ \"length of strings do not match\" unless $len == length($b);\n    for(my $i\
    \ = 0; $i < $len; $i++) {\n        if(substr($a, $i, 1) eq substr($b, $i, 1))\
    \ {\n            $xor .= \"0\";\n        } else {\n            $xor .= \"1\";\n\
    \        }\n    }\n    return $xor;\n}", "    my($c, $i);\n    for($i = 0; $i\
    \ < length($a); $i++) {\n        $c .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n\
    \    }\n    return $c;\n}", "    $a =~ tr/01/10/;\n    $b =~ tr/01/10/;\n    $a\
    \ ^= $b;\n    $a =~ tr/01/10/;\n    return $a;\n}", "    my($xor) = \"\";\n  \
    \  if (length($a) != length($b)) {\n        print(\"\\nERROR: length of arguments\
    \ must be equal\\n\");\n        return $xor;\n    }\n    for (my $i = 0; $i <\
    \ length($a); $i++) {\n        $xor .= substr($a, $i, 1) ^ substr($b, $i, 1);\n\
    \    }\n    return $xor;\n}", "    # how to split the string without using regex\n\
    \    my @a = split(\"\", $a);\n    my @b = split(\"\", $b);\n    my $o = '';\n\
    \    for (my $i = 0; $i < scalar(@a); $i++) {\n        if ($a[$i] eq $b[$i]) {\n\
    \            $o .= '0';\n        } else {\n            $o .= '1';\n        }\n\
    \    }\n    return $o;\n}", "    my $res = \"\";\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        $res .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n   \
    \ return $res;\n}", "    my @a = split //, $a;\n    my @b = split //, $b;\n  \
    \  my @r;\n    foreach my $i (0 .. $#a) {\n        push @r, $a[$i] ^ $b[$i];\n\
    \    }\n    return join('', @r);\n}", "    if (length($a) != length($b)) {\n \
    \       die \"Inputs to binary XOR must be of the same length\";\n    }\n    my\
    \ @a = split //, $a;\n    my @b = split //, $b;\n    my @xor;\n    while (@a)\
    \ {\n        push @xor, (shift @a) ^ (shift @b);\n    }\n    return join \"\"\
    , @xor;\n}", "    return pack \"H*\", unpack \"H*\", $a ^ $b;\n}", "    my $r\
    \ = '';\n    for my $i (0..length($a)-1) {\n        $r .= substr($a, $i, 1) ne\
    \ substr($b, $i, 1) ? '1' : '0';\n    }\n    return $r;\n}", "    my $r = \"\"\
    ;\n    for (my $i = 0; $i < length($a); $i++) {\n        $r .= (substr($a, $i,\
    \ 1) ^ substr($b, $i, 1));\n    }\n    return $r;\n}", "    die \"Invalid arguments:\
    \ string_xor(\\\"$a\\\", \\\"$b\\\")\"\n\tunless (length($a) == length($b));\n\
    \    my $result = '';\n    for my $i (0 .. length($a)-1) {\n\t$result .= substr($a,\
    \ $i, 1) eq substr($b, $i, 1) ? \"0\" : \"1\";\n    }\n    return $result;\n}",
  "    my $ret = \"\";\n    my $len = length($a);\n    for(my $i = 0; $i < $len; $i++)\
    \ {\n        $ret .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return\
    \ $ret;\n}", "    my $n = length($a);\n    my $c = '';\n    my $i;\n    for($i\
    \ = 0; $i < $n; $i++) {\n        $c .= substr($a, $i, 1) ^ substr($b, $i, 1);\n\
    \    }\n    return $c;\n}", '    my($i, $j, $res);', "    my $len = max(length($a),\
    \ length($b));\n    $a = \"0\" x ($len - length($a)) . $a;\n    $b = \"0\" x ($len\
    \ - length($b)) . $b;\n    my $c = \"\";\n    for (my $i = 0; $i < $len; $i++)\
    \ {\n        my $v = substr($a, $i, 1) eq substr($b, $i, 1) ? \"0\" : \"1\";\n\
    \        $c .= $v;\n    }\n    return $c;\n}", "    my($i, $length);\n    my($out)\
    \ = \"\";", "    my $min_length = min(length($a), length($b));\n    my $a_chars\
    \ = split(//, substr($a, -$min_length));\n    my $b_chars = split(//, substr($b,\
    \ -$min_length));\n    my $s = '';\n    for (my $i = 0; $i < $min_length; $i++)\
    \ {\n        $s .= ($a_chars->[$i] ^ $b_chars->[$i]);\n    }\n    return $s;\n\
    }", "    $a =~ s/^0*//; $b =~ s/^0*//;\n    my($i, $n) = (0, length($a) > length($b)\
    \ ? length($a) : length($b));\n    my($x, $y) = (\"\", \"\");\n    for(; $i <\
    \ $n; $i++) {\n        $x .= $i < length($a) ? substr($a, $i, 1) : \"0\";\n  \
    \      $y .= $i < length($b) ? substr($b, $i, 1) : \"0\";\n    }\n    my($z) =\
    \ \"\";\n    for($i = 0; $i < $n; $i++) {\n        $z .= substr($x, $i, 1) ne\
    \ substr($y, $i, 1) ? \"1\" : \"0\";\n    }\n    return $z;\n}", "    return join(\"\
    \", map { $_[0] ^ $_[1] } split(//, $a), split(//, $b));\n}", "    my $result\
    \ = '';\n    my $min_length = length($a) > length($b) ? length($b) : length($a);\n\
    \    for(my $i = 0; $i < $min_length; $i++) {\n        my $x = substr($a, $i,\
    \ 1);\n        my $y = substr($b, $i, 1);\n        $result .= $x == $y ? 0 : 1;\n\
    \    }\n    return $result;\n}", "    my $b1 = pack(\"B*\", $a);\n    my $b2 =\
    \ pack(\"B*\", $b);\n    my $b3 = $b1 ^ $b2;\n    return unpack(\"B*\", $b3);\n\
    }", "    return \"\".xor_arrays([split //, $a], [split //, $b]);\n}", "    return\
    \ unless length($a) == length($b);\n    my $l = length($a);\n    my $r = \"\"\
    ;\n    for (my $i = 0; $i < $l; $i++) {\n        my $aa = substr($a, $i, 1);\n\
    \        my $bb = substr($b, $i, 1);\n        if ($aa eq $bb) {\n            $r\
    \ .= \"0\";\n        } else {\n            $r .= \"1\";\n        }\n    }\n  \
    \  return $r;\n}", "    $a ^= $b;\n    return unpack(\"B*\", pack(\"N\", $a));\n\
    }", "    my $a_bin = pack(\"B*\", $a);\n    my $b_bin = pack(\"B*\", $b);\n  \
    \  my $c_bin = $a_bin ^ $b_bin;\n    return unpack(\"B*\", $c_bin);\n}", "   \
    \ $a =~ y/01/10/;\n    $b =~ y/01/10/;\n    my $c = ~($a | $b);\n    $c =~ y/01/10/;\n\
    \    return $c;\n}", "    my($result);\n    my($i);", "    my $r;\n    my $clen\
    \ = length($a) > length($b) ? length($a) : length($b);\n    while($clen > 0) {\n\
    \        $clen--;\n        my $a = substr($a, $clen, 1) || 0;\n        my $b =\
    \ substr($b, $clen, 1) || 0;\n        $r = ($a^$b).$r;\n    }\n    return $r;\n\
    }", "    my @a = split(//, $a);\n    my @b = split(//, $b);\n    my @c;\n    for(my\
    \ $i = 0; $i < scalar(@a); $i++) {\n        push(@c, $a[$i] ^ $b[$i]);\n    }\n\
    \    my $c = join(\"\", @c);\n    return $c;\n}", "    my $ret;\n    my $i;\n\
    \    for ($i = 0; $i < length($a); $i++) {\n        $ret .= substr($a, $i, 1)\
    \ eq substr($b, $i, 1) ? '0' : '1';\n    }\n    return $ret;\n}", "    my @a =\
    \ split(\"\", $a);\n    my @b = split(\"\", $b);\n    my $max = @a;\n    my $result\
    \ = \"\";\n    foreach my $i (0..$max) {\n        if ($a[$i] eq $b[$i]) {\n  \
    \          $result .= \"0\";\n        } else {\n            $result .= \"1\";\n\
    \        }\n    }\n    return $result;\n}", "    $a ^= $b;\n    my $res = '';\n\
    \    while($a) {\n        $res = ($a & 1) . $res;\n        $a >>= 1;\n    }\n\
    \    return $res;\n}", "    my @a = split(//, $a);\n    my @b = split(//, $b);\n\
    \    my @out;\n    for (my $i = 0; $i < scalar(@a); $i++) {\n        if ($a[$i]\
    \ eq $b[$i]) {\n            push(@out, 0);\n        } else {\n            push(@out,\
    \ 1);\n        }\n    }\n    return join(\"\", @out);\n}", "    return unpack\
    \ \"H*\", pack \"H*\", $a ^ pack \"H*\", $b;\n}", "    my($out) = \"\";\n    my($i);\n\
    \    for($i = 0; $i < length($a); $i++) {\n        $out .= (substr($a, $i, 1)\
    \ ^ substr($b, $i, 1)) ? \"1\" : \"0\";\n    }\n    return $out;\n}", "    my\
    \ $l = length($a);\n    my $xor = \"\";\n    for (my $i = 0; $i < $l; $i++) {\n\
    \        $xor .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $xor;\n\
    }", "    $a =~ tr/01/\\0\\1/;\n    $b =~ tr/01/\\0\\1/;\n    return pack(\"B*\"\
    , unpack(\"B*\", $a) ^ unpack(\"B*\", $b));\n}", "    $a =~ s/\\s//g;\n    $b\
    \ =~ s/\\s//g;\n    return undef if length($a) != length($b);\n    my $r = '';\n\
    \    for (my $i = 0; $i < length($a); $i++) {\n        my $ca = substr($a, $i,\
    \ 1);\n        my $cb = substr($b, $i, 1);\n        $r .= $ca eq $cb ? '0' : '1';\n\
    \    }\n    return $r;\n}", "    return $a ^ $b;\n}", "    $a =~ y/01/10/ if length($a)\
    \ < length($b);\n    $b =~ y/01/10/ if length($b) < length($a);\n    return $a\
    \ ^ $b;\n}", "    $a =~ tr/01/\\0\\1/;\n    $b =~ tr/01/\\0\\1/;\n    return unpack\
    \ \"B*\", pack \"N\", ($a ^ $b);\n}", "    my @a = split '', $a;\n    my @b =\
    \ split '', $b;\n    return join \"\", map {$a[$_] ^ $b[$_]} (0..$#a);\n}", " \
    \   return join(\"\", map { $_[0]{$_} } ($a ^ $b) =~ /./g);\n}", "    my($x, $y);\n\
    \    my($result) = \"\";", "    $a = string_to_array($a);\n    $b = string_to_array($b);\n\
    \    my $c = [];\n    for (my $i = 0; $i < @$a; $i++) {\n        $c->[$i] = ($a->[$i]\
    \ == $b->[$i]) ? 0 : 1;\n    }\n    return array_to_string($c);\n}", "    my($x,\
    \ $y);\n    my $ret = \"\";\n    while(length($a) > 0) {\n        $x = chop($a);\n\
    \        $y = chop($b);\n        if($x != $y) {\n            $ret = \"1$ret\"\
    ;\n        } else {\n            $ret = \"0$ret\";\n        }\n    }\n    return\
    \ $ret;\n}", "    # Convert to numbers to do bitwise XOR\n    my $a_num = unpack(\"\
    N\", pack(\"B32\", substr(\"0\" x 32 . $a, -32)));\n    my $b_num = unpack(\"\
    N\", pack(\"B32\", substr(\"0\" x 32 . $b, -32)));\n    # XOR and return as a\
    \ binary string\n    return unpack(\"B32\", pack(\"N\", $a_num ^ $b_num));\n}",
  "    my($l, $r, $len);\n    if(length($a) != length($b)) {\n        die(\"strings\
    \ are not equal length: $a , $b\");\n    }\n    $len = length($a);\n    $l = $a;\n\
    \    $r = $b;\n    return unpack(\"B*\", pack(\"B*\", $l) ^ pack(\"B*\", $r));\n\
    }", "    my $result = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n  \
    \      $result .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return\
    \ $result;\n}", "    return \"\" if(length($a) != length($b));\n    my $res =\
    \ \"\";\n    my $n = length($a);\n    for(my $i = 0; $i < $n; $i++) {\n      \
    \  my $d_a = substr($a, $i, 1);\n        my $d_b = substr($b, $i, 1);\n      \
    \  $res .= ($d_a xor $d_b);\n    }\n    return $res;\n}", "    my $c = \"\";\n\
    \    my $na = length($a);\n    my $nb = length($b);\n    my $n = $na;\n    $n\
    \ = $nb if ($n > $nb);\n    for (my $i = 0; $i < $n; $i++) {\n        my $aa =\
    \ substr($a, $i, 1);\n        my $bb = substr($b, $i, 1);\n        $aa = 0 if\
    \ ($aa eq \"\");\n        $bb = 0 if ($bb eq \"\");\n        $c .= ($aa ^ $bb);\n\
    \    }\n    return $c;\n}", "    return $a ^ $b;\n}", "    my $len = length($a);\n\
    \    my $out = '';\n    my $i;\n    for($i = 0; $i < $len; $i++) {\n        my\
    \ $t = substr($a, $i, 1) ^ substr($b, $i, 1);\n        $out .= $t;\n    }\n  \
    \  return $out;\n}", "    my @a = split(\"\", $a);\n    my @b = split(\"\", $b);\n\
    \    my $return = \"\";\n    for (my $i = 0; $i < scalar(@a); $i++) {\n      \
    \  if ($a[$i] != $b[$i]) {\n            $return .= \"1\";\n        } else {\n\
    \            $return .= \"0\";\n        }\n    }\n    return $return;\n}", " \
    \   return pack(\"H*\", sprintf(\"%x\", oct(\"0b$a\") ^ oct(\"0b$b\")));\n}",
  "    if (length($a) != length($b)) {\n        return '0' x length($a);\n    }\n\
    \    my $res = '';\n    for (my $i = 0; $i < length($a); $i++) {\n        my $bit_a\
    \ = substr($a, $i, 1);\n        my $bit_b = substr($b, $i, 1);\n        $res .=\
    \ $bit_a ^ $bit_b;\n    }\n    return $res;\n}", "    my($i, $j, $out);\n    for\
    \ ($i = 0; $i < length($a); $i++) {\n        $out .= ((substr($a, $i, 1) ^ substr($b,\
    \ $i, 1)) ? '1' : '0');\n    }\n    return $out;\n}", "    return if length($a)\
    \ != length($b);\n    my $c = \"\";\n    for (my $i = 0; $i < length($a); $i++)\
    \ {\n        if (substr($a, $i, 1) ne substr($b, $i, 1)) {\n            $c .=\
    \ \"1\";\n        } else {\n            $c .= \"0\";\n        }\n    }\n    return\
    \ $c;\n}", "    die unless length($a) == length($b);\n    my $result = \"\";\n\
    \    for (my $i = 0; $i < length($a); $i++) {\n        my $bit1 = substr($a, $i,\
    \ 1);\n        my $bit2 = substr($b, $i, 1);\n        $result .= $bit1 ^ $bit2;\n\
    \    }\n    return $result;\n}", "    return $a ^ $b;\n}", "    my @a = split\
    \ //, $a;\n    my @b = split //, $b;\n    my @result;\n    for (0..$#a) {\n  \
    \      $result[$_] = (($a[$_] and not $b[$_]) or (not $a[$_] and $b[$_])) ? 1\
    \ : 0;\n    }\n    return join('', @result);\n}", "    return(undef) if(length($a)\
    \ != length($b));\n    my $result = \"\";\n    for(my $i = 0; $i < length($a);\
    \ $i++) {\n        my $v1 = substr($a, $i, 1);\n        my $v2 = substr($b, $i,\
    \ 1);\n        $result .= $v1 eq $v2 ? \"0\" : \"1\";\n    }\n    return($result);\n\
    }", "    my @ax = split(//, $a);\n    my @bx = split(//, $b);\n    my $str = \"\
    \";\n    for(my $i = 0; $i < scalar(@ax); $i++) {\n        if($ax[$i] eq $bx[$i])\
    \ {\n            $str .= \"0\";\n        } else {\n            $str .= \"1\";\n\
    \        }\n    }\n    return $str;\n}", "    my $res = \"\";\n    my $c = \"\"\
    ;\n    my $carry = 0;\n    # Leading zeros\n    if (length($a) < length($b)) {\n\
    \        $a = \"0\" x (length($b) - length($a)) . $a;\n    }\n    if (length($b)\
    \ < length($a)) {\n        $b = \"0\" x (length($a) - length($b)) . $b;\n    }\n\
    \    # Add\n    for (my $i = length($a) - 1; $i >= 0; $i--) {\n        $c = ((substr($a,\
    \ $i, 1) ^ substr($b, $i, 1)) ^ $carry) ? \"1\" : \"0\";\n        $res = $c .\
    \ $res;\n        $carry = ((substr($a, $i, 1) & substr($b, $i, 1)) | (substr($a,\
    \ $i, 1) & $carry)) ? 1 : 0;\n    }\n    return $res;\n}", "    my $a_len = length($a);\n\
    \    my $b_len = length($b);\n    my $max_len = $a_len > $b_len ? $a_len : $b_len;\n\
    \    my $i;\n    my $str;\n    for($i = 0; $i < $max_len; $i++){\n        my $j\
    \ = $i;\n        my $a_bit = ($j < $a_len) ? substr($a, $j, 1) : '0';\n      \
    \  my $b_bit = ($j < $b_len) ? substr($b, $j, 1) : '0';\n        $str .= ($a_bit\
    \ ^ $b_bit);\n    }\n    return $str;\n}", "    my $res = '';\n    for (my $i\
    \ = 0; $i < length($a); $i++) {\n        if ((substr($a, $i, 1) eq '1') ^ (substr($b,\
    \ $i, 1) eq '1')) {\n            $res .= '1';\n        } else {\n            $res\
    \ .= '0';\n        }\n    }\n    return $res;\n}", "    my @a = split(\"\", $a);\n\
    \    my @b = split(\"\", $b);\n    my $res = \"\";\n    for (my $i = 0; $i < scalar(@a);\
    \ $i++) {\n        $res .= $a[$i] ^ $b[$i];\n    }\n    return $res;\n}", "  \
    \  my $i;\n    my $res = \"\";\n    for($i = 0; $i < length($a); $i++) {\n   \
    \     $res .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $res;\n\
    }", "    my $l = length($a);\n    my $result = \"\";\n    for (my $i = 0; $i <\
    \ $l; $i++) {\n        my $x = substr($a, $i, 1);\n        my $y = substr($b,\
    \ $i, 1);\n        $result .= ($x xor $y);\n    }\n    return $result;\n}", " \
    \   my $res = \"\";\n    my @a = split(//, $a);\n    my @b = split(//, $b);\n\
    \    for (my $i = 0; $i < @a; $i++) {\n        if ($a[$i] eq $b[$i]) {\n     \
    \       $res .= \"0\";\n        } else {\n            $res .= \"1\";\n       \
    \ }\n    }\n    return $res;\n}", "    return unless defined $a && defined $b;\n\
    \    my $a_length = length($a);\n    my $b_length = length($b);\n    return unless\
    \ $a_length == $b_length;\n    my $res = \"\";\n    for (my $i = 0; $i < $a_length;\
    \ $i++) {\n        $res .= ((substr($a, $i, 1) && !substr($b, $i, 1)) || (!substr($a,\
    \ $i, 1) && substr($b, $i, 1))) ? 1 : 0;\n    }\n    return $res;\n}", "    die\
    \ \"Invalid length string for XOR\" if length($a) != length($b);\n    my @a =\
    \ split(//, $a);\n    my @b = split(//, $b);\n    my @c = ();\n    for (my $i\
    \ = 0; $i < @a; $i++) {\n        $c[$i] = ($a[$i] xor $b[$i]) + 0;\n    }\n  \
    \  return join('', @c);\n}", "    my($m, $n) = length($a), length($b);\n    $m\
    \ < $n ? $a = '0' x ($n - $m) . $a : $b = '0' x ($m - $n) . $b;\n    my $r = \"\
    \";\n    for my $i (0 .. $m-1) {\n        $r .= (int(substr($a, $i, 1)) != int(substr($b,\
    \ $i, 1))) ? \"1\" : \"0\";\n    }\n    return $r;\n}", "    # xor each bit\n\
    \    my $r = '';\n    for (my $i = 0; $i < length($a); $i++) {\n        if (substr($a,\
    \ $i, 1) ne substr($b, $i, 1)) {\n            $r .= '1';\n        } else {\n \
    \           $r .= '0';\n        }\n    }\n    return $r;\n}", "    $a = (length($a)\
    \ % 8 == 0) ? $a : \"0\" x (8 - length($a) % 8) . $a;\n    $b = (length($b) %\
    \ 8 == 0) ? $b : \"0\" x (8 - length($b) % 8) . $b;\n    my $c = \"\";\n    for\
    \ (my $i = 0; $i < length($a); $i += 8) {\n        $c .= sprintf(\"%02x\", hex(substr($a,\
    \ $i, 8)) ^ hex(substr($b, $i, 8)));\n    }\n    return $c;\n}", "    my $r =\
    \ \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        $r .= (substr($a,\
    \ $i, 1) ^ substr($b, $i, 1)) ? \"1\" : \"0\";\n    }\n    return $r;\n}", " \
    \   my $len = length($a);\n    my $c = '';\n    for(my $i = 0; $i < $len; $i++)\
    \ {\n        my $x = substr($a, $i, 1);\n        my $y = substr($b, $i, 1);\n\
    \        $c .= ($x eq $y ? '0' : '1');\n    }\n    return $c;\n}", "    my $r\
    \ = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        $r .= substr($a,\
    \ $i, 1) ^ substr($b, $i, 1);\n    }\n    return $r;\n}", "    my $maxlen = max\
    \ length($a), length($b);\n    my $xor = \"\";\n    foreach my $i (0..$maxlen-1)\
    \ {\n        my $s = substr($a, $i, 1) ^ substr($b, $i, 1);\n        $xor .= $s\
    \ ? \"1\" : \"0\";\n    }\n    return $xor;\n}", "    my $n = length($a);\n  \
    \  my $r = '';\n    for my $i (0..$n-1) {\n        my $c = substr($a, $i, 1) eq\
    \ substr($b, $i, 1) ? 0 : 1;\n        $r .= $c;\n    }\n    return $r;\n}", " \
    \   my $ret = '';\n    for (my $i = 0; $i < length($a); $i++) {\n        $ret\
    \ .= (substr($a, $i, 1) == substr($b, $i, 1)) ? '0' : '1';\n    }\n    return\
    \ $ret;\n}", "    my $r = \"\";\n    my $min = length($a) < length($b) ? length($a)\
    \ : length($b);\n    for (my $i = 0; $i < $min; $i++) {\n        my $ai = substr($a,\
    \ $i, 1);\n        my $bi = substr($b, $i, 1);\n        if ($ai eq $bi) {\n  \
    \          $r .= \"0\";\n        } else {\n            $r .= \"1\";\n        }\n\
    \    }\n    return $r;\n}", "    my $len = length($a);\n    die \"string_xor()\
    \ requires two strings of same length\" if $len != length($b);\n    my $res =\
    \ \"\";\n    for (my $i = 0; $i < $len; $i++) {\n        $res .= (substr($a, $i,\
    \ 1) ^ substr($b, $i, 1)) ? \"1\" : \"0\";\n    }\n    return $res;\n}", "   \
    \ return unpack(\"H*\", pack(\"B*\", $a) ^ pack(\"B*\", $b));\n}", "    my @a\
    \ = split('', $a);\n    my @b = split('', $b);\n    my $c = \"\";\n    for (my\
    \ $i = 0; $i < scalar(@a); $i++) {\n        if ($a[$i] == $b[$i]) {\n        \
    \    $c .= \"0\";\n        } else {\n            $c .= \"1\";\n        }\n   \
    \ }\n    return $c;\n}", "    my $short = $a;\n    my $long = $b;\n    if (length($a)\
    \ > length($b)) {\n        $short = $b;\n        $long = $a;\n    }\n    my $len\
    \ = length($short);\n    my $res = \"\";\n    for (my $i = 0; $i < $len; $i++)\
    \ {\n        my $s = substr($short, $i, 1);\n        my $l = substr($long, $i,\
    \ 1);\n        $res .= $s ^ $l;\n    }\n    return $res . substr($long, $len);\n\
    }", "    my $result = \"\";\n    my $length = length($a);\n    for (my $i = 0;\
    \ $i < $length; $i++) {\n        if (substr($a, $i, 1) eq substr($b, $i, 1)) {\n\
    \            $result .= \"0\";\n        } else {\n            $result .= \"1\"\
    ;\n        }\n    }\n    return $result;\n}", "    my $a_len = length($a);\n \
    \   my $b_len = length($b);\n    my $a_ = make_len($a, $b_len);\n    my $b_ =\
    \ make_len($b, $a_len);\n    my $r = '';\n    for (my $i = 0; $i < $a_len; $i++)\
    \ {\n        $r .= ($a_[$i] ^ $b_[$i]);\n    }\n    return $r;\n}", "    my @a\
    \ = split(//, $a);\n    my @b = split(//, $b);\n    my @c;\n    for (my $i = 0;\
    \ $i < scalar(@a); $i++) {\n        push(@c, $a[$i] ^ $b[$i]);\n    }\n    return\
    \ join(\"\", @c);\n}", "    return \"\" if (length($a) != length($b));\n    my\
    \ @a = split(//, $a);\n    my @b = split(//, $b);\n    my $ret = \"\";\n    for(my\
    \ $i = 0; $i < @a; $i++) {\n        $ret .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $ret;\n}", "    my @a = split //, $a;\n    my @b = split //, $b;\n    my @result;\n\
    \    while (@a) {\n        my $a = shift @a;\n        my $b = shift @b;\n    \
    \    if ($a eq $b) {\n            push @result, '0';\n        } else {\n     \
    \       push @result, '1';\n        }\n    }\n    return join('', @result);\n}",
  "    my $c = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n        $c .=\
    \ substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $c;\n}", "    my($temp)\
    \ = $a ^ $b;\n    my($result) = \"\";\n    while($temp != 0) {\n        $result\
    \ = $temp % 2 . $result;\n        $temp /= 2;\n    }\n    return $result;\n}",
  "    $a =~ tr/01/10/;\n    $b =~ tr/01/10/;\n    my $res = $a ^ $b;\n    $res =~\
    \ tr/01/10/;\n    return $res;\n}", "    my $result = \"\";\n    for (my $i =\
    \ 0; $i < length($a); $i++) {\n        my $a_bit = substr($a, $i, 1);\n      \
    \  my $b_bit = substr($b, $i, 1);\n        if ($a_bit == $b_bit) {\n         \
    \   $result .= \"0\";\n        } else {\n            $result .= \"1\";\n     \
    \   }\n    }\n    return $result;\n}", "    my @x = split //, $a;\n    my @y =\
    \ split //, $b;\n    my @r;\n    my $diff = (scalar @x) - (scalar @y);\n    if\
    \ ($diff > 0) {\n        push @y, (0) x $diff;\n    } elsif ($diff < 0) {\n  \
    \      push @x, (0) x ($diff * -1);\n    }\n    for (my $i = 0; $i < scalar @x;\
    \ $i++) {\n        if ($x[$i] eq $y[$i]) {\n            push @r, 0;\n        }\
    \ else {\n            push @r, 1;\n        }\n    }\n    return join '', @r;\n\
    }", "    my $lena = length($a);\n    my $lenb = length($b);\n    if($lena != $lenb)\
    \ {\n        return \"\"\n    }\n    my $r = '';\n    for(my $i = 0; $i < $lena;\
    \ $i++) {\n        my $c = substr($a, $i, 1) ^ substr($b, $i, 1);\n        $r\
    \ .= $c;\n    }\n    return $r;\n}", "    my @a = split(\"\", $a);\n    my @b\
    \ = split(\"\", $b);\n    my $c = \"\";\n    for(my $i = 0; $i < scalar(@a); $i++)\
    \ {\n        if($a[$i] eq $b[$i]) {\n            $c .= \"0\";\n        } else\
    \ {\n            $c .= \"1\";\n        }\n    }\n    return $c;\n}", "    return\
    \ pack(\"H*\", sprintf(\"%x\", oct(\"0b\" . $a) ^ oct(\"0b\" . $b)));\n}", " \
    \   return '' if ($a eq '' || $b eq '');\n    return (substr($a, 0, 1) xor substr($b,\
    \ 0, 1)) .\n           string_xor(substr($a, 1), substr($b, 1));\n}", "    my($aBin,\
    \ $bBin);\n    my($bin);\n    my($ret);", "    $a ^= $b;\n    return sprintf \"\
    %b\", $a;\n}", "    return pack \"H*\", (unpack \"H*\", $a) ^ (unpack \"H*\",\
    \ $b);\n}", "    my $i;\n    my $len = length($a);\n    my $xor = '';\n    for($i\
    \ = 0; $i < $len; $i++) {\n        $xor .= substr($a, $i, 1) eq substr($b, $i,\
    \ 1) ? '0' : '1';\n    }\n    return $xor;\n}", '    my($a_ch, $b_ch, $xor_str);',
  "    return\n        join(\"\", map {\n            my($c, $d) = ($a, $b);\n    \
    \        $c =~ s/^(.)//;\n            $d =~ s/^(.)//;\n            $c ^ $d;\n\
    \        } (1..length($a)));\n}", "    my $a_bin = pack(\"b*\", $a);\n    my $b_bin\
    \ = pack(\"b*\", $b);\n    return unpack(\"b*\", $a_bin ^ $b_bin);\n}", "    my($r);\n\
    \    my($i);", "    return sprintf(\"%b\", oct(\"0b$a\") ^ oct(\"0b$b\"));\n}",
  "    return join(\"\", map { ($a->[$_] eq $b->[$_]) ? \"0\" : \"1\" } 0..$#$a);\n\
    }", "    my($xor_string) = \"\";\n    for (my $i = 0; $i < length($a); $i++) {\n\
    \        $xor_string .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n    return\
    \ $xor_string;\n}", "    my $alen = length($a);\n    my $blen = length($b);\n\
    \    my $diff = $alen - $blen;\n    if ($diff > 0) {\n        $b = \"0\" x $diff\
    \ . $b;\n    }\n    elsif ($diff < 0) {\n        $a = \"0\" x -$diff . $a;\n \
    \   }\n    my $ret;\n    for (my $i = 0; $i < length($a); $i++) {\n        $ret\
    \ .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $ret;\n}", "  \
    \  if (length($a) != length($b)) {\n        die sprintf(\"Elements to XOR have\
    \ different lengths: %d vs %d\\n\",\n            length($a), length($b));\n  \
    \  }\n    return join(\"\", map {$_ == 1 ? '1' : '0'} map {hex(unpack(\"H*\",\
    \ $_))}\n        split(//, $a) ^ split(//, $b));\n}", "    my($output);\n    my($temp);\n\
    \    my($digit_a);\n    my($digit_b);\n    my($length);\n    my($i);", "    my\
    \ @a = split //, $a;\n    my @b = split //, $b;\n    my @r;\n    for my $i (0\
    \ .. $#a) {\n        $r[$i] = $a[$i] ^ $b[$i];\n    }\n    return join('', @r);\n\
    }", "    $a = pack(\"B*\", $a);\n    $b = pack(\"B*\", $b);\n    my $res = $a\
    \ ^ $b;\n    $res = unpack(\"B*\", $res);\n    return $res;\n}", "    my @a =\
    \ split(\"\", $a);\n    my @b = split(\"\", $b);\n    my $str = \"\";\n    while(@a)\
    \ {\n        $str .= pop(@a) ^ pop(@b);\n    }\n    return $str;\n}", "    return\
    \ join('', map {$_ ? 1 : 0} map {$a =~ /$_/i} split(//, $b));\n}", "    my($c)\
    \ = \"\";\n    for(my $i = 0; $i < length($a); $i++) {\n        $c .= (substr($a,\
    \ $i, 1) ^ substr($b, $i, 1));\n    }\n    return $c;\n}", "    if(length($a)\
    \ != length($b)) {\n        printf \"WARNING: Cannot xor strings of different\
    \ lengths '%s' and '%s'\\n\", $a, $b;\n        return undef;\n    }\n    my @a\
    \ = split //, $a;\n    my @b = split //, $b;\n    my @c = ();\n    for(my $i =\
    \ 0; $i < scalar(@a); $i++) {\n        push @c, $a[$i] == $b[$i] ? '0' : '1';\n\
    \    }\n    return join('', @c);\n}", "    my $len = length($a);\n    return ''\
    \ if $len != length($b);\n    my $result = '';\n    for (my $i = 0; $i < $len;\
    \ $i++) {\n        my $ai = substr($a, $i, 1);\n        my $bi = substr($b, $i,\
    \ 1);\n        $result .= $ai ^ $bi;\n    }\n    return $result;\n}", "    $a\
    \ =~ tr/01/\\x00\\x01/;\n    $b =~ tr/01/\\x00\\x01/;\n    $a ^= $b;\n    $a =~\
    \ tr/\\x00\\x01/01/;\n    return $a;\n}", "    $a = unpack('B*', $a);\n    $b\
    \ = unpack('B*', $b);\n    my $str = \"\";\n    for (my $i = 0; $i < length($a);\
    \ $i++) {\n        if (substr($a, $i, 1) eq substr($b, $i, 1)) {\n           \
    \ $str .= '0';\n        } else {\n            $str .= '1';\n        }\n    }\n\
    \    return pack('B*', $str);\n}", "    my $m = length($a);\n    my $n = length($b);\n\
    \    if($m != $n) {\n        print \"Error: length of two strings are not the\
    \ same.\\n\";\n        return;\n    }\n    my $result = \"\";\n    for(my $i =\
    \ 0; $i < $m; $i++) {\n        my $x = substr($a, $i, 1);\n        my $y = substr($b,\
    \ $i, 1);\n        if($x ne $y) {\n            $result .= \"1\";\n        } else\
    \ {\n            $result .= \"0\";\n        }\n    }\n    return $result;\n}",
  "    return (($a ^ $b) ^ $b);\n}", "    my $result = \"\";\n    for (my $i = 0;\
    \ $i < length($a); $i++) {\n        $result .= substr($a, $i, 1) eq substr($b,\
    \ $i, 1) ? \"0\" : \"1\";\n    }\n    return $result;\n}", "    my $r = \"\";\n\
    \    my $len = length($a);\n    for (my $i = 0; $i < $len; $i++) {\n        my\
    \ $d = 0;\n        $d++ if (vec($a, $i, 1) != vec($b, $i, 1));\n        $r .=\
    \ $d;\n    }\n    return $r;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
