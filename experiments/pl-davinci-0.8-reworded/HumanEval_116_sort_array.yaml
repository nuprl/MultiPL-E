name: HumanEval_116_sort_array
language: pl
prompt: "# In this Kata, you have to sort an array of non-negative integers according\
  \ to\n# number of ones in their binary representation in ascending order.\n# For\
  \ similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\n# >>> sort_array([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array([-2,\
  \ -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4])\n\
  # [0, 1, 2, 3, 4]\nsub sort_array {\n    my($arr) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_array;\n\
  \        if(eq_deeply($candidate->([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2,\
  \ -3, -4, -5, -6]),[-4, -2, -6, -5, -3])) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 2, 3, 4]),[0,\
  \ 1, 2, 4, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([2, 5, 77, 4, 5, 3, 5,\
  \ 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 6, 44, 12, 32,\
  \ 5]),[32, 3, 5, 6, 12, 44])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2,\
  \ 4, 8, 16, 32]),[2, 4, 8, 16, 32])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @sorted = sort {\n        $a <=> $b\n    }\n    map {\n    \
    \    $_->[0]\n    }\n    sort {\n        $a->[1] <=> $b->[1]\n        ||\n   \
    \     $a->[0] <=> $b->[0]\n    }\n    map {\n        my $bin = sprintf(\"%b\"\
    , $_);\n        my $ones = $bin =~ tr/1//;\n        [$_, $ones]\n    } @$arr;\n\
    \    return \\@sorted;\n}", "    return [sort { to_decimal($a) <=> to_decimal($b)\
    \ } sort { to_binary($a) cmp to_binary($b) } @$arr];\n}", "    my @sorted = sort\
    \ { count_ones($a) <=> count_ones($b) } @$arr;\n    my @unsorted = grep { count_ones($_)\
    \ == count_ones($sorted[0]) } @sorted;\n    my @sorted2 = grep { count_ones($_)\
    \ != count_ones($sorted[0]) } @sorted;\n    return [ sort { $a <=> $b } @unsorted,\
    \ @sorted2 ];\n}", "    my @binaries = map { sprintf(\"%b\", $_) } @$arr;\n  \
    \  my @indexes = sort {\n        ($binaries[$a] =~ tr/1//) <=> ($binaries[$b]\
    \ =~ tr/1//) ||\n        $a <=> $b\n    } 0..$#$arr;\n    return [ @$arr[@indexes]\
    \ ];\n}", "    my @tmp = ();\n    foreach my $val (@$arr) {\n        my $bin =\
    \ sprintf(\"%b\", $val);\n        push @tmp, [$bin =~ tr/1//, $val];\n    }\n\
    \    return [ map { $_->[1] } sort { $a->[0] <=> $b->[0] } @tmp ];\n}", "    return\
    \ [\n        sort {\n            if ( ( $a + $b ) % 2 == 0 ) {\n             \
    \   -($a <=> $b)\n            } else {\n                if ( count_ones($a) ==\
    \ count_ones($b) ) {\n                    -($a <=> $b)\n                } else\
    \ {\n                    count_ones($a) <=> count_ones($b)\n                }\n\
    \            }\n        } @$arr\n    ];\n}", "    my @result = sort {$a <=> $b}\
    \ @$arr;\n    return @result;\n}", "    my @newarr = sort {\n        my @bin1\
    \ = split //, sprintf(\"%b\", $a);\n        my @bin2 = split //, sprintf(\"%b\"\
    , $b);\n        my $b1 = scalar @bin1;\n        my $b2 = scalar @bin2;\n     \
    \   if ($b1 == $b2) {\n            return $a <=> $b;\n        } else {\n     \
    \       return $b1 <=> $b2;\n        }\n    } @$arr;\n    return \\@newarr;\n}",
  "    my @sorted = sort { num_ones($a) <=> num_ones($b) || $a <=> $b } @$arr;\n \
    \   return \\@sorted;\n}", "    my @sorted = map {$_->[0]}\n        sort {$a->[1]\
    \ <=> $b->[1] or $a->[0] <=> $b->[0]}\n        map {[$_, count_ones($_)]} @$arr;\n\
    \    return \\@sorted;\n}", "    my @ret = ();\n    my %hsh = ();\n    foreach\
    \ my $v ( @$arr ) {\n        my $n = $v;\n        my $c = 0;\n        while( $n\
    \ ) {\n            $c++ if $n & 1;\n            $n >>= 1;\n        }\n       \
    \ $hsh{$c} = [] unless defined $hsh{$c};\n        push @{$hsh{$c}}, $v;\n    }\n\
    \    foreach my $k ( sort { $a <=> $b } keys %hsh ) {\n        push @ret, sort\
    \ { $a <=> $b } @{$hsh{$k}};\n    }\n    return \\@ret;\n}", "    my @list = (ref\
    \ $arr eq 'ARRAY') ? @$arr : ($arr);\n    return [ sort { get_bit_count($a) ==\
    \ get_bit_count($b) ?\n                    $a <=> $b : get_bit_count($a) <=> get_bit_count($b)\
    \ } @list ];\n}", "    my @sorted = sort {\n        if ($a == $b) {\n        \
    \    return $a <=> $b;\n        }\n        else {\n            return bin($a)\
    \ cmp bin($b);\n        }\n    } @$arr;\n    return \\@sorted;\n}", "    return\
    \ [sort { bits($a) <=> bits($b) || $a <=> $b } @$arr];\n}", "    my @ones = map\
    \ { sprintf(\"%0b\", $_) =~ tr/1// } @$arr;\n    my @zeros = map { sprintf(\"\
    %0b\", $_) =~ tr/0// } @$arr;\n    my @sorted = map { sprintf(\"%0b\", $_) =~\
    \ tr/1// } @$arr;\n    my @arr = map { sprintf(\"%0b\", $_) =~ tr/0// } @$arr;\n\
    \    my $index = 0;\n    my $index2 = 0;\n    my $index3 = 0;\n    my $index4\
    \ = 0;\n    foreach my $i (@ones) {\n        if ($i == 1) {\n            $index++;\n\
    \        }\n    }\n    foreach my $i (@zeros) {\n        if ($i == 1) {\n    \
    \        $index2++;\n        }\n    }\n    foreach my $i (@sorted) {\n       \
    \ if ($i == 1) {\n            $index3++;\n        }\n    }\n    foreach my $i\
    \ (@arr) {\n        if ($i == 1) {\n            $index4++;\n        }\n    }\n\
    \    if ($index2 == $index) {\n        return sort { $a <=> $b } @$arr;\n    }\n\
    \    else {\n        @$arr = sort { $arr[$index] <=> $arr[$index2] } @$arr;\n\
    \        return @$arr;\n    }\n}", "    return [ sort {\n        my($x) = sprintf('%b',\
    \ $a);\n        my($y) = sprintf('%b', $b);\n        return($y =~ tr/1//c <=>\
    \ $x =~ tr/1//c)\n            || ($a <=> $b);\n    } @$arr ];\n}\nuse Test::More;\n\
    is_deeply(sort_array([1, 0, 2, 3, 4]), [0, 1, 2, 3, 4]);\nis_deeply(sort_array([1,\
    \ 5, 2, 3, 4]), [1, 2, 3, 4, 5]);\nis_deeply(sort_array([-2, -3, -4, -5, -6]),\
    \ [-6, -5, -4, -3, -2]);\ndone_testing();", "    return [sort {\n        $a <=>\
    \ $b or\n        count_ones($a) <=> count_ones($b)\n    } @$arr];\n}", "    return\
    \ [sort {$a<=>$b} @$arr];\n}", "    return [sort {\n        $a <=> $b ||\n   \
    \     $a == $b ? $a <=> $b : length($a) <=> length($b) ||\n        $a cmp $b\n\
    \    } @$arr];\n}", "    return [] if scalar @$arr == 0;\n    my @res = sort {\
    \ scalar(grep { $_ == 1 } split '', unpack 'B*', $a) <=> scalar(grep { $_ == 1\
    \ } split '', unpack 'B*', $b) || $a <=> $b } @$arr;\n    return \\@res;\n}",
  "    return [sort { bitcount($a) <=> bitcount($b) || $a <=> $b } @$arr];\n}", " \
    \   my @sorted =\n        map { $_->[0] }\n        sort { $a->[1] <=> $b->[1]\
    \ }\n        map {\n            [$_, $_ * -1 + tr/1//]\n        } @$arr;\n   \
    \ return \\@sorted;\n}", "    return [\n      sort {\n          (my $ones = $a)\
    \ =~ s/^0+//;\n          $ones =~ s/0+$//;\n          my $a_ones = $ones =~ tr/1//;\n\
    \          ($ones = $b) =~ s/^0+//;\n          $ones =~ s/0+$//;\n          my\
    \ $b_ones = $ones =~ tr/1//;\n          ($a_ones <=> $b_ones) || ($a <=> $b)\n\
    \      } @$arr\n    ];\n}", "    $arr ||= [];\n    my @sorted =\n      map { $_->[0]\
    \ }\n      sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0] }\n      map { [\
    \ $_, sprintf(\"%b\", $_) =~ tr/1// ] }\n      @$arr;\n    return @sorted;\n}",
  "    return [ sort {\n        my $a_ones = count_ones(dec2bin($a));\n        my\
    \ $b_ones = count_ones(dec2bin($b));\n        $a_ones == $b_ones ? $a <=> $b :\
    \ $a_ones <=> $b_ones\n    } @$arr ]\n}", "    my @a;\n    for my $x (@$arr) {\n\
    \        my $dec = $x;\n        my $bin = sprintf \"%b\", $x;\n        my $ones\
    \ = $bin =~ tr/1//;\n        push @a, [$ones, $dec, $x];\n    }\n    return [map\
    \ { $_->[2] } sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @a];\n}", " \
    \   my @result = map $_->[0], sort {$a->[1] <=> $b->[1]} map [$_, count_ones($_)],\
    \ @$arr;\n    return \\@result;\n}", "    my $size = scalar @$arr;\n    my $mid\
    \ = int($size / 2);\n    if ($size <= 1) {\n        return $arr;\n    }\n    my\
    \ @left = @$arr[0..$mid-1];\n    my @right = @$arr[$mid..$size-1];\n    sort_array(\\\
    @left);\n    sort_array(\\@right);\n    merge(\\@left, \\@right, $arr);\n    return\
    \ $arr;\n}", "    my @sorted = sort {\n        scalar(split(//, unpack(\"B*\"\
    , pack(\"N\", $a)))) <=> scalar(split(//, unpack(\"B*\", pack(\"N\", $b)))) ||\
    \ $a <=> $b\n    } @$arr;\n    return \\@sorted;\n}", "    return [ sort { numOnes($a)\
    \ <=> numOnes($b) || $a <=> $b } @$arr ];\n}", "    my @sorted_arr = ();\n   \
    \ for my $n (@$arr) {\n        my $dec_val = dec_val($n);\n        my $ones_val\
    \ = ones_val($n);\n        my @tmp = ( $n, $dec_val, $ones_val );\n        push\
    \ @sorted_arr, \\@tmp;\n    }\n    @sorted_arr = sort { $a->[2] <=> $b->[2] or\
    \ $a->[1] <=> $b->[1] } @sorted_arr;\n    @sorted_arr = map { $_->[0] } @sorted_arr;\n\
    \    return \\@sorted_arr;\n}", "    @$arr = sort {$a <=> $b} @$arr;\n    return\
    \ $arr;\n}", "    my @sorted =\n        map {$_->[0]}\n        sort {$a->[1] <=>\
    \ $b->[1] || $a->[0] <=> $b->[0]}\n        map {[$_, 1 * (1 x dec2bin($_))]}\n\
    \        @$arr;\n    return \\@sorted;\n}", "    my @sorted = sort {\n       \
    \ my $c = () = split(//, unpack('B*', pack('N', $a))) =~ /1/g;\n        my $d\
    \ = () = split(//, unpack('B*', pack('N', $b))) =~ /1/g;\n        if($c == $d)\
    \ {\n            return $a <=> $b;\n        }\n        else {\n            return\
    \ $c <=> $d;\n        }\n    } @$arr;\n    return \\@sorted;\n}", "    if(!defined($arr)\
    \ || scalar(@$arr) == 0) {\n        return [];\n    }\n    my @arr = map {\n \
    \       my $ones = count_ones($_);\n        { ones => $ones, value => $_ }\n \
    \   } @$arr;\n    @arr = sort {\n        if($a->{ones} == $b->{ones}) {\n    \
    \        return $a->{value} <=> $b->{value};\n        }\n        return $a->{ones}\
    \ <=> $b->{ones};\n    } @arr;\n    return [map { $_->{value} } @arr];\n}", " \
    \   return [ sort {\n               my($x, $y) = ($a, $b);\n               $x\
    \ =~ s/(.)/sprintf(\"%04b\", ord($1))/ge;\n               $y =~ s/(.)/sprintf(\"\
    %04b\", ord($1))/ge;\n               ($x =~ tr/1//) <=> ($y =~ tr/1//)\n     \
    \          || $a <=> $b\n               } @$arr ];\n}", "    $arr = [\n      \
    \  map { $_->[0] }\n        sort {\n            $a->[1] <=> $b->[1] || $a->[0]\
    \ <=> $b->[0]\n        }\n        map { [$_, n_1($_)] }\n        @$arr\n    ];\n\
    \    return $arr;\n}", "    my @a = map { [$_, count_ones($_)] } @$arr;\n    my\
    \ @sorted = sort {\n        $a->[1] <=> $b->[1]\n            ||\n        $a->[0]\
    \ <=> $b->[0]\n    } @a;\n    return [map { $_->[0] } @sorted];\n}", "    my @order\
    \ = sort { sprintf('%08b', $a) =~ tr/1// =~ sprintf('%08b', $b) =~ tr/1// || $a\
    \ <=> $b } @$arr;\n    return \\@order;\n}", "    return [] if !@$arr;\n    my\
    \ @result = sort {dec2bin($a) cmp dec2bin($b)} @$arr;\n    return \\@result;\n\
    }", "    my @ones = map { $_ - tr/0//c } map { sprintf(\"%b\", $_) } @$arr;\n\
    \    my @sorted = map { $arr->[$_] } sort { $ones[$a] <=> $ones[$b] || $a <=>\
    \ $b } 0..$#$arr;\n    return \\@sorted;\n}", "    my @ret = ();\n    my @sorted\
    \ = ();\n    foreach (@$arr) {\n        my @ones = /1/g;\n        my $ones = scalar\
    \ @ones;\n        push @ret, {value => $_, ones => $ones};\n    }\n    @sorted\
    \ = sort {$a->{ones} <=> $b->{ones} || $a->{value} <=> $b->{value}} @ret;\n  \
    \  return [map {$_->{value}} @sorted];\n}", "    my @result = sort {\n       \
    \ my $a_ones = () = split('', sprintf(\"%b\", $a));\n        my $b_ones = () =\
    \ split('', sprintf(\"%b\", $b));\n        if ($a_ones != $b_ones) {\n       \
    \     return $a_ones <=> $b_ones;\n        } else {\n            return $a <=>\
    \ $b;\n        }\n    } @$arr;\n    return \\@result;\n}", "    my $narr = [];\n\
    \    for my $a (@$arr) {\n        my $b = $a;\n        my $n = 0;\n        while\
    \ ($b > 0) {\n            $n++ if $b % 2;\n            $b /= 2;\n        }\n \
    \       push @$narr, [$n, $a];\n    }\n    return [map {$_->[1]} sort {$a->[0]\
    \ <=> $b->[0] || $a->[1] <=> $b->[1]} @$narr];\n}", "    return [ sort { countOnes($a)\
    \ <=> countOnes($b) || $a <=> $b } @$arr ];\n}", '    # your code here', "   \
    \ return $arr if @$arr < 2;\n    my $median = $arr->[int(@$arr / 2)];\n    [\n\
    \        sort_array([grep {$_ < $median} @$arr]),\n        grep {$_ == $median}\
    \ @$arr,\n        sort_array([grep {$_ > $median} @$arr]),\n    ];\n}", "    my\
    \ @sorted = sort {\n        scalar(grep { $_ eq '1' } split //, sprintf('%b',\
    \ $a)) <=>\n        scalar(grep { $_ eq '1' } split //, sprintf('%b', $b)) ||\n\
    \        $a <=> $b\n    } @$arr;\n    return @sorted;\n}", "    my @ones = map\
    \ {\n        my $ones = 0;\n        my $x = $_;\n        while ($x) {\n      \
    \      $ones++ if $x & 1;\n            $x >>= 1;\n        }\n        [$_, $ones];\n\
    \    } @$arr;\n    return [ map { $_->[0] } sort { $a->[1] <=> $b->[1] || $a->[0]\
    \ <=> $b->[0] } @ones ];\n}", "    my @result = ();\n    foreach (@$arr) {\n \
    \       my @number = split('', sprintf(\"%b\", $_));\n        my $tmp = 0;\n \
    \       foreach (@number) {\n            $tmp += $_;\n        }\n        push\
    \ @result, {\n            value => $_,\n            one => $tmp,\n        };\n\
    \    }\n    return [map {$_->{value}} sort {$a->{one} <=> $b->{one} || $a->{value}\
    \ <=> $b->{value}} @result];\n}", "    $arr = join(\";\", @$arr);\n    $arr =~\
    \ s/(\\d+)/sprintf(\"%064b\", $1)/eg;\n    $arr =~ s/(\\d+);/$1,/g;\n    my @pairs\
    \ = split(\",\", $arr);\n    @pairs = sort @pairs;\n    $arr = join(\";\", @pairs);\n\
    \    $arr =~ s/(\\d+);/$1,/g;\n    $arr =~ s/(\\d+)/sprintf(\"%u\", oct(\"0b$1\"\
    ))/eg;\n    return [ split(\",\", $arr) ];\n}", "    my @sorted = sort {\n   \
    \     my @b1 = split(//, sprintf(\"%b\", $a));\n        my @b2 = split(//, sprintf(\"\
    %b\", $b));\n        my $ones1 = grep /1/, @b1;\n        my $ones2 = grep /1/,\
    \ @b2;\n        if ($ones1 == $ones2) {\n            return $a <=> $b;\n     \
    \   }\n        else {\n            return $ones1 <=> $ones2;\n        }\n    }\
    \ @$arr;\n    return \\@sorted;\n}", "    return [\n        sort {\n         \
    \   my($x) = $a;\n            my($y) = $b;\n            my($xones) = $x == 0 ?\
    \ 0 : 1 + $x =~ tr/01/01/;\n            my($yones) = $y == 0 ? 0 : 1 + $y =~ tr/01/01/;\n\
    \            if($xones <=> $yones) {\n                return $xones <=> $yones;\n\
    \            }\n            else {\n                return $x <=> $y;\n      \
    \      }\n        } @$arr\n    ];\n}", "    @{$arr} = sort {($a ^ $b) % 2 <=>\
    \ ($b ^ $a) % 2} @{$arr};\n    return $arr;\n}", "    my %hash = map { $_ => unpack('%32b*',\
    \ $_) } @$arr;\n    $arr = [ sort {\n        $hash{$a} cmp $hash{$b}\n       \
    \ ||\n        $a <=> $b\n    } @$arr ];\n    return $arr;\n}", "    return sort\
    \ {\n        my($an) = $a;\n        my($bn) = $b;\n        my($c) = $an ^ $bn;\n\
    \        my($ac) = 0;\n        my($bc) = 0;\n        for (my($i) = 0; $i < 32;\
    \ $i++) {\n            if (($c & (1 << $i)) != 0) {\n                if (($an\
    \ & (1 << $i)) != 0) {\n                    $ac++;\n                }\n      \
    \          if (($bn & (1 << $i)) != 0) {\n                    $bc++;\n       \
    \         }\n            }\n        }\n        if ($ac == $bc) {\n           \
    \ return $a <=> $b;\n        }\n        else {\n            return $ac <=> $bc;\n\
    \        }\n    } @$arr;\n}", "    return [ sort { $a <=> $b || $a <=> $b } @$arr\
    \ ];\n}", "    my @ret = sort {\n        $a =~ tr/1//;\n        my $a_ones = length($a);\n\
    \        $b =~ tr/1//;\n        my $b_ones = length($b);\n        return $a_ones\
    \ <=> $b_ones || $a <=> $b;\n    } @$arr;\n    return \\@ret;\n}", "    $arr =\
    \ [$arr] unless ref $arr eq 'ARRAY';\n    my %map = map { $_->[0] => $_->[1] }\n\
    \      sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0] }\n      map { [$_, ones_in_binary($_)]\
    \ } @$arr;\n    return [ map { $map{$_} } @$arr ];\n}", "    my %ones;\n    my\
    \ %dec;\n    foreach my $v(@$arr) {\n        $ones{$v} = count_ones($v);\n   \
    \     $dec{$v} = $v;\n    }\n    my @result = sort {\n        $ones{$a} <=> $ones{$b}\n\
    \            ||\n        $dec{$a} <=> $dec{$b}\n    } @$arr;\n    return \\@result;\n\
    }", "    return $arr if @$arr < 2;\n    my $pivot = $arr->[0];\n    my @less =\
    \ grep { $_ < $pivot } @$arr;\n    my @more = grep { $_ > $pivot } @$arr;\n  \
    \  my @equal = grep { $_ == $pivot } @$arr;\n    return [@{sort_array(\\@less)},\
    \ @equal, @{sort_array(\\@more)}];\n}", "    my @arr = @$arr;\n    my @a;\n  \
    \  for (my $i = 0; $i < @arr; $i++) {\n        my $n = $arr[$i];\n        $a[$i]\
    \ = [$n, int(reverse(sprintf(\"%b\", abs($n))))];\n    }\n    @a = sort {\n  \
    \      my $comp = $a->[1] <=> $b->[1];\n        if ($comp == 0) {\n          \
    \  $a->[0] <=> $b->[0];\n        } else {\n            $comp;\n        }\n   \
    \ } @a;\n    return [map { $_->[0] } @a];\n}", "    return [sort {dec($a) <=>\
    \ dec($b) || count_ones($a) <=> count_ones($b)} @$arr];\n}", "    return [sort\
    \ {$a <=> $b || $a <=> $b} @$arr];\n}", "    return [sort {binary_sort($a, $b)}\
    \ @$arr];\n}", "    my @tmp = @$arr;\n    my @sorted = map { ($_->[0]) }\n   \
    \     sort { $a->[1] <=> $b->[1] }\n        map { [ $_, sprintf(\"%08b\", $_)\
    \ =~ tr/1//] } @tmp;\n    return \\@sorted;\n}", "    return [ sort {\n      \
    \  ($b =~ tr/1//) <=> ($a =~ tr/1//)\n        ||\n        $a <=> $b\n    } @$arr\
    \ ];\n}", "    return [ sort {\n        (split //, unpack(\"B*\", pack(\"N\",\
    \ $a)))[-1] <=> (split //, unpack(\"B*\", pack(\"N\", $b)))[-1] || $a <=> $b\n\
    \    } @$arr ];\n}", "    my @sorted = sort {\n        return $a <=> $b if $a\
    \ == $b;\n        count_ones($a) <=> count_ones($b)\n    } @$arr;\n    return\
    \ \\@sorted;\n}", "    my @ary;\n    for (@$arr) {\n        my $bin = sprintf(\"\
    %b\", $_);\n        my $ones = () = $bin =~ /1/g;\n        push @ary, [$ones,\
    \ $_];\n    }\n    return [map { $_->[1] } sort { $a->[0] <=> $b->[0] || $a->[1]\
    \ <=> $b->[1] } @ary];\n}", "    return [\n        sort {\n            my $a1\
    \ = $a == 0 ? -1 : scalar(grep { $_ eq '1' } split '', sprintf(\"%b\", $a));\n\
    \            my $b1 = $b == 0 ? -1 : scalar(grep { $_ eq '1' } split '', sprintf(\"\
    %b\", $b));\n            return $a1 <=> $b1 || $a <=> $b;\n        } @$arr\n \
    \   ];\n}", "    my @sorted = sort { \n        my @ones_a = split //, unpack('B*',\
    \ pack('C', $a));\n        my @ones_b = split //, unpack('B*', pack('C', $b));\n\
    \        my $ones_a = scalar(grep { $_ eq '1' } @ones_a);\n        my $ones_b\
    \ = scalar(grep { $_ eq '1' } @ones_b);\n        $ones_a == $ones_b ? $a <=> $b\
    \ : $ones_a <=> $ones_b;\n    } @$arr;\n    return \\@sorted;\n}", "    return\
    \ map { $_->[0] }\n        sort { $a->[1] <=> $b->[1] }\n        map { [$_, $_,\
    \ tr/1//] }\n        @$arr;\n}", "    my @indexes = @$arr;\n    my @sorted = sort\
    \ {$a <=> $b} @$arr;\n    my @ones = map {cnt_ones($_)} @sorted;\n    my @ind_ones\
    \ = map {[$ones[$_], $_]} 0..$#ones;\n    my @sorted_ind_ones = sort {$a->[0]\
    \ <=> $b->[0] || $a->[1] <=> $b->[1]} @ind_ones;\n    return [map {$sorted[$_->[1]]}\
    \ @sorted_ind_ones];\n}", "    return [sort {\n        $a <=> $b || $a !~ /1/\
    \ <=> $b !~ /1/ || scalar(($a+0) =~ /1/g) <=> scalar(($b+0) =~ /1/g)\n    } @$arr];\n\
    }", "    return [sort {$a <=> $b} @$arr];\n}", "    return [sort { $a <=> $b }\
    \ @$arr];\n}", "    $arr = [sort { count_bits($a) <=> count_bits($b) || $a <=>\
    \ $b } @$arr];\n    return $arr;\n}", "    $arr = [map { [$_, sprintf(\"%b\",\
    \ $_)] } @$arr];\n    $arr = [sort { my $l = length($a->[1]); my $r = length($b->[1]);\
    \ ($l <=> $r) || ($a->[0] <=> $b->[0]) } @$arr];\n    $arr = [map { $_->[0] }\
    \ @$arr];\n    return $arr;\n}", "    my @arr = @$arr;\n    my @ans;\n    foreach\
    \ my $x (@arr) {\n        my $bin = sprintf(\"%b\", $x);\n        my $cnt = $bin\
    \ =~ tr/1//;\n        push @ans, [$cnt, $x];\n    }\n    @ans = sort {$a->[0]\
    \ == $b->[0] ? $a->[1] <=> $b->[1] : $a->[0] <=> $b->[0]} @ans;\n    return [map\
    \ {$_->[1]} @ans];\n}", "    my @arr2 = @$arr;\n    my %ones;\n    my %dec;\n\
    \    my @dec;\n    my @ret;\n    my $deckey;\n    my $oneskey;\n    foreach (@arr2)\
    \ {\n        $deckey = $_;\n        $oneskey = $_;\n        $dec{$deckey} = $_;\n\
    \        $ones{$oneskey} = (split '', sprintf(\"%b\", $_))[0];\n    }\n    @dec\
    \ = sort {$a <=> $b} @dec{keys %dec};\n    my $dec;\n    foreach (sort {$ones{$a}\
    \ <=> $ones{$b}} keys %ones) {\n        $dec = $_;\n        push @ret, $dec{$dec};\n\
    \    }\n    return \\@ret;\n}", "    my @sorted = sort { count_ones($a) <=> count_ones($b)\
    \ || $a <=> $b } @$arr;\n    return @sorted;\n}", "    return [\n        sort\
    \ { (join '', split //, sprintf \"%b\", $a) cmp (join '', split //, sprintf \"\
    %b\", $b) || $a <=> $b }\n        @$arr\n    ];\n}", "    my @sorted = sort {\n\
    \        my $x1 = $a;\n        my $x2 = $b;\n        my $count1 = 0;\n       \
    \ my $count2 = 0;\n        for (my $i = 0; $i < 32; $i++) {\n            if ($x1\
    \ & 1) {\n                $count1++;\n            }\n            if ($x2 & 1)\
    \ {\n                $count2++;\n            }\n            $x1 >>= 1;\n     \
    \       $x2 >>= 1;\n        }\n        $count1 == $count2 ? $a <=> $b : $count1\
    \ <=> $count2;\n    } @$arr;\n    return \\@sorted;\n}", "    my $str_arr = [map\
    \ {sprintf \"%b\", $_} @$arr];\n    my $refs = [map {[$_, $_->[0] =~ tr/1//, $_->[1]]}\n\
    \                map {[$_, scalar reverse $_]}\n                @$str_arr];\n\
    \    my @sorted = map {$_->[1]}\n                 sort {$a->[0] <=> $b->[0] ||\
    \ $a->[2] <=> $b->[2]}\n                 @$refs;\n    return \\@sorted;\n}", " \
    \   my @arr_temp = @$arr;\n    # \u628A\u6570\u7EC4\u8F6C\u6362\u6210 2 \u8FDB\
    \u5236\u5B57\u7B26\u4E32\n    my @arr_temp2 = map { unpack('B*', pack('N', $_))\
    \ } @arr_temp;\n    my @arr_ones;\n    my @arr_dec;\n    my $str_temp;\n    my\
    \ $index = 0;\n    my $index2 = 0;\n    # \u7EDF\u8BA1\u6BCF\u4E2A\u6570\u5B57\
    \u76841\u7684\u4E2A\u6570\n    for $str_temp (@arr_temp2) {\n        $arr_ones[$index++]\
    \ = $str_temp =~ tr/1//;\n    }\n    # \u7EDF\u8BA1\u6BCF\u4E2A\u6570\u5B57\u7684\
    10\u8FDB\u5236\u503C\n    for $str_temp (@arr_temp) {\n        $arr_dec[$index2++]\
    \ = $str_temp;\n    }\n    # \u5192\u6CE1\u6392\u5E8F\n    for $index (0 .. $#arr_ones)\
    \ {\n        for $index2 ($index + 1 .. $#arr_ones) {\n            if ($arr_ones[$index]\
    \ > $arr_ones[$index2]) {\n                ($arr_ones[$index], $arr_ones[$index2])\
    \ = ($arr_ones[$index2], $arr_ones[$index]);\n                ($arr_dec[$index],\
    \ $arr_dec[$index2]) = ($arr_dec[$index2], $arr_dec[$index]);\n            }\n\
    \        }\n    }\n    return \\@arr_dec;\n}", "    return [sort {$a <=> $b} @$arr];\n\
    }", "    return $arr if !$arr || !@$arr;\n    return [sort {\n        sprintf(\"\
    %b\", $a) cmp sprintf(\"%b\", $b) || $a <=> $b\n    } @$arr];\n}", "    my @ret;\n\
    \    foreach my $i (0..$#{$arr}) {\n        $ret[$i] = [$arr->[$i], ones($arr->[$i])];\n\
    \    }\n    @ret = sort {\n        if($a->[1] != $b->[1]) {\n            return\
    \ $a->[1] <=> $b->[1];\n        } else {\n            return $a->[0] <=> $b->[0];\n\
    \        }\n    } @ret;\n    @ret = map { $_->[0] } @ret;\n    return \\@ret;\n\
    }", "    if(defined $arr) {\n        my @out = sort {\n            my $a_ones\
    \ = count_ones($a);\n            my $b_ones = count_ones($b);\n            $a_ones\
    \ <=> $b_ones\n                or\n            $a <=> $b\n        } @$arr;\n \
    \       return \\@out;\n    }\n    return [];\n}", "    my @zero;\n    my @one;\n\
    \    foreach my $x (@$arr) {\n        my $c = count_ones($x);\n        if($c ==\
    \ 0) {\n            push @zero, $x;\n        }\n        else {\n            push\
    \ @one, [$x, $c];\n        }\n    }\n    my @res = sort {\n        my $a_c = $a->[1];\n\
    \        my $b_c = $b->[1];\n        if($a_c != $b_c) {\n            return $a_c\
    \ <=> $b_c;\n        }\n        return $a->[0] <=> $b->[0];\n    } @one;\n   \
    \ my @ret;\n    for my $x (@res) {\n        push @ret, $x->[0];\n    }\n    return\
    \ [@zero, @ret];\n}", "    my @arr = @$arr;\n    my @new_arr = map {\n       \
    \ sprintf(\"%08d %04d\", substr(unpack(\"B32\", pack(\"N\", $_)), -8), $_)\n \
    \   } @arr;\n    my @sorted_arr = sort @new_arr;\n    return [map {substr($_,\
    \ -4)} @sorted_arr];\n}", "    my @sorted = sort {binary_num_ones($a) <=> binary_num_ones($b)\
    \ or $a <=> $b} @$arr;\n    return \\@sorted;\n}", "    my %h;\n    for my $i\
    \ (@$arr) {\n        my $bin = sprintf(\"%b\", $i);\n        $h{$bin} //= [];\n\
    \        push @{$h{$bin}}, $i;\n    }\n    my @r;\n    for my $key (sort { $a\
    \ cmp $b } keys %h) {\n        push @r, sort { $a <=> $b } @{$h{$key}};\n    }\n\
    \    return \\@r;\n}", "    my @result = sort{\n        my $left = $a;\n     \
    \   my $right = $b;\n        my $left_bin = dec2bin($left);\n        my $right_bin\
    \ = dec2bin($right);\n        my $left_count = 0;\n        my $right_count = 0;\n\
    \        while( $left > 0 ){\n            $left_count += $left % 2;\n        \
    \    $left /= 2;\n        }\n        while( $right > 0 ){\n            $right_count\
    \ += $right % 2;\n            $right /= 2;\n        }\n        $left_count <=>\
    \ $right_count || $left <=> $right;\n    } @$arr;\n    return \\@result;\n}",
  "    my @result = ();\n    foreach my $num (@$arr) {\n        push @result, $num;\n\
    \    }\n    @result = sort {\n        my $bnum = $a + 0;\n        my $b1num =\
    \ $b + 0;\n        $bnum = sprintf(\"%b\", $bnum);\n        $b1num = sprintf(\"\
    %b\", $b1num);\n        $bnum =~ s/0//g;\n        $b1num =~ s/0//g;\n        if\
    \ (length($bnum) != length($b1num)) {\n            return length($bnum) <=> length($b1num);\n\
    \        } else {\n            return $a <=> $b;\n        }\n    } @result;\n\
    \    return \\@result;\n}", "    my @res = sort {($a + 0) <=> ($b + 0)} $arr;\n\
    \    return \\@res;\n}", "    return [ sort {\n        my $b_bin = sprintf \"\
    %b\", $b;\n        my $a_bin = sprintf \"%b\", $a;\n        $b_bin =~ s/0//g;\n\
    \        $a_bin =~ s/0//g;\n        $b_bin <=> $a_bin or $a <=> $b;\n    } @$arr];\n\
    }", "    return sort { countOnes($a) <=> countOnes($b) || $a <=> $b } @$arr;\n\
    }", "    my $len = scalar @$arr;\n    for (my $i = 0; $i < $len - 1; $i++) {\n\
    \        for (my $j = $i + 1; $j < $len; $j++) {\n            my $a = $arr->[$i];\n\
    \            my $b = $arr->[$j];\n            my @a = split //, sprintf('%b',\
    \ $a);\n            my @b = split //, sprintf('%b', $b);\n            my $ones_a\
    \ = grep {$_ == 1} @a;\n            my $ones_b = grep {$_ == 1} @b;\n        \
    \    if ($ones_a > $ones_b || ($ones_a == $ones_b && $a > $b)) {\n           \
    \     $arr->[$i] = $b;\n                $arr->[$j] = $a;\n            }\n    \
    \    }\n    }\n    return $arr;\n}", "    my %counts;\n    for my $n (@$arr) {\n\
    \        my $bin = sprintf('%b', $n);\n        $counts{$bin} = [] unless exists\
    \ $counts{$bin};\n        push @{$counts{$bin}}, $n;\n    }\n    my @counts =\
    \ sort { $a <=> $b } keys %counts;\n    my @result;\n    for my $count (@counts)\
    \ {\n        my @nums = sort { $a <=> $b } @{$counts{$count}};\n        push @result,\
    \ @nums;\n    }\n    return \\@result;\n}", "    my @arr_copy = @$arr;\n    my\
    \ @ones_arr = map {\n        my $dec = $_;\n        my $bin = sprintf(\"%b\",\
    \ $dec);\n        my $cnt = ($bin =~ tr/1//);\n        {val => $dec, ones => $cnt};\n\
    \    } @arr_copy;\n    my @sorted_ones_arr = sort {$a->{ones} <=> $b->{ones} ||\
    \ $a->{val} <=> $b->{val}} @ones_arr;\n    my @sorted_arr = map {$_->{val}} @sorted_ones_arr;\n\
    \    return \\@sorted_arr;\n}", "    my @sorted =\n        map { $_->[0] }\n \
    \       sort { $a->[1] <=> $b->[1] }\n        map { [$_, sprintf(\"%b\", $_),\
    \ sprintf(\"%d\", $_)] }\n        @$arr;\n    return \\@sorted;\n}", "    my @sorted\
    \ = sort {\n        my $ac = unpack(\"%32b*\", pack(\"N\", $a));\n        my $bc\
    \ = unpack(\"%32b*\", pack(\"N\", $b));\n        ($ac <=> $bc) || ($a <=> $b)\n\
    \    } @$arr;\n    return \\@sorted;\n}", "    return [ sort {\n        my($v1)\
    \ = @$a;\n        my($v2) = @$b;\n        $v1 = sprintf(\"%b\", $v1);\n      \
    \  $v2 = sprintf(\"%b\", $v2);\n        $v1 =~ s/[01]//g;\n        $v2 =~ s/[01]//g;\n\
    \        $v1 <=> $v2 || $a <=> $b;\n    } map { [ $_ ] } @$arr ];\n}", "    my\
    \ @sorted = sort {\n        $a =~ tr/1//;\n        my $a_ones = $#+;\n       \
    \ $b =~ tr/1//;\n        my $b_ones = $#+;\n        if ($a_ones == $b_ones) {\n\
    \            return $a <=> $b;\n        }\n        else {\n            return\
    \ $a_ones <=> $b_ones;\n        }\n    } @$arr;\n    return \\@sorted;\n}", " \
    \   my $info = [];\n    for (@$arr) {\n        my $count = scalar(split(//, unpack(\"\
    B*\", pack(\"N\", $_))));\n        push @$info, [$count, $_];\n    }\n    @$info\
    \ = sort {$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]} @$info;\n    return [map\
    \ {$_->[1]} @$info];\n}", "    my @sorted = sort {$a <=> $b} @$arr;\n    @sorted;\n\
    }", "    return $arr unless(scalar(@$arr));\n    my $ones = [];\n    my $notones\
    \ = [];\n    foreach my $num (@$arr) {\n        if ($num < 0) {\n            push\
    \ @$notones, $num;\n        } else {\n            my $bin = sprintf(\"%b\", $num);\n\
    \            my $i = 0;\n            $i++ while($bin =~ /1/g);\n            push\
    \ @{$ones->[$i]}, $num;\n        }\n    }\n    foreach my $i (1..scalar(@$ones))\
    \ {\n        if ($ones->[$i]) {\n            @{$ones->[$i]} = sort {$a <=> $b}\
    \ @{$ones->[$i]};\n        }\n    }\n    @$arr = sort {$a <=> $b} @$notones;\n\
    \    foreach my $i (0..scalar(@$ones)) {\n        if ($ones->[$i]) {\n       \
    \     push @$arr, @{$ones->[$i]};\n        }\n    }\n    return $arr;\n}", " \
    \   my @sorted = sort { #{\n        my $x = sprintf('%b', $a);\n        my $y\
    \ = sprintf('%b', $b);\n        $x =~ tr/01/10/;\n        $y =~ tr/01/10/;\n \
    \       $x cmp $y;\n    } @$arr;\n    return \\@sorted;\n}", "    my @sorted =\
    \ sort {decimal_value($a) <=> decimal_value($b)} @$arr;\n    @sorted = sort {ones_binary($a)\
    \ <=> ones_binary($b)} @sorted;\n    return \\@sorted;\n}", "    my @ret = sort\
    \ {\n        int($a) <=> int($b) || count_ones($a) <=> count_ones($b)\n    } @$arr;\n\
    \    return \\@ret;\n}", "    my @sort_arr = sort {\n        $b =~ tr/1// <=>\
    \ $a =~ tr/1// or\n        $a <=> $b\n    }\n    map { dec_to_bin($_) } @$arr;\n\
    \    return [ map { bin_to_dec($_) } @sort_arr ];\n}", "    return [] if not $arr\
    \ or not @$arr;\n    my @list = map {\n        my $binary = sprintf('%b', $_);\n\
    \        $binary =~ s/0//g;\n        [length($binary), $_];\n    } @$arr;\n  \
    \  my @result = map { $_->[1] } sort {\n        $a->[0] <=> $b->[0] || $a->[1]\
    \ <=> $b->[1]\n    } @list;\n    return \\@result;\n}", "    my $len = @$arr;\n\
    \    for(my $i = 0; $i < $len - 1; $i++) {\n        for(my $j = $i + 1; $j < $len;\
    \ $j++) {\n            my $one_count_i = ones_count($$arr[$i]);\n            my\
    \ $one_count_j = ones_count($$arr[$j]);\n            if ($one_count_i > $one_count_j)\
    \ {\n                swap($arr, $i, $j);\n            }\n            elsif ($one_count_i\
    \ == $one_count_j) {\n                if ($$arr[$i] > $$arr[$j]) {\n         \
    \           swap($arr, $i, $j);\n                }\n            }\n        }\n\
    \    }\n    return $arr;\n}", "    return [sort {ones($a) <=> ones($b) || $a <=>\
    \ $b} @$arr];\n}", "    my @r = sort { $a <=> $b } map { $a % 2 } @$arr;\n   \
    \ return \\@r;\n}", "    my %hash;\n    my @sorted;\n    my @res;\n    foreach\
    \ my $num (@$arr) {\n        my $val = dec2bin($num);\n        $hash{$num} = $val;\n\
    \    }\n    @sorted = sort { $hash{$a} cmp $hash{$b} } keys %hash;\n    return\
    \ @sorted;\n}", "    my @rarr = @$arr;\n    @rarr = sort {\n        $a <=> $b\n\
    \        or (count_bits($a) <=> count_bits($b))\n    } @rarr;\n    return \\@rarr;\n\
    }", "    my @new_arr = map { to_dec($_) } @$arr;\n    my @sorted_arr = sort {\
    \ $a <=> $b } @new_arr;\n    my @final_arr = map { from_dec($_) } @sorted_arr;\n\
    \    return \\@final_arr;\n}", "    return [sort {\n        my $a_bin = sprintf(\"\
    %b\", $a);\n        my $b_bin = sprintf(\"%b\", $b);\n        $a_bin =~ s/0//g;\n\
    \        $b_bin =~ s/0//g;\n        return $a_bin <=> $b_bin || $a <=> $b;\n \
    \   } @$arr];\n}", "    my @ones = map { $_ =~ tr/1//; [$_, $_] } @$arr;\n   \
    \ my @zeros = map { [$_, $_] } grep { $_ =~ /0/ } @$arr;\n    return [ sort {\n\
    \        $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n    } @ones, @zeros ];\n}",
  "    return [\n        sort {\n            (\n                scalar reverse(\n\
    \                    sprintf \"%b\",\n                    $a\n               \
    \ ) =~ tr/1//c\n            ) <=> (\n                scalar reverse(\n       \
    \             sprintf \"%b\",\n                    $b\n                ) =~ tr/1//c\n\
    \            ) || $a <=> $b\n        } @$arr\n    ];\n}", "    return [ sort {\n\
    \        my $c = ($a + 1) & 1;\n        my $d = ($b + 1) & 1;\n        $c <=>\
    \ $d || $a <=> $b\n    } @$arr ];\n}", "    my %ones = map { $_ => count_ones($_)\
    \ } @$arr;\n    my @sorted = sort { $ones{$a} <=> $ones{$b} or $a <=> $b } @$arr;\n\
    \    return \\@sorted;\n}", "    my @non_neg = grep { $_ >= 0 } @$arr;\n    my\
    \ @neg = grep { $_ < 0 } @$arr;\n    my @bin_non_neg = map { count_bin_ones($_)\
    \ } @non_neg;\n    my @bin_neg = map { count_bin_ones($_) } @neg;\n    @non_neg\
    \ = @non_neg[ sort {\n        $bin_non_neg[$a] <=> $bin_non_neg[$b] || $non_neg[$a]\
    \ <=> $non_neg[$b]\n    } 0 .. $#non_neg ];\n    @neg = @neg[ sort {\n       \
    \ $bin_neg[$a] <=> $bin_neg[$b] || $neg[$a] <=> $neg[$b]\n    } 0 .. $#neg ];\n\
    \    @non_neg, @neg;\n}", "    my @binary_arr = map(dec2bin($_), @$arr);\n   \
    \ my @result = sort {$b->{ones} <=> $a->{ones} || $a->{dec} <=> $b->{dec}} map({ones\
    \ => scalar(($_ =~ s/1//g)), dec => $_}, @binary_arr);\n    return [map($_->{dec},\
    \ @result)];\n}", "    my @arr = @$arr;\n    if (@arr == 0) {\n        return\
    \ [];\n    }\n    my $sign = $arr[0] >= 0 ? 1 : -1;\n    my @sorted = sort {\n\
    \        my $ones_a = scalar(($a * $sign) =~ /1/g);\n        my $ones_b = scalar(($b\
    \ * $sign) =~ /1/g);\n        if ($ones_a < $ones_b) {\n            return -1;\n\
    \        }\n        elsif ($ones_a > $ones_b) {\n            return 1;\n     \
    \   }\n        else {\n            return $a <=> $b;\n        }\n    } @arr;\n\
    \    return \\@sorted;\n}", "    my $result = [\n        map { $_->[0] }\n   \
    \     sort { $a->[1] <=> $b->[1] }\n        map {\n            my @ones = /(1)/g;\n\
    \            [$_, scalar(@ones), $_]\n        } @$arr\n    ];\n    return $result;\n\
    }", "    my $size = scalar @$arr;\n    for my $i (0..$size-1) {\n        for my\
    \ $j ($i+1..$size-1) {\n            my $one_i = to_ones($arr->[$i]);\n       \
    \     my $one_j = to_ones($arr->[$j]);\n            if ($one_i == $one_j) {\n\
    \                if ($arr->[$i] > $arr->[$j]) {\n                    my $tmp =\
    \ $arr->[$i];\n                    $arr->[$i] = $arr->[$j];\n                \
    \    $arr->[$j] = $tmp;\n                }\n            }\n            else {\n\
    \                if ($one_i > $one_j) {\n                    my $tmp = $arr->[$i];\n\
    \                    $arr->[$i] = $arr->[$j];\n                    $arr->[$j]\
    \ = $tmp;\n                }\n            }\n        }\n    }\n    return $arr;\n\
    }", "    return $arr if scalar @$arr <= 1;\n    my $less = [grep {$_->[0] < $_->[1]}\
    \ @$arr];\n    my $equal = [grep {$_->[0] == $_->[1]} @$arr];\n    my $greater\
    \ = [grep {$_->[0] > $_->[1]} @$arr];\n    [\n        sort_array($less),\n   \
    \     sort_array($equal),\n        sort_array($greater)\n    ];\n}", "    my @result\
    \ = sort {\n        my $x = sprintf(\"%b\", $a);\n        my $y = sprintf(\"%b\"\
    , $b);\n        $x =~ tr/1//;\n        $y =~ tr/1//;\n        $x cmp $y || $a\
    \ <=> $b\n    } @$arr;\n    return \\@result;\n}", "    my @ret = sort {\n   \
    \     scalar(split(\"\", unpack(\"B*\", pack(\"N\", $a)))) <=> scalar(split(\"\
    \", unpack(\"B*\", pack(\"N\", $b))))\n        || $a <=> $b\n    } @$arr;\n  \
    \  return \\@ret;\n}", "    return [sort {\n        my $binary_a = sprintf(\"\
    %b\", $a);\n        my $binary_b = sprintf(\"%b\", $b);\n        my $number_of_ones_a\
    \ = $binary_a =~ tr/1//;\n        my $number_of_ones_b = $binary_b =~ tr/1//;\n\
    \        $number_of_ones_a <=> $number_of_ones_b || $a <=> $b\n    } @$arr];\n\
    }", "    return [sort { $a <=> $b } @$arr];\n}", "    my @ret;\n    foreach my\
    \ $i (sort {\n        $a <=> $b or\n        count_ones($a) <=> count_ones($b)\n\
    \    } @$arr) {\n        push @ret, $i;\n    }\n    return \\@ret;\n}", "    my\
    \ %count = map { $_ => scalar(tr/1//, sprintf \"%b\", $_) } @$arr;\n    [ sort\
    \ { $count{$a} cmp $count{$b} || $a <=> $b } @$arr ];\n}", "    my @sorted_binary_ones\
    \ = sort {\n        scalar(split(//, unpack(\"B*\", pack(\"N\", $a)))) <=> scalar(split(//,\
    \ unpack(\"B*\", pack(\"N\", $b)))) || $a <=> $b;\n    } @$arr;\n    return \\\
    @sorted_binary_ones;\n}", "    return sort {number_of_ones($a) <=> number_of_ones($b)\
    \ || $a <=> $b} @$arr;\n}", "    my @result = sort {get_ones($a) <=> get_ones($b)\n\
    \        || $a <=> $b} @$arr;\n    return \\@result;\n}", "    return [\n    \
    \    sort {\n            $b->binary_ones() <=> $a->binary_ones()\n           \
    \ || $a->int() <=> $b->int()\n        }\n        map { Math::BigInt->new($_) }\
    \ @$arr\n    ];\n}", "    my %hash = ();\n    my @sorted;\n    foreach(@$arr){\n\
    \        my $count = () = sprintf(\"%b\", $_) =~ /1/g;\n        $hash{$_} = $count;\n\
    \    }\n    @sorted = sort { $hash{$a} <=> $hash{$b} || $a <=> $b } keys %hash;\n\
    \    return \\@sorted;\n}", "    my $cmp = sub {\n        my($x, $y) = @_;\n \
    \       my $bitx = sprintf \"%b\", $x;\n        my $bity = sprintf \"%b\", $y;\n\
    \        my $nx = $bitx =~ tr/1//;\n        my $ny = $bity =~ tr/1//;\n      \
    \  if ($nx < $ny) {\n            return -1;\n        } elsif ($nx > $ny) {\n \
    \           return 1;\n        } else {\n            return $x <=> $y;\n     \
    \   }\n    };\n    return [sort $cmp @$arr];\n}", "    return [\n        sort\
    \ {\n            my $num_ones = sub {\n                my($i) = @_;\n        \
    \        my $count = 0;\n                my $decimal = $i;\n                while($decimal\
    \ > 0) {\n                    if($decimal % 2 == 1) {\n                      \
    \  $count++;\n                    }\n                    $decimal = int($decimal\
    \ / 2);\n                }\n                return $count;\n            };\n \
    \           $num_ones->($a) <=> $num_ones->($b)\n            ||\n            $a\
    \ <=> $b\n        } @$arr\n    ];\n}", "    my @sorted_arr = sort {$a <=> $b}\
    \ @$arr;\n    my @x = map { bin($_) =~ tr/1// } @sorted_arr;\n    my @y = map\
    \ { ($_, $x[$_]) } 0..$#x;\n    return [ sort { $a->[1] <=> $b->[1] || $a->[0]\
    \ <=> $b->[0] } @y ];\n}", "    my @result = sort {\n        my $left_ones = ()\
    \ = $a =~ /1/g;\n        my $right_ones = () = $b =~ /1/g;\n        $left_ones\
    \ != $right_ones ? $left_ones <=> $right_ones : $a <=> $b;\n    } @$arr;\n   \
    \ return \\@result;\n}", "    return $arr if !@$arr;\n    my $hash = {};\n   \
    \ my $count = 0;\n    my $max;\n    map {\n        my $count = _count_ones($_);\n\
    \        $hash->{$count}->{$_} = $_;\n        $max = $count if !defined $max ||\
    \ $count > $max;\n    } @$arr;\n    my @sorted = map {\n        map {\n      \
    \      $hash->{$_}->{$_}\n        } sort {\n            $a <=> $b\n        } keys\
    \ %{$hash->{$_}}\n    } (0..$max);\n    return \\@sorted;\n}", "    return []\
    \ if @$arr == 0;\n    my $lambda = sub {\n        my $x = shift;\n        my $u\
    \ = unpack('B*', pack('N', $x));\n        my $bin = $u =~ tr/1//;\n        my\
    \ $dec = $x;\n        return [$bin, $dec];\n    };\n    return [map { $_->[1]\
    \ } sort { $a->[0] <=> $b->[0] } map { $lambda->($_) } @$arr];\n}", "    $arr\
    \ = [sort {\n        ($a =~ tr/1//) <=> ($b =~ tr/1//)\n        || $a <=> $b\n\
    \    } @$arr];\n    return $arr;\n}", "    return\n        map { $_->[0] }\n \
    \       sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0] }\n        map { [$_,\
    \ unpack(\"%32b*\", pack(\"I\", $_))] }\n        @$arr;\n}", "    return [] if(!defined($arr)\
    \ || ref($arr) ne 'ARRAY');\n    return $arr if($#$arr == -1);\n    my $tmp_arr\
    \ = [];\n    foreach(@$arr) {\n        next if(!defined($_) || $_ !~ /^-?\\d+$/);\n\
    \        my $one_count = get_one_count($_);\n        push(@$tmp_arr, \"$one_count,$_\"\
    );\n    }\n    @$tmp_arr = sort {$a cmp $b} @$tmp_arr;\n    foreach(@$tmp_arr)\
    \ {\n        $_ =~ s/,.*//;\n    }\n    return $tmp_arr;\n}", "    my @arr = @$arr;\n\
    \    for my $num (@arr) {\n        $num = {dec => $num, bin => sprintf(\"%b\"\
    , $num)};\n    }\n    my @sorted = sort {\n        if (length($a->{bin}) != length($b->{bin}))\
    \ {\n            length($a->{bin}) <=> length($b->{bin});\n        } elsif ($a->{bin}\
    \ =~ tr/1// != $b->{bin} =~ tr/1//) {\n            $a->{bin} =~ tr/1// <=> $b->{bin}\
    \ =~ tr/1//;\n        } else {\n            $a->{dec} <=> $b->{dec};\n       \
    \ }\n    } @arr;\n    return [map { $_->{dec} } @sorted];\n}", "    my %bin_mapping\
    \ = ();\n    my @bin_keys = ();\n    foreach my $value (@$arr) {\n        my $binary\
    \ = sprintf \"%b\", $value;\n        my $count = $binary =~ tr/1//;\n        my\
    \ $mapping = \"$count-$value\";\n        if(!exists $bin_mapping{$mapping}) {\n\
    \            push @bin_keys, $mapping;\n        }\n        push @{$bin_mapping{$mapping}},\
    \ $value;\n    }\n    my @sorted_arr = map { $_->[0] } sort { $a->[1] cmp $b->[1]\
    \ }\n        map { [ join(\"\", @{$bin_mapping{$_}}), $_ ] } @bin_keys;\n    return\
    \ \\@sorted_arr;\n}", "    my @result = sort {$a <=> $b} @$arr;\n    return \\\
    @result;\n}", "    my %ones;\n    my %decimal;\n    my @result;\n    for my $n\
    \ (@$arr) {\n        my $bin = sprintf \"%b\", $n;\n        $ones{$n} = $bin =~\
    \ tr/1//;\n        $decimal{$n} = $n;\n    }\n    my @sorted = sort { $ones{$a}\
    \ <=> $ones{$b} || $decimal{$a} <=> $decimal{$b} } @$arr;\n    return \\@sorted;\n\
    }", "    my @sorted = sort {\n        my $x = sprintf(\"%b\", $a);\n        my\
    \ $y = sprintf(\"%b\", $b);\n        my $c = ($x =~ tr/1//);\n        my $d =\
    \ ($y =~ tr/1//);\n        if ($c == $d) {\n            return $a <=> $b;\n  \
    \      }\n        else {\n            return $c <=> $d;\n        }\n    } @$arr;\n\
    \    return \\@sorted;\n}", "    my @sorted = sort {\n        $a->{count} <=>\
    \ $b->{count}\n        ||\n        $a->{value} <=> $b->{value}\n    } map { {\
    \ value => $_, count => count_ones(dec_to_bin($_)) } } @$arr;\n    return [ map\
    \ { $_->{value} } @sorted ];\n}", "    my @sorted = map { $_->[0] }\n        \
    \         sort { $a->[1] <=> $b->[1] }\n                 map { [$_, scalar(split(\"\
    \", unpack(\"B*\", pack(\"L\", $_))))] }\n                 @$arr;\n    return\
    \ @sorted;\n}", "    if ($arr) {\n        my @sorted = sort {\n            $a\
    \ <=> $b\n                ||\n            unpack(\"%32b*\", $a) <=> unpack(\"\
    %32b*\", $b)\n        } @$arr;\n        return \\@sorted;\n    }\n    return;\n\
    }", "    return [sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }\n       \
    \   map { [ $_, unpack('%32b*', $_) ] } @$arr];\n}", "    my $ones_pattern = qr/(1+)/;\n\
    \    my @sorted = map { $_->[0] }\n        sort { $a->[1] <=> $b->[1] }\n    \
    \    map { [ $_, length($_) - length(s/$ones_pattern//g) ] }\n        @$arr;\n\
    \    return \\@sorted;\n}", "    my @new_arr = sort {\n        my $x = scalar\
    \ reverse unpack(\"B*\", pack(\"N\", abs($a)));\n        my $y = scalar reverse\
    \ unpack(\"B*\", pack(\"N\", abs($b)));\n        my $n = 0;\n        my $o = 0;\n\
    \        for (my $i = 0; $i < 32; $i++) {\n            $n += substr($x, $i, 1);\n\
    \            $o += substr($y, $i, 1);\n        }\n        $n <=> $o || $a <=>\
    \ $b;\n    } @$arr;\n    return \\@new_arr;\n}", "    return sort {count_ones($a)\
    \ <=> count_ones($b) || $a <=> $b} @$arr;\n}", "    my @sorted = map { $_->[0]\
    \ }\n                 sort { $a->[1] <=> $b->[1] }\n                 map { [$_,\
    \ $_=~ tr/1//] }\n                 @$arr;\n    return \\@sorted;\n}", "    return\
    \ [] if not @$arr;\n    return $arr if @$arr == 1;\n    my $ones = 0;\n    my\
    \ $zero = 0;\n    my @one_arr;\n    my @zero_arr;\n    for(my $i = 0; $i < @$arr;\
    \ $i++) {\n        if(count_ones($arr->[$i]) == 0) {\n            $zero_arr[$zero++]\
    \ = $arr->[$i];\n        } else {\n            $one_arr[$ones++] = $arr->[$i];\n\
    \        }\n    }\n    @one_arr = sort {count_ones($a) <=> count_ones($b) || $a\
    \ <=> $b} @one_arr;\n    return [@zero_arr, @one_arr];\n}", "    return [sort\
    \ {\n        my $b1 = unpack 'B*', pack 'N', $b;\n        my $a1 = unpack 'B*',\
    \ pack 'N', $a;\n        return $b1 cmp $a1 || $a <=> $b;\n    } @$arr];\n}",
  "    return [ sort {\n        my($a_ones) = () = split(//, unpack(\"B*\", pack(\"\
    n\", $a)));\n        my($b_ones) = () = split(//, unpack(\"B*\", pack(\"n\", $b)));\n\
    \        if ($a_ones == $b_ones) {\n            return $a <=> $b;\n        }\n\
    \        return $a_ones <=> $b_ones;\n    } @$arr ];\n}", "    my @sorted = map\
    \ { $_->[0] } sort { $a->[1] <=> $b->[1] }\n                            map {\
    \ [ $_, count_ones($_) ] } @$arr;\n    return \\@sorted;\n}", "    return [ sort\
    \ { $a<=>$b || to_binary($a) cmp to_binary($b) } @$arr ];\n}", "    return [sort\
    \ {\n        my $a_ones = scalar(@{[split(//, unpack(\"B*\", pack(\"i\", $a)))]});\n\
    \        my $b_ones = scalar(@{[split(//, unpack(\"B*\", pack(\"i\", $b)))]});\n\
    \        $a_ones == $b_ones ? $a <=> $b : $a_ones <=> $b_ones;\n    } @$arr];\n\
    }", "    return [] if not defined $arr or $#$arr < 0;\n    my @sorted = map {\
    \ $_->[0] }\n        sort {\n            my $a_1s = $_->[1];\n            my $b_1s\
    \ = $a->[1];\n            if ($a_1s < $b_1s) { return -1; }\n            if ($a_1s\
    \ > $b_1s) { return 1; }\n            if ($a->[0] < $b->[0]) { return -1; }\n\
    \            if ($a->[0] > $b->[0]) { return 1; }\n            return 0;\n   \
    \     }\n        map {\n            my $v = $_;\n            my $bin = sprintf(\"\
    %b\", $v);\n            my $ones = $bin =~ tr/1//;\n            [$v, $ones];\n\
    \        } @$arr;\n    return \\@sorted;\n}", "    return sort {\n        $a <=>\
    \ $b or\n        sprintf('%b', $a) =~ tr/1// <=> sprintf('%b', $b) =~ tr/1//\n\
    \    } @$arr;\n}", "    my @binarr = sort {$a =~ tr/1// <=> $b =~ tr/1// or $a\
    \ <=> $b} @$arr;\n    return \\@binarr;\n}", "    my %count;\n    foreach my $item\
    \ (@$arr) {\n        my $bin = sprintf(\"%b\", $item);\n        $count{$item}\
    \ = $bin =~ tr/1//;\n    }\n    my @sorted = sort { $count{$a} <=> $count{$b}\
    \ || $a <=> $b } @$arr;\n    return \\@sorted;\n}", "    my @arr = @$arr;\n  \
    \  my @a;\n    my @b;\n    my @c;\n    my $i;\n    my $j;\n    my $k;\n    my\
    \ $t;\n    my $l;\n    $l = 0;\n    for($i = 0; $i < @arr; $i++) {\n        $a[$i]\
    \ = [$arr[$i], sprintf(\"%b\", $arr[$i])];\n        $t = length($a[$i][1]);\n\
    \        if($t > $l) {\n            $l = $t;\n        }\n    }\n    for($i = 0;\
    \ $i < @arr; $i++) {\n        $t = $l - length($a[$i][1]);\n        for($j = 0;\
    \ $j < $t; $j++) {\n            $a[$i][1] = \"0\" . $a[$i][1];\n        }\n  \
    \  }\n    for($i = 0; $i < @arr; $i++) {\n        $b[$i] = [0, $i];\n        for($j\
    \ = 0; $j < $l; $j++) {\n            if(substr($a[$i][1], $j, 1) eq \"1\") {\n\
    \                $b[$i][0]++;\n            }\n        }\n    }\n    for($i = 0;\
    \ $i < @arr; $i++) {\n        $c[$i] = $i;\n    }\n    for($i = 0; $i < @arr;\
    \ $i++) {\n        for($j = $i; $j < @arr; $j++) {\n            if($b[$i][0] >\
    \ $b[$j][0]) {\n                $t = $b[$i][0];\n                $b[$i][0] = $b[$j][0];\n\
    \                $b[$j][0] = $t;\n                $t = $b[$i][1];\n          \
    \      $b[$i][1] = $b[$j][1];\n                $b[$j][1] = $t;\n           ",
  "    my @one_count;\n    my %sorted_array;\n    for( my $i = 0; $i < scalar @$arr;\
    \ $i++ ) {\n        my $count = (reverse(unpack(\"B*\", pack(\"N\", $arr->[$i]))))\
    \ =~ tr/1//;\n        push @one_count, $count;\n        push @{$sorted_array{$count}},\
    \ $arr->[$i];\n    }\n    return [map { sort { $a <=> $b } @{$sorted_array{$_}}\
    \ } sort { $a <=> $b } @one_count];\n}", "    my @sorted =\n      map { $_->[0]\
    \ }\n      sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0] }\n      map { [\
    \ $_, scalar(reverse(sprintf(\"%b\", $_)) =~ /1/g) ] } @$arr;\n    return @sorted;\n\
    }", "    return [] if @$arr == 0;\n    my @sorted = sort {\n        $a == $b\n\
    \            ? 0\n            : $a <=> $b\n    } map {\n        Math::BigInt->new(\
    \ $_ )->as_bin\n    } @$arr;\n    return $arr;\n}", "    my @a = @$arr;\n    my\
    \ @sorted_arr = ();\n    # find the max number of ones\n    my $max_ones = 0;\n\
    \    foreach my $num (@a) {\n        my $count = 0;\n        while ($num > 0)\
    \ {\n            $count += $num & 1;\n            $num >>= 1;\n        }\n   \
    \     $max_ones = $count if $count > $max_ones;\n    }\n    foreach my $i (0..$max_ones)\
    \ {\n        foreach my $num (@a) {\n            my $count = 0;\n            while\
    \ ($num > 0) {\n                $count += $num & 1;\n                $num >>=\
    \ 1;\n            }\n            if ($count == $i) {\n                push @sorted_arr,\
    \ $num;\n            }\n        }\n    }\n    return \\@sorted_arr;\n}", "   \
    \ return sort {\n        my $a_ones = ($a == 0) ? 0 : scalar(grep {$_ eq '1'}\
    \ split(//, $a));\n        my $b_ones = ($b == 0) ? 0 : scalar(grep {$_ eq '1'}\
    \ split(//, $b));\n        $a_ones <=> $b_ones || $a <=> $b\n    } @$arr;\n}",
  "    return [] if (! $arr);\n    my @copy = @$arr;\n    my @result = ();\n    while\
    \ (@copy) {\n        my $min = shift @copy;\n        my $loc = 0;\n        my\
    \ $i = 0;\n        for (@copy) {\n            $i++;\n            if (to_bin($_)\
    \ lt to_bin($min)) {\n                $min = $_;\n                $loc = $i;\n\
    \            }\n        }\n        splice @copy, $loc, 1;\n        push @result,\
    \ $min;\n    }\n    return \\@result;\n}", "    my @arr_sorted = sort { count_ones($a)\
    \ <=> count_ones($b) } @$arr;\n    return \\@arr_sorted;\n}", "    @$arr = sort\
    \ {\n        return $a <=> $b if count_ones($a) == count_ones($b);\n        return\
    \ count_ones($a) <=> count_ones($b);\n    } @$arr;\n    return $arr;\n}", "  \
    \  return [ sort { $a <=> $b || $a =~ tr/1// <=> $b =~ tr/1// } @$arr ];\n}",
  "    my @arr = @$arr;\n    my @sort_arr = sort {\n        return $a <=> $b if unpack(\"\
    %32b*\", $a) == unpack(\"%32b*\", $b);\n        return unpack(\"%32b*\", $a) <=>\
    \ unpack(\"%32b*\", $b);\n    } @arr;\n    return \\@sort_arr;\n}", "    return\
    \ sort {\n        my $ab = sprintf('%b', $a);\n        my $bb = sprintf('%b',\
    \ $b);\n        $ab =~ tr/1//;\n        $bb =~ tr/1//;\n        return (length($ab)\
    \ <=> length($bb)) || ($a <=> $b);\n    } @$arr;\n}", "    my @tmp = @$arr;\n\
    \    my @res = ();\n    foreach my $item (@tmp) {\n        my $count = 0;\n  \
    \      my $tmp_item = $item;\n        while($tmp_item > 0) {\n            $count++\
    \ if($tmp_item % 2 == 1);\n            $tmp_item /= 2;\n        }\n        push\
    \ @res, [$count, $item];\n    }\n    @res = sort { $a->[0] <=> $b->[0] || $a->[1]\
    \ <=> $b->[1] } @res;\n    @tmp = ();\n    foreach my $item (@res) {\n       \
    \ push @tmp, $item->[1];\n    }\n    return \\@tmp;\n}", "    my @sorted_array\
    \ = sort {decimal_value($a) <=> decimal_value($b)} sort {bin_ones($a) <=> bin_ones($b)}\
    \ @$arr;\n    return \\@sorted_array;\n}", "    my @sorted_arr = sort {\n    \
    \    my $cmp = num_ones($a) <=> num_ones($b);\n        if ($cmp == 0) {\n    \
    \        $a <=> $b;\n        } else {\n            $cmp;\n        }\n    } @$arr;\n\
    \    return \\@sorted_arr;\n}", "    return [] if @$arr == 0;\n    my $max = 0;\n\
    \    for my $x (@$arr) {\n        $max = max($max, $x);\n    }\n    my $n = 1;\n\
    \    while ($max >> $n) {\n        $n ++;\n    }\n    for my $i (0 .. $n - 1)\
    \ {\n        my @sorted = partition($arr, $i);\n        $arr = \\@sorted;\n  \
    \  }\n    return $arr;\n}", "    if(!defined($arr) || !@$arr) {\n        return\
    \ [];\n    }\n    my @sorted = map { $_->[0] }\n        sort { $a->[1] <=> $b->[1]\
    \ || $a->[0] <=> $b->[0] }\n        map {\n            my $bin = sprintf('%b',\
    \ $_);\n            [$_, $bin =~ tr/1//, $bin];\n        } @$arr;\n    return\
    \ \\@sorted;\n}", "    my %h = map {\n        my $v = $_;\n        $_ = scalar(reverse(split(\"\
    \", unpack(\"B32\", pack(\"N\", $_)))));\n        s/^0+//;\n        s/0/x/g;\n\
    \        s/1/0/g;\n        s/x/1/g;\n        $v => $_;\n    } @$arr;\n    return\
    \ [\n        map { $_->[0] }\n        sort {\n            my $c = $a->[1] cmp\
    \ $b->[1];\n            return $c if $c;\n            return $a->[0] <=> $b->[0];\n\
    \        }\n        map {\n            [ $_, $h{$_} ]\n        } @$arr\n    ];\n\
    }", "    my @arr_sorted = sort { (split //, sprintf '%b', $a)[0] <=> (split //,\
    \ sprintf '%b', $b)[0] } $arr;\n    for my $i (0 .. $#arr_sorted) {\n        if\
    \ ( (split //, sprintf '%b', $arr_sorted[$i])[0] != (split //, sprintf '%b', $arr_sorted[$i+1])[0]\
    \ ) {\n            last;\n        } else {\n            @arr_sorted = sort { $a\
    \ <=> $b } @arr_sorted[0..$i];\n        }\n    }\n    return @arr_sorted;\n}",
  "    map { $_->[0] } sort { $a->[1] <=> $b->[1] } map { [$_, ones($_)] } @$arr;\n\
    }", "    my @res = map { $_->[0] }\n        sort { $a->[1] <=> $b->[1] }\n   \
    \     map { [$_, scalar split(//, sprintf(\"%b\", $_))] } @$arr;\n    return \\\
    @res;\n}", "    my $arr_ref = $arr;\n    my @sorted_arr = map {$_->[0]} sort {$a->[1]\
    \ <=> $b->[1]} map {[$_, $_ > 0 ? scalar(unpack('%32b*', pack('I', $_))) : 1_000_000_000]}\
    \ @$arr_ref;\n    return \\@sorted_arr;\n}", "    my @temp;\n    foreach my $num\
    \ (@$arr) {\n        push @temp, [$num, sprintf(\"%b\", $num)];\n    }\n    @temp\
    \ = sort { $a->[1] cmp $b->[1] || $a->[0] <=> $b->[0] } @temp;\n    return [map\
    \ { $_->[0] } @temp];\n}", "    my @sorted = sort {\n        my $bin1 = sprintf(\"\
    %b\", $a);\n        my $bin2 = sprintf(\"%b\", $b);\n        $bin1 =~ tr/1//;\n\
    \        $bin2 =~ tr/1//;\n        $bin1 <=> $bin2 || $a <=> $b;\n    } @$arr;\n\
    \    return \\@sorted;\n}", "    my @sorted = sort {\n        my $x = $a;\n  \
    \      my $y = $b;\n        while ($x) {\n            $x &= $x - 1;\n        \
    \    $y &= $y - 1;\n        }\n        $x <=> $y;\n    } @$arr;\n    return @sorted;\n\
    }\nuse Test::More;\nis_deeply([sort_array([1, 5, 2, 3, 4])], [1, 2, 3, 4, 5]);\n\
    is_deeply([sort_array([-2, -3, -4, -5, -6])], [-6, -5, -4, -3, -2]);\nis_deeply([sort_array([1,\
    \ 0, 2, 3, 4])], [0, 1, 2, 3, 4]);\ndone_testing;", "    my $result = [\n    \
    \    map $_->[0],\n        sort {$a->[1] <=> $b->[1] || $a->[0] <=> $b->[0]}\n\
    \        map [(my $k = $_), count_ones($k)],\n        @$arr\n    ];\n    return\
    \ $result;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
