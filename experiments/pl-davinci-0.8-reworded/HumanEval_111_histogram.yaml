name: HumanEval_111_histogram
language: pl
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a hash\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> histogram(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n\
  # >>> histogram(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"a b\
  \ c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"b b b b a\")\n# {\"b\"\
  \ => 4}\n# >>> histogram(\"\")\n# {}\nsub histogram {\n    my($test) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&histogram;\n\
  \        if(eq_deeply($candidate->(\"a b b a\"),{\"a\" => 2, \"b\" => 2})) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  a b c a b\"),{\"a\" => 2, \"b\" => 2})) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c d g\"),{\"a\" =>\
  \ 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1})) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"r t g\"\
  ),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(\"b b b b a\"),{\"b\"\
  \ => 4})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  r t g\"),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),{})) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  a\"),{\"a\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  }\n\ntesthumaneval();"
completions: ["    my %hash = ();\n    my @test = split(' ', $test);\n    foreach\
    \ my $value (@test) {\n        if (exists $hash{$value}) {\n            $hash{$value}++;\n\
    \        } else {\n            $hash{$value} = 1;\n        }\n    }\n    return\
    \ %hash;\n}", "    my(%hash) = ();\n    my($h);\n    my($max) = 0;\n    my(@letters)\
    \ = split(' ', $test);\n    foreach my $letter (@letters) {\n        $hash{$letter}\
    \ += 1;\n        if ($hash{$letter} > $max) {\n            $max = $hash{$letter};\n\
    \        }\n    }\n    for $h (keys %hash) {\n        if ($hash{$h} != $max) {\n\
    \            delete $hash{$h};\n        }\n    }\n    return \\%hash;\n}", " \
    \   # Your code here.\n    my %hash;\n    foreach (split(\" \", $test)) {\n  \
    \      $hash{$_}++;\n    }\n    return %hash;\n}", "    my @letters = split(/\\\
    s+/, $test);\n    my %hash;\n    my $max_count = 0;\n    foreach my $letter (@letters)\
    \ {\n        $hash{$letter} += 1;\n        if ($hash{$letter} > $max_count) {\n\
    \            $max_count = $hash{$letter};\n        }\n    }\n    # Now determine\
    \ if there are multiple max values\n    my @max_letters;\n    while (my ($key,\
    \ $value) = each %hash) {\n        if ($value == $max_count) {\n            push\
    \ @max_letters, $key;\n        }\n    }\n    my %result;\n    for my $key (@max_letters)\
    \ {\n        $result{$key} = $max_count;\n    }\n    return %result;\n}", "  \
    \  my $result = {};\n    my $max    = 0;\n    foreach (split(/\\s+/, $test)) {\n\
    \        $result->{$_} = exists $result->{$_} ? $result->{$_} + 1 : 1;\n     \
    \   $max = $result->{$_} if $result->{$_} > $max;\n    }\n    my @to_delete =\
    \ grep {$result->{$_} != $max} keys %$result;\n    delete @{$result}{@to_delete};\n\
    \    return $result;\n}", "    my @letters = split(\" \", $test);\n    my %letter_count;\n\
    \    my %letter_max;\n    my @letter_max_keys;\n    my $max_value = 0;\n    for\
    \ my $letter (@letters) {\n        $letter_count{$letter} += 1;\n    }\n    for\
    \ my $key (keys %letter_count) {\n        if ($letter_count{$key} > $max_value)\
    \ {\n            $max_value = $letter_count{$key};\n            @letter_max_keys\
    \ = ($key);\n        } elsif ($letter_count{$key} == $max_value) {\n         \
    \   push(@letter_max_keys, $key);\n        }\n    }\n    for my $key (@letter_max_keys)\
    \ {\n        $letter_max{$key} = $max_value;\n    }\n    return %letter_max;\n\
    }", "    my @letters = split(/ /, $test);\n    my %result;\n    for my $i (0 ..\
    \ $#letters) {\n        $result{$letters[$i]} += 1;\n    }\n    my @highest =\
    \ sort { $result{$b} <=> $result{$a} } keys %result;\n    my $high = $result{$highest[0]};\n\
    \    my @k = grep { $result{$_} == $high } keys %result;\n    my %h;\n    @h{@k}\
    \ = @result{@k};\n    return %h;\n}", "    my $times;\n    my %histogram;\n  \
    \  if ($test =~ /^\\s*$/) {\n        return %histogram;\n    }\n    while ($test\
    \ =~ /(\\w+)/g) {\n        $times = () = $test =~ /$1/g;\n        $histogram{$1}\
    \ = $times;\n    }\n    return %histogram;\n}", "    my(%final);\n    my(@test_array)\
    \ = split(/ /, $test);\n    foreach my $var (@test_array) {\n        if (exists\
    \ $final{$var}) {\n            $final{$var} += 1;\n        } else {\n        \
    \    $final{$var} = 1;\n        }\n    }\n    return %final;\n}", "    my %h =\
    \ ();\n    my @temp = split(/\\s+/, $test);\n    foreach(@temp) {\n        if(exists\
    \ $h{$_}) {\n            $h{$_}++;\n        } else {\n            $h{$_} = 1;\n\
    \        }\n    }\n    return %h;\n}", "    my %ret;\n    my @words = split /\
    \ /, $test;\n    for my $word (@words) {\n        if (exists $ret{$word}) {\n\
    \            $ret{$word}++;\n        } else {\n            $ret{$word} = 1;\n\
    \        }\n    }\n    my $max = 0;\n    for my $key (keys %ret) {\n        if\
    \ ($ret{$key} > $max) {\n            $max = $ret{$key};\n        }\n    }\n  \
    \  my @max;\n    for my $key (keys %ret) {\n        if ($ret{$key} == $max) {\n\
    \            push @max, $key;\n        }\n    }\n    my %histo;\n    for my $key\
    \ (@max) {\n        $histo{$key} = $max;\n    }\n    return %histo;\n}", "   \
    \ my $result = {};\n    my @letters = split / /, $test;\n    for my $letter (@letters)\
    \ {\n        if (exists $result->{$letter}) {\n            $result->{$letter}\
    \ += 1;\n        } else {\n            $result->{$letter} = 1;\n        }\n  \
    \  }\n    my $occurence = 0;\n    my $result2 = {};\n    for my $key (keys %$result)\
    \ {\n        if ($result->{$key} >= $occurence) {\n            $occurence = $result->{$key};\n\
    \            $result2->{$key} = $occurence;\n        }\n    }\n    return $result2;\n\
    }", "    my @test = split(\" \", $test);\n    my %histogram;\n    my $maxKey =\
    \ 0;\n    my $maxVal = 0;\n    foreach my $t (@test) {\n        if (exists $histogram{$t})\
    \ {\n            $histogram{$t} += 1;\n        } else {\n            $histogram{$t}\
    \ = 1;\n        }\n        if ($histogram{$t} > $maxVal) {\n            $maxVal\
    \ = $histogram{$t};\n            $maxKey = $t;\n        }\n    }\n    foreach\
    \ my $key (keys %histogram) {\n        if ($histogram{$key} < $maxVal) {\n   \
    \         delete $histogram{$key};\n        }\n    }\n    return %histogram;\n\
    }", "    return {} if not $test;\n    my @a = split(/ /, $test);\n    my %h;\n\
    \    map {$h{$_}++} @a;\n    my $max = max(values %h);\n    my %result;\n    for\
    \ (keys %h) {\n        $result{$_} = $h{$_} if $h{$_} == $max;\n    }\n    return\
    \ \\%result;\n}", "    my %hash = ();\n    my $count = 0;\n    my @array = split(\"\
    \ \", $test);\n    foreach my $i (@array) {\n        if (exists $hash{$i}) {\n\
    \            $hash{$i} += 1;\n        } else {\n            $hash{$i} = 1;\n \
    \       }\n    }\n    return %hash;\n}", "    # Write your code here.\n    my\
    \ @array = split(' ', $test);\n    my $hash = {};\n    foreach my $letter (@array)\
    \ {\n        if (defined $hash->{$letter}) {\n            $hash->{$letter} +=\
    \ 1;\n        } else {\n            $hash->{$letter} = 1;\n        }\n    }\n\
    \    return $hash;\n}", "    my @AoA = map { [ split ] } split /\\n/, $test;\n\
    \    return @AoA;\n}", "    my @chars = split(/ /, $test);\n    my %hist;\n  \
    \  foreach my $char (@chars) {\n        if (exists $hist{$char}) {\n         \
    \   $hist{$char}++;\n        } else {\n            $hist{$char} = 1;\n       \
    \ }\n    }\n    return %hist;\n}", "    my $test_copy = $test;\n    $test_copy\
    \ =~ s/\\s+//g;", "    my $alpha = 0;\n    my $numb = 0;\n    my $other = 0;\n\
    \    my $answer = {};\n    my @array = split(\" \", $test);\n    my @answer =\
    \ [];\n    for my $i (0..@array-1) {\n        if ($array[$i] =~ m/[A-Za-z]/) {\n\
    \            $alpha++;\n        } elsif ($array[$i] =~ m/[0-9]/) {\n         \
    \   $numb++;\n        } else {\n            $other++;\n        }\n    }\n    $answer->{\"\
    alpha\"} = $alpha;\n    $answer->{\"numb\"} = $numb;\n    $answer->{\"other\"\
    } = $other;\n    return $answer;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
