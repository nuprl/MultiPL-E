name: HumanEval_145_order_by_points
language: pl
prompt: "# Write a function which sorts the given array of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ array.\n# For example:\n# >>> order_by_points([1, 11, -1, -11, -12])\n# [-1, -11,\
  \ 1, -12, 11]\n# >>> order_by_points([])\n# []\nsub order_by_points {\n    my($nums)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&order_by_points;\n\
  \        if(eq_deeply($candidate->([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0,\
  \ 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @res;\n    foreach my $i (sort { $b <=> $a } keys @$nums) {\n\
    \        push @res, $nums->[$i];\n    }\n    return @res;\n}", "    my $num_points\
    \ = {};\n    foreach my $index (0..$#$nums) {\n        my $point = sum_of_digits($nums->[$index]);\n\
    \        push @{$num_points->{$point}}, $index;\n    }\n    my @sorted_points\
    \ = sort {$a <=> $b} keys %$num_points;\n    my @sorted_nums = ();\n    foreach\
    \ my $point (@sorted_points) {\n        push @sorted_nums, @{$num_points->{$point}};\n\
    \    }\n    my @result = ();\n    foreach my $index (@sorted_nums) {\n       \
    \ push @result, $nums->[$index];\n    }\n    return \\@result;\n}", "    return\
    \ [] if !scalar @$nums;\n    return sort {\n        sum_digits($a) <=> sum_digits($b)\
    \ || $a <=> $b\n    } @$nums;\n}", "    my @result = ();\n    foreach my $num\
    \ (@$nums) {\n        my $sum = 0;\n        $sum += $_ for(split //, $num);\n\
    \        push @result, [$num, $sum];\n    }\n    @result = sort { $a->[1] <=>\
    \ $b->[1] || $a->[0] <=> $b->[0] } @result;\n    return [map { $_->[0] } @result];\n\
    }", "    my %sum;\n    my @sorted;\n    my $i = 0;\n    foreach my $num (@$nums)\
    \ {\n        my $j = $num;\n        my $sum = 0;\n        while ($j) {\n     \
    \       $sum += $j % 10;\n            $j = int($j / 10);\n        }\n        $sum{$sum}\
    \ = [] unless exists $sum{$sum};\n        push @{$sum{$sum}}, $i;\n        $i++;\n\
    \    }\n    foreach my $s (sort {$a <=> $b} keys %sum) {\n        foreach my $idx\
    \ (@{$sum{$s}}) {\n            push @sorted, $nums->[$idx];\n        }\n    }\n\
    \    return \\@sorted;\n}", "    my @new_nums = @$nums;\n    #Defines the sort\
    \ order\n    my $sub_to_sort = sub {\n        my ($a, $b) = @_;\n        #This\
    \ is the 'sum of digits' function.\n        my $sum_of_digits = sub {\n      \
    \      #Splits the number into an array of digits\n            my @digits = split(//,\
    \ $_[0]);\n            my $sum = 0;\n            for my $d (@digits) {\n     \
    \           $sum += $d;\n            }\n            return $sum;\n        };\n\
    \        #compares the sums\n        my $sum_a = $sum_of_digits->($a);\n     \
    \   my $sum_b = $sum_of_digits->($b);\n        if ($sum_a == $sum_b) {\n     \
    \       #if they are equal, order by the index in the original array\n       \
    \     return ($nums->[$a] <=> $nums->[$b]);\n        }\n        else {\n     \
    \       #if they are not equal, order by the sum\n            return ($sum_a <=>\
    \ $sum_b);\n        }\n    };\n    #creates an array of indices\n    my @indices\
    \ = 0..$#new_nums;\n    #sorts the array of indices\n    @indices = sort $sub_to_sort\
    \ @indices;\n    my @result = ();\n    #pushes the sorted array of indices into\
    \ the @result array\n    for my $i (@indices) {\n        push(@result, $new_nums[$i]);\n\
    \    }\n    return @result;\n}", "    my %h;\n    my $i = 0;\n    foreach my $n\
    \ (@$nums) {\n        my $s = 0;\n        for (my $n = abs($n); $n; $n /= 10)\
    \ {\n            $s += $n % 10;\n        }\n        $h{$s} ||= [];\n        push\
    \ @{$h{$s}}, $nums->[$i++];\n    }\n    my @res;\n    my @nums = sort { $a <=>\
    \ $b } keys %h;\n    foreach my $n (@nums) {\n        my @ss = sort { $a <=> $b\
    \ } @{$h{$n}};\n        foreach my $s (@ss) {\n            push @res, $s;\n  \
    \      }\n    }\n    return \\@res;\n}", "    @$nums = sort {sum_of_digits($a)\
    \ <=> sum_of_digits($b) || $a <=> $b} @$nums;\n    return $nums;\n}", "    my\
    \ @sorted = sort {\n            ($a =~ tr/0-9//) <=> ($b =~ tr/0-9//) ||\n   \
    \         $nums->[$a] <=> $nums->[$b]\n    } 0..$#$nums;\n    return [@{$nums}[@sorted]];\n\
    }", "    my $length = scalar @$nums;\n    for(my $i = 0; $i < $length; $i++) {\n\
    \        for(my $j = $i + 1; $j < $length; $j++) {\n            if($nums->[$i]\
    \ == $nums->[$j]) {\n                next;\n            }\n            my $n1\
    \ = $nums->[$i];\n            my $n2 = $nums->[$j];\n            my $sum1 = 0;\n\
    \            my $sum2 = 0;\n            while($n1) {\n                $sum1 +=\
    \ $n1 % 10;\n                $n1 /= 10;\n            }\n            while($n2)\
    \ {\n                $sum2 += $n2 % 10;\n                $n2 /= 10;\n        \
    \    }\n            if($sum1 == $sum2) {\n                if($i > $j) {\n    \
    \                $nums->[$i] = $nums->[$j];\n                    $nums->[$j] =\
    \ $n1;\n                }\n            }\n            if($sum1 > $sum2) {\n  \
    \              $nums->[$i] = $nums->[$j];\n                $nums->[$j] = $n1;\n\
    \            }\n        }\n    }\n    return $nums;\n}", "    my @new_nums = @$nums;\n\
    \    my @output;\n    #use selection sort\n    for(my $i = 0; $i < scalar @new_nums;\
    \ $i++){\n        my $min = $i;\n        for(my $j = $i + 1; $j < scalar @new_nums;\
    \ $j++){\n            my $sum1 = sum_digits($new_nums[$j]);\n            my $sum2\
    \ = sum_digits($new_nums[$min]);\n            if($sum1 < $sum2 || ($sum1 == $sum2\
    \ && $new_nums[$j] < $new_nums[$min])){\n                $min = $j;\n        \
    \    }\n        }\n        if($min != $i){\n            my $temp = $new_nums[$i];\n\
    \            $new_nums[$i] = $new_nums[$min];\n            $new_nums[$min] = $temp;\n\
    \        }\n    }\n    @output = @new_nums;\n    return @output;\n}", "    return\
    \ sort { sum_digits($a) <=> sum_digits($b) } @$nums;\n}", "    my %nums;\n   \
    \ foreach my $i (0..$#$nums) {\n        $nums{$i} = sum_digits($nums->[$i]);\n\
    \    }\n    my @sorted = map { $nums->[$_] } sort { $nums{$a} <=> $nums{$b} }\
    \ keys %nums;\n    return \\@sorted;\n}", "    return $nums if @$nums == 0;\n\
    \    my %sum;\n    for (my $i = 0; $i < @$nums; $i++) {\n        my $sum = 0;\n\
    \        for (split //, abs($nums->[$i])) {\n            $sum += $_;\n       \
    \ }\n        if (!defined $sum{$sum}) {\n            $sum{$sum} = [];\n      \
    \  }\n        push @{$sum{$sum}}, $nums->[$i];\n    }\n    my @nums;\n    foreach\
    \ my $sum (sort {$a <=> $b} keys %sum) {\n        push @nums, @{$sum{$sum}};\n\
    \    }\n    return \\@nums;\n}", "    my @output;\n    my %hash;\n    for(my $i\
    \ = 0; $i < scalar @$nums; $i++) {\n        $hash{$i} = 0;\n        my @digits\
    \ = split //, $nums->[$i];\n        for(my $j = 0; $j < scalar @digits; $j++)\
    \ {\n            $hash{$i} += $digits[$j];\n        }\n    }\n    foreach my $key\
    \ (sort {$hash{$a} <=> $hash{$b}} keys %hash) {\n        push @output, $nums->[$key];\n\
    \    }\n    return @output;\n}", "    my %map = ();\n    foreach my $num (@$nums)\
    \ {\n        my $digits_sum = 0;\n        while($num) {\n            $digits_sum\
    \ += $num % 10;\n            $num /= 10;\n        }\n        push @{$map{$digits_sum}},\
    \ $num;\n    }\n    my @sorted_keys = sort {$a <=> $b} keys %map;\n    my @sorted_nums\
    \ = ();\n    foreach my $key (@sorted_keys) {\n        push @sorted_nums, @{$map{$key}};\n\
    \    }\n    return \\@sorted_nums;\n}", "    return [] if !@$nums;\n    return\
    \ [sort { $a <=> $b } @$nums] if @$nums < 2;\n    my $result = [];\n    my $temp\
    \ = {};\n    my $i = 0;\n    while ($i < @$nums) {\n        my $num = $nums->[$i];\n\
    \        if (!exists $temp->{$num}) {\n            my $point = 0;\n          \
    \  my $n = $num;\n            if ($n < 0) {\n                $n = -$n;\n     \
    \       }\n            while ($n > 0) {\n                $point += $n % 10;\n\
    \                $n = int($n / 10);\n            }\n            $temp->{$num}\
    \ = $point;\n        }\n        $i++;\n    }\n    my @sort_keys = sort { $temp->{$a}\
    \ <=> $temp->{$b} || $a <=> $b } keys %$temp;\n    for my $k (@sort_keys) {\n\
    \        push @$result, $k;\n    }\n    return $result;\n}", "    my @sorted =\
    \ sort { to_num($a) <=> to_num($b) } @$nums;\n    return \\@sorted;\n}", "   \
    \ return sort {\n        (split '', $a) <=> (split '', $b)\n    } @$nums;\n}",
  "    my %hash;\n    my $idx = 0;\n    for my $num (@$nums) {\n        my $n = 0;\n\
    \        my $m = $num;\n        while ($m > 0) {\n            $n += $m % 10;\n\
    \            $m = int($m / 10);\n        }\n        $hash{$n} = [] unless defined\
    \ $hash{$n};\n        push @{$hash{$n}}, $idx;\n        $idx++;\n    }\n    my\
    \ @keys = sort {$a <=> $b} keys %hash;\n    my @res;\n    for my $key (@keys)\
    \ {\n        for my $idx (@{$hash{$key}}) {\n            push @res, $nums->[$idx];\n\
    \        }\n    }\n    return \\@res;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
