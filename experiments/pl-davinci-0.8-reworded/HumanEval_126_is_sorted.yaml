name: HumanEval_126_is_sorted
language: pl
prompt: "# Given an array of numbers, return whether or not they are sorted\n# in\
  \ ascending order. If array has more than 1 duplicate of the same\n# number, return\
  \ . Assume no negative numbers and only integers.\n# Examples\n# >>> is_sorted([5])\n\
  # 1\n# >>> is_sorted([1, 2, 3, 4, 5])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5])\n#\
  \ \"\"\n# >>> is_sorted([1, 2, 3, 4, 5, 6])\n# 1\n# >>> is_sorted([1, 2, 3, 4, 5,\
  \ 6, 7])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n# \"\"\n# >>> is_sorted([1,\
  \ 2, 2, 3, 3, 4])\n# 1\n# >>> is_sorted([1, 2, 2, 2, 3, 4])\n# \"\"\nsub is_sorted\
  \ {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_sorted;\n\
  \        if(eq_deeply($candidate->([5]),1)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 3, 2, 4, 5]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4, 5, 6, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, 7]),\"\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3,\
  \ 2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->([1, 2, 2, 2, 3, 4]),\"\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 3, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([1, 2, 2, 3, 3, 4]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    my($i);\n    for($i = 1; $i < @$lst; $i++) {\n        if($lst->[$i]\
    \ < $lst->[$i-1]) {\n            return \"\";\n        }\n    }\n    return 1;\n\
    }\n1;", "    my $prev = 0;\n    my $cur = 0;\n    my $is_sorted = 1;\n    for\
    \ $cur (@$lst) {\n        if ($cur < $prev) {\n            $is_sorted = 0;\n \
    \           last;\n        }\n        $prev = $cur;\n    }\n    return $is_sorted;\n\
    }", "    if(@$lst == 1) {\n        return 1;\n    } else {\n        for(my $i\
    \ = 0; $i < @$lst - 1; $i++) {\n            if($lst->[$i] > $lst->[$i + 1]) {\n\
    \                return \"\";\n            }\n        }\n        return 1;\n \
    \   }\n}", "    my($max) = $lst->[0];\n    for(my($i) = 1; $i < @$lst; $i++) {\n\
    \        if($lst->[$i] <= $max) {\n            return;\n        }\n        $max\
    \ = $lst->[$i];\n    }\n    return 1;\n}", "    my @lst = @$lst;\n    my $i;\n\
    \    for $i (1 .. $#lst) {\n        return if $lst[$i] < $lst[$i-1];\n    }\n\
    \    return 1;\n}", "    my $prev = undef;\n    my $result = 1;\n    for my $val\
    \ (@$lst) {\n        if (defined $prev && $val < $prev) {\n            $result\
    \ = \"\";\n            last;\n        }\n        $prev = $val;\n    }\n    return\
    \ $result;\n}", "    my $last = 0;\n    my $dups = 0;\n    foreach (@$lst) {\n\
    \        if ($_ < $last) {\n            return \"\";\n        }\n        elsif\
    \ ($_ == $last) {\n            $dups++;\n        }\n        $last = $_;\n    }\n\
    \    return $dups == 0 ? 1 : \"\";\n}", "    my $last = 0;\n    my $last_num =\
    \ 0;\n    my $dups = 0;\n    foreach my $num (@$lst) {\n        return unless\
    \ $num > $last;\n        $dups++ if $num == $last_num;\n        $last_num = $num;\n\
    \        $last = $num;\n    }\n    return unless $dups < 2;\n    return 1;\n}",
  "    # check if the input list is empty\n    if (@$lst == 0) {\n        return \"\
    \";\n    }\n    # check if the input list only has one element\n    if (@$lst\
    \ == 1) {\n        return 1;\n    }\n    # loop through the input list\n    for\
    \ (my $i = 0; $i < @$lst - 1; $i++) {\n        # case 1: if element at index $i\
    \ is smaller than element at index $i + 1, then check if there is any duplicate\
    \ of the element\n        if ($lst->[$i] < $lst->[$i + 1]) {\n            # loop\
    \ through the list again after the index\n            for (my $j = $i + 1; $j\
    \ < @$lst; $j++) {\n                # if there is any duplicate of the element\
    \ at index $i, then return \"\"\n                if ($lst->[$i] == $lst->[$j])\
    \ {\n                    return \"\";\n                }\n            }\n    \
    \    }\n        # case 2: if element at index $i is larger than element at index\
    \ $i + 1, then return \"\"\n        if ($lst->[$i] > $lst->[$i + 1]) {\n     \
    \       return \"\";\n        }\n    }\n    # if the input list satisfies both\
    \ conditions, then return 1\n    return 1;\n}", "    my $prev = undef;\n    my\
    \ $dupe = 0;\n    foreach my $curr (@$lst) {\n        if (defined $prev) {\n \
    \           return \"\" if $curr < $prev;\n            $dupe = 1 if $curr == $prev;\n\
    \        }\n        $prev = $curr;\n    }\n    return $dupe ? \"\" : 1;\n}", " \
    \   my @lst  = @$lst;\n    my $last = $lst[0];\n    for my $val (@lst) {\n   \
    \     return q{} if $val < $last;\n        $last = $val;\n    }\n    return 1;\n\
    }", "    my $rv = 1;\n    my $last = -1;\n    for my $i (@$lst) {\n        $rv\
    \ = '' if $i < $last;\n        $last = $i;\n    }\n    return $rv;\n}", "    my\
    \ $i = 0;\n    while ($i < scalar(@$lst)-1) {\n        if ($lst->[$i] >= $lst->[$i+1])\
    \ {\n            return '';\n        }\n        $i++;\n    }\n    return 1;\n}",
  "    my($prev) = pop(@$lst);\n    while (my $el = pop(@$lst)) {\n        if ($el\
    \ >= $prev) {\n            $prev = $el;\n        } else {\n            return\
    \ \"\";\n        }\n    }\n    return 1;\n}", "    for (my $i = 0; $i < @$lst\
    \ - 1; $i++) {\n        if ($lst->[$i] >= $lst->[$i + 1]) {\n            return\
    \ \"\";\n        }\n    }\n    return 1;\n}", "    for my $i (0 .. $#$lst - 1)\
    \ {\n        return \"\" if $lst->[$i] > $lst->[$i+1];\n    }\n    return 1;\n\
    }", "    my @lst = @$lst;\n    return 0 if @lst < 1;\n    my $prev = pop @lst;\n\
    \    while(@lst) {\n        my $curr = pop @lst;\n        return '' if $curr >\
    \ $prev;\n        $prev = $curr;\n    }\n    return 1;\n}", "    for my $i (1..$#$lst)\
    \ {\n        if ($lst->[$i] < $lst->[$i-1]) {\n            return \"\";\n    \
    \    }\n    }\n    return 1;\n}", "    my $l_ind = @$lst - 1;\n    my $sorted\
    \ = 1;\n    for (my $i = 0; $i < $l_ind; $i++) {\n        if ($lst->[$i] > $lst->[$i\
    \ + 1]) {\n            $sorted = 0;\n            last;\n        }\n    }\n   \
    \ return $sorted;\n}", "    my $sorted = 1;\n    for (my $i = 0; $i < @$lst -\
    \ 1; $i++) {\n        if ($lst->[$i] >= $lst->[$i + 1]) {\n            $sorted\
    \ = 0;\n            last;\n        }\n    }\n    return $sorted;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
