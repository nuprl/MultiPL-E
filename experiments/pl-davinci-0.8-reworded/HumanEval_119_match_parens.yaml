name: HumanEval_119_match_parens
language: pl
prompt: "# You are given an array of two strings, both strings consist of open\n#\
  \ parentheses '(' or close parentheses ')' only.\n# Your job is to check if it is\
  \ possible to concatenate the two strings in\n# some order, that the resulting string\
  \ will be good.\n# A string S is considered to be good if and only if all parentheses\
  \ in S\n# are balanced. For example: the string '(())()' is good, while the string\n\
  # '())' is not.\n# Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n# Examples:\n# >>> match_parens([\"()(\", \")\"])\n# \"Yes\"\n\
  # >>> match_parens([\")\", \")\"])\n# \"No\"\nsub match_parens {\n    my($lst) =\
  \ @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&match_parens;\n\
  \        if(eq_deeply($candidate->([\"()(\", \")\"]),\"Yes\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )\", \")\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([\"(()(())\", \"())())\"]),\"No\")) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )())\", \"(()()(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\"(())))\", \"(()())((\"]),\"Yes\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  ()\", \"())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([\"(()(\", \"()))()\"]),\"Yes\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  ((((\", \"((())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\")(()\", \"(()(\"]),\"No\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )(\", \")(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([\"(\", \")\"]),\"Yes\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )\", \"(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n}\n\ntesthumaneval();"
completions: ["    my $str = join(\"\", @$lst);\n    my $count = 0;\n    for my $ch\
    \ (split(\"\", $str)) {\n        if ($ch eq '(') {\n            $count++;\n  \
    \      } elsif ($ch eq ')') {\n            $count--;\n        }\n        return\
    \ \"No\" if $count < 0;\n    }\n    return \"Yes\";\n}", "    my($s, $t) = @$lst;\n\
    \    my($s1, $s2) = split /\\(/, $s;\n    my($t1, $t2) = split /\\)/, $t;\n  \
    \  return $s2 eq $t1 ? \"Yes\" : \"No\";\n}", "    my($l, $r) = @$lst;\n    return\
    \ 'Yes' if is_good($l) and is_good($r);\n    return 'Yes' if is_good($l . $r);\n\
    \    return 'Yes' if is_good($r . $l);\n    return 'No';\n}", '    my @p = ("\0",
    @$lst);', "    my $str1 = @$lst[0];\n    my $str2 = @$lst[1];\n    my @chars1\
    \ = split('', $str1);\n    my @chars2 = split('', $str2);\n    my $good1 = 0;\n\
    \    my $good2 = 0;\n    for (my $i = 0; $i < scalar(@chars1); $i++) {\n     \
    \   if ($chars1[$i] eq '(') {\n            $good1++;\n        } else {\n     \
    \       $good1--;\n        }\n        if ($good1 < 0) {\n            return \"\
    No\";\n        }\n    }\n    for (my $i = 0; $i < scalar(@chars2); $i++) {\n \
    \       if ($chars2[$i] eq '(') {\n            $good2++;\n        } else {\n \
    \           $good2--;\n        }\n        if ($good2 < 0) {\n            return\
    \ \"No\";\n        }\n    }\n    if ($good1 + $good2 == 0) {\n        return \"\
    Yes\";\n    } else {\n        return \"No\";\n    }\n}", "    return 'Yes' if\
    \ !$lst->[0] && !$lst->[1];\n    return 'No' if $lst->[0] eq ')' || $lst->[1]\
    \ eq '(';\n    my $ret = 'No';\n    if ($lst->[0]) {\n        my $str1 = substr($lst->[0],\
    \ 1);\n        my $str2 = $lst->[1];\n        $ret = match_parens([$str1, $str2])\
    \ if $lst->[0] eq '(';\n        $ret = match_parens([$str1, $str2]) if $lst->[0]\
    \ eq ')';\n    }\n    if ($lst->[1]) {\n        my $str1 = $lst->[0];\n      \
    \  my $str2 = substr($lst->[1], 1);\n        $ret = match_parens([$str1, $str2])\
    \ if $lst->[1] eq '(';\n        $ret = match_parens([$str1, $str2]) if $lst->[1]\
    \ eq ')';\n    }\n    return $ret;\n}", "    if(scalar(@$lst) != 2) {\n      \
    \  return undef;\n    }\n    my($s1, $s2) = @$lst;\n    my($cnt, $op, $cl);\n\
    \    foreach my $s ($s1, $s2) {\n        $cnt = 0;\n        $op = 0;\n       \
    \ $cl = 0;\n        foreach my $c (split(\"\", $s)) {\n            if($c eq \"\
    (\") {\n                $cnt++;\n                $op++;\n            } elsif($c\
    \ eq \")\") {\n                $cnt--;\n                $cl++;\n            }\n\
    \            if($cnt < 0) {\n                return \"No\";\n            }\n \
    \       }\n        if($cnt != 0) {\n            return \"No\";\n        }\n  \
    \  }\n    if($op == $cl) {\n        return \"Yes\";\n    } else {\n        return\
    \ \"No\";\n    }\n}", "    my($s1, $s2) = @$lst;\n    return \"Yes\" if ($s1 eq\
    \ \"\" && $s2 eq \"\");\n    return \"No\" if (substr($s1, 0, 1) eq \")\" && substr($s2,\
    \ 0, 1) eq \")\");\n    return \"Yes\" if (substr($s1, 0, 1) eq \")\" &&\n   \
    \                  match_parens([substr($s1, 1), substr($s2, 1)]) eq \"Yes\");\n\
    \    return \"Yes\" if (substr($s2, 0, 1) eq \")\" &&\n                     match_parens([substr($s1,\
    \ 1), substr($s2, 1)]) eq \"Yes\");\n    my($s) = $s1 . $s2;\n    my($open) =\
    \ 0;\n    my($i);\n    for ($i = 0; $i < length($s); $i++) {\n        $open +=\
    \ 1 if (substr($s, $i, 1) eq \"(\");\n        $open -= 1 if (substr($s, $i, 1)\
    \ eq \")\");\n        return \"No\" if ($open < 0);\n    }\n    return \"Yes\"\
    ;\n}", "    my $l = shift @$lst;\n    while (@$lst) {\n        my $r = shift @$lst;\n\
    \        if ($l eq ')' && $r eq '(') {\n            return \"No\";\n        }\n\
    \        if ($l eq '(' && $r eq ')') {\n            return \"Yes\";\n        }\n\
    \        $l = $r;\n    }\n    return \"No\";\n}", "    my($s, $t) = @$lst;\n \
    \   my($num_open, $num_close) = (0, 0);\n    for my $c (split(//, $s)) {\n   \
    \     if ($c eq '(') {\n            $num_open += 1;\n        } else {\n      \
    \      $num_close += 1;\n        }\n    }\n    for my $c (split(//, $t)) {\n \
    \       if ($c eq '(') {\n            $num_open += 1;\n        } else {\n    \
    \        $num_close += 1;\n        }\n    }\n    return $num_open == $num_close\
    \ ? 'Yes' : 'No';\n}", "    my($first, $second) = @$lst;\n    my($count) = 0;\n\
    \    for (split '', $first) {\n        $count++ if $_ eq '(';\n        $count--\
    \ if $_ eq ')';\n        return 'No' if $count < 0;\n    }\n    for (split '',\
    \ $second) {\n        $count++ if $_ eq '(';\n        $count-- if $_ eq ')';\n\
    \        return 'No' if $count < 0;\n    }\n    return 'Yes' if $count == 0;\n\
    \    return 'No';\n}", "    my $s = join('', @$lst);\n    my @s = split //, $s;\n\
    \    my $good = 1;\n    my $cnt = 0;\n    for my $c (@s) {\n        if ($c eq\
    \ '(') {\n            $cnt += 1;\n        } elsif ($c eq ')') {\n            $cnt\
    \ -= 1;\n        }\n        if ($cnt < 0) {\n            $good = 0;\n        \
    \    last;\n        }\n    }\n    return 'Yes' if $good && $cnt == 0;\n    return\
    \ 'No';\n}", "    my($res, $cnt) = @$lst;\n    return 'No' if $cnt < 0;\n    if\
    \ ($res eq '') {\n        return $cnt == 0 ? 'Yes' : 'No';\n    }\n    my $x =\
    \ chop $res;\n    my $res1 = match_parens([$res, $cnt + ($x eq '(' ? 1 : -1)]);\n\
    \    my $res2 = match_parens([$res, $cnt + ($x eq ')' ? 1 : -1)]);\n    return\
    \ $res1 eq 'Yes' || $res2 eq 'Yes' ? 'Yes' : 'No';\n}", "    my($str1, $str2)\
    \ = @$lst;\n    my($str1_closes, $str2_closes, $str1_opens, $str2_opens) = (0,\
    \ 0, 0, 0);\n    $str1_closes += length( $str1 =~ s/\\)//g);\n    $str2_closes\
    \ += length( $str2 =~ s/\\)//g);\n    $str1_opens += length( $str1 =~ s/\\(//g);\n\
    \    $str2_opens += length( $str2 =~ s/\\(//g);\n    if ($str1_closes == $str2_opens\
    \ && $str2_closes == $str1_opens) {\n        return \"Yes\";\n    } else {\n \
    \       return \"No\";\n    }\n}", "    my($left, $right) = @$lst;\n    my($n,\
    \ $m) = (0, 0);\n    for (split '', $left) {\n        if ($_ eq '(') {\n     \
    \       $n++;\n        } else {\n            $n--;\n        }\n        if ($n\
    \ < 0) {\n            return 'No';\n        }\n    }\n    for (split '', $right)\
    \ {\n        if ($_ eq '(') {\n            $m++;\n        } else {\n         \
    \   $m--;\n        }\n        if ($m < 0) {\n            return 'No';\n      \
    \  }\n    }\n    if ($n == $m) {\n        return 'Yes';\n    } else {\n      \
    \  return 'No';\n    }\n}", "    my($a, $b) = @$lst;\n    $a =~ /\\)\\)*/;\n \
    \   my $extra_open = length($&);\n    $b =~ /\\(\\(*/;\n    my $extra_close =\
    \ length($&);\n    if (substr($a, -$extra_open) eq ')' x $extra_open and\n   \
    \     substr($b, 0, $extra_close) eq '(' x $extra_close) {\n        'Yes';\n \
    \   } else {\n        'No';\n    }\n}", "    my $str1 = $lst->[0];\n    my $str2\
    \ = $lst->[1];\n    my $str3 = $str1.$str2;\n    my $str4 = $str2.$str1;\n   \
    \ if (is_good($str3) || is_good($str4)) {\n        return \"Yes\";\n    } else\
    \ {\n        return \"No\";\n    }\n}", "    my @lst = @$lst;\n    my $lparen\
    \ = 0;\n    my $rparen = 0;\n    for (@lst) {\n        $lparen += $_ =~ tr/\\\
    (//;\n        $rparen += $_ =~ tr/\\)//;\n    }\n    if ($lparen == $rparen) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", " \
    \   my($s1, $s2) = @$lst;\n    my $good = 0;\n    my $incomplete = 0;\n    my\
    \ $i;\n    for $i (0 .. length($s1) - 1) {\n        $incomplete += $s1 =~ /\\\
    (/g;\n        $incomplete -= $s1 =~ /\\)/g;\n        if ($incomplete < 0) {\n\
    \            last;\n        }\n        if ($incomplete == 0) {\n            $good\
    \ = 1;\n            last;\n        }\n    }\n    if ($incomplete == 0) {\n   \
    \     return \"Yes\";\n    }\n    if ($good == 0) {\n        return \"No\";\n\
    \    }\n    for $i (0 .. length($s2) - 1) {\n        $incomplete += $s2 =~ /\\\
    (/g;\n        $incomplete -= $s2 =~ /\\)/g;\n        if ($incomplete == 0) {\n\
    \            return \"Yes\";\n        }\n        if ($incomplete < 0) {\n    \
    \        return \"No\";\n        }\n    }\n    return \"No\";\n}", "    my @lst\
    \ = @$lst;\n    my $lhs = shift @lst;\n    my $rhs = shift @lst;\n    my @lhs\
    \ = split //, $lhs;\n    my @rhs = split //, $rhs;\n    my $open = 0;\n    my\
    \ $close = 0;\n    for (@lhs) {\n        if ($_ eq '(') {\n            $open++;\n\
    \        }\n        else {\n            $close++;\n        }\n    }\n    for (@rhs)\
    \ {\n        if ($_ eq '(') {\n            $open++;\n        }\n        else {\n\
    \            $close++;\n        }\n    }\n    return 'No' if $open != $close;\n\
    \    my $l_open = 0;\n    my $l_close = 0;\n    for (@lhs) {\n        if ($_ eq\
    \ '(') {\n            $l_open++;\n        }\n        else {\n            $l_close++;\n\
    \        }\n        if ($l_close > $l_open) {\n            return 'No';\n    \
    \    }\n    }\n    my $r_open = 0;\n    my $r_close = 0;\n    for (@rhs) {\n \
    \       if ($_ eq '(') {\n            $r_open++;\n        }\n        else {\n\
    \            $r_close++;\n        }\n        if ($r_close > $r_open) {\n     \
    \       return 'No';\n        }\n    }\n    return 'Yes';\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
