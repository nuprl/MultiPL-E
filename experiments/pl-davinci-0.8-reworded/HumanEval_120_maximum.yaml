name: HumanEval_120_maximum
language: pl
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# >>>\
  \ maximum([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum([4, -4, 4],\
  \ 2)\n# [4, 4]\n# Example 3:\n# >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n\
  # Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The\
  \ elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\n\
  sub maximum {\n    my($arr, $k) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&maximum;\n\
  \        if(eq_deeply($candidate->([-3, -4, 5], 3),[-4, -3, 5])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ -4, 4], 2),[4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([-3, 2, 1, 2, -1, -2, 1], 1),[2])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([123,\
  \ -123, 20, 0, 1, 2, -3], 3),[2, 20, 123])) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([-123, 20, 0, 1, 2,\
  \ -3], 4),[0, 1, 2, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8,\
  \ 0, 0, 3, 5, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([-1, 0, 2, 5, 3, -10], 2),[3, 5])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 0, 5, -7], 1),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([4, -4], 2),[-4, 4])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10,\
  \ 10], 2),[-10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1, 2, 3, -23, 243, -400, 0], 0),[])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @subset = ();\n    my @result = ();\n    my $num = 0;\n    #print\
    \ \"array: @$arr\";\n    #print \"k: $k\";\n    while ($num < $k) {\n        my\
    \ $max = -1001;\n        my $index = 0;\n        my $count = 0;\n        for my\
    \ $x (@$arr) {\n            if ($x > $max) {\n                $max = $x;\n   \
    \             $index = $count;\n            }\n            $count++;\n       \
    \ }\n        push(@subset, $max);\n        splice(@$arr, $index, 1);\n       \
    \ $num++;\n    }\n    #print \"@subset\";\n    my @sorted = sort {$a <=> $b} @subset;\n\
    \    for my $x (@sorted) {\n        push(@result, $x);\n    }\n    #print \"result:\
    \ @result\";\n    return @result;\n}", "    my $n = @$arr;\n    my $idx = 0;\n\
    \    $k <= $n or return [];\n    my $r = partition($arr, 0, $n - 1);\n    while\
    \ ($r != $k - 1) {\n        $r > $k - 1 and $r = partition($arr, 0, $r - 1);\n\
    \        $r < $k - 1 and $r = partition($arr, $r + 1, $n - 1);\n    }\n    return\
    \ [@$arr[0..$r]];\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "   \
    \ my @arr = @$arr;\n    my @out;\n    for my $j (0..$k-1) {\n        my $max =\
    \ $arr[0];\n        my $maxi = 0;\n        for my $i (1..$#arr) {\n          \
    \  if ($arr[$i] > $max) {\n                $max = $arr[$i];\n                $maxi\
    \ = $i;\n            }\n        }\n        $out[$j] = $max;\n        splice @arr,\
    \ $maxi, 1;\n    }\n    return @out;\n}", "    my @heap = reverse sort {$a <=>\
    \ $b} @$arr;\n    return [reverse @heap[0..$k-1]];\n}", "    if ($k >= @$arr)\
    \ {\n        @$arr = sort {$b <=> $a} @$arr;\n    } else {\n        my $n = scalar\
    \ @$arr;\n        my $m = $n - $k;\n        for my $i (0..$m-1) {\n          \
    \  for my $j ($i+1..$n-1) {\n                if ($arr->[$i] < $arr->[$j]) {\n\
    \                    @$arr[$i, $j] = @$arr[$j, $i];\n                }\n     \
    \       }\n        }\n        @$arr = splice @$arr, $m;\n    }\n    return $arr;\n\
    }", "    # use Heap:Min\n    my $minheap = Heap::Min->new();\n    foreach my $el\
    \ (@$arr) {\n        if ($minheap->count() < $k) {\n            $minheap->add($el);\n\
    \        } else {\n            my $min = $minheap->top();\n            if ($el\
    \ > $min) {\n                $minheap->delete_top();\n                $minheap->add($el);\n\
    \            }\n        }\n    }\n    my @list = ();\n    while ($minheap->count()\
    \ > 0) {\n        push @list, $minheap->top();\n        $minheap->delete_top();\n\
    \    }\n    return reverse @list;\n}", "    my $i = @$arr - $k;\n    my @ret =\
    \ splice(@$arr, $i);\n    @ret = sort {$a <=> $b} @ret;\n    return @ret;\n}",
  "    my @sorted = sort {$b <=> $a} @$arr;\n    return [@sorted[0..$k-1]];\n}", " \
    \   my @arr = @$arr;\n    return sort {$b <=> $a} @arr[0..$k-1];\n}", "    my\
    \ @sorted = sort {$b <=> $a} @$arr;\n    return @sorted[0..$k-1];\n}", "    my\
    \ @max;\n    push @max, shift @$arr while @max < $k;\n    while(@$arr){\n    \
    \    if ($arr->[0] > $max[-1]){\n            push @max, shift @$arr;\n       \
    \     pop @max;\n        } else {\n            shift @$arr;\n        }\n    }\n\
    \    return @max;\n}", "    my $len = scalar @$arr;\n    if($k >= $len) {\n  \
    \      return [sort {$b <=> $a} @$arr];\n    }\n    my $min_heap = Heap::Binary->new;\n\
    \    for(my $i = 0; $i < $k; $i++) {\n        $min_heap->add($arr->[$i]);\n  \
    \  }\n    for(my $i = $k; $i < $len; $i++) {\n        my $top = $min_heap->extract_top;\n\
    \        if($arr->[$i] > $top) {\n            $min_heap->add($arr->[$i]);\n  \
    \      } else {\n            $min_heap->add($top);\n        }\n    }\n    my @result;\n\
    \    while($min_heap->size > 0) {\n        push @result, $min_heap->extract_top;\n\
    \    }\n    return [reverse @result];\n}", "    my @sorted = sort {$b <=> $a}\
    \ @$arr;\n    return [@sorted[0..$k-1]];\n}", "    my @arr = sort {$b <=> $a}\
    \ @$arr;\n    my @res = splice(@arr, 0, $k);\n    return @res;\n}", "    my @sorted_array\
    \ = sort {$b <=> $a} @$arr;\n    return [ @sorted_array[0..$k-1] ];\n}", "   \
    \ return unless $k;\n    return @$arr[0..$k-1] if scalar @$arr == $k;\n    my\
    \ @maxheap = sort {$b <=> $a} @$arr[0..$k-1];\n    foreach my $idx ($k..$#$arr)\
    \ {\n        if ($arr->[$idx] > $maxheap[0]) {\n            shift @maxheap;\n\
    \            my $i = 0;\n            for ($i=0; $i<=$#maxheap; $i++) {\n     \
    \           last if $arr->[$idx] < $maxheap[$i];\n            }\n            splice\
    \ @maxheap, $i, 0, $arr->[$idx];\n        }\n    }\n    return @maxheap;\n}",
  "    return max_k($arr, $k, 0, @$arr - 1);\n}", "    my @pq = sort {$b <=> $a} @$arr[0..$k-1];\n\
    \    for my $i ($k..$#$arr) {\n        if ($arr->[$i] > $pq[-1]) {\n         \
    \   shift @pq;\n            push @pq, $arr->[$i];\n            my $j = $#pq;\n\
    \            while ($j > 0 and $pq[$j] > $pq[$j-1]) {\n                ($pq[$j],\
    \ $pq[$j-1]) = ($pq[$j-1], $pq[$j]);\n                $j--;\n            }\n \
    \       }\n    }\n    return \\@pq;\n}", "    my @r;\n    my %m;\n    for my $n\
    \ (@$arr) {\n        if (keys %m < $k) {\n            $m{$n}++;\n        }\n \
    \       else {\n            my $v = (sort {$b <=> $a} keys %m)[0];\n         \
    \   if ($n > $v) {\n                delete $m{$v};\n                $m{$n}++;\n\
    \            }\n        }\n    }\n    for my $k (keys %m) {\n        push @r,\
    \ $k for 1..$m{$k};\n    }\n    return \\@r;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
