name: HumanEval_120_maximum
language: pl
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# >>>\
  \ maximum([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum([4, -4, 4],\
  \ 2)\n# [4, 4]\n# Example 3:\n# >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n\
  # Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The\
  \ elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\n\
  sub maximum {\n    my($arr, $k) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&maximum;\n\
  \        if(eq_deeply($candidate->([-3, -4, 5], 3),[-4, -3, 5])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ -4, 4], 2),[4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([-3, 2, 1, 2, -1, -2, 1], 1),[2])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([123,\
  \ -123, 20, 0, 1, 2, -3], 3),[2, 20, 123])) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([-123, 20, 0, 1, 2,\
  \ -3], 4),[0, 1, 2, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8,\
  \ 0, 0, 3, 5, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([-1, 0, 2, 5, 3, -10], 2),[3, 5])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 0, 5, -7], 1),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([4, -4], 2),[-4, 4])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10,\
  \ 10], 2),[-10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1, 2, 3, -23, 243, -400, 0], 0),[])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @subset = ();\n    my @result = ();\n    my $num = 0;\n    #print\
    \ \"array: @$arr\";\n    #print \"k: $k\";\n    while ($num < $k) {\n        my\
    \ $max = -1001;\n        my $index = 0;\n        my $count = 0;\n        for my\
    \ $x (@$arr) {\n            if ($x > $max) {\n                $max = $x;\n   \
    \             $index = $count;\n            }\n            $count++;\n       \
    \ }\n        push(@subset, $max);\n        splice(@$arr, $index, 1);\n       \
    \ $num++;\n    }\n    #print \"@subset\";\n    my @sorted = sort {$a <=> $b} @subset;\n\
    \    for my $x (@sorted) {\n        push(@result, $x);\n    }\n    #print \"result:\
    \ @result\";\n    return @result;\n}", "    my $n = @$arr;\n    my $idx = 0;\n\
    \    $k <= $n or return [];\n    my $r = partition($arr, 0, $n - 1);\n    while\
    \ ($r != $k - 1) {\n        $r > $k - 1 and $r = partition($arr, 0, $r - 1);\n\
    \        $r < $k - 1 and $r = partition($arr, $r + 1, $n - 1);\n    }\n    return\
    \ [@$arr[0..$r]];\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "   \
    \ my @arr = @$arr;\n    my @out;\n    for my $j (0..$k-1) {\n        my $max =\
    \ $arr[0];\n        my $maxi = 0;\n        for my $i (1..$#arr) {\n          \
    \  if ($arr[$i] > $max) {\n                $max = $arr[$i];\n                $maxi\
    \ = $i;\n            }\n        }\n        $out[$j] = $max;\n        splice @arr,\
    \ $maxi, 1;\n    }\n    return @out;\n}", "    my @heap = reverse sort {$a <=>\
    \ $b} @$arr;\n    return [reverse @heap[0..$k-1]];\n}", "    if ($k >= @$arr)\
    \ {\n        @$arr = sort {$b <=> $a} @$arr;\n    } else {\n        my $n = scalar\
    \ @$arr;\n        my $m = $n - $k;\n        for my $i (0..$m-1) {\n          \
    \  for my $j ($i+1..$n-1) {\n                if ($arr->[$i] < $arr->[$j]) {\n\
    \                    @$arr[$i, $j] = @$arr[$j, $i];\n                }\n     \
    \       }\n        }\n        @$arr = splice @$arr, $m;\n    }\n    return $arr;\n\
    }", "    # use Heap:Min\n    my $minheap = Heap::Min->new();\n    foreach my $el\
    \ (@$arr) {\n        if ($minheap->count() < $k) {\n            $minheap->add($el);\n\
    \        } else {\n            my $min = $minheap->top();\n            if ($el\
    \ > $min) {\n                $minheap->delete_top();\n                $minheap->add($el);\n\
    \            }\n        }\n    }\n    my @list = ();\n    while ($minheap->count()\
    \ > 0) {\n        push @list, $minheap->top();\n        $minheap->delete_top();\n\
    \    }\n    return reverse @list;\n}", "    my $i = @$arr - $k;\n    my @ret =\
    \ splice(@$arr, $i);\n    @ret = sort {$a <=> $b} @ret;\n    return @ret;\n}",
  "    my @sorted = sort {$b <=> $a} @$arr;\n    return [@sorted[0..$k-1]];\n}", " \
    \   my @arr = @$arr;\n    return sort {$b <=> $a} @arr[0..$k-1];\n}", "    my\
    \ @sorted = sort {$b <=> $a} @$arr;\n    return @sorted[0..$k-1];\n}", "    my\
    \ @max;\n    push @max, shift @$arr while @max < $k;\n    while(@$arr){\n    \
    \    if ($arr->[0] > $max[-1]){\n            push @max, shift @$arr;\n       \
    \     pop @max;\n        } else {\n            shift @$arr;\n        }\n    }\n\
    \    return @max;\n}", "    my $len = scalar @$arr;\n    if($k >= $len) {\n  \
    \      return [sort {$b <=> $a} @$arr];\n    }\n    my $min_heap = Heap::Binary->new;\n\
    \    for(my $i = 0; $i < $k; $i++) {\n        $min_heap->add($arr->[$i]);\n  \
    \  }\n    for(my $i = $k; $i < $len; $i++) {\n        my $top = $min_heap->extract_top;\n\
    \        if($arr->[$i] > $top) {\n            $min_heap->add($arr->[$i]);\n  \
    \      } else {\n            $min_heap->add($top);\n        }\n    }\n    my @result;\n\
    \    while($min_heap->size > 0) {\n        push @result, $min_heap->extract_top;\n\
    \    }\n    return [reverse @result];\n}", "    my @sorted = sort {$b <=> $a}\
    \ @$arr;\n    return [@sorted[0..$k-1]];\n}", "    my @arr = sort {$b <=> $a}\
    \ @$arr;\n    my @res = splice(@arr, 0, $k);\n    return @res;\n}", "    my @sorted_array\
    \ = sort {$b <=> $a} @$arr;\n    return [ @sorted_array[0..$k-1] ];\n}", "   \
    \ return unless $k;\n    return @$arr[0..$k-1] if scalar @$arr == $k;\n    my\
    \ @maxheap = sort {$b <=> $a} @$arr[0..$k-1];\n    foreach my $idx ($k..$#$arr)\
    \ {\n        if ($arr->[$idx] > $maxheap[0]) {\n            shift @maxheap;\n\
    \            my $i = 0;\n            for ($i=0; $i<=$#maxheap; $i++) {\n     \
    \           last if $arr->[$idx] < $maxheap[$i];\n            }\n            splice\
    \ @maxheap, $i, 0, $arr->[$idx];\n        }\n    }\n    return @maxheap;\n}",
  "    return max_k($arr, $k, 0, @$arr - 1);\n}", "    my @pq = sort {$b <=> $a} @$arr[0..$k-1];\n\
    \    for my $i ($k..$#$arr) {\n        if ($arr->[$i] > $pq[-1]) {\n         \
    \   shift @pq;\n            push @pq, $arr->[$i];\n            my $j = $#pq;\n\
    \            while ($j > 0 and $pq[$j] > $pq[$j-1]) {\n                ($pq[$j],\
    \ $pq[$j-1]) = ($pq[$j-1], $pq[$j]);\n                $j--;\n            }\n \
    \       }\n    }\n    return \\@pq;\n}", "    my @r;\n    my %m;\n    for my $n\
    \ (@$arr) {\n        if (keys %m < $k) {\n            $m{$n}++;\n        }\n \
    \       else {\n            my $v = (sort {$b <=> $a} keys %m)[0];\n         \
    \   if ($n > $v) {\n                delete $m{$v};\n                $m{$n}++;\n\
    \            }\n        }\n    }\n    for my $k (keys %m) {\n        push @r,\
    \ $k for 1..$m{$k};\n    }\n    return \\@r;\n}", "    my @ret = ();\n    for\
    \ (my $i = 0; $i < $k; $i++) {\n        $ret[$i] = shift @$arr;\n    }\n    my\
    \ $x = &find_last_smaller_idx(@ret);\n    while (@$arr) {\n        my $v = shift\
    \ @$arr;\n        if ($v > $ret[$x]) {\n            splice @ret, $x + 1, 0, $v;\n\
    \            pop @ret;\n            $x = &find_last_smaller_idx(@ret);\n     \
    \   }\n    }\n    return @ret;\n}", "    my @res = ();\n    for(my $i = 0; $i\
    \ < $k; $i++){\n        $res[$i] = $arr->[$i];\n    }\n    for(my $i = $k/2; $i\
    \ >= 0; $i--){\n        sink($res, $i, $k);\n    }\n    for(my $i = $k; $i < scalar(@$arr);\
    \ $i++){\n        if($arr->[$i] > $res[0]){\n            $res[0] = $arr->[$i];\n\
    \            sink($res, 0, $k);\n        }\n    }\n    return @res;\n}", "   \
    \ my @arr = @$arr;\n    @arr = sort {$b <=> $a} @arr;\n    return @arr[0..$k-1];\n\
    }", "    return [sort {$b <=> $a} @$arr[0..$k-1]];\n}", "    return sort {$b <=>\
    \ $a} @$arr[0..$k-1];\n}", "    $k -= 1;\n    my @res = @$arr[0..$k];\n    @res\
    \ = sort @res;\n    for my $i (@$arr[$k+1..$#$arr]) {\n        my $j = 0;\n  \
    \      while ($j < $k and $res[$j] < $i) {\n            $j += 1;\n        }\n\
    \        if ($j < $k) {\n            my $t = $k;\n            while ($t > $j)\
    \ {\n                $res[$t] = $res[$t-1];\n                $t -= 1;\n      \
    \      }\n            $res[$j] = $i;\n        }\n    }\n    return @res;\n}",
  "    my $n = scalar @$arr;\n    return if $k <= 0 or $k > $n;\n    my @p = partition($arr,\
    \ 0, $n - 1);\n    for (my $i = 0; $i < $k; $i++) {\n        my $m = max($arr,\
    \ 0, $p[$i] - 1);\n        if ($m == -1) {\n            $i--;\n            last;\n\
    \        }\n        $arr->[$m] = undef;\n    }\n    my @res;\n    my $j = 0;\n\
    \    for (my $i = 0; $i < $n; $i++) {\n        if (defined $arr->[$i]) {\n   \
    \         $res[$j++] = $arr->[$i];\n        }\n    }\n    return @res;\n}", " \
    \   my @heap = sort {$b <=> $a} @$arr[0..$k-1];\n    for (my $i = $k; $i < @$arr;\
    \ $i++) {\n        if ($arr->[$i] > $heap[0]) {\n            $heap[0] = $arr->[$i];\n\
    \            @heap = sort {$b <=> $a} @heap;\n        }\n    }\n    return \\\
    @heap;\n}\nsay join \" \", @{maximum([-3, -4, 5], 3)};\nsay join \" \", @{maximum([4,\
    \ -4, 4], 2)};\nsay join \" \", @{maximum([-3, 2, 1, 2, -1, -2, 1], 1)};", " \
    \   return [] if $k == 0;\n    my $n = @$arr;\n    return [] if $k > $n;\n   \
    \ if ($k == $n) {\n        @$arr = sort {$b <=> $a} @$arr;\n        return $arr;\n\
    \    }\n    my $heap = Heap::Binary->new;\n    $heap->add($_) for @$arr[0..$k-1];\n\
    \    for my $i ($k..$n-1) {\n        if ($arr->[$i] > $heap->top) {\n        \
    \    $heap->extract_top;\n            $heap->add($arr->[$i]);\n        }\n   \
    \ }\n    my @result;\n    while ($heap->size) {\n        push @result, $heap->extract_top;\n\
    \    }\n    return \\@result;\n}", "    my @res = ();\n    my $L = scalar(@$arr);\n\
    \    if ($L == $k) {\n        return @$arr;\n    }\n    my @arr = sort {$b <=>\
    \ $a} @$arr;\n    while ($k > 0) {\n        $k--;\n        push @res, shift @arr;\n\
    \    }\n    return @res;\n}", "    my @res = ();\n    my $n = @$arr;\n    my $max_idx\
    \ = -1;\n    my $cnt = 0;\n    while($cnt < $k) {\n        $max_idx = 0;\n   \
    \     for(my $i = 0; $i < $n; $i++) {\n            $max_idx = $i if @$arr[$i]\
    \ > @$arr[$max_idx];\n        }\n        push @res, @$arr[$max_idx];\n       \
    \ splice @$arr, $max_idx, 1;\n        $n--;\n        $cnt++;\n    }\n    return\
    \ @res;\n}", "    my @heap = ($arr->[0]);\n    my $heap_size = 1;\n    for my\
    \ $i (1 .. $#$arr) {\n        if ($heap_size < $k) {\n            push @heap,\
    \ $arr->[$i];\n            $heap_size++;\n            my $child = $heap_size;\n\
    \            my $parent = ($child-1) >> 1;\n            while ($parent > 0 &&\
    \ $heap[$parent] < $heap[$child]) {\n                ($heap[$parent], $heap[$child])\
    \ = ($heap[$child], $heap[$parent]);\n                $child = $parent;\n    \
    \            $parent = ($child-1) >> 1;\n            }\n        } else {\n   \
    \         if ($arr->[$i] > $heap[0]) {\n                $heap[0] = $arr->[$i];\n\
    \                my $parent = 0;\n                my $child = 1;\n           \
    \     while ($child < $heap_size) {\n                    if ($child+1 < $heap_size\
    \ && $heap[$child+1] > $heap[$child]) {\n                        $child++;\n \
    \                   }\n                    if ($heap[$parent] < $heap[$child])\
    \ {\n                        ($heap[$parent], $heap[$child]) = ($heap[$child],\
    \ $heap[$parent]);\n                        $parent = $child;\n              \
    \          $child = ($parent << 1) + 1;\n                    } else {\n      \
    \                  last;\n                    }\n                }\n         \
    \   }\n        }\n    }\n    return @heap;\n}", "    my $n = @$arr;\n    my $res\
    \ = [];\n    if($k == 0) {\n        return $res;\n    }\n    my $left = 0;\n \
    \   my $right = $n - 1;\n    my $index = partition($arr, $left, $right);\n   \
    \ while($index != $k - 1) {\n        if($index > $k - 1) {\n            $right\
    \ = $index - 1;\n            $index = partition($arr, $left, $right);\n      \
    \  } else {\n            $left = $index + 1;\n            $index = partition($arr,\
    \ $left, $right);\n        }\n    }\n    for(my $i = 0; $i < $k; $i++) {\n   \
    \     push @$res, $$arr[$i];\n    }\n    return $res;\n}", "    my @res = ();\n\
    \    my @sorted = sort {$b <=> $a} @$arr;\n    return @sorted[0..$k-1];\n}", " \
    \   my $max_idx = 0;\n    my $max_val = $arr->[0];\n    for my $i (1..scalar(@$arr)\
    \ - 1) {\n        if ($arr->[$i] > $max_val) {\n            $max_idx = $i;\n \
    \           $max_val = $arr->[$i];\n        }\n    }\n    splice(@$arr, $max_idx,\
    \ 1);\n    if (scalar(@$arr) == $k) {\n        return $arr;\n    }\n    else {\n\
    \        return &maximum($arr, $k);\n    }\n}", "    sub max {\n        my($i,\
    \ $j) = @_;\n        return $arr->[$i] > $arr->[$j] ? $i : $j;\n    }\n    my\
    \ $l = scalar @$arr;\n    # Iterate over the array and find the max of the first\
    \ $k elements\n    my $imax = 0;\n    for my $i (1..$k-1) {\n        $imax = max($imax,\
    \ $i);\n    }\n    # For each element, compare against the max, and if larger,\n\
    \    # swap the elements and update $imax.\n    for my $i ($k..$l-1) {\n     \
    \   $imax = max($imax, $i) if $arr->[$i] > $arr->[$imax];\n        next if $imax\
    \ == $i;\n        @$arr[$imax, $i] = @$arr[$i, $imax];\n    }\n    # Shorten the\
    \ array and return\n    splice @$arr, $k;\n    return $arr;\n}", "    return []\
    \ if $k == 0;\n    my $len = scalar @$arr;\n    return $arr if $k >= $len;\n \
    \   my $heap = Heap::Fibonacci->new;\n    foreach (@$arr) {\n        if ($heap->n\
    \ < $k) {\n            $heap->add($_);\n        } else {\n            my $min\
    \ = $heap->extract_top;\n            $heap->add($_) if $min < $_;\n        }\n\
    \    }\n    my @res = ();\n    push @res, $heap->extract_top while $heap->n >\
    \ 0;\n    return \\@res;\n}", "    my @res = ();\n    foreach my $i (1..$k) {\n\
    \        push @res, pop @$arr;\n    }\n    @res = sort {$a <=> $b} @res;\n   \
    \ return @res;\n}", "    my $len = scalar @$arr;\n    my $result = [];\n    for\
    \ my $i (0..$len-1) {\n        my $j = scalar @$result;\n        if($j < $k) {\n\
    \            push @$result, $arr->[$i];\n        }\n        else {\n         \
    \   while($j > 0 && $result->[$j-1] < $arr->[$i]) {\n                $j--;\n \
    \           }\n            if($j < $k) {\n                splice @$result, $j,\
    \ 0, $arr->[$i];\n                pop @$result;\n            }\n        }\n  \
    \  }\n    return $result;\n}", "    my @sorted = sort {$b <=> $a} @$arr;\n   \
    \ my @result = ();\n    foreach (0..$k-1) {\n        push @result, $sorted[$_];\n\
    \    }\n    return @result;\n}\n1;", "    my $ref = priority_queue(sub {$b <=>\
    \ $a}, @$arr);\n    my @max;\n    for (1..$k) {\n        my $max = dequeue($ref);\n\
    \        push @max, $max;\n    }\n    return @max;\n}", "    my @res = ();\n \
    \   my $len = @$arr;\n    return $arr if $k == $len;\n    my $start = 0;\n   \
    \ my $end = $len - 1;\n    while ($start < $end) {\n        my $pivot = partition($arr,\
    \ $start, $end);\n        if ($pivot == $k) {\n            last;\n        } elsif\
    \ ($pivot < $k) {\n            $start = $pivot + 1;\n        } else {\n      \
    \      $end = $pivot - 1;\n        }\n    }\n    for (my $i = 0; $i < $k; $i++)\
    \ {\n        push @res, $$arr[$i];\n    }\n    return \\@res;\n}", "    return\
    \ [] if $k == 0;\n    return $arr if $k >= @$arr;\n    my @subarr = @$arr[0..$k-1];\n\
    \    my $heap = new Heap::Binary(\\@subarr);\n    for my $i ( $k..$#$arr ) {\n\
    \        $heap->insert($arr->[$i]);\n        $heap->extract_top();\n    }\n  \
    \  return [$heap->sorted];\n}", "    my $end = $k - 1;\n    my $start = 0;\n \
    \   my $pivot = $arr->[0];\n    while($start < $end) {\n        while($arr->[$start]\
    \ <= $pivot) {\n            $start++;\n        }\n        while($arr->[$end] >\
    \ $pivot) {\n            $end--;\n        }\n        if($start < $end) {\n   \
    \         my $tmp = $arr->[$start];\n            $arr->[$start] = $arr->[$end];\n\
    \            $arr->[$end] = $tmp;\n        }\n    }\n    $arr->[0] = $arr->[$end];\n\
    \    $arr->[$end] = $pivot;\n    if($end == $k - 1) {\n        return $arr;\n\
    \    } elsif($end < $k - 1) {\n        return maximum([@$arr[$end+1..$#$arr]],\
    \ $k - $end - 1);\n    } else {\n        return maximum([@$arr[0..$end-1]], $k);\n\
    \    }\n}", "    my @min_heap = heap_init($k);\n    foreach (@$arr) {\n      \
    \  if ($_ > $min_heap[0]) {\n            heap_pop(\\@min_heap);\n            heap_push(\\\
    @min_heap, $_);\n        }\n    }\n    heap_sort(\\@min_heap);\n    return @min_heap;\n\
    }", "    my @sorted = sort {$b <=> $a} @$arr;\n    return [@sorted[0..$k-1]];\n\
    }", "    my $n = scalar @$arr;\n    die \"bad arguments\" if $k > $n;\n    my\
    \ @max;\n    my $i = 0;\n    while ($i < $k) {\n        $max[$i] = $arr->[$i];\n\
    \        $i++;\n    }\n    build_heap(@max);\n    while ($i < $n) {\n        if\
    \ ($arr->[$i] > $max[0]) {\n            $max[0] = $arr->[$i];\n            shift_down(@max);\n\
    \        }\n        $i++;\n    }\n    return @max;\n}", "    heapify($arr);\n\
    \    my @result;\n    for my $i (0..$k-1) {\n        push @result, heappop($arr);\n\
    \    }\n    return \\@result;\n}", "    my @result;\n    my $size = scalar @$arr;\n\
    \    for (my $i = 0; $i < $size; $i++) {\n        my $x = $$arr[$i];\n       \
    \ if (scalar @result < $k) {\n            push @result, $x;\n        } else {\n\
    \            my $j = $k - 1;\n            while ($j >= 0 && $result[$j] < $x)\
    \ {\n                $result[$j + 1] = $result[$j];\n                $j--;\n \
    \           }\n            $result[$j + 1] = $x;\n        }\n    }\n    return\
    \ @result;\n}\nmy @tests = (\n    [\n        [-3, -4, 5], 3\n    ],\n    [\n \
    \       [4, -4, 4], 2\n    ],\n    [\n        [-3, 2, 1, 2, -1, -2, 1], 1\n  \
    \  ],\n);\nforeach my $test (@tests) {\n    my @arr = @{$test->[0]};\n    my $k\
    \ = $test->[1];\n    print \"[@arr] $k: \";\n    my @result = maximum($test->[0],\
    \ $k);\n    print \"@result\\n\";\n}", "    return [] if $k == 0;\n    my @result\
    \ = ();\n    foreach my $el (@$arr) {\n        if (scalar(@result) < $k) {\n \
    \           push @result, $el;\n            @result = sort {$b <=> $a} @result;\n\
    \        } else {\n            if ($el > $result[-1]) {\n                $result[-1]\
    \ = $el;\n                @result = sort {$b <=> $a} @result;\n            }\n\
    \        }\n    }\n    return \\@result;\n}", "    my @max;\n    if (scalar @$arr\
    \ < $k) {\n        @max = sort {$b <=> $a} @$arr;\n    } else {\n        for (my\
    \ $i = 0; $i < $k; $i++) {\n            my $max_index = 0;\n            for (my\
    \ $j = 1; $j < scalar @$arr; $j++) {\n                if ($arr->[$j] > $arr->[$max_index])\
    \ {\n                    $max_index = $j;\n                }\n            }\n\
    \            push @max, $arr->[$max_index];\n            splice @$arr, $max_index,\
    \ 1;\n        }\n    }\n    return @max;\n}", "    my @result;\n    for (my $i\
    \ = 0; $i < $k; $i++) {\n        my $max = $arr->[$i];\n        my $max_index\
    \ = $i;\n        for (my $j = $i + 1; $j < scalar @$arr; $j++) {\n           \
    \ if ($arr->[$j] > $max) {\n                $max = $arr->[$j];\n             \
    \   $max_index = $j;\n            }\n        }\n        my $temp = $arr->[$i];\n\
    \        $arr->[$i] = $max;\n        $arr->[$max_index] = $temp;\n        push\
    \ @result, $max;\n    }\n    return \\@result;\n}", "    @$arr = sort {$b <=>\
    \ $a} @$arr;\n    my @ret = @$arr[0..$k-1];\n    return @ret;\n}", "    my $h\
    \ = max_heapify($arr);\n    my @max_k;\n    for (1..$k) {\n        push @max_k,\
    \ heap_pop($h);\n    }\n    return @max_k;\n}", "    my $len = scalar @$arr;\n\
    \    return [] if $len == 0;\n    my $start = 0;\n    my $end = $len - 1;\n  \
    \  my $pivot = partition($arr, $start, $end);\n    while ($pivot + 1 != $k) {\n\
    \        if ($pivot + 1 > $k) {\n            $end = $pivot - 1;\n            $pivot\
    \ = partition($arr, $start, $end);\n        } else {\n            $start = $pivot\
    \ + 1;\n            $pivot = partition($arr, $start, $end);\n        }\n    }\n\
    \    my @ans = ();\n    foreach (0..$k-1) {\n        push @ans, $arr->[$_];\n\
    \    }\n    return \\@ans;\n}", "    my @res = sort {$b <=> $a} @$arr;\n    return\
    \ @res[0..$k-1];\n}", "    my @max = ($arr->[0]);\n    for (my $i = 1; $i < $k;\
    \ $i++) {\n        my $j = 0;\n        while ($j < $i && $arr->[$i] <= $max[$j])\
    \ {\n            $j++;\n        }\n        splice(@max, $j, 0, $arr->[$i]);\n\
    \    }\n    my $n = scalar(@$arr);\n    for (my $i = $k; $i < $n; $i++) {\n  \
    \      my $j = 0;\n        while ($j < $k && $arr->[$i] <= $max[$j]) {\n     \
    \       $j++;\n        }\n        if ($j < $k) {\n            splice(@max, $j,\
    \ 0, $arr->[$i]);\n            shift(@max);\n        }\n    }\n    return \\@max;\n\
    }", "    my $length = @$arr;\n    $k = $length if $k > $length;\n    return unless\
    \ $k;\n    my @max = ();\n    my @heap = ();\n    my $root_index = 0;\n    my\
    \ $left_index = 1;\n    my $right_index = 2;\n    for my $index (0..$length-1)\
    \ {\n        if(@heap < $k) {\n            push @heap, $arr->[$index];\n     \
    \       $index += 1;\n            my $current_index = $#heap;\n            my\
    \ $parent_index = int(($current_index-1)/2);\n            while($parent_index\
    \ >= 0 && $heap[$parent_index] < $heap[$current_index]) {\n                my\
    \ $temp = $heap[$parent_index];\n                $heap[$parent_index] = $heap[$current_index];\n\
    \                $heap[$current_index] = $temp;\n                $current_index\
    \ = $parent_index;\n                $parent_index = int(($current_index-1)/2);\n\
    \            }\n        }\n        else {\n            if($arr->[$index] > $heap[$root_index])\
    \ {\n                $heap[$root_index] = $arr->[$index];\n                my\
    \ $current_index = $root_index;\n                while($left_index < $k && $right_index\
    \ < $k) {\n                    if($heap[$left_index] > $heap[$right_index]) {\n\
    \                        if($heap[$left_index] > $heap[$current_index]) {\n  \
    \                          my $temp = $heap[$left_index];\n                  \
    \          $heap[$left_index] = $heap[$current_index];\n                     \
    \       $heap[$current_index] = $temp;\n                            $current_index\
    \ = $left_index;\n                        }\n                        else {\n\
    \                            last;\n                        }\n              \
    \      }\n                    else {\n                        if($heap[$right_index]\
    \ > $heap[$current_index]) {\n                            my", "    return [sort\
    \ {$b <=> $a} @$arr[0..$k-1]];\n}", "    my @res = sort {$b <=> $a} @$arr;\n \
    \   splice @res, $k;\n    return @res;\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n\
    }", "    my @max;\n    foreach (@$arr) {\n        push @max, $_ if @max < $k;\n\
    \        @max = sort {$b <=> $a} @max;\n        shift @max if @max > $k;\n   \
    \ }\n    return \\@max;\n}", "    return [] if $k < 1;\n    my @items = sort {\
    \ $b <=> $a } @$arr;\n    splice @items, $k;\n    return \\@items;\n}", "    my\
    \ @res = sort {$b <=> $a} @$arr;\n    splice @res, $k;\n    return @res;\n}",
  "    $k = @$arr if $k > @$arr;\n    #return sort {$b <=> $a} @$arr[0..$k-1];\n \
    \   return $k ? max_heap(@$arr[0..$k-1]), max_heap(@$arr[$k..$#$arr]) : ();\n}",
  "    my %seen;\n    my @unique = grep !$seen{$_}++, @$arr;\n    my @sorted = sort\
    \ { $b <=> $a } @unique;\n    return [@sorted[0..$k-1]];\n}", "    $k = scalar(@$arr)\
    \ if $k > scalar(@$arr);\n    if ($k == 0) {\n        return [];\n    }\n    if\
    \ ($k == 1) {\n        return [max @$arr];\n    }\n    my $res = [];\n    my $i\
    \ = 0;\n    my $j = $k;\n    for (; $i < $k; $i++) {\n        my $largest = $i;\n\
    \        for (my $l = $i + 1; $l < $j; $l++) {\n            if ($arr->[$l] > $arr->[$largest])\
    \ {\n                $largest = $l;\n            }\n        }\n        ($arr->[$i],\
    \ $arr->[$largest]) = ($arr->[$largest], $arr->[$i]);\n        push @$res, $arr->[$i];\n\
    \    }\n    for (; $j < scalar(@$arr); $j++) {\n        my $largest = 0;\n   \
    \     for (my $l = 1; $l < $k; $l++) {\n            if ($arr->[$l] > $arr->[$largest])\
    \ {\n                $largest = $l;\n            }\n        }\n        if ($arr->[$j]\
    \ > $arr->[$largest]) {\n            ($arr->[$largest], $arr->[$j]) = ($arr->[$j],\
    \ $arr->[$largest]);\n            $res->[$largest] = $arr->[$largest];\n     \
    \   }\n    }\n    return $res;\n}", "    if (scalar(@$arr) == 0 || scalar(@$arr)\
    \ < $k) {\n        die \"Invalid array or k\";\n    }\n    my $result = [];\n\
    \    my $heap = Paws::Heap->new(sub { $_[0] < $_[1] });\n    for my $n (@$arr)\
    \ {\n        if ($heap->size < $k) {\n            $heap->insert($n);\n       \
    \ }\n        else {\n            my $top = $heap->top;\n            if ($n > $top)\
    \ {\n                $heap->extract_top;\n                $heap->insert($n);\n\
    \            }\n        }\n    }\n    while ($heap->size > 0) {\n        push\
    \ @$result, $heap->extract_top;\n    }\n    return $result;\n}", "    return sort\
    \ {$b <=> $a} @$arr[0..$k-1];\n}", "    my @res = ();\n    for (my $i = 0; $i\
    \ < @$arr; $i++) {\n        my $insert = 0;\n        for (my $j = 0; $j < @res;\
    \ $j++) {\n            if ($arr->[$i] >= $res[$j]) {\n                splice(@res,\
    \ $j, 0, $arr->[$i]);\n                $insert = 1;\n                last;\n \
    \           }\n        }\n        if ($insert == 0) {\n            push(@res,\
    \ $arr->[$i]);\n        }\n        if (@res > $k) {\n            pop(@res);\n\
    \        }\n    }\n    return @res;\n}", "    heap_sort($arr);\n    return [@$arr[$#$arr\
    \ - $k + 1 .. $#$arr]];\n}", "    return [] if $k == 0;\n    my $maxHeap = MaxHeap->new();\n\
    \    my $len = @$arr;\n    if ($k >= $len) {\n        $maxHeap->build_heap($arr);\n\
    \    } else {\n        $maxHeap->build_heap( [ @$arr[0..$k-1] ] );\n        for\
    \ my $i ($k..$len-1) {\n            if ($arr->[$i] > $maxHeap->get_max()) {\n\
    \                $maxHeap->pop_max();\n                $maxHeap->insert($arr->[$i]);\n\
    \            }\n        }\n    }\n    return $maxHeap->to_array();\n}", "    my\
    \ @max_k = ();\n    return @max_k if !@$arr;\n    my $num = scalar @$arr;\n  \
    \  for my $i (0..$num-1) {\n        if (scalar @max_k < $k) {\n            push\
    \ @max_k, $arr->[$i];\n        }\n        else {\n            my $min = get_min(\\\
    @max_k);\n            if ($arr->[$i] > $min) {\n                my $j = get_pos(\\\
    @max_k, $min);\n                $max_k[$j] = $arr->[$i];\n            }\n    \
    \    }\n    }\n    return @max_k;\n}", "    my @sorted = sort {$b <=> $a} @$arr;\n\
    \    splice @sorted, $k;\n    return @sorted;\n}", "    my $n = scalar @$arr;\n\
    \    my $return = [];\n    return $return if ($k == 0);\n    return $arr if ($k\
    \ == $n);\n    my @arr = @$arr;\n    @arr = sort {$b <=> $a} @arr;\n    my $i\
    \ = 0;\n    while($i < $k) {\n        push @$return, $arr[$i];\n        $i++;\n\
    \    }\n    return $return;\n}", "    return [] if $k == 0;\n    return [sort\
    \ {$b <=> $a} @$arr] if $k >= @$arr;\n    my $left = 0;\n    my $right = $k -\
    \ 1;\n    my $pivot = get_pivot($arr, $left, $right);\n    while (1) {\n     \
    \   my $new_pivot = partition($arr, $left, $right, $pivot);\n        if ($new_pivot\
    \ == $k - 1) {\n            return [sort {$b <=> $a} @{$arr}[0..$k-1]];\n    \
    \    } elsif ($new_pivot < $k - 1) {\n            $left = $new_pivot + 1;\n  \
    \          $pivot = get_pivot($arr, $left, $right);\n        } else {\n      \
    \      $right = $new_pivot - 1;\n            $pivot = get_pivot($arr, $left, $right);\n\
    \        }\n    }\n}", "    my @ans;\n    my %seen;\n    for my $i (0..@$arr-1)\
    \ {\n        next if $seen{$i};\n        my $index = $i;\n        my $value =\
    \ $arr->[$i];\n        for my $j ($i+1..@$arr-1) {\n            if ($value < $arr->[$j])\
    \ {\n                $index = $j;\n                $value = $arr->[$j];\n    \
    \        }\n        }\n        $seen{$index} = 1;\n        push @ans, $value;\n\
    \        last if @ans == $k;\n    }\n    return \\@ans;\n}", "    my @pq = ();\n\
    \    foreach my $n (@$arr) {\n        my $i = @pq;\n        while ($i > 0) {\n\
    \            last if $n > $pq[$i - 1];\n            $i--;\n        }\n       \
    \ splice @pq, $i, 0, $n;\n        pop @pq if @pq > $k;\n    }\n    return \\@pq;\n\
    }", "    my $size = scalar @$arr;\n    if ($k == $size) {\n        return $arr;\n\
    \    } elsif ($k > $size) {\n        return \"k is larger than the length of array\"\
    ;\n    } else {\n        my $result = [@$arr[0..$k-1]];\n        my $i = $k;\n\
    \        while ($i < $size) {\n            my $j = 0;\n            my $temp =\
    \ $result->[$j];\n            for (; $j < $k; $j++) {\n                if ($arr->[$i]\
    \ > $result->[$j]) {\n                    $temp = $result->[$j];\n           \
    \         $result->[$j] = $arr->[$i];\n                    last;\n           \
    \     }\n            }\n            for (; $j < $k; $j++) {\n                my\
    \ $t = $result->[$j];\n                $result->[$j] = $temp;\n              \
    \  $temp = $t;\n            }\n            $i++;\n        }\n        return $result;\n\
    \    }\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "    # First sort\
    \ the array.\n    my @sorted = sort {$a <=> $b} @$arr;\n    # Then take the last\
    \ k elements.\n    return [@sorted[$#sorted - $k + 1 .. $#sorted]];\n}", "   \
    \ my $n = scalar @$arr;\n    return if $k <= 0 || $k > $n;\n    # Build a min-heap\
    \ of $k elements\n    my @max = map { $_ } (0..$k-1);\n    my $min = $arr->[0];\n\
    \    my $min_idx = 0;\n    for my $i (0..$k-1) {\n        if ($arr->[$i] < $min)\
    \ {\n            $min = $arr->[$i];\n            $min_idx = $i;\n        }\n \
    \   }\n    my $end = $k-1;\n    for my $i ($k..$n-1) {\n        if ($arr->[$i]\
    \ > $min) {\n            $max[$min_idx] = $arr->[$i];\n            # Re-heapify\n\
    \            my $j = ($min_idx-1)/2;\n            my $idx = $min_idx;\n      \
    \      while ($j >= 0) {\n                if ($max[$j] > $max[$idx]) {\n     \
    \               my $tmp = $max[$j];\n                    $max[$j] = $max[$idx];\n\
    \                    $max[$idx] = $tmp;\n                    $idx = $j;\n    \
    \                $j = ($j-1)/2;\n                } else {\n                  \
    \  last;\n                }\n            }\n            # Find the new min.\n\
    \            $min = $max[0];\n            $min_idx = 0;\n            for my $i\
    \ (0..$k-1) {\n                if ($max[$i] < $min) {\n                    $min\
    \ = $max[$i];\n                    $min_idx = $i;\n                }\n       \
    \     }\n        }\n    }\n    return @max;\n}", "    my $j = 0;\n    my @max\
    \ = $arr->[0] x $k;\n    for my $i (1..@$arr-1) {\n        for ($j = 0; $j < $k\
    \ && $max[$j] > $arr->[$i]; $j++) {}\n        splice @max, $j, 0, $arr->[$i];\n\
    \        pop @max;\n    }\n    return @max;\n}", "    my @heap = ();\n    foreach\
    \ my $num (@$arr) {\n        if (@heap < $k) {\n            push @heap, $num;\n\
    \            my $i = $#heap;\n            while ($i > 0) {\n                my\
    \ $parent = ($i - 1) / 2;\n                if ($heap[$i] > $heap[$parent]) {\n\
    \                    @heap[$i, $parent] = @heap[$parent, $i];\n              \
    \      $i = $parent;\n                } else {\n                    last;\n  \
    \              }\n            }\n        } else {\n            if ($num > $heap[0])\
    \ {\n                $heap[0] = $num;\n                my $i = 0;\n          \
    \      while (1) {\n                    my $left = $i * 2 + 1;\n             \
    \       my $right = $i * 2 + 2;\n                    my $largest = $i;\n     \
    \               if ($left < @heap && $heap[$left] > $heap[$largest]) {\n     \
    \                   $largest = $left;\n                    }\n               \
    \     if ($right < @heap && $heap[$right] > $heap[$largest]) {\n             \
    \           $largest = $right;\n                    }\n                    if\
    \ ($largest != $i) {\n                        @heap[$i, $largest] = @heap[$largest,\
    \ $i];\n                        $i = $largest;\n                    } else {\n\
    \                        last;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return @heap;\n}", "    # Sort the array.\n\
    \    my @sorted = sort { $a <=> $b } @$arr;\n    # Return all but the last $k\
    \ elements.\n    return [@sorted[0 .. $#$arr - $k]];\n}", "    return sort {$b\
    \ <=> $a} @$arr[0..$k-1];\n}", "    my $n = @$arr;\n    return $arr if $k == $n;\n\
    \    return array_max($arr, $k, 0, $n-1);\n}", "    my @output = sort {$b <=>\
    \ $a} @$arr;\n    splice @output, $k;\n    return @output;\n}", "    $k = int($k);\n\
    \    return [] if $k <= 0 || $k > scalar(@$arr);\n    my @sorted = sort {$b <=>\
    \ $a} @$arr;\n    return [@sorted[0..$k-1]];\n}", "    my @sorted = sort {$b <=>\
    \ $a} @$arr;\n    return [@sorted[0..$k-1]];\n}", "    my @result;\n    my $length\
    \ = scalar @$arr;\n    return $arr if $k == $length;\n    my $start = 0;\n   \
    \ my $end = $length - 1;\n    my $index = partition($arr, $start, $end);\n   \
    \ while ($index != $k) {\n        if ($index > $k) {\n            $end = $index\
    \ - 1;\n            $index = partition($arr, $start, $end);\n        }\n     \
    \   else {\n            $start = $index + 1;\n            $index = partition($arr,\
    \ $start, $end);\n        }\n    }\n    return [@$arr[0..$k-1]];\n}", "    my\
    \ @sorted_arr = sort {$b <=> $a} @$arr;\n    my @result = @sorted_arr[0..$k-1];\n\
    \    return @result;\n}", "    my @out;\n    @arr = sort {$b <=> $a} @$arr;\n\
    \    for my $i (0..$k-1) {\n        push @out, $arr[$i];\n    }\n    return @out;\n\
    }", "    if ($k == 0) {\n        return [];\n    }\n    if ($k == 1) {\n     \
    \   return [maxnum(@$arr)];\n    }\n    my @arr = @$arr;\n    my @max;\n    for\
    \ (my $i = 0; $i < $k; $i++) {\n        $max[$i] = splice(@arr, 0, 1);\n    }\n\
    \    $max[-1] = maxnum(@max);\n    foreach my $num (@arr) {\n        if ($num\
    \ > $max[-1]) {\n            $max[-1] = $num;\n            $max[-1] = maxnum(@max);\n\
    \        }\n    }\n    return [sort @max];\n}", "    return @$arr[0..$k-1] if\
    \ $k >= @$arr;\n    return @$arr[-$k..-1] if $k < @$arr;\n}", "    my @max;\n\
    \    for my $n (@$arr) {\n        if (@max < $k) {\n            push @max, $n;\n\
    \            @max = sort { $b <=> $a } @max;\n        }\n        elsif ($n > $max[-1])\
    \ {\n            pop @max;\n            push @max, $n;\n            @max = sort\
    \ { $b <=> $a } @max;\n        }\n    }\n    return @max;\n}", "    return [ sort\
    \ { $b <=> $a } @$arr ][0..$k-1];\n}", "    my $n = @$arr;\n    if($k == $n) {\n\
    \        return sort {$b <=> $a} @$arr;\n    }\n    my @heap = splice(@$arr, 0,\
    \ $k);\n    heapify(\\@heap);\n    for my $val (@$arr) {\n        if($val > $heap[0])\
    \ {\n            shift(@heap);\n            push(@heap, $val);\n            reheap_up(\\\
    @heap);\n        }\n    }\n    return sort {$b <=> $a} @heap;\n}", "    return\
    \ if $k < 1;\n    my @max = max_k($arr, $k);\n    quicksort_dec(\\@max);\n   \
    \ return @max;\n}", "    my @stack;\n    for (@$arr) {\n        if (@stack < $k)\
    \ {\n            push @stack, $_;\n        } else {\n            if ($_ > $stack[0])\
    \ {\n                push @stack, $_;\n                shift @stack;\n       \
    \     }\n        }\n    }\n    return @stack;\n}", "    @$arr = sort {$b <=> $a}\
    \ @$arr;\n    my @result = @$arr[0..$k-1];\n    return @result;\n}", "    return\
    \ sort {$b <=> $a} @$arr[0..$k-1];\n}", "    use MaxHeap;\n    my $maxheap = MaxHeap->new(arr\
    \ => $arr);\n    $maxheap->heapify();\n    my @output;\n    for (1..$k) {\n  \
    \      push @output, $maxheap->pop();\n    }\n    return @output;\n}", "    return\
    \ [] if $k <= 0;\n    my $n = @$arr;\n    return $arr if $k >= $n;\n    my @ret\
    \ = (splice @$arr, 0, $k);\n    @ret = sort {$a <=> $b} @ret;\n    for my $x (@$arr)\
    \ {\n        if ($x > $ret[0]) {\n            shift @ret;\n            push @ret,\
    \ $x;\n            @ret = sort {$a <=> $b} @ret;\n        }\n    }\n    return\
    \ \\@ret;\n}", "    my @max_array = ();\n    my $count = 0;\n    foreach my $num\
    \ (@$arr) {\n        if ($count == 0) {\n            push @max_array, $num;\n\
    \            $count++;\n        } else {\n            my $flag = 0;\n        \
    \    foreach my $max_num (@max_array) {\n                if ($num >= $max_num)\
    \ {\n                    unshift @max_array, $num;\n                    if (scalar\
    \ @max_array > $k) {\n                        pop @max_array;\n              \
    \      }\n                    $flag = 1;\n                    last;\n        \
    \        }\n            }\n            if ($flag == 0) {\n                if (scalar\
    \ @max_array < $k) {\n                    push @max_array, $num;\n           \
    \     }\n            }\n        }\n    }\n    return @max_array;\n}\nmy @my_array\
    \ = (-3, -4, 5);\nmy $k = 3;\nprint join(', ', maximum(\\@my_array, $k)) . \"\\\
    n\";\n@my_array = (4, -4, 4);\n$k = 2;\nprint join(', ', maximum(\\@my_array,\
    \ $k)) . \"\\n\";\n@my_array = (-3, 2, 1, 2, -1, -2, 1);\n$k = 1;\nprint join(',\
    \ ', maximum(\\@my_array, $k)) . \"\\n\";", "    my @result;\n    foreach my $number\
    \ (@$arr) {\n        if (scalar @result < $k) {\n            push @result, $number;\n\
    \        } else {\n            # $arr is sorted here, so if the first element\
    \ \n            # of @result is not large than $number, $number\n            #\
    \ is definitely not the maximum number in $arr\n            if ($result[0] <=\
    \ $number) {\n                # if the first element is the maximum, replace it\n\
    \                if ($result[0] < $result[$#result]) {\n                    $result[0]\
    \ = $number;\n                } else {\n                    # if the first element\
    \ is not the maximum,\n                    # replace the first element with $number\n\
    \                    # then loop from the second element to\n                \
    \    # find the correct position for $number\n                    $result[0] =\
    \ $number;\n                    for my $i (1..$#result) {\n                  \
    \      if ($result[$i] > $number) {\n                            $result[$i -\
    \ 1] = $result[$i];\n                        } else {\n                      \
    \      $result[$i] = $number;\n                            last;\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n    }\n    @result;\n}", "    if($k == 1) {\n        my $max = $arr->[0];\n\
    \        for my $i (1..$#$arr) {\n            $max = $arr->[$i] if $arr->[$i]\
    \ > $max;\n        }\n        return [$max];\n    }\n    if($k >= scalar @$arr)\
    \ {\n        my @sorted = sort {$a <=> $b} @$arr;\n        return \\@sorted;\n\
    \    }\n    my @res = splice @$arr, 0, $k;\n    my $min = $res[0];\n    my $min_idx\
    \ = 0;\n    for my $i (1..$#res) {\n        if($res[$i] < $min) {\n          \
    \  $min = $res[$i];\n            $min_idx = $i;\n        }\n    }\n    for my\
    \ $i (0..$#$arr) {\n        if($arr->[$i] > $min) {\n            $res[$min_idx]\
    \ = $arr->[$i];\n            $min = $res[0];\n            $min_idx = 0;\n    \
    \        for my $j (1..$#res) {\n                if($res[$j] < $min) {\n     \
    \               $min = $res[$j];\n                    $min_idx = $j;\n       \
    \         }\n            }\n        }\n    }\n    my @sorted = sort {$a <=> $b}\
    \ @res;\n    return \\@sorted;\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n\
    }", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "    if (scalar(@$arr) <=\
    \ $k) {\n        return [ sort { $b <=> $a } @$arr ];\n    }\n    my $h = List::PriorityQueue->new;\n\
    \    for my $i (0 .. $k - 1) {\n        $h->insert($arr->[$i], -$arr->[$i]);\n\
    \    }\n    for my $i ($k .. $#$arr) {\n        my $lowest = $h->top();\n    \
    \    if ($arr->[$i] > $lowest) {\n            $h->extract();\n            $h->insert($arr->[$i],\
    \ -$arr->[$i]);\n        }\n    }\n    my @res;\n    for (1 .. $k) {\n       \
    \ push @res, $h->extract();\n    }\n    return [ sort { $b <=> $a } @res ];\n}",
  "    my $len = @$arr;\n    my @result;\n    return [] if ($len == 0 || $k == 0);\n\
    \    my @stack;\n    foreach my $num (@$arr) {\n        while (@stack && $num\
    \ > $stack[-1] && $len - @stack + 1 >= $k) {\n            pop @stack;\n      \
    \  }\n        push @stack, $num;\n    }\n    return \\@stack;\n}", "    my %h;\n\
    \    for my $i (@$arr) {\n        $h{$i}++;\n    }\n    my @k = sort {$a <=> $b}\
    \ keys %h;\n    my @res;\n    my $i = 0;\n    while ($i < $k) {\n        push\
    \ @res, pop @k;\n        $i++;\n    }\n    return \\@res;\n}", "    my @sorted\
    \ = sort {$b <=> $a} @$arr;\n    @sorted[0..$k-1];\n}", "    my @list = ();\n\
    \    my $count = 0;\n    my $length = scalar @$arr;\n    if ($k >= $length) {\n\
    \        return @$arr;\n    }\n    for (my $i = 0; $i < $length; $i++) {\n   \
    \     if ($count == 0) {\n            push @list, $arr->[$i];\n            $count++;\n\
    \        } else {\n            if ($arr->[$i] > $list[0]) {\n                shift\
    \ @list;\n                push @list, $arr->[$i];\n            }\n        }\n\
    \    }\n    return @list;\n}", "    my @sort_arr = sort {$b <=> $a} @$arr;\n \
    \   return [@sort_arr[0..$k-1]];\n}", "    my %seen;\n    my @max;\n    while(@max\
    \ < $k) {\n        my $max = -1001;\n        my $max_index;\n        foreach my\
    \ $i (0..$#{$arr}) {\n            next if exists $seen{$i};\n            my $num\
    \ = $arr->[$i];\n            if($num > $max) {\n                $max = $num;\n\
    \                $max_index = $i;\n            }\n        }\n        push @max,\
    \ $max;\n        $seen{$max_index} = 1;\n    }\n    return @max;\n}", "    my\
    \ @sorted_arr = sort {$b <=> $a} @$arr;\n    return @sorted_arr[0..$k-1];\n}",
  "    my @max;\n    my $count = 0;\n    foreach my $i (@$arr) {\n        if ($count\
    \ == 0) {\n            $max[$count] = $i;\n            $count++;\n        }\n\
    \        elsif ($count < $k) {\n            $max[$count] = $i;\n            for\
    \ (my $j = $count - 1; $j >= 0; $j--) {\n                if ($max[$j] < $max[$j\
    \ + 1]) {\n                    my $t = $max[$j];\n                    $max[$j]\
    \ = $max[$j + 1];\n                    $max[$j + 1] = $t;\n                }\n\
    \            }\n            $count++;\n        }\n        else {\n           \
    \ if ($i > $max[$k - 1]) {\n                $max[$k - 1] = $i;\n             \
    \   for (my $j = $k - 2; $j >= 0; $j--) {\n                    if ($max[$j] <\
    \ $max[$j + 1]) {\n                        my $t = $max[$j];\n               \
    \         $max[$j] = $max[$j + 1];\n                        $max[$j + 1] = $t;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return @max;\n}", "    my $len = scalar @$arr;\n    if($k > $len) {\n    \
    \    return;\n    }\n    my $start = 0;\n    my $end = $len - 1;\n    my $index\
    \ = partition($arr, $start, $end);\n    while($index != $k - 1) {\n        if($index\
    \ > $k - 1) {\n            $end = $index - 1;\n            $index = partition($arr,\
    \ $start, $end);\n        } else {\n            $start = $index + 1;\n       \
    \     $index = partition($arr, $start, $end);\n        }\n    }\n    my @result\
    \ = ();\n    for(my $i = 0; $i < $k; $i++) {\n        push @result, $arr->[$i];\n\
    \    }\n    return @result;\n}", "    my @sorted = sort {$b <=> $a} @$arr;\n \
    \   my @max = @sorted[0..$k-1];\n    return @max;\n}", "    my $length = scalar\
    \ @$arr;\n    my $maxHeap = createMaxHeap($arr);\n    my @res;\n    for (1..$k)\
    \ {\n        push @res, extractMax($maxHeap);\n    }\n    return \\@res;\n}",
  "    my @arr = sort {$b <=> $a} @$arr;\n    return @arr[0..$k-1];\n}", '    my $i;',
  "    my $num_values = @$arr;\n    # If the number of items to be returned is greater\
    \ than the size of the\n    # array, then we simply return the array sorted.\n\
    \    return sort { $a <=> $b } @$arr if $k > $num_values;\n    # We use the partition\
    \ function to find the kth item.\n    my $index = partition($arr, 0, $num_values\
    \ - 1, $k - 1);\n    # And then we return the array from 0 to k, sorted.\n   \
    \ return sort { $a <=> $b } @$arr[0..$index];\n}", "    my $len = scalar @$arr;\n\
    \    return [] if $len == 0;\n    my $min = -1000;\n    my $max = 1000;\n    my\
    \ $n = $len > $k ? $k : $len;\n    my $count = $max - $min + 1;\n    my @counts\
    \ = ();\n    for (0..$count-1) {\n        push @counts, 0;\n    }\n    for my\
    \ $num (@$arr) {\n        $counts[$num - $min]++;\n    }\n    my @res = ();\n\
    \    for (0..$count-1) {\n        for (0..$counts[$_]-1) {\n            push @res,\
    \ $_ + $min;\n            $n--;\n            last if $n == 0;\n        }\n   \
    \     last if $n == 0;\n    }\n    return \\@res;\n}", "    my @sorted = sort\
    \ {$b <=> $a} @$arr;\n    return [ @sorted[0..$k-1] ];\n}", "    my $size = @$arr;\n\
    \    my $start = 0;\n    my $end = $size - 1;\n    my $i = $start;\n    my $j\
    \ = $end;\n    my $index = partition_dutch_flag($arr, $start, $end);\n    while\
    \ ($index != $k - 1) {\n        if ($index > $k - 1) {\n            $end = $index\
    \ - 1;\n            $index = partition_dutch_flag($arr, $start, $end);\n     \
    \   } else {\n            $start = $index + 1;\n            $index = partition_dutch_flag($arr,\
    \ $start, $end);\n        }\n    }\n    return [@$arr[0..$k-1]];\n}", "    my\
    \ $arr_len = scalar @$arr;\n    if ($k > $arr_len) {\n        $k = $arr_len;\n\
    \    }\n    # use insertion sort\n    for (my $i = 1; $i < $k; $i++) {\n     \
    \   my $curr = $arr->[$i];\n        my $j = $i - 1;\n        while ($j >= 0 &&\
    \ $arr->[$j] < $curr) {\n            $arr->[$j + 1] = $arr->[$j];\n          \
    \  $j--;\n        }\n        $arr->[$j + 1] = $curr;\n    }\n    # print \"arr\
    \ = [@$arr]\\n\";\n    for (my $i = $k; $i < $arr_len; $i++) {\n        my $curr\
    \ = $arr->[$i];\n        my $j = $k - 1;\n        while ($j >= 0 && $arr->[$j]\
    \ < $curr) {\n            $arr->[$j + 1] = $arr->[$j];\n            $j--;\n  \
    \      }\n        if ($j != $k - 1) {\n            $arr->[$j + 1] = $curr;\n \
    \       }\n    }\n    return [@$arr[0..$k-1]];\n}", '    my @heap = sort {$b <=>
    $a} @$arr[0..$k-1];', "    my $len = @$arr;\n    my @ret;\n    my @heap;\n   \
    \ my %seen;\n    my $pos = 0;\n    while($pos < $len) {\n        my $cur = $arr->[$pos];\n\
    \        push @heap, $cur;\n        $seen{$cur}->{pos} = $pos;\n        $seen{$cur}->{cnt}++;\n\
    \        $pos++;\n        my $idx = $#heap;\n        while($idx > 0) {\n     \
    \       my $parent = int(($idx - 1) / 2);\n            if($heap[$parent] > $heap[$idx])\
    \ {\n                @heap[$parent, $idx] = @heap[$idx, $parent];\n          \
    \      $idx = $parent;\n            } else {\n                last;\n        \
    \    }\n        }\n    }\n    while($k-- > 0) {\n        my $cur = shift @heap;\n\
    \        my $idx = $seen{$cur}->{pos};\n        push @ret, $cur;\n        $seen{$cur}->{cnt}--;\n\
    \        if($seen{$cur}->{cnt} > 0) {\n            push @heap, $cur;\n       \
    \     my $cur_idx = $#heap;\n            while($cur_idx > 0) {\n             \
    \   my $parent = int(($cur_idx - 1) / 2);\n                if($heap[$parent] >\
    \ $heap[$cur_idx]) {\n                    @heap[$parent, $cur_idx] = @heap[$cur_idx,\
    \ $parent];\n                    $cur_idx = $parent;\n                } else {\n\
    \                    last;\n                }\n            }\n        }\n    \
    \    my $pos = $idx + 1;\n        while($pos < $len) {\n            my $cur =\
    \ $arr->[$pos];\n            if(!$seen{$cur} || $seen{$cur}->{cnt} == 0) {\n \
    \               push @heap, $cur;\n                $seen{$cur}->", "    my @max\
    \ = sort {$b <=> $a} @$arr[0..$k-1];\n    for (my $i = $k; $i < @$arr; $i++) {\n\
    \        for (my $j = 0; $j < $k; $j++) {\n            if ($arr->[$i] > $max[$j])\
    \ {\n                $max[$j] = $arr->[$i];\n                last;\n         \
    \   }\n        }\n    }\n    return @max;\n}", "    my @sorted = sort {$b <=>\
    \ $a} @$arr;\n    return [splice(@sorted, 0, $k)];\n}", "    return unless $k;\n\
    \    my @res = map {$_} sort {$b <=> $a} @$arr[0..$k-1];\n    for my $i ($k..@$arr-1)\
    \ {\n        if ($arr->[$i] > $res[-1]) {\n            my $j = 0;\n          \
    \  while ($j < $k && $arr->[$i] < $res[$j]) {$j++;}\n            if ($j < $k)\
    \ {\n                @res = ($res[0..$j-1], $arr->[$i], @res[$j..$k-2]);\n   \
    \         }\n        }\n    }\n    return @res;\n}", "    my $len = @$arr;\n \
    \   my $res = [];\n    if ($k >= $len) {\n        return [sort {$b <=> $a} @$arr];\n\
    \    }\n    my $min = 0;\n    my $max = $len - 1;\n    my $index = partition($arr,\
    \ $min, $max);\n    while ($index != $k - 1) {\n        if ($index > $k - 1) {\n\
    \            $max = $index - 1;\n            $index = partition($arr, $min, $max);\n\
    \        } else {\n            $min = $index + 1;\n            $index = partition($arr,\
    \ $min, $max);\n        }\n    }\n    for (my $i = 0; $i < $k; $i++) {\n     \
    \   push(@$res, $arr->[$i]);\n    }\n    return $res;\n}", "    my @res = ();\n\
    \    my $i = 0;\n    my $j = 0;\n    my $tmp = -1000;\n    my $offset = 0;\n \
    \   my $count = 0;\n    my $idx = 0;\n    my $len = 0;\n    my @priority = ();\n\
    \    my @values = ();\n    for (my $i = 0; $i < scalar(@$arr); $i++) {\n     \
    \   push(@values, $arr->[$i]);\n        push(@priority, $i);\n    }\n    $len\
    \ = scalar(@values);\n    while ($i < $len) {\n        $tmp = -1000;\n       \
    \ for (my $i = 0; $i < scalar(@values); $i++) {\n            if ($values[$i] >\
    \ $tmp) {\n                $idx = $i;\n                $tmp = $values[$i];\n \
    \           }\n        }\n        $res[$j] = $tmp;\n        $j++;\n        $values[$idx]\
    \ = -1000;\n        $i++;\n    }\n    $i = 0;\n    while ($i < $k) {\n       \
    \ print \"$res[$i]\\n\";\n        $i++;\n    }\n}", "    my @nums = sort {$b <=>\
    \ $a} @$arr;\n    my @res = ();\n    for(my $i = 0; $i < $k; $i++){\n        push\
    \ @res, $nums[$i];\n    }\n    return @res;\n}", "    my @sorted_arr = sort {$b\
    \ <=> $a} @$arr;\n    return @sorted_arr[0..$k-1];\n}", "    return sort {$b <=>\
    \ $a} @$arr[0..$k-1];\n}", "    $#{$arr} >= $k or return $arr;\n    @{$arr} =\
    \ sort {$b <=> $a} @{$arr};\n    return [@{$arr}[0..$k-1]];\n}", "    my $n =\
    \ @$arr;\n    if ($k == $n) {\n        return [sort {$b <=> $a} @$arr];\n    }\n\
    \    my @result = ();\n    my $i = 0;\n    while ($i < $k) {\n        if (!@result\
    \ || $arr->[$i] > $result[-1]) {\n            push @result, $arr->[$i];\n    \
    \    } else {\n            insert_to_pos($arr->[$i], \\@result);\n        }\n\
    \        $i++;\n    }\n    while ($i < $n) {\n        if ($arr->[$i] <= $result[-1])\
    \ {\n            $i++;\n            next;\n        }\n        pop @result;\n \
    \       push @result, $arr->[$i];\n        $i++;\n    }\n    return \\@result;\n\
    }", "    my $l = scalar @$arr;\n    my $r = 0;\n    my $e = $l - 1;\n    for (0..$k-1)\
    \ {\n        for my $i ($r..$e) {\n            if ($arr->[$i] > $arr->[$r]) {\n\
    \                $r = $i;\n            }\n        }\n        ($arr->[$r], $arr->[$e])\
    \ = ($arr->[$e], $arr->[$r]);\n        $e--;\n    }\n    [@$arr[$e+1..$l-1]];\n\
    }", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "    return $arr if !@$arr;\n\
    \    my $max = max(@$arr);\n    my $min = min(@$arr);\n    my @buckets = map {\
    \ [] } 0..(($max - $min) + 1);\n    for my $num (@$arr) {\n        my $i = $num\
    \ - $min;\n        push @{$buckets[$i]}, $num;\n    }\n    my @sorted;\n    for\
    \ my $bucket (@buckets) {\n        push @sorted, sort { $b <=> $a } @$bucket;\n\
    \        last if @sorted >= $k;\n    }\n    return [@sorted[0..($k - 1)]];\n}",
  "    my @max;\n    my $i = 0;\n    my $tail = 0;\n    my $min = 1000;\n    my $min_index\
    \ = -1;\n    for(my $i = 0; $i < $k; $i++) {\n        my $value = $arr->[$i];\n\
    \        if($i == 0) {\n            $max[$i] = $value;\n            if($value\
    \ < $min) {\n                $min = $value;\n                $min_index = $i;\n\
    \            }\n        } else {\n            if($value < $min) {\n          \
    \      $min = $value;\n                $min_index = $i;\n            }\n     \
    \       my $j = $i;\n            while($j > 0 && $max[$j - 1] < $value) {\n  \
    \              $max[$j] = $max[$j - 1];\n                $j--;\n            }\n\
    \            $max[$j] = $value;\n        }\n    }\n    for(my $i = $k; $i < scalar(@$arr);\
    \ $i++) {\n        my $value = $arr->[$i];\n        if($value < $min) {\n    \
    \        next;\n        }\n        my $j = $k - 1;\n        while($j > 0 && $max[$j\
    \ - 1] < $value) {\n            $max[$j] = $max[$j - 1];\n            $j--;\n\
    \        }\n        $max[$j] = $value;\n        if($j == 0) {\n            $min\
    \ = $max[$k - 1];\n            $min_index = $k - 1;\n        }\n    }\n    return\
    \ @max;\n}", "    my @arr = @$arr;\n    my @result;\n    my $i = 0;\n    while\
    \ ($i < $k) {\n        my $max = max(@arr);\n        push @result, $max;\n   \
    \     @arr = delete($max, @arr);\n        $i++;\n    }\n    return @result;\n}",
  "    my $n = scalar @$arr;\n    return [] if $k == 0;\n    my $left = 0;\n    my\
    \ $right = $n - 1;\n    my $p = partition($arr, $left, $right);\n    while($p\
    \ != $k - 1) {\n        if($p > $k - 1) {\n            $right = $p - 1;\n    \
    \        $p = partition($arr, $left, $right);\n        }\n        else {\n   \
    \         $left = $p + 1;\n            $p = partition($arr, $left, $right);\n\
    \        }\n    }\n    my @ans = ();\n    for(my $i = 0; $i < $k; $i++) {\n  \
    \      push @ans, $arr->[$i];\n    }\n    return \\@ans;\n}", "    if ($k <= 0)\
    \ {\n        return [];\n    }\n    if ($k >= @$arr) {\n        return [ sort\
    \ { $b <=> $a } @$arr ];\n    }\n    my @r = ( sort { $b <=> $a } @$arr[0..$k-1]\
    \ );\n    for (my $i = $k; $i < @$arr; $i++) {\n        if ($arr->[$i] < $r[$k-1])\
    \ {\n            $r[$k-1] = $arr->[$i];\n            for (my $j = $k-1; $j > 0;\
    \ $j--) {\n                if ($r[$j] > $r[$j-1]) {\n                    my $t\
    \ = $r[$j];\n                    $r[$j] = $r[$j-1];\n                    $r[$j-1]\
    \ = $t;\n                }\n            }\n        }\n    }\n    return \\@r;\n\
    }", "    return [] if $k == 0;\n    my $len = @$arr;\n    if ($k == $len) {\n\
    \        @$arr = sort {$b <=> $a} @$arr;\n        return $arr;\n    }\n    else\
    \ {\n        my $last = $k - 1;\n        my $left = 0;\n        my $right = $len\
    \ - 1;\n        $arr = quickSelect($arr, $left, $right, $last);\n        @$arr\
    \ = sort {$b <=> $a} @$arr;\n        return $arr;\n    }\n}", "    my @idx = sort\
    \ { $arr->[$b] <=> $arr->[$a] } 0..$#$arr;\n    @idx = @idx[0..$k-1];\n    my\
    \ @max = sort { $a <=> $b } @{$arr}[@idx];\n    return @max;\n}", "    my @sorted\
    \ = sort {$b <=> $a} @$arr;\n    splice @sorted, $k;\n    return @sorted;\n}",
  "    my @output = ();\n    for my $n (@$arr) {\n        if (@output < $k) {\n  \
    \          push @output, $n;\n        } else {\n            # insertion sort\n\
    \            my $i = @output;\n            for (; $i > 0 && $output[$i-1] < $n;\
    \ $i--) {\n                $output[$i] = $output[$i-1];\n            }\n     \
    \       $output[$i] = $n;\n        }\n    }\n    return \\@output;\n}", "    if\
    \ ($k > scalar @$arr) {\n        $k = scalar @$arr;\n    }\n    return [sort {$b\
    \ <=> $a} @$arr[0..$k-1]];\n}", "    my $n = scalar @$arr;\n    return $arr if\
    \ ($k == $n);\n    my $i = $n - 1;\n    my $j = $k - 1;\n    my $lastIdx = $n\
    \ - 1;\n    my $maxIdx = $n - 1;\n    my $tmp;\n    my $swapped = 0;\n    while\
    \ ($i > $j) {\n        # Find the biggest idx.\n        for ($maxIdx = $i; $maxIdx\
    \ > $j; $maxIdx--) {\n            if ($arr->[$maxIdx] > $arr->[$maxIdx - 1]) {\n\
    \                $swapped = 1;\n                $tmp = $arr->[$maxIdx];\n    \
    \            $arr->[$maxIdx] = $arr->[$maxIdx - 1];\n                $arr->[$maxIdx\
    \ - 1] = $tmp;\n            }\n        }\n        if ($swapped == 0) {\n     \
    \       # We've found the biggest value.\n            last;\n        }\n     \
    \   $swapped = 0;\n        $i--;\n        # Find the smallest idx.\n        for\
    \ ($lastIdx = $j; $lastIdx < $i; $lastIdx++) {\n            if ($arr->[$lastIdx]\
    \ > $arr->[$lastIdx + 1]) {\n                $swapped = 1;\n                $tmp\
    \ = $arr->[$lastIdx];\n                $arr->[$lastIdx] = $arr->[$lastIdx + 1];\n\
    \                $arr->[$lastIdx + 1] = $tmp;\n            }\n        }\n    \
    \    if ($swapped == 0) {\n            # We've found the smallest value.\n   \
    \         last;\n        }\n        $swapped = 0;\n        $j++;\n    }\n    my\
    \ @result = @$arr[$j..$n - 1];\n    return \\@result;\n}", "    my @sorted = sort\
    \ {$b <=> $a} @$arr;\n    @sorted[0..$k-1];\n}", "    my @res = sort {$b <=> $a}\
    \ @$arr;\n    @res = @res[0..$k-1];\n    return \\@res;\n}", "    my @arr = @$arr;\n\
    \    my @res;\n    my $len = @arr;\n    if($k > $len){\n        $k = $len;\n \
    \   }\n    for(my $i = 0; $i < $k; $i++){\n        my $max = $arr[$i];\n     \
    \   my $max_idx = $i;\n        for(my $j = $i + 1; $j < $len; $j++){\n       \
    \     if($arr[$j] > $max){\n                $max = $arr[$j];\n               \
    \ $max_idx = $j;\n            }\n        }\n        @arr[$i, $max_idx] = @arr[$max_idx,\
    \ $i];\n        $res[$i] = $max;\n    }\n    return @res;\n}", "    my @arr =\
    \ sort {$b <=> $a} @$arr;\n    @arr[0..$k-1];\n}", "    if(scalar(@$arr) <= $k)\
    \ {\n        return sort {$b <=> $a} @$arr;\n    }\n    my @idx;\n    for my $i\
    \ (0..$k - 1) {\n        $idx[$i] = $i;\n    }\n    for my $i ($k..$#$arr) {\n\
    \        my $minIdx = $idx[0];\n        my $minVal = $arr->[$minIdx];\n      \
    \  for my $j (1..$k - 1) {\n            if($arr->[$idx[$j]] < $minVal) {\n   \
    \             $minIdx = $idx[$j];\n                $minVal = $arr->[$minIdx];\n\
    \            }\n        }\n        if($arr->[$i] > $minVal) {\n            $idx[$minIdx]\
    \ = $i;\n        }\n    }\n    my @result;\n    for my $i (0..$k - 1) {\n    \
    \    push @result, $arr->[$idx[$i]];\n    }\n    return sort {$b <=> $a} @result;\n\
    }", "    return $arr if @$arr <= $k;\n    my $n = @$arr;\n    my $left = 0;\n\
    \    my $right = $n - 1;\n    my $index = partition($arr, $left, $right);\n  \
    \  while ($index != $k - 1) {\n        if ($index > $k - 1) {\n            $right\
    \ = $index - 1;\n            $index = partition($arr, $left, $right);\n      \
    \  } else {\n            $left = $index + 1;\n            $index = partition($arr,\
    \ $left, $right);\n        }\n    }\n    return [@$arr[0..$k-1]];\n}", "    if($k\
    \ <= 0) {\n        return [];\n    }\n    if($k >= @$arr) {\n        return sort\
    \ {$b <=> $a} @$arr;\n    }\n    # find the smallest k numbers in O(n) time\n\
    \    my @p;\n    foreach my $i (0..$k-1) {\n        $p[$i] = $i;\n    }\n    my\
    \ $p_i = 0;\n    my $p_length = $k;\n    foreach my $i ($k..@$arr-1) {\n     \
    \   if($arr->[$i] > $arr->[$p[$p_i]]) {\n            $p[$p_i] = $i;\n        \
    \    $p_i = ($p_i + 1) % $p_length;\n        }\n    }\n    my @v;\n    foreach\
    \ my $i (0..$k-1) {\n        $v[$i] = $arr->[$p[$i]];\n    }\n    return @v;\n\
    }", "    use POSIX qw(ceil);\n    my $n = @$arr;\n    my $mid = ceil($n / 2);\n\
    \    my $left = 0;\n    my $right = $n - 1;\n    my $pivot = partition($arr, $left,\
    \ $right);\n    while ($pivot != $mid) {\n        if ($pivot > $mid) {\n     \
    \       $right = $pivot - 1;\n            $pivot = partition($arr, $left, $right);\n\
    \        }\n        else {\n            $left = $pivot + 1;\n            $pivot\
    \ = partition($arr, $left, $right);\n        }\n    }\n    return [sort {$b <=>\
    \ $a} @$arr[($mid - $k)..($mid - 1)]];\n}", "    return [] if $k == 0;\n    my\
    \ @max;\n    for (my $i = 0; $i < $k; $i++) {\n        push @max, $arr->[$i];\n\
    \    }\n    for (my $i = $k; $i < @$arr; $i++) {\n        $max[$i%$k] = $arr->[$i];\n\
    \        my $min = min(@max);\n        my $minIdx = $min->[1];\n        if ($arr->[$i]\
    \ > $max[$minIdx]) {\n            $max[$minIdx] = $arr->[$i];\n        }\n   \
    \ }\n    @max = sort {$a <=> $b} @max;\n    return \\@max;\n}", "    my @sorted\
    \ = sort {$b <=> $a} @$arr;\n    return [@sorted[0..$k-1]];\n}", "    my $size\
    \ = scalar @$arr;\n    my $max = 0;\n    my $max2 = 0;\n    my $maxIndex = 0;\n\
    \    my $maxIndex2 = 0;\n    for(my $i = 0; $i < $size; $i++) {\n        if($arr->[$i]\
    \ > $max) {\n            $max2 = $max;\n            $maxIndex2 = $maxIndex;\n\
    \            $max = $arr->[$i];\n            $maxIndex = $i;\n        }\n    \
    \    elsif($arr->[$i] > $max2) {\n            $max2 = $arr->[$i];\n          \
    \  $maxIndex2 = $i;\n        }\n    }\n    @$arr[$maxIndex, $maxIndex2] = @$arr[$maxIndex2,\
    \ $maxIndex];\n    my @ans = ();\n    push @ans, $max;\n    push @ans, $max2;\n\
    \    return @ans;\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "   \
    \ die \"not enough numbers in the array\\n\" unless @$arr >= $k;\n    my @max;\n\
    \    foreach my $item (@$arr) {\n        if (@max < $k) {\n            push @max,\
    \ $item;\n            @max = sort {$b <=> $a} @max;\n        }\n        else {\n\
    \            my $min = $max[-1];\n            if ($item > $min) {\n          \
    \      pop @max;\n                push @max, $item;\n                @max = sort\
    \ {$b <=> $a} @max;\n            }\n        }\n    }\n    return @max;\n}", " \
    \   my @a = sort {$b <=> $a} @$arr;\n    my @b = splice(@a, 0, $k);\n    return\
    \ @b;\n}", "    my @heap = sort {$b <=> $a} @$arr[0..$k-1];\n    foreach my $x\
    \ (@$arr[$k..$#$arr]) {\n        if ($x > $heap[0]) {\n            $heap[0] =\
    \ $x;\n            @heap = sort {$b <=> $a} @heap;\n        }\n    }\n    return\
    \ \\@heap;\n}", "    my @max = ();\n    my $i = 0;\n    while ($i < @$arr) {\n\
    \        my $j = $#max;\n        while ($j >= 0 && $max[$j] < $arr->[$i]) {\n\
    \            splice(@max, $j, 1);\n            $j--;\n        }\n        if (@max\
    \ < $k) {\n            push @max, $arr->[$i];\n        }\n        $i++;\n    }\n\
    \    return @max;\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n}", "   \
    \ my @t;\n    $arr = [sort @$arr];\n    if ($k < scalar @$arr){\n        while\
    \ ($k){\n            push @t, pop @$arr;\n            $k--;\n        }\n    }\n\
    \    else {\n        @t = @$arr;\n    }\n    return \\@t;\n}", "    my @res =\
    \ ();\n    for (my $i = 0; $i < $k; $i++) {\n        push @res, $arr->[$i];\n\
    \    }\n    for (my $i = $k; $i < scalar @$arr; $i++) {\n        my $idx = first_idx\
    \ {$_ > $arr->[$i]} @res;\n        if ($idx > -1) {\n            splice @res,\
    \ $idx, 0, $arr->[$i];\n            pop @res;\n        }\n    }\n    return \\\
    @res;\n}", "    my @sorted = sort {$b <=> $a} @$arr;\n    return @sorted[0..$k-1];\n\
    }\nprint Dumper(\\&maximum);", "    $k = @$arr if $k > @$arr;\n    return sort\
    \ {$b <=> $a} @$arr[0..$k-1];\n}", "    my $heap = Heap::Simple->new(\n      \
    \  order => '<',\n        elements => 'Num',\n    );\n    for (@$arr) {\n    \
    \    $heap->insert($_);\n        $heap->extract_top if $heap->size > $k;\n   \
    \ }\n    return $heap->values;\n}", "    my @results;\n    my $size = scalar @$arr;\n\
    \    if ($k > $size) {\n        return @$arr;\n    }\n    foreach my $i (0..$size-1)\
    \ {\n        if (scalar @results < $k) {\n            push @results, $arr->[$i];\n\
    \        }\n        else {\n            my $p = $i + 1;\n            while ($p\
    \ < $size && $arr->[$p] > $arr->[$i]) {\n                $p++;\n            }\n\
    \            if ($p == $size) {\n                @results = sort {$b <=> $a} @results;\n\
    \                for (my $j = 0; $j < $k; $j++) {\n                    if ($arr->[$i]\
    \ > $results[$j]) {\n                        $results[$j] = $arr->[$i];\n    \
    \                    last;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    @results = sort {$b <=> $a} @results;\n    return\
    \ @results;\n}", "    my @sorted = sort {$b <=> $a} @$arr;\n    splice @sorted,\
    \ $k;\n    return @sorted;\n}", "    my @result;\n    my $arrLen = @$arr;\n  \
    \  if ($k > $arrLen) {\n        die \"k <= arrLen\\n\";\n    }\n    my $left =\
    \ 0;\n    my $right = $arrLen - 1;\n    while ($left <= $right) {\n        my\
    \ $pivot = partition($arr, $left, $right);\n        if ($pivot + 1 == $k) {\n\
    \            for (my $i = 0; $i < $k; $i++) {\n                push @result, $arr->[$i];\n\
    \            }\n            return @result;\n        } elsif ($pivot + 1 < $k)\
    \ {\n            $left = $pivot + 1;\n        } else {\n            $right = $pivot\
    \ - 1;\n        }\n    }\n}", "    my @res = sort {$b <=> $a} @$arr;\n    splice\
    \ @res, $k;\n    return @res;\n}", "    my $len = scalar @$arr;\n    if ($k >=\
    \ $len) {\n        @$arr = sort {$b <=> $a} @$arr;\n        return $arr;\n   \
    \ }\n    my $tmp = [];\n    for my $i (0..$k-1) {\n        $tmp->[$i] = $arr->[$i];\n\
    \    }\n    @$tmp = sort {$b <=> $a} @$tmp;\n    for my $i ($k..$len-1) {\n  \
    \      if ($arr->[$i] > $tmp->[$k-1]) {\n            $tmp->[$k-1] = $arr->[$i];\n\
    \            @$tmp = sort {$b <=> $a} @$tmp;\n        }\n    }\n    return $tmp;\n\
    }", "    my %count;\n    foreach my $x (@$arr) {\n        $count{$x}++;\n    }\n\
    \    my @max;\n    for (my $i = 0; $i < $k; $i++) {\n        my $max = 0;\n  \
    \      foreach my $x (keys %count) {\n            if ($count{$x} > $count{$max})\
    \ {\n                $max = $x;\n            }\n        }\n        push @max,\
    \ $max;\n        delete $count{$max};\n    }\n    return \\@max;\n}", "    return\
    \ [] if @$arr < $k;\n    my $n = scalar @$arr;\n    my $left = 0;\n    my $right\
    \ = $n - 1;\n    while ($left <= $right) {\n        my $j = partition($arr, $left,\
    \ $right);\n        if ($j == $k - 1) {\n            last;\n        } elsif ($j\
    \ > $k - 1) {\n            $right = $j - 1;\n        } else {\n            $left\
    \ = $j + 1;\n        }\n    }\n    my @ans = map { $arr->[$_] } (0 .. $k - 1);\n\
    \    return \\@ans;\n}", "    my @result;\n    my @sorted_arr = sort {$b <=> $a}\
    \ @$arr;\n    for my $i (0..$k-1) {\n        $result[$i] = $sorted_arr[$i];\n\
    \    }\n    return @result;\n}", "    my $len = @$arr;\n    my @result;\n    if\
    \ (defined $k && $k > 0 && $k <= $len) {\n        if ($k == 1) {\n           \
    \ my @array = sort {$b <=> $a} @$arr;\n            return [$array[0]];\n     \
    \   } else {\n            for (my $i = 0; $i < $k; $i++) {\n                my\
    \ $max = $arr->[$i];\n                my $maxIndex = $i;\n                for\
    \ (my $j = $i + 1; $j < $len; $j++) {\n                    if ($arr->[$j] > $max)\
    \ {\n                        $max = $arr->[$j];\n                        $maxIndex\
    \ = $j;\n                    }\n                }\n                @result[$i]\
    \ = $max;\n                my $temp = $arr->[$i];\n                $arr->[$i]\
    \ = $max;\n                $arr->[$maxIndex] = $temp;\n            }\n       \
    \ }\n    }\n    return \\@result;\n}", "    $k = @$arr if($k > @$arr);\n    my\
    \ @arr = @$arr;\n    my @out;\n    for my $i (0..$k-1) {\n        my $max_index\
    \ = $i;\n        for my $j ($i+1..@arr-1) {\n            $max_index = $j if($arr[$j]\
    \ > $arr[$max_index]);\n        }\n        $out[$i] = $arr[$max_index];\n    \
    \    $arr[$max_index] = $arr[$i];\n        $arr[$i] = $out[$i];\n    }\n    @out;\n\
    }", "    my $i;\n    my $len = scalar @$arr;\n    my @result;\n    if ($k >= $len)\
    \ {\n        return $arr;\n    }\n    for ($i = 0; $i < $k; $i++) {\n        my\
    \ $max = $arr->[$i];\n        my $index = $i;\n        my $j;\n        for ($j\
    \ = $i + 1; $j < $len; $j++) {\n            if ($arr->[$j] > $max) {\n       \
    \         $max = $arr->[$j];\n                $index = $j;\n            }\n  \
    \      }\n        if ($index != $i) {\n            @$arr[$i, $index] = @$arr[$index,\
    \ $i];\n        }\n        $result[$i] = $max;\n    }\n    return \\@result;\n\
    }", "    my $count = 0;\n    my @result;\n    my @output;\n    my $first_elem\
    \ = shift @$arr;\n    push @result, $first_elem;\n    $count++;\n    for (@$arr)\
    \ {\n        if ($count < $k) {\n            if ($_ > $first_elem) {\n       \
    \         unshift @result, $_;\n                $first_elem = $_;\n          \
    \  }\n            else {\n                push @result, $_;\n            }\n \
    \           $count++;\n        }\n        else {\n            if ($_ > $first_elem)\
    \ {\n                pop @result;\n                unshift @result, $_;\n    \
    \            $first_elem = $_;\n            }\n        }\n    }\n    print \"\
    @result\\n\";\n}", "    if(@$arr == $k) {\n        return $arr;\n    }\n    my\
    \ @max;\n    my $inserted = 0;\n    for(my $i = 0; $i < @$arr; $i++) {\n     \
    \   if($inserted == $k) {\n            if($arr->[$i] > $max[0]) {\n          \
    \      $max[0] = $arr->[$i];\n                _heapify(\\@max, 0);\n         \
    \   }\n        }\n        else {\n            push @max, $arr->[$i];\n       \
    \     _sift_up(\\@max, $inserted);\n            $inserted++;\n        }\n    }\n\
    \    return \\@max;\n}", "    return [ sort { $b <=> $a } @$arr[0..$k-1] ];\n}",
  "    my $len = @$arr;\n    return [] if !$len;\n    my $q = Heap::Fibonacci->new();\n\
    \    for my $i (0..$len-1) {\n        $q->add($arr->[$i], $arr->[$i]);\n    }\n\
    \    my @result;\n    for my $i (0..$k-1) {\n        my $res = $q->extract_top();\n\
    \        push @result, $res->val;\n    }\n    return \\@result;\n}", "    my $n\
    \ = scalar @$arr;\n    if ($k >= $n) {\n        return [ sort { $b <=> $a } @$arr\
    \ ];\n    }\n    my $res = [ @$arr[0..$k-1] ];\n    my $max = $k - 1;\n    @$res\
    \ = sort { $b <=> $a } @$res;\n    for (my $i = $k; $i < $n; $i++) {\n       \
    \ if ($arr->[$i] > $res->[$max]) {\n            $res->[$max] = $arr->[$i];\n \
    \           @$res = sort { $b <=> $a } @$res;\n        }\n    }\n    return $res;\n\
    }", "    return if $k > @$arr;\n    return $arr if $k == @$arr;\n    my @list\
    \ = @$arr;\n    my @ret;\n    while($k--) {\n        my $max = $list[0];\n   \
    \     my $i = 0;\n        foreach my $j (1..$#list) {\n            if($list[$j]\
    \ > $max) {\n                $max = $list[$j];\n                $i = $j;\n   \
    \         }\n        }\n        push @ret, $max;\n        splice @list, $i, 1;\n\
    \    }\n    return @ret;\n}\nprint join(', ', maximum([-3, -4, 5], 3)) . \"\\\
    n\";\nprint join(', ', maximum([4, -4, 4], 2)) . \"\\n\";\nprint join(', ', maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1)) . \"\\n\";", "    return [] if $k == 0;\n    my $len\
    \ = @$arr;\n    return $arr if $k >= $len;\n    my @sorted_arr = sort {$b <=>\
    \ $a} @$arr;\n    splice @sorted_arr, $k;\n    return \\@sorted_arr;\n}", "  \
    \  my $len = scalar @$arr;\n    if ($k == $len) { return $arr }\n    quickselect($arr,\
    \ 0, $len - 1, $len - $k);\n    return [splice @$arr, -$k, $k];\n}", "    $k =\
    \ @$arr if $k > @$arr;\n    my @result = ();\n    while (@result < $k) {\n   \
    \     my $max = shift @$arr;\n        my $maxIndex = 0;\n        foreach my $i\
    \ (0..@$arr-1) {\n            if ($arr->[$i] > $max) {\n                $max =\
    \ $arr->[$i];\n                $maxIndex = $i;\n            }\n        }\n   \
    \     push @result, $max;\n        splice @$arr, $maxIndex, 1;\n    }\n    return\
    \ @result;\n}", "    my $len = scalar @$arr;\n    $len > $k ? (sort {$b <=> $a}\
    \ @$arr)[0..$k-1] : (sort {$b <=> $a} @$arr)\n}", "    my @res = ();\n    my $arr_len\
    \ = scalar @$arr;\n    if($k > $arr_len){\n        return @res;\n    }\n    my\
    \ @tmp = sort {$b <=> $a} @$arr;\n    for(my $i = 0; $i < $k; $i++){\n       \
    \ push @res, $tmp[$i];\n    }\n    return @res;\n}", "    if($k == 0) { return\
    \ []; }\n    if($k >= scalar(@$arr)) { return [sort {$b <=> $a} @$arr]; }\n  \
    \  my $n = scalar(@$arr);\n    my @s = sort {$b <=> $a} @$arr[0..$k-1];\n    my\
    \ $i = $k;\n    while($i < $n) {\n        if($arr->[$i] > $s[$k-1]) {\n      \
    \      $s[$k-1] = $arr->[$i];\n            @s = sort {$b <=> $a} @s;\n       \
    \ }\n        $i++;\n    }\n    return \\@s;\n}", "    my @min_heap = sort {$a\
    \ <=> $b} @$arr[0..$k-1];\n    # Heap sort\n    my $i = $k;\n    while ($i < @$arr)\
    \ {\n        if ($arr->[$i] > $min_heap[0]) {\n            $min_heap[0] = $arr->[$i];\n\
    \            my $parent = 0;\n            my $child = 1;\n            do {\n \
    \               $parent = $child;\n                $child = $parent * 2 + 1;\n\
    \                if ($child + 1 < @min_heap && $min_heap[$child] > $min_heap[$child\
    \ + 1]) {\n                    $child++;\n                }\n                if\
    \ ($child < @min_heap && $min_heap[$parent] > $min_heap[$child]) {\n         \
    \           my $tmp = $min_heap[$parent];\n                    $min_heap[$parent]\
    \ = $min_heap[$child];\n                    $min_heap[$child] = $tmp;\n      \
    \          }\n            } while ($child < @min_heap);\n        }\n        $i++;\n\
    \    }\n    return \\@min_heap;\n}", "    return sort {$b <=> $a} @$arr[0..$k-1];\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
