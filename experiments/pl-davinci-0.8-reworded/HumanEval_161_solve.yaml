name: HumanEval_161_solve
language: pl
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve(\"1234\")\n# \"4321\"\n# >>> solve(\"ab\")\n\
  # \"AB\"\n# >>> solve(\"#a@C\")\n# \"#A@c\"\nsub solve {\n    my($s) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n\
  \        if(eq_deeply($candidate->(\"AsDf\"),\"aSdF\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1234\"\
  ),\"4321\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(\"ab\"),\"AB\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#a@C\"),\"#A@c\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  #AsdfW^45\"),\"#aSDFw^45\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"#6@2\"),\"2@6#\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  #$a^D\"),\"#$A^d\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"#ccc\"),\"#CCC\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return '' if $s eq '';\n    my @letters = map { /[a-z]/ ? $_ eq\
    \ lc($_) ? uc($_) : lc($_) : $_ }\n            split(//, $s);\n    return join('',\
    \ @letters);\n}", "    my $rev_str = '';\n    my $str_len = length($s);\n    for(my\
    \ $i=0; $i<$str_len; $i++) {\n        my $each_char = substr($s, $i, 1);\n   \
    \     if ($each_char =~ m/[a-z]/i) {\n            if ($each_char =~ m/[a-z]/)\
    \ {\n                $each_char = uc($each_char);\n            }\n           \
    \ else {\n                $each_char = lc($each_char);\n            }\n      \
    \  }\n        $rev_str = $each_char.$rev_str;\n    }\n    return $rev_str;\n}",
  "    if ( $s =~ /\\p{IsAlpha}/ ) {\n        $s =~ tr/a-zA-Z/A-Za-z/;\n    }\n  \
    \  else {\n        $s = reverse $s;\n    }\n    return $s;\n}", "    if ($s =~\
    \ /\\w/) {\n        my @chars = split //, $s;\n        for my $char (@chars) {\n\
    \            if ($char =~ /[a-z]/) {\n                $char = uc $char;\n    \
    \        } elsif ($char =~ /[A-Z]/) {\n                $char = lc $char;\n   \
    \         }\n        }\n        $s = join '', @chars;\n    } else {\n        $s\
    \ = reverse $s;\n    }\n    return $s;\n}", "    my @chars = split //, $s;\n \
    \   for(my $i = 0; $i < scalar @chars; $i++) {\n        if(($chars[$i] lt 'a'\
    \ or $chars[$i] gt 'z') and\n           ($chars[$i] lt 'A' or $chars[$i] gt 'Z'))\
    \ {\n            next;\n        }\n        $chars[$i] = uc $chars[$i] if $chars[$i]\
    \ lt 'a';\n        $chars[$i] = lc $chars[$i] if $chars[$i] ge 'a';\n    }\n \
    \   my $result = join '', @chars;\n    $result = reverse $result if $result =~\
    \ /^[^a-zA-Z]+$/;\n    return $result;\n}", "    my $reversed = reverse($s);\n\
    \    my $result;\n    for (my $i = 0; $i < length($s); $i++) {\n        if ($s[$i]\
    \ =~ /[a-zA-Z]/) {\n            $result .= uc($s[$i]);\n        } else {\n   \
    \         $result .= $s[$i];\n        }\n    }\n    return $result;\n}", "   \
    \ # Implement your solution here.\n    my $res = \"\";\n    for (my $i = 0; $i\
    \ < length($s); $i++) {\n        my $ch = substr($s, $i, 1);\n        if ($ch\
    \ ge \"a\" && $ch le \"z\") {\n            $res .= uc($ch);\n        } elsif ($ch\
    \ ge \"A\" && $ch le \"Z\") {\n            $res .= lc($ch);\n        } else {\n\
    \            $res .= $ch;\n        }\n    }\n    if ($res eq \"\") {\n       \
    \ return scalar reverse($s);\n    }\n    return $res;\n}", "    my @in = split\
    \ //, $s;\n    my @out;\n    for (@in) {\n        if (/[[:alpha:]]/) {\n     \
    \       push @out, $_ eq lc($_) ? uc($_) : lc($_);\n        } else {\n       \
    \     push @out, $_;\n        }\n    }\n    if (@out == 0) {\n        return reverse\
    \ $s;\n    } else {\n        return join '', @out;\n    }\n}", "    my $re;\n\
    \    if($s =~ /[a-zA-Z]/) {\n        $re = reverse $s;\n        $re =~ tr/[a-zA-Z]/[A-Za-z]/;\n\
    \    }\n    else {\n        $re = reverse $s;\n    }\n    return $re;\n}", " \
    \   if($s =~ /[a-zA-Z]/) {\n        if($s =~ /[a-z]/) {\n            $s =~ tr/a-z/A-Z/;\n\
    \        }\n        else {\n            $s =~ tr/A-Z/a-z/;\n        }\n    }\n\
    \    else {\n        $s = reverse $s;\n    }\n    return $s;\n}", "    my $r =\
    \ \"\";\n    my $l = \"\";\n    my $u = \"\";\n    my $m = \"\";\n    my $c =\
    \ 0;\n    my $n = 0;\n    my $f = 0;\n    my $t = 0;\n    my $x = 0;\n    my $i\
    \ = 0;\n    for(my $i = 0; $i < length($s); $i++) {\n        $l = $u = \"\";\n\
    \        $m = substr($s, $i, 1);\n        $c = ord($m);\n        $n = $c - ord(\"\
    a\");\n        $f = $c - ord(\"A\");\n        $t = 0;\n        if(($n >= 0) &&\
    \ ($n <= 25)) {\n            $l = $m;\n            $u = chr($c - 32);\n      \
    \      $t = 1;\n        }\n        if(($f >= 0) && ($f <= 25)) {\n           \
    \ $l = chr($c + 32);\n            $u = $m;\n            $t = 1;\n        }\n \
    \       if($t) {\n            $r = $r . $u;\n        } else {\n            $r\
    \ = $r . $m;\n        }\n    }\n    return $r;\n}\n$s = <STDIN>;\nprint(solve($s).\"\
    \\n\");", "    # your code here\n}", "    my @s = split //, $s;\n    my @n = reverse\
    \ @s;\n    for(my $i = 0; $i < scalar @n; $i++) {\n        if(ord($n[$i]) >= 65\
    \ && ord($n[$i]) <= 90) {\n            $n[$i] = lc($n[$i]);\n        }elsif(ord($n[$i])\
    \ >= 97 && ord($n[$i]) <= 122) {\n            $n[$i] = uc($n[$i]);\n        }\n\
    \    }\n    return join '', @n;\n}", "    my $result;\n    my $i = 0;\n    my\
    \ $has_letter = 0;\n    while ($i < length($s)) {\n        if ($s =~ /[a-zA-Z]/)\
    \ {\n            $has_letter = 1;\n        }\n        if ($s =~ /[a-z]/) {\n \
    \           substr($s, $i, 1) = uc(substr($s, $i, 1));\n        } elsif ($s =~\
    \ /[A-Z]/) {\n            substr($s, $i, 1) = lc(substr($s, $i, 1));\n       \
    \ }\n        $i++;\n    }\n    if ($has_letter) {\n        return $s;\n    } else\
    \ {\n        return scalar reverse $s;\n    }\n}", "    if($s =~ /[a-zA-Z]/) {\n\
    \        $s =~ tr/a-zA-Z/A-Za-z/;\n    }\n    else {\n        $s = reverse $s;\n\
    \    }\n    return $s;\n}", "    my @chars = split //, $s;\n    for (my $i = 0;\
    \ $i < scalar @chars; $i++) {\n        if (is_letter($chars[$i])) {\n        \
    \    if (is_upper($chars[$i])) {\n                $chars[$i] = uc($chars[$i]);\n\
    \            } else {\n                $chars[$i] = lc($chars[$i]);\n        \
    \    }\n        }\n    }\n    return join \"\", @chars;\n}", "    $s = reverse\
    \ $s;\n    return $s unless $s =~ /[a-zA-Z]/;\n    my @chars = split //, $s;\n\
    \    foreach (@chars) {\n        if (/[a-z]/) {\n            $_ = uc $_;\n   \
    \     } elsif (/[A-Z]/) {\n            $_ = lc $_;\n        }\n    }\n    return\
    \ join '', @chars;\n}", "    if($s =~ /[a-zA-Z]/) {\n        $s =~ tr/a-zA-Z/A-Za-z/;\n\
    \    }\n    else {\n        $s = reverse $s;\n    }\n    return $s;\n}", "   \
    \ if($s =~ /[a-zA-Z]/) {\n        return reverse($s);\n    }\n    else {\n   \
    \     return reverse(uc($s));\n    }\n}", "    if ($s =~ /[a-zA-Z]/) {\n     \
    \   $s =~ tr/a-zA-Z/A-Za-z/;\n    }\n    else {\n        $s = reverse $s;\n  \
    \  }\n    return $s;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
