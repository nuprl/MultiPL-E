name: HumanEval_21_rescale_to_unit
language: pl
prompt: "# Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n# such that the smallest number will become 0 and the largest\
  \ will become 1\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nsub rescale_to_unit {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rescale_to_unit;\n\
  \        if(eq_deeply($candidate->([2.0, 49.9]),[0.0, 1.0])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0,\
  \ 49.9]),[1.0, 0.0])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5,\
  \ 0.75, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5,\
  \ 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12.0,\
  \ 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $len = scalar(@$numbers);\n    my $min = min(@$numbers);\n \
    \   my $max = max(@$numbers);\n    my $range = $max - $min;\n    if ($range <=\
    \ 0) {\n        return [ (1.0) x $len ];\n    }\n    my @res;\n    for (my $i\
    \ = 0; $i < $len; $i++) {\n        my $val = $numbers->[$i];\n        my $scaled\
    \ = ($val - $min) / $range;\n        push @res, $scaled;\n    }\n    return \\\
    @res;\n}", "    croak \"rescale_to_unit: at least 2 numbers needed\" unless @$numbers\
    \ >= 2;\n    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my\
    \ $delta = $max - $min;\n    my @rescaled = ();\n    for my $val (@$numbers) {\n\
    \        my $rescaled = ($val - $min) / $delta;\n        push @rescaled, $rescaled;\n\
    \    }\n    return @rescaled;\n}", "    my $min = min(@$numbers);\n    my $max\
    \ = max(@$numbers);\n    my $range = $max - $min;\n    return map { ($_ - $min)\
    \ / $range } @$numbers;\n}", "    my $m = min(@$numbers);\n    my $M = max(@$numbers);\n\
    \    if ($m == $M) {\n        return [ map { 1 } @$numbers ];\n    }\n    else\
    \ {\n        return [ map { ($_ - $m) / ($M - $m) } @$numbers ];\n    }\n}", " \
    \   my($min, $max) = (1_000_000, -1_000_000);\n    for my $i (@$numbers) {\n \
    \       $min = $i if $i < $min;\n        $max = $i if $i > $max;\n    }\n    my\
    \ $range = $max - $min;\n    return $range ? map { ($_ - $min) / $range } @$numbers\
    \ : @$numbers;\n}", "    my @numbers = @$numbers;\n    my $min = min(@numbers);\n\
    \    my $max = max(@numbers);\n    my $range = $max - $min;\n    if ($range) {\n\
    \        my @result = map {($_ - $min) / $range} @numbers;\n        return @result;\n\
    \    } else {\n        return (1) x @numbers;\n    }\n}", "    my $min_number\
    \ = min @$numbers;\n    my $max_number = max @$numbers;\n    return map { ($_\
    \ - $min_number) / ($max_number - $min_number) } @$numbers;\n}", "    croak \"\
    rescale_to_unit: not an array reference\" if ref($numbers) ne 'ARRAY';\n    croak\
    \ \"rescale_to_unit: empty array\" unless @$numbers > 0;\n    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $range = $max - $min;\n    return $range\
    \ == 0 ? [] : [ map { ($_ - $min) / $range } @$numbers ];\n}", '    return $numbers
    unless @$numbers > 1;', "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n\
    \    my $denom = $max - $min;\n    return map { ($_ - $min) / $denom } @$numbers;\n\
    }", "    my $min = find_min($numbers);\n    my $max = find_max($numbers);\n  \
    \  return [ map { $_ / $max } @$numbers ];\n}", "    my $min = min @$numbers;\n\
    \    my $max = max @$numbers;\n    my $range = $max - $min;\n    my @rescaled\
    \ = map { ( $_ - $min ) / $range } @$numbers;\n    return @rescaled;\n}", "  \
    \  my @out;\n    my($min, $max) = max_min(@$numbers);\n    foreach my $n (@$numbers)\
    \ {\n        if($max == $min) {\n            push @out, 0.5;\n        } else {\n\
    \            push @out, ($n - $min) / ($max - $min);\n        }\n    }\n    return\
    \ @out;\n}", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n \
    \   return [ map { ($_ - $min) / ($max - $min) } @$numbers ];\n}", "    my $min\
    \ = $numbers->[0];\n    my $max = $numbers->[0];\n    for my $number (@$numbers)\
    \ {\n        $min = $number if $number < $min;\n        $max = $number if $number\
    \ > $max;\n    }\n    my $range = $max - $min;\n    return [map { ($_ - $min)\
    \ / $range } @$numbers];\n}", "    my($min) = min(@$numbers);\n    my($max) =\
    \ max(@$numbers);\n    return [ map { rescale_value_to_unit($_, $min, $max) }\
    \ @$numbers ];\n}", "    my($min, $max) = minmax(@$numbers);\n    my @rescaled\
    \ = ();\n    for my $number (@$numbers) {\n        push @rescaled, ($number -\
    \ $min) / ($max - $min);\n    }\n    return @rescaled;\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $range = $max - $min;\n    return [map\
    \ { ($_ - $min) / $range } @$numbers];\n}", "    my $max = max @$numbers;\n  \
    \  my $min = min @$numbers;\n    my $scale = 1 / ($max - $min);\n    my @scaled_numbers\
    \ = map { ($_ - $min) * $scale } @$numbers;\n    return @scaled_numbers;\n}",
  "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $delta = $max\
    \ - $min;\n    return [map { ($_ - $min) / $delta } @$numbers];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
