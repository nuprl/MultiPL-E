name: HumanEval_21_rescale_to_unit
language: pl
prompt: "# Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n# such that the smallest number will become 0 and the largest\
  \ will become 1\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nsub rescale_to_unit {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rescale_to_unit;\n\
  \        if(eq_deeply($candidate->([2.0, 49.9]),[0.0, 1.0])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0,\
  \ 49.9]),[1.0, 0.0])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5,\
  \ 0.75, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5,\
  \ 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12.0,\
  \ 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $len = scalar(@$numbers);\n    my $min = min(@$numbers);\n \
    \   my $max = max(@$numbers);\n    my $range = $max - $min;\n    if ($range <=\
    \ 0) {\n        return [ (1.0) x $len ];\n    }\n    my @res;\n    for (my $i\
    \ = 0; $i < $len; $i++) {\n        my $val = $numbers->[$i];\n        my $scaled\
    \ = ($val - $min) / $range;\n        push @res, $scaled;\n    }\n    return \\\
    @res;\n}", "    croak \"rescale_to_unit: at least 2 numbers needed\" unless @$numbers\
    \ >= 2;\n    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my\
    \ $delta = $max - $min;\n    my @rescaled = ();\n    for my $val (@$numbers) {\n\
    \        my $rescaled = ($val - $min) / $delta;\n        push @rescaled, $rescaled;\n\
    \    }\n    return @rescaled;\n}", "    my $min = min(@$numbers);\n    my $max\
    \ = max(@$numbers);\n    my $range = $max - $min;\n    return map { ($_ - $min)\
    \ / $range } @$numbers;\n}", "    my $m = min(@$numbers);\n    my $M = max(@$numbers);\n\
    \    if ($m == $M) {\n        return [ map { 1 } @$numbers ];\n    }\n    else\
    \ {\n        return [ map { ($_ - $m) / ($M - $m) } @$numbers ];\n    }\n}", " \
    \   my($min, $max) = (1_000_000, -1_000_000);\n    for my $i (@$numbers) {\n \
    \       $min = $i if $i < $min;\n        $max = $i if $i > $max;\n    }\n    my\
    \ $range = $max - $min;\n    return $range ? map { ($_ - $min) / $range } @$numbers\
    \ : @$numbers;\n}", "    my @numbers = @$numbers;\n    my $min = min(@numbers);\n\
    \    my $max = max(@numbers);\n    my $range = $max - $min;\n    if ($range) {\n\
    \        my @result = map {($_ - $min) / $range} @numbers;\n        return @result;\n\
    \    } else {\n        return (1) x @numbers;\n    }\n}", "    my $min_number\
    \ = min @$numbers;\n    my $max_number = max @$numbers;\n    return map { ($_\
    \ - $min_number) / ($max_number - $min_number) } @$numbers;\n}", "    croak \"\
    rescale_to_unit: not an array reference\" if ref($numbers) ne 'ARRAY';\n    croak\
    \ \"rescale_to_unit: empty array\" unless @$numbers > 0;\n    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $range = $max - $min;\n    return $range\
    \ == 0 ? [] : [ map { ($_ - $min) / $range } @$numbers ];\n}", '    return $numbers
    unless @$numbers > 1;', "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n\
    \    my $denom = $max - $min;\n    return map { ($_ - $min) / $denom } @$numbers;\n\
    }", "    my $min = find_min($numbers);\n    my $max = find_max($numbers);\n  \
    \  return [ map { $_ / $max } @$numbers ];\n}", "    my $min = min @$numbers;\n\
    \    my $max = max @$numbers;\n    my $range = $max - $min;\n    my @rescaled\
    \ = map { ( $_ - $min ) / $range } @$numbers;\n    return @rescaled;\n}", "  \
    \  my @out;\n    my($min, $max) = max_min(@$numbers);\n    foreach my $n (@$numbers)\
    \ {\n        if($max == $min) {\n            push @out, 0.5;\n        } else {\n\
    \            push @out, ($n - $min) / ($max - $min);\n        }\n    }\n    return\
    \ @out;\n}", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n \
    \   return [ map { ($_ - $min) / ($max - $min) } @$numbers ];\n}", "    my $min\
    \ = $numbers->[0];\n    my $max = $numbers->[0];\n    for my $number (@$numbers)\
    \ {\n        $min = $number if $number < $min;\n        $max = $number if $number\
    \ > $max;\n    }\n    my $range = $max - $min;\n    return [map { ($_ - $min)\
    \ / $range } @$numbers];\n}", "    my($min) = min(@$numbers);\n    my($max) =\
    \ max(@$numbers);\n    return [ map { rescale_value_to_unit($_, $min, $max) }\
    \ @$numbers ];\n}", "    my($min, $max) = minmax(@$numbers);\n    my @rescaled\
    \ = ();\n    for my $number (@$numbers) {\n        push @rescaled, ($number -\
    \ $min) / ($max - $min);\n    }\n    return @rescaled;\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $range = $max - $min;\n    return [map\
    \ { ($_ - $min) / $range } @$numbers];\n}", "    my $max = max @$numbers;\n  \
    \  my $min = min @$numbers;\n    my $scale = 1 / ($max - $min);\n    my @scaled_numbers\
    \ = map { ($_ - $min) * $scale } @$numbers;\n    return @scaled_numbers;\n}",
  "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $delta = $max\
    \ - $min;\n    return [map { ($_ - $min) / $delta } @$numbers];\n}", "    if (@$numbers\
    \ < 2) {\n        die \"You can't rescale a list of less than two numbers\";\n\
    \    }\n    my($min) = min(@$numbers);\n    my($max) = max(@$numbers);\n    my($result)\
    \ = [];\n    foreach my $number (@$numbers) {\n        my($fraction) = ($number\
    \ - $min) / ($max - $min);\n        push(@$result, $fraction);\n    }\n    return\
    \ $result;\n}", "    die \"Not implemented\\n\";\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    return map { ($_ - $min) / ($max - $min) }\
    \ @$numbers;\n}", "    my($smallest, $largest) = (sort {$a <=> $b} @$numbers)[0,\
    \ -1];\n    my $scale = $largest - $smallest;\n    return map {($_ - $smallest)\
    \ / $scale} @$numbers;\n}", "    my $scaled_numbers = [];\n    my $min = min @$numbers;\n\
    \    my $max = max @$numbers;\n    my $diff = $max - $min;\n    if($diff == 0)\
    \ {\n        $diff = 1;\n    }\n    foreach my $number (@$numbers) {\n       \
    \ push @$scaled_numbers, ( $number - $min ) / $diff;\n    }\n    return $scaled_numbers;\n\
    }", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $delta\
    \ = $max - $min;\n    if ($delta == 0) {\n        $delta = 1;\n    }\n    my @result\
    \ = map {\n        my $v = ($_ - $min) / $delta;\n        $v\n    } @$numbers;\n\
    \    return \\@result;\n}", "    my $smallest = min(@$numbers);\n    my $largest\
    \ = max(@$numbers);\n    my $largest_minus_smallest = $largest - $smallest;\n\
    \    my @rescaled = map { $_ - $smallest } @$numbers;\n    if ($largest_minus_smallest\
    \ != 0) {\n        @rescaled = map { $_ / $largest_minus_smallest } @rescaled;\n\
    \    }\n    return @rescaled;\n}", "    my($max, $min);\n    foreach (@$numbers)\
    \ {\n        if(!defined($max) || $max < $_) {\n            $max = $_;\n     \
    \   }\n        if(!defined($min) || $min > $_) {\n            $min = $_;\n   \
    \     }\n    }\n    if($max == $min) {\n        return map { 0.5 } @$numbers;\n\
    \    }\n    return map { ($_ - $min) / ($max - $min) } @$numbers;\n}", "    my($low,\
    \ $high) = ($numbers->[0], $numbers->[0]);\n    for my $n (@$numbers) {\n    \
    \    $low = $n if $n < $low;\n        $high = $n if $n > $high;\n    }\n    return\
    \ map { ($_ - $low) / ($high - $low) } @$numbers;\n}", "    my($min, $max) = minmax(@$numbers);\n\
    \    return [map { $_ - $min } @$numbers] if $min == $max; # avoid divide by zero\
    \ if all values are the same\n    return [map { ($_ - $min) / ($max - $min) }\
    \ @$numbers];\n}", "    my($min, $max) = minmax(@$numbers);\n    return [ map\
    \ { ($_ - $min) / ($max - $min) } @$numbers ];\n}", "    die \"rescale_to_unit()\
    \ only works with arrays of at least two elements\" if $#$numbers < 1;\n    my\
    \ $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $range = $max\
    \ - $min;\n    $range = 1 if $range == 0;\n    return map { ($_ - $min) / $range\
    \ } @$numbers;\n}", "    my $max = max(@$numbers);\n    my $min = min(@$numbers);\n\
    \    if (abs($max - $min) < 1e-9) {\n        warn \"min = max = $min; trying to\
    \ scale to unit array\";\n        return [map {0.5} @$numbers];\n    }\n    my\
    \ $divisor = $max - $min;\n    [map {($_ - $min) / $divisor} @$numbers];\n}",
  "    my($min) = min(@$numbers);\n    my($max) = max(@$numbers);\n    my $delta =\
    \ $max - $min;\n    return map { ($_ - $min) / $delta } @$numbers;\n}", "    my\
    \ $n = scalar(@$numbers);\n    my @numbers = sort { $a <=> $b } @$numbers;\n \
    \   my $min = $numbers[0];\n    my $max = $numbers[$n - 1];\n    my $range = $max\
    \ - $min;\n    my @transformed;\n    for my $i (0..$n - 1) {\n        $transformed[$i]\
    \ = ($numbers[$i] - $min) / $range;\n    }\n    return @transformed;\n}", "  \
    \  my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $range = $max\
    \ - $min;\n    my @rescaled = map { ($_ - $min) / $range } @$numbers;\n    return\
    \ @rescaled;\n}", "    if (@$numbers < 2) {\n        die 'Need at least two input\
    \ values for rescaling to unit';\n    }\n    my $min = min(@$numbers);\n    my\
    \ $max = max(@$numbers);\n    if ($min == $max) {\n        warn \"Did not scale\
    \ to unit, as all numbers equal $min\\n\";\n        return @$numbers;\n    }\n\
    \    return map { ($_ - $min) / ($max - $min) } @$numbers;\n}", "    my $min =\
    \ min(@$numbers);\n    my $max = max(@$numbers);\n    # Don't divide by zero\n\
    \    return $numbers if $max == $min;\n    return [map { ($_ - $min) / ($max -\
    \ $min) } @$numbers];\n}", "    return [] unless @$numbers;\n    my($min) = min\
    \ @$numbers;\n    my($max) = max @$numbers;\n    my($range) = $max - $min;\n \
    \   return [] if $range <= 0;\n    return [ map { ( $_ - $min ) / $range } @$numbers\
    \ ];\n}", "    my($len) = scalar(@$numbers);\n    my($min) = min(@$numbers);\n\
    \    my($max) = max(@$numbers);\n    my($diff) = $max - $min;\n    if ($diff >\
    \ 0) {\n        my($rv) = [];\n        foreach my $i (0..$len-1) {\n         \
    \   my($x) = $$numbers[$i];\n            push(@$rv, ($x - $min) / $diff);\n  \
    \      }\n        return $rv;\n    } else {\n        return [];\n    }\n}", " \
    \   my($low, $high) = (min(@$numbers), max(@$numbers));\n    if ($low == $high)\
    \ {\n        my $zero_to_one = ($low <= 0) ? 0 : 1;\n        return [map { $zero_to_one\
    \ } @$numbers];\n    }\n    return [map { ($_ - $low) / ($high - $low) } @$numbers];\n\
    }", "    my $max_number = max($numbers);\n    my $min_number = min($numbers);\n\
    \    my $max_min_diff = $max_number - $min_number;\n    my @rescaled_numbers =\
    \ map { ($_ - $min_number) / $max_min_diff } @$numbers;\n    return \\@rescaled_numbers;\n\
    }", "    return map { ($_ - min($numbers)) / (max($numbers) - min($numbers)) }\
    \ @$numbers;\n}", "    my($min, $max) = minmax(@$numbers);\n    my($range) = $max\
    \ - $min;\n    return [ map { ($_ - $min) / $range } @$numbers ];\n}", "    my\
    \ $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $diff = $max -\
    \ $min;\n    return map { ($_ - $min) / $diff } @$numbers;\n}", "    my @rescaled;\n\
    \    return @rescaled unless @$numbers > 1;\n    my $min = min(@$numbers);\n \
    \   my $max = max(@$numbers);\n    my $range = $max - $min;\n    foreach my $number\
    \ (@$numbers) {\n        push @rescaled, ($number - $min) / $range;\n    }\n \
    \   return @rescaled;\n}", "    my $len = @$numbers;\n    if ($len == 0) {\n \
    \       return [];\n    } elsif ($len == 1) {\n        return [0];\n    }\n  \
    \  my $min = min @$numbers;\n    my $max = max @$numbers;\n    my $scale = 1.0\
    \ / ($max - $min);\n    my @result = map { ($_ - $min) * $scale } @$numbers;\n\
    \    return \\@result;\n}", "    die 'Argument must be an array' unless (ref($numbers)\
    \ eq 'ARRAY');\n    die 'Array must contain at least two elements' unless (scalar(@$numbers)\
    \ >= 2);\n    my($min, $max) = minmax(@$numbers);\n    my($delta) = $max - $min;\n\
    \    return [map {($_ - $min) / $delta} @$numbers];\n}", "    my $min = min @$numbers;\n\
    \    my $max = max @$numbers;\n    return [ map { ( $_ - $min ) / ( $max - $min\
    \ ) } @$numbers ];\n}", "    my($min) = $numbers->[0];\n    my($max) = $numbers->[0];\n\
    \    for (my($i) = 1; $i < @$numbers; $i++) {\n        if ($numbers->[$i] < $min)\
    \ {\n            $min = $numbers->[$i];\n        }\n        if ($numbers->[$i]\
    \ > $max) {\n            $max = $numbers->[$i];\n        }\n    }\n    my($scale)\
    \ = 1 / ($max - $min);\n    my($results) = [];\n    for (my($i) = 0; $i < @$numbers;\
    \ $i++) {\n        push(@$results, ($numbers->[$i] - $min) * $scale);\n    }\n\
    \    return $results;\n}", "    my $min = min($numbers);\n    my $max = max($numbers);\n\
    \    return [map {$min == $max ? 0.5 : ($_ - $min) / ($max - $min)} @$numbers];\n\
    }", "    my $min = min @$numbers;\n    my $max = max @$numbers;\n    my $n = @$numbers;\n\
    \    my $delta = $max - $min;\n    if ($delta == 0) {\n        return [0.5; $n];\n\
    \    }\n    [map {($_ - $min) / $delta} @$numbers];\n}", "    my $s = min(@$numbers);\n\
    \    my $t = max(@$numbers);\n    my $result = [map { ($_ - $s) / ($t - $s) }\
    \ @$numbers];\n    return $result;\n}", "    my($min, $max) = minmax(@$numbers);\n\
    \    return map { ($_ - $min) / ($max - $min) } @$numbers;\n}", "    my $min =\
    \ min(@$numbers);\n    my $max = max(@$numbers);\n    return [ map { ( $_ - $min\
    \ ) / ( $max - $min ) } @$numbers ];\n}", "    my $min = min @$numbers;\n    my\
    \ $max = max @$numbers;\n    my $diff = $max - $min;\n    return map { ($_ - $min)\
    \ / $diff } @$numbers;\n}", "    my $max_number = max(@$numbers);\n    my $min_number\
    \ = min(@$numbers);\n    my $range = $max_number - $min_number;\n    return [map\
    \ {($_ - $min_number) / $range} @$numbers];\n}", "    die \"rescale_to_unit(undef)\"\
    \ if !defined $numbers;\n    die \"rescale_to_unit([])\" if !@$numbers;\n    my($min,\
    \ $max) = _min_max($numbers);\n    [map { ($_ - $min) / ($max - $min) } @$numbers];\n\
    }", "    my($max) = max($numbers);\n    my($min) = min($numbers);\n    return\
    \ map { ($_ - $min) / ($max - $min) } @$numbers;\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $delta = $max - $min;\n    return $delta\
    \ ? [ map { ($_ - $min) / $delta } @$numbers ] : [ @$numbers ];\n}", "    my($min,\
    \ $max) = ($numbers->[0], $numbers->[0]);\n    for my $x (@$numbers) {\n     \
    \   $min = $x if $x < $min;\n        $max = $x if $x > $max;\n    }\n    return\
    \ map { ($_ - $min) / ($max - $min) } @$numbers;\n}", "    my @sorted = sort {\
    \ $a <=> $b } @$numbers;\n    my $min = $sorted[0];\n    my $max = $sorted[-1];\n\
    \    return unless $max - $min > 0;\n    map { ($_ - $min) / ($max - $min) } @$numbers;\n\
    }", "    return [] unless @$numbers;\n    my $min = min(@$numbers);\n    my $max\
    \ = max(@$numbers);\n    my $range = $max - $min;\n    my $result = [];\n    foreach\
    \ my $n (@$numbers) {\n        push @$result, ($n - $min) / $range;\n    }\n \
    \   return $result;\n}", "    my($min) = min(@$numbers);\n    my($max) = max(@$numbers);\n\
    \    my($range) = $max - $min;\n    return [map {($_ - $min) / $range} @$numbers];\n\
    }", "    my($min, $max) = minmax(@$numbers);\n    return map { $_ / $max } @$numbers;\n\
    }", "    my($min, $max) = ($numbers->[0], $numbers->[0]);\n    foreach (@$numbers)\
    \ {\n        $min = $_ if $_ < $min;\n        $max = $_ if $_ > $max;\n    }\n\
    \    my $range = $max - $min;\n    return [map { ($_ - $min) / $range } @$numbers];\n\
    }", "    my($min, $max);\n    for my $num (@$numbers) {\n        if (!defined($min)\
    \ || $num < $min) {\n            $min = $num;\n        }\n        if (!defined($max)\
    \ || $num > $max) {\n            $max = $num;\n        }\n    }\n    my $range\
    \ = $max - $min;\n    my @new_numbers;\n    for my $num (@$numbers) {\n      \
    \  my $new_num = ($num - $min) / $range;\n        push @new_numbers, $new_num;\n\
    \    }\n    return \\@new_numbers;\n}", "    my $max = max @$numbers;\n    my\
    \ $min = min @$numbers;\n    my $scale = $max - $min;\n    my @result = map {\
    \ ($_ - $min) / $scale } @$numbers;\n    return @result;\n}", "    my($min, $max)\
    \ = (min(@$numbers), max(@$numbers));\n    my $scale = ($max - $min);\n    if($scale\
    \ == 0) {\n        # Every number is the same,\n        # so just return a list\
    \ of 0's\n        return 0 x scalar(@$numbers);\n    }\n    my $scaled_values\
    \ = [];\n    for my $n (@$numbers) {\n        push @$scaled_values, ($n - $min)\
    \ / $scale;\n    }\n    return $scaled_values;\n}", "    my @numbers = @$numbers;\n\
    \    my $min = min @numbers;\n    my $max = max @numbers;\n    my $range = $max\
    \ - $min;\n    return [ map { (($_ - $min) / $range) } @numbers ];\n}", "    my($min,\
    \ $max) = minmax(@$numbers);\n    return [map {($_ - $min) / ($max - $min)} @$numbers];\n\
    }", "    my($min, $max) = minmax($numbers);\n    my($scaling_factor) = 1.0 / ($max\
    \ - $min);\n    my(@result) = ();\n    foreach my $number (@$numbers) {\n    \
    \    my($normalized) = ($number - $min) * $scaling_factor;\n        push(@result,\
    \ $normalized);\n    }\n    return @result;\n}", "    my @unorm;\n    my($min,\
    \ $max) = get_min_max($numbers);\n    for my $number (@$numbers) {\n        my\
    \ $num = ($number - $min) / ($max - $min);\n        push @unorm, $num;\n    }\n\
    \    return \\@unorm;\n}", "    my @numbers = @$numbers;\n    croak \"At least\
    \ two values required\" unless @numbers >= 2;\n    my $min = min(@numbers);\n\
    \    my $max = max(@numbers);\n    my $span = $max - $min;\n    return map { ($_\
    \ - $min) / $span } @numbers;\n}", "    die unless defined $numbers;\n    my $n\
    \ = scalar @$numbers;\n    die unless $n >= 2;\n    my($min, $max) = (min @$numbers,\
    \ max @$numbers);\n    my $span = $max - $min;\n    die if $span == 0;\n    my\
    \ @result = map { ($_ - $min) / $span } @$numbers;\n    return @result;\n}", " \
    \   my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $span = $max\
    \ - $min;\n    $span = 1 if $span == 0;\n    return [ map { ($_ - $min) / $span\
    \ } @$numbers ];\n}", "    my $min = min(@$numbers);\n    my $range = max(@$numbers)\
    \ - $min;\n    return map { ($_ - $min) / $range } @$numbers;\n}", "    my $min\
    \ = __PACKAGE__->min($numbers);\n    my $max = __PACKAGE__->max($numbers);\n \
    \   my $span = $max - $min;\n    return map { ($_ - $min) / $span } @$numbers;\n\
    }", "    die \"array of numbers is required\" unless is_array_of_numbers($numbers);\n\
    \    return [] if @$numbers == 0;\n    my $min = min(@$numbers);\n    my $max\
    \ = max(@$numbers);\n    my $range = $max - $min;\n    if ($range == 0) {\n  \
    \      return map { 1 } @$numbers;\n    }\n    return map { ($_ - $min) / $range\
    \ } @$numbers;\n}", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n\
    \    my($delta) = $max - $min;\n    my($result) = [];\n    push @$result, (($_\
    \ - $min) / $delta) foreach @$numbers;\n    return $result;\n}", "    my($n, $min,\
    \ $max, $normed_n);\n    $min = $max = $$numbers[0];\n    for $n (@$numbers) {\n\
    \        $min = $n if $n < $min;\n        $max = $n if $n > $max;\n    }\n   \
    \ return [map { ($_ - $min) / ($max - $min) } @$numbers];\n}", "    my($min) =\
    \ min(@$numbers);\n    my($max) = max(@$numbers);\n    my(@result);\n    my($x);\n\
    \    foreach $x (@$numbers) {\n        push(@result, ($x - $min) / ($max - $min));\n\
    \    }\n    return @result;\n}", "    # Smallest number\n    my $min = List::Util::min(@$numbers);\n\
    \    # Largest number\n    my $max = List::Util::max(@$numbers);\n    my $scale\
    \ = $max - $min;\n    # If min and max are the same, then this becomes a constant\
    \ array\n    # of zeros.\n    return [ map { ($_ - $min) / $scale } @$numbers\
    \ ];\n}", "    return _rescale_to_unit($numbers, 0, 1);\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $range = $max - $min;\n    return map {\
    \ ($_ - $min) / $range } @$numbers;\n}", "    my $min = min(@$numbers);\n    my\
    \ $max = max(@$numbers);\n    return map { ($_ - $min) / ($max - $min) } @$numbers;\n\
    }", "    my($numbers_with_minmax) = _numbers_with_minmax($numbers);\n    my($numbers_with_unit)\
    \ = _numbers_with_unit($numbers_with_minmax);\n    return $numbers_with_unit;\n\
    }", "    return [ map { $_->[0] / $_->[1] } pairwise { [$a, $b] } @$numbers, max\
    \ @$numbers ];\n}", "    my($min, $max) = (min($numbers), max($numbers));\n  \
    \  return [map { ($_ - $min) / ($max - $min) } @$numbers];\n}", "    my $min =\
    \ min($numbers);\n    my $max = max($numbers);\n    my $span = $max - $min;\n\
    \    if ($span > 0) {\n        return [map {($_ - $min) / $span} @$numbers];\n\
    \    } else {\n        return [map {0} @$numbers];\n    }\n}", "    my($min, $max);\n\
    \    my($number);\n    my($rescale);", "    my $min = $numbers->[0];\n    my $max\
    \ = $numbers->[0];\n    for my $number (@$numbers) {\n        $min = $number if\
    \ $number < $min;\n        $max = $number if $number > $max;\n    }\n    my $delta\
    \ = $max - $min;\n    return [ map { ($_ - $min) / $delta } @$numbers ];\n}",
  '    # is there a vector lib for perl?', "    my $min = min(@$numbers);\n    my\
    \ $max = max(@$numbers);\n    my $scale = $max - $min;\n    $scale ||= 1; # avoid\
    \ division by zero in the following\n    [ map { ($_ - $min) / $scale } @$numbers\
    \ ];\n}", "    my($min, $max);\n    foreach my $n (@$numbers) {\n        $min\
    \ = $n if not defined $min or $n < $min;\n        $max = $n if not defined $max\
    \ or $n > $max;\n    }\n    return [map { ($_ - $min) / ($max - $min) } @$numbers];\n\
    }", "    my($min, $max) = minmax(@$numbers);\n    if ($max == $min) {\n      \
    \  return map { 0.0 } @$numbers;\n    }\n    return map { ($_ - $min) / ($max\
    \ - $min) } @$numbers;\n}", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n\
    \    my $diff = $max - $min;\n    $diff or die \"Can't rescale to unit: all numbers\
    \ are identical\\n\";\n    return map { ($_ - $min) / $diff } @$numbers;\n}",
  "    my @numbers = @$numbers;\n    my $min = $numbers[0];\n    my $max = $numbers[0];\n\
    \    for my $number (@numbers) {\n        $min = $number if $number < $min;\n\
    \        $max = $number if $number > $max;\n    }\n    my $factor = 1 / ($max\
    \ - $min);\n    my @result;\n    for my $number (@numbers) {\n        push @result,\
    \ ($number - $min) * $factor;\n    }\n    return @result;\n}", "    my($min) =\
    \ min @$numbers;\n    my($max) = max @$numbers;\n    my($range) = $max - $min;\n\
    \    my($new) = [];\n    foreach my $number (@$numbers) {\n        my($new_number)\
    \ = ($number - $min) / $range;\n        push @$new, $new_number;\n    }\n    return\
    \ $new;\n}", "    if (@$numbers == 1) {\n        return $numbers;\n    }\n   \
    \ my ($min, $max) = _find_min_max($numbers);\n    return [map { ($_ - $min) /\
    \ ($max - $min) } @$numbers];\n}", "    # TODO: add code\n    return $numbers;\n\
    }", "    my($min, $max);\n    my($scaled_i);\n    my(@scaled);", "    my($smallest)\
    \ = min(@$numbers);\n    my($largest) = max(@$numbers);\n    return map {($_ -\
    \ $smallest) / ($largest - $smallest)} @$numbers;\n}", "    die(\"Argument to\
    \ 'rescale_to_unit' must be an array reference\") unless ref($numbers) eq 'ARRAY';\n\
    \    die(\"Array must have at least two elements\") unless @$numbers >= 2;\n \
    \   my($max) = max(@$numbers);\n    my($min) = min(@$numbers);\n    my(@rescaled);\n\
    \    foreach my $n (@$numbers) {\n        my($x) = ($n - $min) / ($max - $min);\n\
    \        push(@rescaled, $x);\n    }\n    return \\@rescaled;\n}", "    my($min,\
    \ $max) = (min(@$numbers), max(@$numbers));\n    return map {($_ - $min) / ($max\
    \ - $min)} @$numbers;\n}", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n\
    \    my $range = $max - $min;\n    return [map { ($_ - $min) / $range } @$numbers];\n\
    }", "    return [] unless @$numbers;\n    my $min = min @$numbers;\n    my $range\
    \ = max @$numbers - $min;\n    return [map { ($_ - $min) / $range } @$numbers];\n\
    }", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n    my($scale) =\
    \ ($max - $min);\n    my($i);\n    for ($i = 0; $i < @$numbers; $i++) {\n    \
    \    $numbers->[$i] = ($numbers->[$i] - $min) / $scale;\n    }\n    return $numbers;\n\
    }", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n    my($range) =\
    \ $max - $min;\n    return map {($_ - $min) / $range} @$numbers;\n}", "    my\
    \ $min = min($numbers);\n    my $max = max($numbers);\n    my $denominator = $max\
    \ - $min;\n    # FIXME: check for zeros\n    my @transformed = map { ($_ - $min)\
    \ / $denominator } @$numbers;\n    return @transformed;\n}", "    my @result;\n\
    \    my $min = min($numbers);\n    my $max = max($numbers);\n    foreach my $n\
    \ (@$numbers) {\n        my $unit = ($n - $min) / ($max - $min);\n        push\
    \ @result, $unit;\n    }\n    return \\@result;\n}", "    my($min) = min($numbers);\n\
    \    my($max) = max($numbers);\n    return $min == $max ?\n        map { 0.5 }\
    \ @$numbers :\n        map { ($_ - $min) / ($max - $min) } @$numbers;\n}", " \
    \   my($min, $max) = (Math::BigFloat->bone, Math::BigFloat->bzero);\n    foreach\
    \ my $number (@$numbers) {\n        $min = $number if $number < $min;\n      \
    \  $max = $number if $number > $max;\n    }\n    my $span = $max - $min;\n   \
    \ return map { ($_ - $min) / $span } @$numbers;\n}", "    my $minimum = min(@$numbers);\n\
    \    my $maximum = max(@$numbers);\n    my $minmax = $maximum - $minimum;\n  \
    \  my @result = ();\n    foreach my $n (@$numbers) {\n        push @result, ($n\
    \ - $minimum) / $minmax;\n    }\n    return @result;\n}", "    if(scalar(@$numbers)\
    \ < 2) {\n        return $numbers;\n    }", "    my($min, $max) = ($numbers->[0],\
    \ $numbers->[0]);\n    for my $n (@$numbers) {\n        $min = $n if $n < $min;\n\
    \        $max = $n if $n > $max;\n    }\n    return [ map { ($_ - $min) / ($max\
    \ - $min) } @$numbers ];\n}", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n\
    \    return [map {($_ - $min) / ($max - $min)} @$numbers];\n}", "    my($min)\
    \ = min(@$numbers);\n    my($max) = max(@$numbers);\n    return [map {($_ - $min)\
    \ / ($max - $min)} @$numbers];\n}", "    my @rescaled = ();\n    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    foreach my $n (@$numbers) {\n        if($max\
    \ - $min) {\n            push @rescaled, (($n - $min) / ($max - $min));\n    \
    \    } else {\n            push @rescaled, 0;\n        }\n    }\n    return @rescaled;\n\
    }", "    my($min, $max) = minmax(@$numbers);\n    my @rescaled;\n    for my $n\
    \ (@$numbers) {\n        if ($max == $min) {\n            push @rescaled, 0.5;\n\
    \        } else {\n            push @rescaled, ($n - $min) / ($max - $min);\n\
    \        }\n    }\n    return @rescaled;\n}", "    my $max = max(@$numbers);\n\
    \    my $min = min(@$numbers);\n    return [map { ($_ - $min) / ($max - $min)\
    \ } @$numbers];\n}", "    my($min, $max) = minmax(@$numbers);\n    my $result\
    \ = array(scalar(@$numbers));\n    my $delta = $max - $min;\n    for (my $i =\
    \ 0; $i < scalar(@$numbers); $i++) {\n        $result->[$i] = ($numbers->[$i]\
    \ - $min) / $delta;\n    }\n    return $result;\n}", "    my @rescaled;\n    my\
    \ $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $range = $max\
    \ - $min;\n    if($range == 0) {\n        @rescaled = (0) x @$numbers;\n    }\
    \ else {\n        @rescaled = map { ($_ - $min) / $range } @$numbers;\n    }\n\
    \    return @rescaled;\n}", "    my $max = max(@$numbers);\n    my $min = min(@$numbers);\n\
    \    return [map {($_ - $min) / ($max - $min)} @$numbers];\n}", "    my($min,\
    \ $max) = minmax(@$numbers);\n    my $range = $max - $min;\n    my @result = map\
    \ { ($_ - $min) / $range } @$numbers;\n    return \\@result;\n}", "    my($first,\
    \ $last);\n    my(@scaled);", "    if (scalar(@$numbers) < 2) {\n        die \"\
    Can't rescale array of less than two elements\";\n    }\n    my $result = [];\n\
    \    my $min = $numbers->[0];\n    my $max = $numbers->[0];\n    for (my $i =\
    \ 1; $i < scalar(@$numbers); $i++) {\n        if ($numbers->[$i] < $min) {\n \
    \           $min = $numbers->[$i];\n        }\n        if ($numbers->[$i] > $max)\
    \ {\n            $max = $numbers->[$i];\n        }\n    }\n    if ($min == $max)\
    \ {\n        die \"Can't rescale array with all elements equal to $min\";\n  \
    \  }\n    my $scale = $max - $min;\n    for (my $i = 0; $i < scalar(@$numbers);\
    \ $i++) {\n        $result->[$i] = ($numbers->[$i] - $min) / $scale;\n    }\n\
    \    return $result;\n}", "    my($min, $max) = minmax(@$numbers);\n    return\
    \ map { ($_ - $min) / ($max - $min) } @$numbers;\n}", "    return [] unless @$numbers\
    \ > 1;\n    my($min, $max) = (min($numbers), max($numbers));\n    return [map\
    \ { ($_ - $min) / ($max - $min) } @$numbers];\n}", "    my $min = min @$numbers;\n\
    \    my $max = max @$numbers;\n    # The $max - $min can be 0 for certain kinds\
    \ of inputs.\n    # Skip the divide in that case.\n    if ($max - $min == 0) {\n\
    \        return [ map { 0 } @$numbers ];\n    }\n    return [ map { ($_ - $min)\
    \ / ($max - $min) } @$numbers ];\n}", "    my($min) = $numbers->[0];\n    my($max)\
    \ = $numbers->[0];\n    foreach my $n (@$numbers) {\n        $min = $n if $n <\
    \ $min;\n        $max = $n if $n > $max;\n    }\n    my($scale) = 1.0 / ($max\
    \ - $min);\n    return [ map { ($_ - $min) * $scale } @$numbers ];\n}", "    my\
    \ $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $range = $max\
    \ - $min;\n    if ($range == 0) {\n        $range = 1;\n    }\n    my @scaled\
    \ = map { ($_ - $min) / $range } @$numbers;\n    return @scaled;\n}", "    my\
    \ @numbers = @$numbers;\n    my $min = min(@numbers);\n    my $max = max(@numbers);\n\
    \    if ($max == $min) {\n        return (0) x @numbers;\n    }\n    return map\
    \ { ($_ - $min) / ($max - $min) } @numbers;\n}", "    my $min = min @$numbers;\n\
    \    my $max = max @$numbers;\n    my $scale = 1.0 / ($max - $min);\n    my @result\
    \ = map { ($_ - $min) * $scale } @$numbers;\n    return @result;\n}", "    my($min)\
    \ = min(@$numbers);\n    my($max) = max(@$numbers);\n    my($range) = $max - $min;\n\
    \    return map($_ == $max ? 1 : ($_ - $min) / $range, @$numbers);\n}", "    my($max)\
    \ = max(@$numbers);\n    my($min) = min(@$numbers);\n    my($delta) = $max - $min;\n\
    \    my(@result);\n    if($delta != 0) {\n        @result = map {($_ - $min) /\
    \ $delta} @$numbers;\n    } else {\n        @result = @$numbers;\n    }\n    return\
    \ \\@result;\n}", "    die \"need at least two numbers\" if @$numbers < 2;\n \
    \   my($min, $max) = minmax @$numbers;\n    return [map { ($_ - $min) / ($max\
    \ - $min) } @$numbers];\n}", "    die \"Need at least two numbers\" if scalar(@$numbers)\
    \ < 2;\n    my $min = List::Util::min(@$numbers);\n    my $max = List::Util::max(@$numbers);\n\
    \    my $range = $max - $min;\n    die \"All numbers are the same\" if $range\
    \ == 0;\n    return [ map { ($_ - $min) / $range } @$numbers ];\n}", "    my $min\
    \ = min(@$numbers);\n    my $max = max(@$numbers);\n    my $scale = 1.0 / ($max\
    \ - $min);\n    return map { ($_ - $min) * $scale } @$numbers;\n}", "    my($min,\
    \ $max) = (min @$numbers, max @$numbers);\n    map { ($_ - $min) / ($max - $min)\
    \ } @$numbers;\n}", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n\
    \    my $scale = sub {\n        my($x) = @_;\n        $min + ($x - $min) * ($max\
    \ - $min);\n    };\n    map { $scale->($_) } @$numbers;\n}", "    my($n, $total)\
    \ = (0,0);\n    my($min, $max) = minmax(@$numbers);\n    foreach my $number (@$numbers)\
    \ {\n        push @$numbers, ($number - $min) / ($max - $min);\n    }\n    return\
    \ $numbers;\n}", "    my $min = min(@$numbers);\n    my $range = max(@$numbers)\
    \ - $min;\n    map { ($_ - $min) / $range } @$numbers;\n}", "    my($min, $max)\
    \ = minmax(@$numbers);\n    my $result = [];\n    for my $number (@$numbers) {\n\
    \        push @$result, ($number - $min) / ($max - $min);\n    }\n    return $result;\n\
    }", "    my($smallest, $largest) = minmax(@$numbers);\n    my($range) = $largest\
    \ - $smallest;\n    my(@transformed);\n    foreach my $n (@$numbers) {\n     \
    \   my($scaled) = ($n - $smallest) / $range;\n        push(@transformed, $scaled);\n\
    \    }\n    return(@transformed);\n}", "    my($smallest, $largest) = (1e100,\
    \ -1e100);\n    for my $x (@$numbers) {\n        $smallest = $x if $x < $smallest;\n\
    \        $largest = $x if $x > $largest;\n    }\n    my $diff = $largest - $smallest;\n\
    \    if ($diff == 0) {\n        return [map {0} @$numbers];\n    }\n    return\
    \ [map {($_ - $smallest) / $diff} @$numbers];\n}", "    my($min, $max);\n    foreach\
    \ (@$numbers) {\n        if (!defined($min) || $_ < $min) {\n            $min\
    \ = $_;\n        }\n        if (!defined($max) || $_ > $max) {\n            $max\
    \ = $_;\n        }\n    }\n    my $range = $max - $min;\n    return undef if $range\
    \ <= 0;\n    my @rescaled = map {($_ - $min) / $range} @$numbers;\n    return\
    \ \\@rescaled;\n}", "    my @sorted = sort { $a <=> $b } @$numbers;\n    my($min,\
    \ $max) = ($sorted[0], $sorted[-1]);\n    my $range = $max - $min;\n    return\
    \ [ map { ( $_ - $min ) / $range } @$numbers ];\n}", "    my $min = $numbers->[0];\n\
    \    my $max = $numbers->[0];\n    for my $val (@$numbers) {\n        $min = $val\
    \ if $val < $min;\n        $max = $val if $val > $max;\n    }\n    my $range =\
    \ $max - $min;\n    return [ map { ($_ - $min) / $range } @$numbers ];\n}", " \
    \   my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $unit_range\
    \ = $max - $min;\n    my @result = ();\n    foreach my $number (@$numbers) {\n\
    \        if ($unit_range == 0) {\n            push @result, 1;\n        } else\
    \ {\n            push @result, ($number - $min) / $unit_range;\n        }\n  \
    \  }\n    return \\@result;\n}", "    my @rescaled = ();\n    return \\@rescaled\
    \ unless @$numbers;", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n\
    \    my $range = $max - $min;\n    my @unit = map { ($_ - $min) / $range } @$numbers;\n\
    \    return \\@unit;\n}", "    assert(@$numbers > 1);\n    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $diff = $max - $min;\n    my @scaled =\
    \ map { ($_ - $min) / $diff } @$numbers;\n    return @scaled;\n}", "    my $min\
    \ = min(@$numbers);\n    my $max = max(@$numbers);\n    my $coef = ($max - $min)\
    \ != 0 ? 1.0 / ($max - $min) : 1.0;\n    my @res = map { ($_ - $min) * $coef }\
    \ @$numbers;\n    return \\@res;\n}", "    my $min_value = min(@$numbers);\n \
    \   my $max_value = max(@$numbers);\n    my $difference = $max_value - $min_value;\n\
    \    return [map {($_ - $min_value) / $difference} @$numbers];\n}", "    my $min\
    \ = min(@$numbers);\n    my $max = max(@$numbers);\n    my $denom = $max - $min;\n\
    \    return [ map { ($_ - $min) / $denom } @$numbers ];\n}", "    my($min, $max)\
    \ = @$numbers[0, -1];\n    return map { ($_ - $min) / ($max - $min) } @$numbers;\n\
    }", "    my $min = min($numbers);\n    my $max = max($numbers);\n    my $scale\
    \ = $max - $min;\n    if ($scale == 0) {\n        return [0, 0, 0, 0, 0];\n  \
    \  }\n    else {\n        return [map(($_ - $min) / $scale, @$numbers)];\n   \
    \ }\n}", "    my($smallest, $largest) = @$numbers[0,0];\n    foreach my $number\
    \ (@$numbers) {\n        $smallest = $number if $number < $smallest;\n       \
    \ $largest = $number if $number > $largest;\n    }\n    return map { ($_ - $smallest)\
    \ / ($largest - $smallest) } @$numbers;\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $rescale_factor = 1.0 / ($max - $min);\n\
    \    return [ map { ($_ - $min) * $rescale_factor } @$numbers ];\n}", "    die\
    \ if (!defined $numbers);\n    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n\
    \    my $range = $max - $min;\n    if ($range == 0) {\n        return ([0.5] x\
    \ @$numbers);\n    }\n    else {\n        return [map {($_ - $min) / $range} @$numbers];\n\
    \    }\n}", "    my $min = min @$numbers;\n    my $max = max @$numbers;\n    my\
    \ $diff = $max - $min;\n    return map { ($_ - $min) / $diff } @$numbers;\n}",
  "    my($min) = $numbers->[0];\n    my($max) = $numbers->[0];\n    foreach my $n\
    \ (@$numbers) {\n        $min = $n if $n < $min;\n        $max = $n if $n > $max;\n\
    \    }\n    my $diff = $max - $min;\n    my $result = [];\n    foreach my $n (@$numbers)\
    \ {\n        my $new_value = ($n - $min) / $diff;\n        push @$result, $new_value;\n\
    \    }\n    return $result;\n}", "    # Sort the values in ascending order.\n\
    \    my @sorted = sort { $a <=> $b } @$numbers;\n    # We need two numbers to\
    \ scale between.\n    die \"Tried to rescale a vector with only one element\"\
    \ unless @sorted > 1;\n    my $minimum = $sorted[0];\n    my $maximum = $sorted[-1];\n\
    \    # If the minimum is the same as the maximum, don't rescale.\n    return map\
    \ { $_ - $minimum } @$numbers if $minimum == $maximum;\n    # Otherwise, rescale\
    \ by subtracting the minimum, dividing by the difference, and mapping to a unit.\n\
    \    return map { ($_ - $minimum) / ($maximum - $minimum) } @$numbers;\n}", " \
    \   return [\n        map {\n            $_ < 0 ? 0 : $_ > 1 ? 1 : $_\n      \
    \  } _rescale($numbers)\n    ];\n}", "    my($min, $max) = minmax(@$numbers);\n\
    \    my $range = $max - $min;\n    my @res;\n    if ($range == 0) {\n        @res\
    \ = (0.5) x scalar(@$numbers);\n    } else {\n        @res = map { ($_ - $min)\
    \ / $range } @$numbers;\n    }\n    return \\@res;\n}", "    my($num_numbers)\
    \ = scalar(@$numbers);\n    if ($num_numbers == 0) {\n        return [];\n   \
    \ }\n    if ($num_numbers == 1) {\n        return [1.0];\n    }\n    my($min)\
    \ = min(@$numbers);\n    my($max) = max(@$numbers);\n    my($range) = $max - $min;\n\
    \    if ($range == 0) {\n        return [1.0];\n    }\n    return [map {($_ -\
    \ $min) / $range} @$numbers];\n}", "    my $min = min @$numbers;\n    my $max\
    \ = max @$numbers;\n    my $delta = $max - $min;\n    if ($delta == 0) {\n   \
    \     return [map { 1.0 } @$numbers];\n    }\n    return [map { ($_ - $min) /\
    \ $delta } @$numbers];\n}", "    my $min = min @$numbers;\n    my $max = max @$numbers;\n\
    \    my $range = $max - $min;\n    # if $range is zero, then the numbers are all\
    \ the same, which is the maximum range\n    $range ||= 1;\n    return [ map {\
    \ ($_ - $min) / $range } @$numbers ];\n}", "    my $min = min(@$numbers);\n  \
    \  my $max = max(@$numbers);\n    my $diff = $max - $min;\n    return $diff ?\
    \ [ map { ($_ - $min) / $diff } @$numbers ] : $numbers;\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    my $range = $max - $min;\n    my @rescaled\
    \ = map { ($_ - $min) / $range } @$numbers;\n    return \\@rescaled;\n}", "  \
    \  die \"no numbers!\" unless $numbers && @$numbers > 1;\n    my $min = min($numbers);\n\
    \    my $max = max($numbers);\n    my $range = $max - $min;\n    my @out = ();\n\
    \    for my $n (@$numbers) {\n        my $rescaled = ($n - $min) / $range;\n \
    \       push @out, $rescaled;\n    }\n    return @out;\n}", "    my $max = max(@$numbers);\n\
    \    my $min = min(@$numbers);\n    my $diff = $max - $min;\n    if ($diff ==\
    \ 0) {\n        # no need to rescale...\n        return $numbers;\n    } else\
    \ {\n        return [map {($_ - $min) / $diff} @$numbers];\n    }\n}", "    my($min)\
    \ = min(@$numbers);\n    my($max) = max(@$numbers);\n    my $range = $max - $min;\n\
    \    my($rescaled) = [ map { ($_ - $min) / $range } @$numbers ];\n    return $rescaled;\n\
    }", "    my($min, $max) = minmax(@$numbers);\n    return [ map { my $num = $_;\
    \ ($num - $min) / ($max - $min) } @$numbers ];\n}", "    my @numbers = @$numbers;\n\
    \    my $min = min(@numbers);\n    my $max = max(@numbers);\n    my $diff = $max\
    \ - $min;\n    my @res = map { ($_ - $min) / $diff } @numbers;\n    return \\\
    @res;\n}", "    my($min, $max) = minmax(@$numbers);\n    if ($max > $min) {\n\
    \        for my $i (0 .. $#$numbers) {\n            $numbers->[$i] = ($numbers->[$i]\
    \ - $min) / ($max - $min);\n        }\n    } else {\n        for my $i (0 .. $#$numbers)\
    \ {\n            $numbers->[$i] = 0.5;\n        }\n    }\n    return $numbers;\n\
    }", "    die 'expected non-empty array' unless (defined $numbers && scalar @$numbers\
    \ > 0);\n    my ($min, $max) = (min @$numbers, max @$numbers);\n    return apply_linear_transform($numbers,\
    \ sub { 0 }, sub { 1 }, $min, $max);\n}", "    my $min = min @$numbers;\n    my\
    \ $max = max @$numbers;\n    my $range = $max - $min;\n    return [map {($_ -\
    \ $min) / $range} @$numbers];\n}", "    my($min, $max) = (\n        List::Util::min(@$numbers),\n\
    \        List::Util::max(@$numbers),\n    );\n    my($max_min_diff) = $max - $min;\n\
    \    my($rescaled) = [\n        map {\n            if ($max_min_diff == 0) {\n\
    \                0;\n            } else {\n                ($_ - $min) / $max_min_diff;\n\
    \            }\n        } @$numbers\n    ];\n    return $rescaled;\n}", "    return\
    \ [map { ($_ - $numbers->[0]) / ($numbers->[-1] - $numbers->[0]) } @$numbers];\n\
    }", "    my($min, $max) = minmax(@$numbers);\n    return [] if ($min == $max);\n\
    \    return [map { ($_ - $min) / ($max - $min) } @$numbers];\n}", "    my($min,\
    \ $max) = (min(@$numbers), max(@$numbers));\n    my $scale = $max - $min;\n  \
    \  return [map { ($_ - $min) / $scale } @$numbers];\n}", "    my @rescaled;\n\
    \    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $length\
    \ = $max - $min;\n    for my $num (@$numbers) {\n        my $rescaled = ($num\
    \ - $min) / $length;\n        push @rescaled, $rescaled;\n    }\n    return @rescaled;\n\
    }", "    my @sorted = sort { $a <=> $b } @$numbers;\n    my $smallest = $sorted[0];\n\
    \    my $largest = $sorted[-1];\n    my $diff = $largest - $smallest;\n    my\
    \ @rescaled = map { ($_ - $smallest) / $diff } @$numbers;\n    return @rescaled;\n\
    }", "    my($lowest, $highest) = (min @$numbers, max @$numbers);\n    return undef\
    \ if $lowest == $highest;\n    return [ map { ($_ - $lowest) / ($highest - $lowest)\
    \ } @$numbers ];\n}", "    my($smallest) = smallest($numbers);\n    my($largest)\
    \ = largest($numbers);\n    my($spread) = $largest - $smallest;\n    my($n) =\
    \ @$numbers;\n    my(@result);\n    for (my($i) = 0; $i < $n; $i++) {\n      \
    \  push(@result, ($numbers->[$i] - $smallest) / $spread);\n    }\n    \\@result;\n\
    }", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $n =\
    \ ($max - $min) + 1;\n    my @result = ();\n    for my $num (@$numbers) {\n  \
    \      my $new_num = ($num - $min) / $n;\n        push @result, $new_num;\n  \
    \  }\n    return \\@result;\n}", "    my $min = min(@$numbers);\n    my $max =\
    \ max(@$numbers);\n    my $scale = 1.0 / ($max - $min);\n    my @res = map {\n\
    \        if ($min == $max) {\n            0.0;\n        } else {\n           \
    \ ($_ - $min) * $scale;\n        }\n    } @$numbers;\n    return @res;\n}", " \
    \   my @copy = @$numbers;\n    @copy = sort { $a <=> $b } @copy;\n    my $min\
    \ = $copy[0];\n    my $max = $copy[-1];\n    my $range = $max - $min;\n    return\
    \ [ map { ($_ - $min) / $range } @$numbers ];\n}", "    my($min, $max);\n    if\
    \ (@$numbers) {\n        $min = $max = $numbers->[0];\n        for my $i (1..$#$numbers)\
    \ {\n            if ($numbers->[$i] < $min) {\n                $min = $numbers->[$i];\n\
    \            }\n            if ($numbers->[$i] > $max) {\n                $max\
    \ = $numbers->[$i];\n            }\n        }\n    }\n    return [] unless $min\
    \ and $max;\n    my $scale = $max - $min;\n    return [map {($_ - $min) / $scale}\
    \ @$numbers];\n}", "    die unless ref($numbers) eq 'ARRAY';\n    die unless @$numbers\
    \ > 1;\n    my($min) = min(@$numbers);\n    my($max) = max(@$numbers);\n    my($range)\
    \ = $max - $min;\n    my($result) = [];\n    for my $num (@$numbers) {\n     \
    \   my($new) = ($num - $min) / $range;\n        push @$result, $new;\n    }\n\
    \    return $result;\n}", "    if (scalar(@$numbers) < 2) {\n        return $numbers;\n\
    \    }\n    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $diff\
    \ = $max - $min;\n    my @rescaled;\n    for my $n (@$numbers) {\n        push\
    \ @rescaled, ($n - $min) / $diff;\n    }\n    return \\@rescaled;\n}", "    my\
    \ $min = min @$numbers;\n    my $max = max @$numbers;\n    my $scaling_factor\
    \ = 1.0 / ($max - $min);\n    return [ map { ($_ - $min) * $scaling_factor } @$numbers\
    \ ];\n}", "    my $min_value = $numbers->[0];\n    my $max_value = $numbers->[0];\n\
    \    for my $index (1 .. $#$numbers) {\n        my $value = $numbers->[$index];\n\
    \        if ($value < $min_value) {\n            $min_value = $value;\n      \
    \  }\n        if ($value > $max_value) {\n            $max_value = $value;\n \
    \       }\n    }\n    if ($min_value == $max_value) {\n        return [map { 0.0\
    \ } @$numbers];\n    }\n    else {\n        my $max_min = $max_value - $min_value;\n\
    \        return [map { ($_ - $min_value) / $max_min } @$numbers];\n    }\n}",
  "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    return [map {($_\
    \ - $min) / ($max - $min)} @$numbers];\n}", "    my $min = min(@$numbers);\n \
    \   my $max = max(@$numbers);\n    my $scale = 1.0 / ($max - $min);\n    my @scaled\
    \ = ();\n    for my $n (@$numbers) {\n        push @scaled, ($n - $min) * $scale;\n\
    \    }\n    return @scaled;\n}", "    my($min, $max) = minmax(@$numbers);\n  \
    \  die unless $min != $max;\n    my $denominator = $max - $min;\n    return [map\
    \ {($_ - $min) / $denominator} @$numbers];\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    $min == $max and return map { 0.5 } @$numbers;\n\
    \    my $range = $max - $min;\n    return map { ($_ - $min) / $range } @$numbers;\n\
    }", "    my($min, $max) = minmax(@$numbers);\n    my $slope = 1 / ($max - $min);\n\
    \    my $intercept = -$min * $slope;\n    return [map { $slope * $_ + $intercept\
    \ } @$numbers];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
