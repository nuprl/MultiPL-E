name: HumanEval_90_next_smallest
language: pl
prompt: "# You are given an array of integers.\n# Write a function next_smallest()\
  \ that returns the 2nd smallest element of the array.\n# Return undef if there is\
  \ no such element.\n# >>> next_smallest([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest([5,\
  \ 1, 4, 3, 2])\n# 2\n# >>> next_smallest([])\n# undef\n# >>> next_smallest([1, 1])\n\
  # undef\nsub next_smallest {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&next_smallest;\n\
  \        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),2)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 1, 4,\
  \ 3, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1]),undef)) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 1, 1, 1, 0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([1, 1]),undef)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([-35, 34, 12, -45]),-35))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($smallest) = shift @$lst;\n    my($next_smallest) = undef;\n\
    \    for(@$lst) {\n        if ($_ < $smallest) {\n            $next_smallest =\
    \ $smallest;\n            $smallest = $_;\n        }\n        elsif (!defined($next_smallest)\
    \ || $_ < $next_smallest) {\n            $next_smallest = $_;\n        }\n   \
    \ }\n    return $next_smallest;\n}", "    my @res = sort {$a <=> $b} @$lst;\n\
    \    my $res_cnt = @res;\n    if ($res_cnt >= 2) {\n        return $res[1];\n\
    \    }\n    return undef;\n}", "    my($min, $next_min);\n    if(@$lst < 2) {\n\
    \        return undef;\n    }\n    for(my $i = 0; $i < @$lst; $i++) {\n      \
    \  if(!defined($min) || $lst->[$i] < $min) {\n            $next_min = $min;\n\
    \            $min = $lst->[$i];\n        } elsif(!defined($next_min) || $lst->[$i]\
    \ < $next_min) {\n            $next_min = $lst->[$i];\n        }\n    }\n    return\
    \ $next_min;\n}", '    return undef if ($#{$lst} < 1);', "    if (scalar(@$lst)\
    \ < 2) {\n        return undef;\n    }\n    my $min = $lst->[0];\n    my $nxt\
    \ = $lst->[1];\n    for (my $i = 1; $i < scalar(@$lst); $i++) {\n        if ($lst->[$i]\
    \ < $min) {\n            $nxt = $min;\n            $min = $lst->[$i];\n      \
    \  } elsif ($lst->[$i] < $nxt) {\n            $nxt = $lst->[$i];\n        }\n\
    \    }\n    return $nxt;\n}", "    my $min1 = undef;\n    my $min2 = undef;\n\
    \    for(my $i = 0; $i < @$lst; $i++) {\n        if(defined($min1)) {\n      \
    \      if($lst->[$i] < $min1) {\n                $min2 = $min1;\n            \
    \    $min1 = $lst->[$i];\n            }\n            elsif(!defined($min2) ||\
    \ $lst->[$i] < $min2) {\n                $min2 = $lst->[$i];\n            }\n\
    \        }\n        else {\n            $min1 = $lst->[$i];\n        }\n    }\n\
    \    return $min2;\n}", "    return undef unless defined($lst);\n    return undef\
    \ unless @$lst > 1;\n    my @sorted = sort { $a <=> $b } @$lst;\n    # shortest\
    \ (but a tiny bit slower)\n    # return $sorted[1];\n    my $smallest = $sorted[0];\n\
    \    my $next_smallest = undef;\n    foreach my $elem (@sorted) {\n        if\
    \ ($elem != $smallest) {\n            $next_smallest = $elem;\n            last;\n\
    \        }\n    }\n    return $next_smallest;\n}", "    my(@sorted, $second);\n\
    \    if (scalar(@$lst) == 0) {\n        return undef;\n    }\n    @sorted = sort\
    \ @$lst;\n    $second = undef;\n    while (scalar(@sorted) > 0) {\n        $second\
    \ = shift @sorted;\n        if (scalar(@sorted) == 0 || $second != $sorted[0])\
    \ {\n            last;\n        }\n    }\n    return $second;\n}", "    return\
    \ undef if @$lst < 2;\n    return undef if $lst->[0] == $lst->[1];\n    my $smallest\
    \ = $lst->[0];\n    for my $i (1..$#$lst) {\n        if ($lst->[$i] < $smallest)\
    \ {\n            $smallest = $lst->[$i];\n        }\n    }\n    my $sec_smallest\
    \ = $lst->[0];\n    for my $i (1..$#$lst) {\n        if ($lst->[$i] > $smallest\
    \ && $lst->[$i] < $sec_smallest) {\n            $sec_smallest = $lst->[$i];\n\
    \        }\n    }\n    return $sec_smallest;\n}", "    my($min, $secmin) = undef;\n\
    \    for my $i (@$lst) {\n        if (defined $min) {\n            if ($i < $min)\
    \ {\n                $secmin = $min;\n                $min = $i;\n           \
    \ } elsif (!defined $secmin || $i < $secmin) {\n                $secmin = $i;\n\
    \            }\n        } else {\n            $min = $i;\n        }\n    }\n \
    \   return $secmin;\n}", "    return undef if(!$lst || @$lst == 0);\n    return\
    \ undef if(@$lst == 1);\n    return min(grep {$_ != min($lst)} @$lst);\n}", " \
    \   my $smallest = undef;\n    my $second_smallest = undef;\n    foreach my $el\
    \ (@$lst) {\n        if (defined $smallest) {\n            if ($el < $smallest)\
    \ {\n                $second_smallest = $smallest;\n                $smallest\
    \ = $el;\n            } elsif (defined $second_smallest) {\n                if\
    \ ($el < $second_smallest) {\n                    $second_smallest = $el;\n  \
    \              }\n            } else {\n                $second_smallest = $el;\n\
    \            }\n        } else {\n            $smallest = $el;\n        }\n  \
    \  }\n    return $second_smallest;\n}", "    my @lst = @$lst;\n    return undef\
    \ if @lst < 2;\n    my $min = $lst[0];\n    my $nmin = $lst[1];\n    if ($nmin\
    \ < $min) {\n        $min = $nmin;\n        $nmin = $lst[0];\n    }\n    for (my\
    \ $i = 2; $i < @lst; $i++) {\n        my $val = $lst[$i];\n        if ($val <\
    \ $min) {\n            $nmin = $min;\n            $min = $val;\n        } elsif\
    \ ($val < $nmin) {\n            $nmin = $val;\n        }\n    }\n    return $nmin;\n\
    }", "    my($small, $smallest);\n    for my $i (@$lst) {\n        if (defined\
    \ $small) {\n            if ($i < $small) {\n                $smallest = $small;\n\
    \                $small = $i;\n            } elsif (!defined $smallest or $i <\
    \ $smallest) {\n                $smallest = $i;\n            }\n        } else\
    \ {\n            $small = $i;\n        }\n    }\n    return $smallest;\n}", " \
    \   my @nums = @$lst;\n    my @sort_nums = sort {$a <=> $b} @nums;\n    my $current_smallest\
    \ = shift @sort_nums;\n    my $second_smallest = undef;\n    foreach my $x (@sort_nums)\
    \ {\n        if($x != $current_smallest) {\n            $second_smallest = $x;\n\
    \            last;\n        }\n    }\n    return $second_smallest;\n}", "    return\
    \ undef if !defined $lst || @$lst < 2;\n    my $min = $lst->[0];\n    my $next_min\
    \ = $lst->[1];\n    for my $i (2..$#$lst) {\n        my $v = $lst->[$i];\n   \
    \     if ($v < $min) {\n            $next_min = $min;\n            $min = $v;\n\
    \        } elsif ($v < $next_min) {\n            $next_min = $v;\n        }\n\
    \    }\n    return $next_min;\n}", "    if(scalar(@$lst) < 2) {\n        return\
    \ undef;\n    }\n    my $smallest = $lst->[0];\n    my $second_smallest = undef;\n\
    \    for(my $i = 1; $i < scalar(@$lst); $i++) {\n        if($lst->[$i] < $smallest)\
    \ {\n            $second_smallest = $smallest;\n            $smallest = $lst->[$i];\n\
    \        }\n        elsif(not defined($second_smallest) or $lst->[$i] < $second_smallest)\
    \ {\n            $second_smallest = $lst->[$i];\n        }\n    }\n    return\
    \ $second_smallest;\n}", "    return undef unless scalar @$lst > 0;\n    my $min\
    \ = shift @$lst;\n    for my $e (@$lst) {\n        $min = $e if $e < $min;\n \
    \   }\n    my $next_min = $min;\n    for my $e (@$lst) {\n        $next_min =\
    \ $e if $e < $next_min && $e > $min;\n    }\n    return $next_min;\n}", "    return\
    \ undef if scalar(@$lst) < 2;\n    my @sorted = sort { $a <=> $b } @$lst;\n  \
    \  return $sorted[1];\n}", "    my $len = $#$lst;\n    my $min1 = $lst->[0];\n\
    \    my $min2 = undef;\n    for (my $i = 1; $i <= $len; $i++) {\n        if ($lst->[$i]\
    \ < $min1) {\n            $min2 = $min1;\n            $min1 = $lst->[$i];\n  \
    \      } elsif ($lst->[$i] < $min2) {\n            $min2 = $lst->[$i];\n     \
    \   }\n    }\n    return $min2;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
