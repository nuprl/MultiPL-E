name: HumanEval_5_intersperse
language: pl
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ array `numbers'\n# >>> intersperse([], 4)\n# []\n# >>> intersperse([1, 2, 3],\
  \ 4)\n# [1, 4, 2, 4, 3]\nsub intersperse {\n    my($numbers, $delimeter) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersperse;\n\
  \        if(eq_deeply($candidate->([], 7),[])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 2], 8),[5,\
  \ 8, 6, 8, 3, 8, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([2, 2, 2], 2),[2, 2, 2, 2, 2])) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return map([$_, $delimeter], @$numbers[0..($#$numbers-1)]), $numbers->[-1];\n\
    }", "    my $numbers_length = scalar(@$numbers);\n    my @result = ();\n    for(my\
    \ $i = 0; $i < $numbers_length; $i++) {\n        push(@result, $numbers->[$i]);\n\
    \        push(@result, $delimeter) if($i < $numbers_length - 1);\n    }\n    return\
    \ @result;\n}", "    my @result = ();\n    for (my $i = 0; $i < @$numbers - 1;\
    \ $i++) {\n        push @result, $numbers->[$i];\n        push @result, $delimeter;\n\
    \    }\n    push @result, $numbers->[@$numbers - 1];\n    return @result;\n}",
  "    if (@$numbers == 0) {\n        return [];\n    }\n    elsif (@$numbers == 1)\
    \ {\n        return [$numbers->[0]];\n    }\n    else {\n        my @result =\
    \ ($numbers->[0]);\n        foreach my $index (1 .. $#$numbers) {\n          \
    \  push @result, $delimeter, $numbers->[$index];\n        }\n        return \\\
    @result;\n    }\n}", "    return $numbers if (scalar(@$numbers) <= 1);\n    my\
    \ $len = scalar(@$numbers);\n    my @res = ();\n    for (my $i = 0; $i < $len\
    \ - 1; $i++) {\n        push @res, $numbers->[$i];\n        push @res, $delimeter;\n\
    \    }\n    push @res, $numbers->[$len - 1];\n    return \\@res;\n}", "    return\
    \ [] if @$numbers == 0;\n    return @$numbers if @$numbers == 1;\n    my @ret\
    \ = ($numbers->[0]);\n    for my $idx (1 .. @$numbers - 1) {\n        push @ret,\
    \ $delimeter, $numbers->[$idx];\n    }\n    return @ret;\n}", "    my @new = ();\n\
    \    foreach my $number (@$numbers) {\n        push @new, $number;\n        push\
    \ @new, $delimeter;\n    }\n    pop @new;\n    return @new;\n}", "    return []\
    \ if (@$numbers < 1);\n    my @res = ($numbers->[0]);\n    for my $i (1 .. @$numbers\
    \ - 1) {\n        push @res, $delimeter, $numbers->[$i];\n    }\n    return \\\
    @res;\n}", "    my @res = ();\n    for my $n (@$numbers) {\n        push @res,\
    \ $n, $delimeter;\n    }\n    # Remove the last delimeter\n    pop @res;\n   \
    \ return @res;\n}", "    my @result = (shift @$numbers);\n    foreach my $n (@$numbers)\
    \ {\n        push @result, $delimeter, $n;\n    }\n    return @result;\n}", " \
    \   my @result = @$numbers;\n    for (my $i = 1; $i < @result; $i += 2) {\n  \
    \      splice @result, $i, 0, $delimeter;\n    }\n    return \\@result;\n}", " \
    \   my @result = ();\n    my @numbers = @$numbers;\n    while (@numbers) {\n \
    \       my $n = shift @numbers;\n        push @result, $n;\n        push @result,\
    \ $delimeter if @numbers;\n    }\n    return @result;\n}", "    return [] if @$numbers\
    \ == 0;\n    return [ $numbers->[0] ] if @$numbers == 1;\n    return [ $numbers->[0],\
    \ $delimeter, @{ intersperse([ @$numbers[1..$#$numbers] ], $delimeter) } ];\n}",
  "    my $interpersed = [];\n    if (@$numbers > 0) {\n        push @$interpersed,\
    \ $numbers->[0];\n        foreach my $i (1..$#$numbers) {\n            push @$interpersed,\
    \ $delimeter, $numbers->[$i];\n        }\n    }\n    return $interpersed;\n}",
  "    if (not @$numbers) {\n        return [];\n    }\n    my @result = shift @$numbers;\n\
    \    foreach my $number (@$numbers) {\n        push @result, $delimeter, $number;\n\
    \    }\n    return \\@result;\n}", "    my @result = @$numbers;\n    while (my\
    \ $i = splice(@result, 1, 1)) {\n        unshift @result, $delimeter, $i;\n  \
    \  }\n    return @result;\n}", "    my @result = @$numbers;\n    for (my $i =\
    \ 1; $i < @result; $i += 2) {\n        splice @result, $i, 0, $delimeter;\n  \
    \  }\n    return \\@result;\n}", "    my @result = ();\n    my $i = 0;\n    while\
    \ ($i < scalar(@$numbers)) {\n        push @result, $numbers->[$i];\n        if\
    \ ($i + 1 < scalar(@$numbers)) {\n            push @result, $delimeter;\n    \
    \    }\n        $i += 1;\n    }\n    return \\@result;\n}", "    return $numbers\
    \ if @$numbers < 2;\n    my $head = shift @$numbers;\n    return [$head, map {\
    \ $delimeter, $_ } @$numbers];\n}", "    return [] if not @$numbers;\n    my $head\
    \ = shift @$numbers;\n    return [$head] if not @$numbers;\n    return [$head,\
    \ $delimeter, @$numbers];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
