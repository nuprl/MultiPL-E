name: HumanEval_11_string_xor
language: jl
prompt: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform\
  \ binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010',\
  \ '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String, b::String)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
  111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\
  \t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
completions: ["    \"\"\" XORs two bitstrings, a and b.\n    \"\"\"\n    if length(a)\
    \ != length(b)\n        return(\"Must be same length\")\n    end\n    c = String(\"\
    \")\n    for i = 1:length(a)\n        if (a[i] == '0' && b[i] == '0') || (a[i]\
    \ == '1' && b[i] == '1')\n            push!(c, '0')\n        else\n          \
    \  push!(c, '1')\n        end\n    end\n    return(c)\nend", "    if length(a)\
    \ != length(b)\n        error(\"a and b must be the same length\")\n    end\n\
    \    c = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n           \
    \ append!(c, '0')\n        else\n            append!(c, '1')\n        end\n  \
    \  end\n    return c\nend", "    bin_a = parse(Int, a, base=2)\n    bin_b = parse(Int,\
    \ b, base=2)\n    xor_val = xor(bin_a, bin_b)\n    xor_str = bin(xor_val, 2)\n\
    \    return xor_str\nend", "    if length(a) != length(b)\n        error(\"Lengths\
    \ of strings to be XORed must be equal\")\n    end\n    string_builder = StringBuilder()\n\
    \    for i in 1:length(a)\n        a_i = parse(Int, a[i])\n        b_i = parse(Int,\
    \ b[i])\n        xor_i = a_i + b_i == 1 ? \"1\" : \"0\"\n        append!(string_builder,\
    \ xor_i)\n    end\n    return string(string_builder)\nend", "    ai = parse(Int,\
    \ a, base=2)\n    bi = parse(Int, b, base=2)\n    ret = ai \u22BB bi\n    return\
    \ string(dec(ret, 2))\nend", "    if length(a) != length(b)\n        error(\"\
    a and b must be of equal length\")\n    end\n    a_ = parse(Int, a, base=2)\n\
    \    b_ = parse(Int, b, base=2)\n    c_ = xor(a_, b_)\n    c = bin(c_)\n    #\
    \ remove the `0b` from the string \n    c = c[3:end]\n    return c\nend", "  \
    \  # TODO: implement me\nend", "    output = \"\"\n    for i = 1:length(a)\n \
    \       if (a[i] == '0' && b[i] == '0')\n            push!(output, '0')\n    \
    \    elseif (a[i] == '1' && b[i] == '1')\n            push!(output, '0')\n   \
    \     else\n            push!(output, '1')\n        end\n    end\n    return output\n\
    end", "    return int(a, 2) $int(b, 2)\nend", "    if length(a) != length(b)\n\
    \        println(\"Length of string a and b must be equal\")\n        return 0\n\
    \    end\n    c = String(length(a))\n    for i in 1:length(a)\n        c[i] =\
    \ xor(a[i], b[i])\n    end\n    return c\nend\na = \"10101\"\nb = \"00101\"\n\
    string_xor(a, b)", "    s = \"\"\n    for i in 1:length(a)\n        if a[i] ==\
    \ b[i]\n            s = s * \"0\"\n        else\n            s = s * \"1\"\n \
    \       end\n    end\n    return s\nend", "    c = \"\"\n    for i in 1:length(a)\n\
    \        c = c * string(int(a[i]) != int(b[i]))\n    end\n    return c\nend",
  "    x = Int.(a)\n    y = Int.(b)\n    return string(x .\u22BB y)\nend", "    \"\
    \"\" String XOR \"\"\"\n    a = parse(Int, a, base=2)\n    b = parse(Int, b, base=2)\n\
    \    return string(a $ b, base=2)\nend", "    c = zeros(String, length(a))\n \
    \   for i in 1:length(a)\n        if a[i] == b[i]\n            c[i] = \"0\"\n\
    \        else\n            c[i] = \"1\"\n        end\n    end\n    return join(c)\n\
    end", "    len = length(a)\n    if len != length(b)\n        error(\"strings must\
    \ be of equal length\")\n    end\n    new_str = \"\"\n    for i in 1:len\n   \
    \     aa = a[i]\n        bb = b[i]\n        if aa == bb\n            new_str =\
    \ new_str * \"0\"\n        else\n            new_str = new_str * \"1\"\n     \
    \   end\n    end\n    return new_str\nend", "    bin_a = parse(Int, a, base=2)\n\
    \    bin_b = parse(Int, b, base=2)\n    string_xor = string(bin_a \u22BB bin_b,\
    \ base=2)\n    return string_xor\nend", "    a = parse(Int, a, base=2)\n    b\
    \ = parse(Int, b, base=2)\n    c = xor(a, b)\n    return string(c, base=2)\nend",
  "    xorred = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n        \
    \    xorred *= \"0\"\n        else\n            xorred *= \"1\"\n        end\n\
    \    end\n    return xorred\nend", "    aa = parse(a,2)\n    bb = parse(b,2)\n\
    \    cc = xor(aa,bb)\n    return string(cc,base=2)\nend\n#\n# binary operators:\n\
    #\n@assert 1 + 2 == 3\n@assert 1 - 2 == -1\n@assert 2 * 3 == 6\n@assert 4 / 2\
    \ == 2\n@assert 5 / 2 == 2.5\n@assert 5 // 2 == 2\n@assert 5 % 2 == 1\n@assert\
    \ 5 ^ 2 == 25\n@assert -1 == ~0\n@assert xor(1,2) == 3\n@assert xor(1,3) == 2\n\
    @assert bitstring(5) == \"00000000000000000000000000000101\"\n@assert bitstring(5,2)\
    \ == \"00000101\"\n@assert bitstring(5,10) == \"000000005\"\n@assert bitstring(5,16)\
    \ == \"0000000000000005\"\n@assert bitstring(5,2^64) == \"0000000000000000000000000000000000000000000000000000000000000101\"\
    \n@assert bitstring(5,2^64-1) == \"101\"\n@assert bitstring(5,2^64-3) == \"00000101\"\
    \n@assert bitstring(5,2^64-5) == \"000000005\"\n@assert bitstring(5,2^64-7) ==\
    \ \"0000000000000005\"\n@assert bin(5) == \"0b101\"\n@assert bin(0b101) == \"\
    0b101\"\n@assert bitstring(0b101) == \"00000000000000000000000000000101\"\n@assert\
    \ string_xor(\"010\",\"110\") == \"100\"\n@assert string_xor(\"010\",\"111\")\
    \ == \"101\"", "    c = Array{Int64}(undef, length(a))\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c[i] = 0\n        else\n            c[i]\
    \ = 1\n        end\n    end\n    return join(c)\nend", "    \n    # Turn strings\
    \ into arrays of bits\n    a_bits = bitarray(a)\n    b_bits = bitarray(b)\n  \
    \  \n    # Perform XOR operation\n    result = a_bits \u22BB b_bits\n    \n  \
    \  # Convert result to a string\n    return str(result)\nend", "    k = length(a)\
    \ #make sure both strings are of equal length\n    c = copy(a)\n    for i in 1:k\n\
    \        c[i] = xor(a[i], b[i])\n    end\n    return c\nend", "    c = Array{Int64}(length(a))\n\
    \    for i in 1:length(a)\n        c[i] = parse(Int64,a[i]) \u22BB parse(Int64,b[i])\n\
    \    end\n    return join(c)\nend", "    if length(a) == length(b)\n        result\
    \ = 0\n        for i in range(1, length(a)+1)\n            result = result * 10\
    \ + int(a[i]) ^ int(b[i])\n        end\n        return string(result)\n    else\n\
    \        print(\"The length of the two input strings should be equal\")\n    end\n\
    end", "    tmp = zeros(a, b)\n    c = \"\"\n    for i in 1:length(tmp)\n     \
    \   if tmp[i] == '1'\n            c = string(c, '0')\n        else\n         \
    \   c = string(c, '1')\n        end\n    end\n    return c\nend", "    c = \"\"\
    \n    for i in 1:length(a)\n        if a[i] == b[i]\n            c = c * \"0\"\
    \n        else\n            c = c * \"1\"\n        end\n    end\n    return c\n\
    end", "    n = length(a)\n    m = length(b)\n    @assert n == m\n    c = \"\"\n\
    \    for i in 1:n\n        if a[i] == b[i]\n            c = c * \"0\"\n      \
    \  else\n            c = c * \"1\"\n        end\n    end\n    return c\nend",
  "    res = \"\"\n    for i in eachindex(a)\n        res = res * string(int(a[i])\
    \ ^ int(b[i]))\n    end\n    return res\nend", "    c = String(undef, length(a))\n\
    \    for i in 1:length(a)\n        c[i] = xor(a[i], b[i])\n    end\n    return\
    \ c\nend", "    \"\"\"\n    XOR two strings together \n    \"\"\"\n    if length(a)\
    \ != length(b)\n        error(\"Length of strings must be the same\")\n    end\n\
    \    c = zeros(UInt8,length(a))\n    for (i,j) in enumerate(zip(a,b))\n      \
    \  c[i] = parse(UInt8,j[1]) #parse(UInt8,j[1]) XOR parse(UInt8,j[2])\n    end\n\
    \    return string(c)\nend", "  return string_from_int(int_xor(string_to_int(a),\
    \ string_to_int(b)))\nend", "    if length(a) == length(b)\n        output = String(length(a))\n\
    \        for i in 1:length(a)\n            output[i] = (a[i] == b[i])?'0':'1'\n\
    \        end\n        return output\n    else\n        print(\"Strings must be\
    \ of equal length\")\n    end\nend", "    if length(a) != length(b)\n        error(\"\
    Inputs must be equal in length\")\n    end\n    result = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            push!(result, '0')\n        else\n     \
    \       push!(result, '1')\n        end\n    end\n    return result\nend", " \
    \   len_a = length(a)\n    len_b = length(b)\n    if (len_a != len_b)\n      \
    \  error(\"string lengths do not match\")\n    end\n    n = len_a\n    r = String(n)\n\
    \    for i = 1:n\n        if (a[i] == b[i])\n            r[i] = '0'\n        else\n\
    \            r[i] = '1'\n        end\n    end\n    return r\nend", "    if length(a)\
    \ != length(b)\n        error(\"lengths of a and b must be equal\")\n    end\n\
    \    c = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n           \
    \ push!(c, '0')\n        else\n            push!(c, '1')\n        end\n    end\n\
    \    return c\nend", "    \"\"\" Return string XOR result of strings a and b.\
    \ \"\"\"\n    return string( (parse(Int, a) != parse(Int, b)) ? 1 : 0 )\nend",
  "    if length(a) != length(b)\n        println(\"Error: wrong number of bits in\
    \ input strings: \", length(a), \" and \", length(b))\n        return -1\n   \
    \ end\n    c = String(length(a))\n    for i in 1:length(a)\n        if a[i] ==\
    \ b[i]\n            c[i] = '0'\n        else\n            c[i] = '1'\n       \
    \ end\n    end\n    return c\nend", "    n = max(length(a), length(b))\n    c\
    \ = \"\"\n    for i in 1:n\n        if a[i] == b[i]\n            c = c * \"0\"\
    \n        else\n            c = c * \"1\"\n        end\n    end\n    return c\n\
    end", "    \n    result = \"\"\n    p = 0\n    while p <= length(a) - 1", "  \
    \  if length(a) != length(b)\n        error(\"Inputs have different lengths\"\
    )\n    end\n    result = String(\"\")\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            push!(result, '0')\n        else\n            push!(result,\
    \ '1')\n        end\n    end\n    return result\nend", "    a = Int(a, base=2)\n\
    \    b = Int(b, base=2)\n    return (a \u22BB b)\nend", "    return bits2string(string2bits(a)\
    \ \u22BB string2bits(b))\nend;\n ", "    if length(a) != length(b)\n        error(\"\
    argument lengths are not equal\")\n    end\n    out = String[]\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            push!(out, \"0\")\n        else\n      \
    \      push!(out, \"1\")\n        end\n    end\n    return join(out)\nend", " \
    \   c = repeat(UInt8(0), maximum(length(a), length(b)))\n    for i = 1:minimum(length(a),\
    \ length(b))\n        c[i] = parse(UInt8, a[i]) \u22BB parse(UInt8, b[i])\n  \
    \  end\n    for i = minimum(length(a), length(b))+1:length(a)\n        c[i] =\
    \ parse(UInt8, a[i])\n    end\n    for i = minimum(length(a), length(b))+1:length(b)\n\
    \        c[i] = parse(UInt8, b[i])\n    end\n    return join(reverse(c), \"\"\
    )\nend", "    x = Int64[(Int64(x) - 48) for x in a]\n    y = Int64[(Int64(x) -\
    \ 48) for x in b]\n    c = zip(x, y)\n    d = Int64[(Int64(x) + Int64(y)) % 2\
    \ for (x, y) in c]\n    e = [string(x) for x in d]\n    return join(e)\nend",
  "    c = zeros(Int8, length(a))\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            c[i] = \"0\"\n        else\n            c[i] = \"1\"\n        end\n\
    \    end\n    return join(c)\nend", "    return \"\".join(xor(a[i], b[i]) for\
    \ i in 1:length(a))\nend", "    c = String(length(a))\n    for i in 1:length(a)\n\
    \        c[i] = ifelse(a[i] == b[i], '0', '1')\n    end\n    return c\nend", " \
    \   res = \"\"\n    for i = 1:length(a)\n        res = res * int2string(int(a[i])\
    \ \u22BB int(b[i]))\n    end\n    return res\nend", "    c=zeros(UInt8, length(a))\n\
    \    for i=1:length(a)\n        if a[i]==b[i]\n            c[i]='0'\n        else\n\
    \            c[i]='1'\n        end\n    end\n    return string(c)\nend", "   \
    \ c = String(a)\n    for i = 1:length(c)\n        if c[i] == b[i]\n          \
    \  c[i] = '0'\n        else\n            c[i] = '1'\n        end\n    end\n  \
    \  return c\nend", "    return join([xor(i,j) for (i,j) in zip(a,b)])\nend\n#string_xor(\"\
    10011101\",\"10011101\")", "    a = string_to_bin(a)\n    b = string_to_bin(b)\n\
    \    bin = a xor b\n    return bin_to_string(bin)\nend", "    lena = length(a)\n\
    \    lenb = length(b)\n    if lena != lenb\n        println(\"Lengths of input\
    \ strings are not equal. Returning nothing\")\n        return nothing\n    end\n\
    \    out = String[]\n    for i in 1:lena\n        out[i] = string(parse(Int64,\
    \ a[i]) \u22BB parse(Int64, b[i]))\n    end\n    return join(out)\nend", "   \
    \ result = \"\"\n    for i in 1:length(a)\n        a_value = parse(Int64, a[i])\n\
    \        b_value = parse(Int64, b[i])\n        if a_value == b_value\n       \
    \     result = result * \"0\"\n        else\n            result = result * \"\
    1\"\n        end\n    end\n    return result\nend", "    out = \"\"\n    for i\
    \ = 1:length(a)\n        if a[i] == b[i]\n            push!(out, '0')\n      \
    \  else\n            push!(out, '1')\n        end\n    end\n    return out\nend",
  "    return string_from_bits(xor(bits_from_string(a), bits_from_string(b)))\nend",
  "    c = \"\"\n    for i in 1:length(a)\n        c = c * string(int(a[i]) \u22BB\
    \ int(b[i]))\n    end\n    return c\nend", "    return String(bitxor.((parse.(Int,\
    \ a)...), (parse.(Int, b)...)))\nend", "    bin = String[]\n    for i in 1:length(a)\n\
    \        push!(bin, (parse(Int, a[i]) \u22BB parse(Int, b[i])))\n    end\n   \
    \ join(bin)\nend", "    strlen = length(a)\n    result = \"\"\n    for i in 1:strlen\n\
    \        if a[i] == b[i]\n            result = result * \"0\"\n        else\n\
    \            result = result * \"1\"\n        end\n    end\n    return result\n\
    end", "    return string(map(xor, a, b))\nend", "    # convert strings into vectors\
    \ of bytes\n    return convert(String, xor(convert(Vector{UInt8}, a), convert(Vector{UInt8},\
    \ b)))\nend", "    if length(a) != length(b)\n        error(\"Input strings must\
    \ be the same length.\")\n    end\n    for i = 1:length(a)\n        if a[i] !=\
    \ b[i]\n            c[i] = '1'\n        else\n            c[i] = '0'\n       \
    \ end\n    end\n    return join(c)\nend", "    c = \"\"\n    for i in eachindex(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend", "    if length(a) != length(b)\n\
    \        return \"Lengths differ\"\n    end\n    res = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] != b[i]\n            push!(res, '1')\n        else\n        \
    \    push!(res, '0')\n        end\n    end\n    return res\nend", "    # Convert\
    \ string to integer\n    a_int = bin_to_int(a)\n    b_int = bin_to_int(b)\n  \
    \  # Perform XOR operation\n    xor_int = a_int \u22BB b_int\n    # Convert the\
    \ result back to a string\n    xor_string = int_to_bin(xor_int)\n    return xor_string\n\
    end", "    if length(a) != length(b)\n        error(\"Both strings must be of\
    \ the same length.\")\n    end\n    result = String[]\n    for i in zip(a, b)\n\
    \        push!(result, string(Int(i[1]) \u22BB Int(i[2])))\n    end\n    return\
    \ join(result)\nend", "    c = String[]\n    for i in 1:length(a)\n        push!(c,\
    \ xor(a[i], b[i]))\n    end\n    return(join(c))\nend", "    c = \"\"\n    for\
    \ i = 1:length(a)\n        c = c * string(int(a[i]) xor int(b[i]))\n    end\n\
    \    return c\nend", "    return a # TODO\nend", "    if length(a) != length(b)\n\
    \        return error(\"string lengths must be the same\")\n    end\n    result\
    \ = String[]\n    for i = 1:length(a)\n        if a[i] == b[i]\n            push!(result,\
    \ '0')\n        else\n            push!(result, '1')\n        end\n    end\n \
    \   return join(result)\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    String arguments must be of equal length\"))\n    end\n    str = String(\"\")\n\
    \    for i in 1:length(a)\n        if a[i] == b[i]\n            push!(str, '0')\n\
    \        else\n            push!(str, '1')\n        end\n    end\n    return str\n\
    end", "    x = string_to_decimal(a)\n    y = string_to_decimal(b)\n    return\
    \ decimal_to_string(x xor y)\nend", "    if (length(a) != length(b)) throw(ArgumentError(\"\
    Arguments must be of equal length\"))\n    x = String[]\n    for i in 1:length(a)\n\
    \        push!(x,string(XOR(parse(Int,a[i]),parse(Int,b[i]))))\n    end\n    return\
    \ string(x)\nend", "    r = \"\"\n    n = min(length(a), length(b))\n    for i\
    \ in 1:n\n        r *= xor(a[i], b[i])\n    end\n    return r\nend", "    @assert\
    \ length(a) == length(b)\n    c = zero(UInt8)\n    for (i, ai) in enumerate(a)\n\
    \        bi = b[i]\n        @assert ai \u2208 ['0', '1']\n        @assert bi \u2208\
    \ ['0', '1']\n        c |= (parse(Int, ai) \u22BB parse(Int, bi)) << (length(a)\
    \ - i - 1)\n    end\n    return string(c, length(a), base=2)\nend;\n \n@test string_xor(\"\
    010\", \"110\") == \"100\"", "    string_xor = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] != b[i]\n            string_xor = string_xor * \"1\"\n      \
    \  else\n            string_xor = string_xor * \"0\"\n        end\n    end\n \
    \   return string_xor\nend", "    c = copy(a)\n    for i in 1:length(a)\n    \
    \    if a[i] != b[i]\n            c[i] = \"1\"\n        else\n            c[i]\
    \ = \"0\"\n        end\n    end\n    return c\nend", "    xor(Int(a, 2), Int(b,\
    \ 2)) |> string(2)\nend", "    # length of the two strings must be the same\n\
    \    if length(a) != length(b)\n        error(\"Length of two strings must be\
    \ the same!\")\n    end\n    a = parse(Int, a, base=2)\n    b = parse(Int, b,\
    \ base=2)\n    return string(a \u22BB b, base=2)\nend", "    if length(a) != length(b)\n\
    \        throw(ArgumentError(\"a and b must be of the same length\"))\n    end\n\
    \    z = zeros(length(a))\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            z[i] = '0'\n        else\n            z[i] = '1'\n        end\n \
    \   end\n    return join(z)\nend", "    return [a[i] == b[i] ? '0' : '1' for i\
    \ in 1:length(a)]\nend", "    x::UInt64 = parse(UInt64, a, base=2)\n    y::UInt64\
    \ = parse(UInt64, b, base=2)\n    z::UInt64 = xor(x, y)\n    return string(z,\
    \ base=2)\nend", "    res = \"\"\n    for i = 1:length(a)\n        res *= (a[i]^b[i])\n\
    \    end\n    return res\nend", "    c = String[]\n    for (i, j) in zip(a, b)\n\
    \        @show i, j\n        push!(c, xor(parse(Int, i), parse(Int, j)))\n   \
    \ end\n    return join(map(string, c))\nend", "    a = [c for c in a]\n    b =\
    \ [c for c in b]\n    c = [string_xor(a[i], b[i]) for i in 1:length(a)]\n    d\
    \ = \"\"\n    for i in c\n        d = d * i\n    end\n    return d\nend", "  \
    \  return join([xor(a[i], b[i]) for i=1:length(a)])\nend", "    res = \"\"\n \
    \   for i in 1:length(a)\n        res = res * ifelse(a[i] == b[i], \"0\", \"1\"\
    )\n    end\n    return res\nend", "    c = zeros(UInt8, length(a))\n    for i\
    \ in 1:length(a)\n        c[i] = a[i] == b[i] ? 0x00 : 0x01\n    end\n    return\
    \ string(c)\nend\n```", "    return [a[i] + b[i] % 2 for i in 1:length(a)]\nend\n\
    \ \n ", "    return_string = \"\"\n    for i in eachindex(a)\n        a_char =\
    \ a[i]\n        b_char = b[i]\n        if a_char == b_char\n            return_string\
    \ *= \"0\"\n        else\n            return_string *= \"1\"\n        end\n  \
    \  end\n    return return_string\nend", "    if length(a) != length(b)\n     \
    \   return \"undefined\"\n    end\n    xor_result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            xor_result = xor_result * \"0\"\n      \
    \  else\n            xor_result = xor_result * \"1\"\n        end\n    end\n \
    \   return xor_result\nend", "    c = zeros(Int8, length(a))\n    for i in 1:length(a)\n\
    \        c[i] = parse(Int8, a[i]) xor parse(Int8, b[i])\n    end\n    string(c)\n\
    end", "  c = \"\"\n  for i = 1:length(a)\n    if a[i] == b[i]\n      push!(c,\
    \ '0')\n    else\n      push!(c, '1')\n    end\n  end\n  return c\nend", "   \
    \ if (length(a) != length(b))\n        println(\"Invalid input\")\n        return\
    \ \"\"\n    end\n    result = \"\"\n    for i = 1:length(a)\n        if a[i] ==\
    \ b[i]\n            result = result * \"0\"\n        else\n            result\
    \ = result * \"1\"\n        end\n    end\n    return result\nend", "    c = \"\
    \"\n    for i in 1:length(a)\n        c *= xor(a[i], b[i])\n    end\n    return\
    \ c\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"strings\
    \ must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        c = c * bitxor(parse(Int, a[i]), parse(Int, b[i]))\n    end\n    return\
    \ c\nend\n \nmutable struct Block\n    plaintext::String\n    ciphertext::String\n\
    \    key::String\nend", "    c = Int[]\n    for i = 1:length(a)\n        push!(c,\
    \ int(a[i]) xor int(b[i]))\n    end\n    return join(string.(c))\nend", "    #Your\
    \ code here\n    length = min(length(a), length(b))\n    ret = []\n    for i =\
    \ 1:length\n        aa = parse(Int, a[i])\n        bb = parse(Int, b[i])\n   \
    \     ret = [ ret ; xor(aa, bb) ]\n    end\n    return join(map(string, ret))\n\
    end\n ", "    bin_a = parse(Int, a, base=2)\n    bin_b = parse(Int, b, base=2)\n\
    \    xor = bin_a \u22BB bin_b\n    out = string(xor, base=2)\n    return out\n\
    end", "    c = \"\"\n    for i = 1:length(a)\n        c = c * string( int(a[i])\
    \ ^ int(b[i]) )\n    end\n    return c\nend", "    # convert strings to bitsets\
    \ for better performance\n    a_bitset = Bitset(a)\n    b_bitset = Bitset(b)\n\
    \    # xor is a bitwise operation in julia\n    xor_bitset = xor(a_bitset, b_bitset)\n\
    \    # convert back to a string\n    xor_string = string(xor_bitset)\n    return\
    \ xor_string\nend", "    c = \"\"\n    for i in eachindex(a)\n        if a[i]\
    \ != b[i]\n            push!(c, '1')\n        else\n            push!(c, '0')\n\
    \        end\n    end\n    return c\nend", "    if length(a) != length(b)\n  \
    \      println(\"Binary strings are not of equal length.\")\n        return \"\
    0\"\n    end\n    ans = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            ans = string(ans, \"0\")\n        else\n            ans = string(ans,\
    \ \"1\")\n        end\n    end\n    return ans\nend", "    a_arr = Array{Bool}(undef,\
    \ length(a))\n    b_arr = Array{Bool}(undef, length(b))\n    c_arr = Array{Bool}(undef,\
    \ length(a))\n    for i = 1:length(a)\n        a_arr[i] = Bool(Int(a[i]))\n  \
    \      b_arr[i] = Bool(Int(b[i]))\n        c_arr[i] = a_arr[i] \u22BB b_arr[i]\n\
    \    end\n    return string(c_arr)\nend", "    A = B = 0\n    for i in a\n   \
    \     if i == '1'\n            A = A + 2^i\n        end\n    end\n    for i in\
    \ b\n        if i == '1'\n            B = B + 2^i\n        end\n    end\n    println(A,\
    \ \" \", B)\n    C = A^B\n    println(C)\n    return string(C)\nend", "    n =\
    \ length(a)\n    @assert n == length(b) \"Inputs must be of equal length.\"\n\
    \    result = Array(Char, n)\n    for i = 1:n\n        result[i] = ifelse(a[i]\
    \ == b[i], '0', '1')\n    end\n    return join(result)\nend", "    is_a = a ==\
    \ \"1\"\n    is_b = b == \"1\"\n    bit = convert(Int, is_a != is_b)\n    return\
    \ string(bit)\nend", "    # Initialize result as an empty string\n    c = \"\"\
    \n    # Traverse all characters\n    for i in 1:length(a)\n        # Find current\
    \ bits in strings a and b\n        bit1 = Int(a[i])\n        bit2 = Int(b[i])\n\
    \        # If both bits are 1 then 0 else 1\n        if bit1 == 1 && bit2 == 1\n\
    \            push!(c, '0')\n        else\n            push!(c, '1')\n        end\n\
    \    end\n    return c\nend", "    output = \"\"\n    for i in 1:length(a)\n \
    \       if a[i] == b[i]\n            output = output * \"0\"\n        else\n \
    \           output = output * \"1\"\n        end\n    end\n    return output\n\
    end", "    if length(a) > length(b)\n        a, b = b, a\n    end\n    b = repeat('0',\
    \ length(a) - length(b)) * b\n    return join([a[i] == b[i] ? '0' : '1' for i\
    \ in 1:length(a)])\nend\n@assert string_xor(\"0\", \"1\") == \"1\"\n@assert string_xor(\"\
    11111\", \"11111\") == \"00000\"\n@assert string_xor(\"110\", \"010\") == \"100\"\
    \n ", "    if length(a) != length(b)\n        throw(ArgumentError(\"a and b must\
    \ be of the same length\"))\n    end\n    out = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            out = out * \"0\"\n        else\n      \
    \      out = out * \"1\"\n        end\n    end\n    return out\nend", "    #convert\
    \ to int\n    a_int = parse(Int, a, base=2)\n    b_int = parse(Int, b, base=2)\n\
    \    #xor them together\n    x = xor(a_int, b_int)\n    #convert back to string\n\
    \    a_string = string(x, base=2)\n    return a_string\nend", "    return string.(xor.(UInt8.(a),\
    \ UInt8.(b)))\nend\n    ", "    @assert length(a) == length(b)\n    res = \"\"\
    \n    for i in 1:length(a)\n        res *= (a[i] \u22BB b[i])\n    end\n    return\
    \ res\nend", "    c = String[]\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            push!(c, \"0\")\n        else\n            push!(c, \"1\")\n    \
    \    end\n    end\n    return join(c)\nend", "    res = String()\n    for i in\
    \ 1:length(a)\n        push!(res, xor(a[i], b[i]))\n    end\n    return res\n\
    end", "    c = \"\"\n    for x in zip(a, b)\n        c = c * string(Int64(x[1])\
    \ \u22BB Int64(x[2]))\n    end\n    return c\nend", "    if length(a) != length(b)\n\
    \        error(\"Inputs have to be of the same length\")\n    end\n    result\
    \ = \"\"\n    for i = 1:length(a)\n        if a[i] == b[i]\n            result\
    \ = string(result, \"0\")\n        else\n            result = string(result, \"\
    1\")\n        end\n    end\n    return result\nend", "    isbits(a) || throw(DomainError(\"\
    a must consist only of bits\"))\n    isbits(b) || throw(DomainError(\"b must consist\
    \ only of bits\"))\n    assert(length(a) == length(b))\n    x::String = String(\"\
    \")\n    for i in eachindex(a)\n        x *= XOR(a[i], b[i])\n    end\n    return\
    \ x\nend", "    return ''.join(chr(int(a[i]) ^ int(b[i])) for i in 1:length(a))\n\
    end", "    x = 0\n    y = 0\n    x = parse(Int, a, base=2)\n    y = parse(Int,\
    \ b, base=2)\n    c = x \u22BB y\n    return string(c, base=2)\nend", "    if\
    \ (length(a) == length(b))\n        result = String(length(a))\n        for i\
    \ = 1:length(a)\n            if (a[i] != b[i])\n                result[i] = '1'\n\
    \            else\n                result[i] = '0'\n            end\n        end\n\
    \        return result\n    else\n        return \"\"\n    end\nend", "    c =\
    \ String(length(a))\n    for i = 1:length(a)\n        c[i] = XOR(a[i], b[i])\n\
    \    end\n    return c\nend", "    n = maximum(length(a), length(b))\n    n =\
    \ convert(Int,ceil(Int,log2(n)))+1\n    a = \"0\"^(n-length(a))*a\n    b = \"\
    0\"^(n-length(b))*b\n    out = \"\"\n    for i = 1:n\n        out = string(out,int(xor(a[i]=='1',b[i]=='1')))\n\
    \    end\n    return out\nend", "    return join([convert(Int, convert(Bool, a[i])\
    \ \u22BB convert(Bool, b[i])) for i in 1:length(a)])\nend", "    x = parse(Int,\
    \ a, base=2)\n    y = parse(Int, b, base=2)\n    return string(x \u22BB y, base=2)\n\
    end", "    k = min(length(a), length(b))\n    return join([(a[i] == b[i] ? \"\
    0\" : \"1\") for i in 1:k], \"\")\nend", "  output = \"\"\n  for i in 1:minimum(length(a),\
    \ length(b))\n    append!(output, (parse(Int,a[i]) \u22BB parse(Int,b[i])))\n\
    \  end\n  return string(output)\nend", "    return string(parse(Int, x)^parse(Int,\
    \ y) for (x, y) in zip(a, b))\nend", "    c = \"\"\n    n = max(length(a), length(b))\n\
    \    for i in 1:n\n        if i > length(a)\n            c *= \"0\"\n        elseif\
    \ i > length(b)\n            c *= \"0\"\n        else\n            if a[i] ==\
    \ b[i]\n                c *= \"0\"\n            else\n                c *= \"\
    1\"\n            end\n        end\n    end\n    return c\nend", "    res = \"\"\
    \n    for i = 1:length(a)\n        res = res * xor(parse(Int, a[i]), parse(Int,\
    \ b[i]))\n    end\n    return res\nend", "    if length(a) != length(b)\n    \
    \    error(\"Length of the two strings is not equal\")\n    end\n    c = \"\"\n\
    \    for i in eachindex(a)\n        if a[i] == b[i]\n            push!(c, '0')\n\
    \        else\n            push!(c, '1')\n        end\n    end\n    return c\n\
    end", "    # one of the two inputs has to be shorter than the other one,\n   \
    \ # otherwise the lengths are not equal, so\n    # the operation can't be performed\n\
    \    if length(a) < length(b)\n        s = a\n        l = b\n    else\n      \
    \  s = b\n        l = a\n    end\n    result = \"\"\n    for i in 1:length(s)\n\
    \        # perform XOR on each digit of each string\n        # and add it to the\
    \ result\n        if s[i] == l[i]\n            result = \"0\" * result\n     \
    \   else\n            result = \"1\" * result\n        end\n    end\n    return\
    \ result\nend", "    result = String[]\n    for i in 1:length(a)\n        push!(result,parse(Int,a[i])\
    \ \u22BB parse(Int,b[i]))\n    end\n    return join(result, \"\")\nend", "   \
    \ c = String[]\n    len = min(length(a), length(b))\n    for i in 1:len\n    \
    \    c = push!(c, xor(parse(Int, a[i]), parse(Int, b[i])))\n    end\n    return\
    \ join(c)\nend", "    if length(a) != length(b)\n        error(\"Input strings\
    \ must be same length\")\n    end\n    output = \"\"\n    for i in range(1, length(a))\n\
    \        if a[i] == '0' && b[i] == '0'\n            push!(output, '0')\n     \
    \   elseif a[i] == '1' && b[i] == '1'\n            push!(output, '0')\n      \
    \  else\n            push!(output, '1')\n        end\n    end\n    return output\n\
    end", "    answer = String()\n    for (i,j) in zip(a,b)\n        if i == j\n \
    \           append!(answer, '0')\n        else\n            append!(answer, '1')\n\
    \        end\n    end\n    return answer\nend", "    \"\"\"\n    Input are two\
    \ strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these\
    \ inputs and return result also as a string.\n    >>> string_xor('010', '110')\n\
    \    '100'\n    \"\"\"\n    #TODO: Implement this!\n    # Note: Do not use int(a,\
    \ 2) to convert from string to int. Instead, use parse(Int,a,2)\n    # So you\
    \ can pass the doctests!\n    if length(a) != length(b)\n        error(\"String\
    \ lengths do not match\")\n    end\n    res = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            res = res * \"0\"\n        else\n      \
    \      res = res * \"1\"\n        end\n    end\n    return res\nend", "    return\
    \ join([ (a[i] ^ b[i] ? \"1\" : \"0\") for i in 1:length(a) ])\nend", "    if\
    \ length(a) != length(b)\n        throw(DomainError(\"a and b are not the same\
    \ length\"))\n    end\n    result = Array{Char}(length(a))\n    @inbounds for\
    \ i in 1:length(a)\n        result[i] = a[i] ^ b[i]\n    end\n    return join(result)\n\
    end", "    if length(a) != length(b)\n        error(\"Strings are not the same\
    \ length.\")\n    end\n    c = String(\"\")\n    for i in 1:length(a)\n      \
    \  x = a[i]\n        y = b[i]\n        if x == y\n            c = c * \"0\"\n\
    \        else\n            c = c * \"1\"\n        end\n    end\n    return c\n\
    end", "    # This is just using the bitwise xor, but with strings and as a string\
    \ result.\n    # a = \"1\" is equivalent to a = 49 which is the ascii value of\
    \ \"1\"\n    # string(x::Int, base=10) is the function that converts from integer\
    \ to string, with base 10 by default\n    return join([string(parse(Int, x) ^\
    \ parse(Int, y)) for (x, y) in zip(a, b)])\nend", "    a = convert(Int, a, base=2)\n\
    \    b = convert(Int, b, base=2)\n    xor = string(bitstring(a \u22BB b))\n  \
    \  return xor\nend", "    c = \"\"\n    for i in 1:length(a)\n        c = c *\
    \ xor(a[i], b[i])\n    end\n    return c\nend", "    return(join([xor(parse(Int,\
    \ a[i]), parse(Int, b[i])) for i in 1:length(a)]))\nend", "    # only need min\
    \ because other string will be 0's\n    min_str = min(a, b, key=len)\n    max_str\
    \ = max(a, b, key=len)\n    out = \"\"\n    for i in 1:length(min_str)\n     \
    \   if a[i] == b[i]\n            out = out * \"0\"\n        else\n           \
    \ out = out * \"1\"\n        end\n    end\n    # pad with 0's\n    out = out *\
    \ max_str[length(min_str)+1:end]\n    return out\nend", "    # If a is shorter\
    \ then b, then pad zeros at left of a.\n    # Padding is needed for correct shifting.\n\
    \    if length(a) < length(b)\n        a = \"0\"*(length(b)-length(a))*a\n   \
    \ end\n    # If b is shorter then a, then pad zeros at left of b.\n    # Padding\
    \ is needed for correct shifting.\n    if length(b) < length(a)\n        b = \"\
    0\"*(length(a)-length(b))*b\n    end\n    # Resultant string\n    c = \"\"\n \
    \   # Left shift at most 'a' times\n    for i in 1:length(a)\n        # Extract\
    \ last character of string a\n        s = last(a)\n        # Removing last character\
    \ of string a\n        a = a[1:end-1]\n        # Left shift in string b\n    \
    \    b = \"0\"*b\n        # Extract last character of string b\n        t = last(b)\n\
    \        # XOR on last characters of string a and b\n        if (s == \"1\" &&\
    \ t == \"0\") || (s == \"0\" && t == \"1\")\n            c = \"1\"*c\n       \
    \ else\n            c = \"0\"*c\n        end\n    end\n    # Return resultant\
    \ string\n    return c\nend", "    c = \"\"\n    for i in 1:length(a)\n      \
    \  if a[i] == b[i]\n            push!(c, '0')\n        else\n            push!(c,\
    \ '1')\n        end\n    end\n    return c\nend\n        \n\"\"\" Base64 encode\
    \ the input string\n    >>> base64encode(\"any carnal pleasure.\")\n    \"YW55IGNhcm5hbCBwbGVhc3VyZS4=\"\
    \n    \"\"\"", "    n = length(a)\n    result = \"\"\n    for i in 1:n\n     \
    \   result *= xor(a[i], b[i])\n    end\n    return result\nend", "    \n    s::String\
    \ = \"\" # initialize output string\n    \n    # loop through all characters in\
    \ both input strings\n    for i in 1:length(a)\n        # XOR each pair of characters\
    \ and append to output string\n        s = s * xor(parse(Int, a[i]), parse(Int,\
    \ b[i]))\n    end\n    \n    return s\nend", "    c = \"\"\n    for i in zip(a,\
    \ b)\n        push!(c, string(Int(i[1]) ^ Int(i[2])))\n    end\n    return join(c)\n\
    end", "    \"\"\"\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n \
    \   if length(a) != length(b)\n        throw(DomainError(a,b,\"Input strings must\
    \ be of equal length\"))\n    end\n    c = \"\"\n    for i in eachindex(a)\n \
    \       if a[i] != b[i]\n            append!(c, '1')\n        else\n         \
    \   append!(c, '0')\n        end\n    end\n    return c\nend\n \nprint(string_xor(\"\
    11010011100\", \"10101101000\"))", "    xor(parse(Int, c) for c in a) \u22BB xor(parse(Int,\
    \ c) for c in b) |> Int |> string\nend", "    return [i==j ? '0' : '1' for (i,j)\
    \ in zip(a,b)]\nend\n ", "    if length(a) > length(b)\n        b = string(\"\
    0\", b)\n    else\n        a = string(\"0\", a)\n    end\n    bin = zeros(Bool,\
    \ length(a))\n    c = zeros(length(a))\n    for i = 1:length(a)\n        bin[i]\
    \ = (a[i] == '1') != (b[i] == '1')\n        c[i] = 0\n    end\n    for i = 1:length(bin)\n\
    \        if bin[i] == true\n            c[i] = 1\n        end\n    end\n    return\
    \ string(c)\nend", "    if length(a) != length(b)\n        throw(DomainError(\"\
    Arguments should be of the same length\"))\n    end\n    c = string(\"\")\n  \
    \  for i in eachindex(a)\n        if a[i] == b[i]\n            push!(c, '0')\n\
    \        else\n            push!(c, '1')\n        end\n    end\n    return c\n\
    end", "    c = \"\"\n    for i in 1:length(a)\n        c = c * string(int(a[i])\
    \ ^ int(b[i]))\n    end\n    return c\nend", "    a = parse(Int, a, base=2)\n\
    \    b = parse(Int, b, base=2)\n    return string(a $ b, base=2)\nend", "    #\
    \ YOUR CODE HERE\nend", "    sxor_table = Dict(\"00\" => \"0\", \"01\" => \"1\"\
    , \"10\" => \"1\", \"11\" => \"0\")\n    result = \"\"\n    for i in 1:length(a)\n\
    \        result = result * sxor_table[a[i] * b[i]]\n    end\n    return result\n\
    end", "    n = length(a)\n    assert(n == length(b))\n    c = zeros(Int, n)\n\
    \    for i = 1:n\n        if (a[i] == '0' && b[i] == '0') || (a[i] == '1' && b[i]\
    \ == '1')\n            c[i] = 0\n        else\n            c[i] = 1\n        end\n\
    \    end\n    return join(c, \"\")\nend", "    c = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend", "    if length(a)\
    \ != length(b)\n        return \"String length must be the same.\"\n    end\n\
    \    result = \"\"\n    for i in 1:length(a)\n        a_char = a[i]\n        b_char\
    \ = b[i]\n        if a_char == '0'\n            if b_char == '0'\n           \
    \     result = result * \"0\"\n            else\n                result = result\
    \ * \"1\"\n            end\n        else\n            if b_char == '0'\n     \
    \           result = result * \"1\"\n            else\n                result\
    \ = result * \"0\"\n            end\n        end\n    end\n    return result\n\
    end", "    a::Array{Int,1} = [int(i) for i in a]\n    b::Array{Int,1} = [int(i)\
    \ for i in b]\n    c::Array{Int,1} = a .\u2260 b\n    [string(i) for i in c]*\"\
    \"\nend", "    temp=[]\n    for i in 1:length(a)\n        temp=[temp; Int(a[i])\
    \ xor Int(b[i])]\n    end\n    res=\"\"\n    for i in 1:length(temp)\n       \
    \ res=res*string(temp[i])\n    end\n    return res\nend", "    return ''.join(string(xor(int(i),\
    \ int(j))) for (i, j) in zip(a, b))\nend", "    # check if string are of same\
    \ length\n    if length(a) != length(b)\n        error(\"String should be of same\
    \ length\")\n    end\n    # output is of same length as input\n    output = String(undef,\
    \ length(a))\n    for i = 1:length(a)\n        if a[i] == b[i]\n            output[i]\
    \ = '0'\n        else\n            output[i] = '1'\n        end\n    end\n   \
    \ return output\nend", "    if length(a) != length(b)\n        println(\"Input\
    \ string lengths must be equal\")\n        return \"\"\n    end\n    result =\
    \ \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n            result\
    \ = result * \"0\"\n        else\n            result = result * \"1\"\n      \
    \  end\n    end\n    return result\nend", "    return string( xor.(Bool.(collect(a)),\
    \ Bool.(collect(b))) )\nend", "    return join([string(convert(Int, a[i]) ^ convert(Int,\
    \ b[i])) for i in 1:length(a)])\nend", "    return join([(x == y) ? \"0\" : \"\
    1\" for (x, y) in zip(a, b)])\nend", "    # need to make sure a and b are of the\
    \ same length\n    # add leading zeros if not\n    if length(a) < length(b)\n\
    \        a = \"0\"^(length(b)-length(a))*a\n    elseif length(b) < length(a)\n\
    \        b = \"0\"^(length(a)-length(b))*b\n    end\n    s = \"\"\n    for i in\
    \ range(1, length(a))\n        if a[i] == b[i]\n            s = s*\"0\"\n    \
    \    else\n            s = s*\"1\"\n        end\n    end\n    return s\nend",
  "    n = length(a)\n    n1 = length(b)\n    if n != n1\n        throw(ArgumentError(\"\
    Strings must be of same length!\"))\n    end\n    m = zeros(n)\n    for i in 1:n\n\
    \        if a[i] != b[i]\n            m[i] = 1\n        end\n    end\n    join(m,\
    \ \"\")\nend", "    n = length(a)\n    s = \"\"\n    for i in 1:n\n        append!(s,\
    \ bits(Int(a[i]) ^ Int(b[i])))\n    end\n    return s\nend", "    s = \"\"\n \
    \   for i in 1:length(a)\n        if a[i] == b[i]\n            s = s * \"0\"\n\
    \        else\n            s = s * \"1\"\n        end\n    end\n    return s\n\
    end", "    c = \"\"\n    for i = 1:length(a)\n        ai = a[i]\n        bi =\
    \ b[i]\n        if ai == bi\n            ci = \"0\"\n        else\n          \
    \  ci = \"1\"\n        end\n        c = c*ci\n    end\n    return c\nend", " \
    \   c = []\n    c = [xor(i,j) for (i,j) in zip(a,b)]\n    return join(c)\nend",
  "    a_bin = bin2vec(a)\n    b_bin = bin2vec(b)\n    if length(a_bin) > length(b_bin)\n\
    \        b_bin = vcat(zeros(Int, length(a_bin) - length(b_bin)), b_bin)\n    elseif\
    \ length(a_bin) < length(b_bin)\n        a_bin = vcat(zeros(Int, length(b_bin)\
    \ - length(a_bin)), a_bin)\n    end\n    return vec2bin(bitxor.(a_bin, b_bin))\n\
    end", "    res = \"\"\n    for i in 1:length(a)\n        res = res * (string_xor(parse(Char,\
    \ a[i]), parse(Char, b[i])))\n    end\n    return res\nend", "    if length(a)\
    \ != length(b)\n        error(\"Strings must be of equal length.\")\n    end\n\
    \    c = String[]\n    for i in 1:length(a)\n        push!(c, a[i] ^ b[i])\n \
    \   end\n    return join(c)\nend\n# Challenge 4:\n# Your task is to implement\
    \ the ECB vs CBC detection oracle.\n# The oracle function is a function that is\
    \ taking two parameters.\n# Your first parameter is the unknown-string which is\
    \ going to be ecrypted.\n# The second parameter is a boolean.\n# If it is true\
    \ ECB will be used for encryption, otherwise CBC.\n# The function shall return\
    \ the ciphertext of the unknown-string as well as\n# the name of the block cipher\
    \ mode that was used for encryption.", "    return [xor(a[i], b[i]) for i in 1:length(a)]\n\
    end", "    return join([string(int(a[i]) \u22BB int(b[i])) for i in 1:length(a)])\n\
    end", "    bin_xor_output = bin_xor(parse(Int, a), parse(Int, b))\n    return\
    \ string(bin_xor_output)\nend", " \n    c=String[]\n    for i in range(length(a))\n\
    \        if (a[i] == '0' && b[i] == '0')\n            push!(c, '0')\n        elseif\
    \ (a[i] == '1' && b[i] == '1')\n            push!(c, '0')\n        elseif (a[i]\
    \ == '0' && b[i] == '1')\n            push!(c, '1')\n        elseif (a[i] == '1'\
    \ && b[i] == '0')\n            push!(c, '1')\n        end\n    end\n    string(c)\n\
    end\n ", "    a = map(char->int(char)-48, collect(a))\n    b = map(char->int(char)-48,\
    \ collect(b))\n    return join(map(char->string(char), map(xor, a, b)))\nend",
  "    c = \"\"\n    for (i,j) in zip(a,b)\n        c *= i+j % 2\n    end\n    return\
    \ c\nend", "    res = \"\"\n    for x in 1:length(a)\n        res *= ((parse(Int,a[x])\
    \ * parse(Int,b[x])) == 0) ? \"1\" : \"0\"\n    end\n    return res\nend", " \
    \   result = \"\"\n    for i in 1:length(a)\n        if (a[i] == b[i])\n     \
    \       result = result * \"0\"\n        else\n            result = result * \"\
    1\"\n        end\n    end\n    return result\nend", "    c = \"\"\n    if length(a)\
    \ != length(b)\n        return \"Strings not equal in length.\"\n    end\n   \
    \ for i in 1:length(a)\n        if a[i] != b[i]\n            c = c * \"1\"\n \
    \       else\n            c = c * \"0\"\n        end\n    end\n    return c\n\
    end", "    xor = [parse(Int, a[i]) \u22BB parse(Int, b[i]) for i in 1:length(a)]\n\
    \    return join(xor, \"\")\nend", "    @assert length(a) == length(b)\n    return\
    \ join([bin(parse(Int, a[i]) \u22BB parse(Int, b[i]))[3] for i=1:length(a)])\n\
    end", "    if length(a) != length(b)\n        error(\"string_xor: input strings\
    \ must be the same length\")\n    end\n    result = \"\"\n    for (x, y) in zip(a,\
    \ b)\n        xval = int(x)\n        yval = int(y)\n        if xval == 0 && yval\
    \ == 0\n            result *= \"0\"\n        elseif xval == 1 && yval == 1\n \
    \           result *= \"0\"\n        else\n            result *= \"1\"\n     \
    \   end\n    end\n    return result\nend", "    c = \"\"\n    lena = length(a)\n\
    \    lenb = length(b)\n    if lena != lenb\n        error(\"Strings must be of\
    \ equal length\")\n    end\n    for i in 1:lena\n        if a[i] == '0' && b[i]\
    \ == '0'\n            c = c * \"0\"\n        elseif a[i] == '1' && b[i] == '1'\n\
    \            c = c * \"0\"\n        else\n            c = c * \"1\"\n        end\n\
    \    end\n    return c\nend", "    return join([(a[i] == b[i] ? \"0\" : \"1\"\
    ) for i in range(1,length(a))] )\nend", "    c = String[]\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            push!(c, '0')\n        else\n          \
    \  push!(c, '1')\n        end\n    end\n    return join(c)\nend", "    res = String(length(a))\n\
    \    for i in 1:length(a)\n        c = parse(Int, a[i])\n        d = parse(Int,\
    \ b[i])\n        r = xor(c, d)\n        res[i] = string(r)\n    end\n    return\
    \ res\nend", "    r = String()\n    for i in range(1, length(a)):\n        ai\
    \ = parse(Int, a[i])\n        bi = parse(Int, b[i])\n        ri = xor(ai, bi)\n\
    \        push!(r, ri)\n    end\n    return r\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
